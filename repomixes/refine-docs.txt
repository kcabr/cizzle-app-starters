This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.repomixignore
advanced-tutorials/access-control.md
advanced-tutorials/auth/auth0.md
advanced-tutorials/auth/azure-ad.md
advanced-tutorials/custom-layout.md
advanced-tutorials/data-provider/handling-filters.md
advanced-tutorials/forms/custom-form-validation.md
advanced-tutorials/multi-level-menu/multi-level-menu.md
advanced-tutorials/mutation-mode.md
advanced-tutorials/real-time.md
advanced-tutorials/search/list-search.md
advanced-tutorials/search/search.md
advanced-tutorials/search/table-search.md
advanced-tutorials/upload/base64-upload.md
advanced-tutorials/upload/multipart-upload.md
advanced-tutorials/web3/ethereum-signin.md
audit-logs/audit-log-provider/index.md
audit-logs/hooks/use-log-list/index.md
audit-logs/hooks/use-log/index.md
authentication/auth-provider/index.md
authentication/components/auth-page/index.md
authentication/components/authenticated/index.md
authentication/hooks/use-forgot-password/index.md
authentication/hooks/use-get-identity/index.md
authentication/hooks/use-is-authenticated/index.md
authentication/hooks/use-login/index.md
authentication/hooks/use-logout/index.md
authentication/hooks/use-on-error/index.md
authentication/hooks/use-permissions/index.md
authentication/hooks/use-register/index.md
authentication/hooks/use-update-password/index.md
authorization/access-control-provider/index.md
authorization/components/can-access/index.md
authorization/hooks/use-can/index.md
core/components/auto-save-indicator/index.md
core/components/auto-save-indicator/usage.tsx
core/components/inferencer/index.md
core/hooks/utilities/buttons/index.md
core/hooks/utilities/use-breadcrumb/index.md
core/hooks/utilities/use-export/index.md
core/hooks/utilities/use-import/index.md
core/hooks/utilities/use-menu/index.md
core/hooks/utilities/use-modal/index.md
core/interface-references/index.md
core/refine-component/index.md
data/data-provider/index.md
data/hooks/use-api-url/index.md
data/hooks/use-create-many/index.md
data/hooks/use-create/index.md
data/hooks/use-custom-mutation/index.md
data/hooks/use-custom/index.md
data/hooks/use-data-provider/index.md
data/hooks/use-delete-many/index.md
data/hooks/use-delete/index.md
data/hooks/use-form/basic-usage.tsx
data/hooks/use-form/index.md
data/hooks/use-infinite-list/_basic-usage-live-preview.md
data/hooks/use-infinite-list/_filtering-live-preview.md
data/hooks/use-infinite-list/_sorting-live-preview.md
data/hooks/use-infinite-list/index.md
data/hooks/use-invalidate/index.md
data/hooks/use-list/_basic-usage-live-preview.md
data/hooks/use-list/_filtering-live-preview.md
data/hooks/use-list/_pagination-live-preview.md
data/hooks/use-list/_sorting-live-preview.md
data/hooks/use-list/index.md
data/hooks/use-many/_basic-usage-live-preview.md
data/hooks/use-many/index.md
data/hooks/use-one/_basic-usage-live-preview.md
data/hooks/use-one/index.md
data/hooks/use-select/_basic-usage-live-preview.md
data/hooks/use-select/_default-value-live-preview.md
data/hooks/use-select/_on-search-live-preview.md
data/hooks/use-select/_sort-live-preview.md
data/hooks/use-select/index.md
data/hooks/use-show/_basic-usage-live-preview.md
data/hooks/use-show/index.md
data/hooks/use-table/_partial-basic-usage-live-preview.md
data/hooks/use-table/_partial-filtering-live-preview.md
data/hooks/use-table/_partial-pagination-live-preview.md
data/hooks/use-table/_partial-relational-data-live-preview.md
data/hooks/use-table/_partial-sorting-live-preview.md
data/hooks/use-table/index.md
data/hooks/use-update-many/index.md
data/hooks/use-update/index.md
data/simple-rest/index.md
examples/audit-log/audit-log-antd.md
examples/audit-log/audit-log-provider.md
examples/auth-provider/auth0.md
examples/auth-provider/google-auth.md
examples/auth-provider/keycloak.md
examples/auth-provider/kinde.md
examples/auth-provider/otpLogin.md
examples/authentication/antd.md
examples/authentication/headless.md
examples/calendar.md
examples/customization/theme/customThemeAntd.md
examples/data-provider/multiple.md
examples/data-provider/supabase.md
examples/form/antd/custom-form-validation.md
examples/form/antd/serverSideFormValidation.md
examples/form/antd/useDrawerForm.md
examples/form/antd/useForm.md
examples/form/antd/useModalForm.md
examples/form/antd/useStepsForm.md
examples/form/chakra-ui/serverSideFormValidation.md
examples/form/chakra-ui/useDrawerForm.md
examples/form/chakra-ui/useForm.md
examples/form/chakra-ui/useModalForm.md
examples/form/mantine/serverSideFormValidation.md
examples/form/mantine/useDrawerForm.md
examples/form/mantine/useForm.md
examples/form/mantine/useModalForm.md
examples/form/mantine/useStepsForm.md
examples/form/mui/serverSideFormValidation.md
examples/form/mui/useDrawerForm.md
examples/form/mui/useForm.md
examples/form/mui/useModalForm.md
examples/form/mui/useStepsForm.md
examples/form/react-hook-form/useForm.md
examples/form/react-hook-form/useModalForm.md
examples/form/react-hook-form/useStepsForm.md
examples/table/antd/advanced-table.md
examples/table/antd/table-filter.md
examples/table/antd/useDeleteMany.md
examples/table/antd/useEditableTable.md
examples/table/antd/useTable.md
examples/table/antd/useUpdateMany.md
examples/table/tanstack-table/advanced.md
examples/table/tanstack-table/basic.md
examples/themes/refine-themes-antd.md
examples/upload/antd/base64.md
examples/upload/antd/multipart.md
further-readings/comparison.md
further-readings/license.md
further-readings/telemetry.md
further-readings/testing.md
getting-started/example/mui.tsx
getting-started/example/preview-url.ts
getting-started/example/sandpack.tsx
getting-started/overview.md
getting-started/quickstart.md
guides-concepts/audit-logs/index.md
guides-concepts/authentication/auth-pages/antd.tsx
guides-concepts/authentication/auth-pages/chakra.tsx
guides-concepts/authentication/auth-pages/headless.tsx
guides-concepts/authentication/auth-pages/mantine.tsx
guides-concepts/authentication/auth-pages/mui.tsx
guides-concepts/authentication/auth-provider-interface.md
guides-concepts/authentication/index.md
guides-concepts/authentication/is-authenticated.tsx
guides-concepts/authentication/login.tsx
guides-concepts/authentication/on-error.tsx
guides-concepts/authentication/register.tsx
guides-concepts/authorization/example.tsx
guides-concepts/authorization/index.md
guides-concepts/contributing/index.md
guides-concepts/data-fetching/authentication.tsx
guides-concepts/data-fetching/data-provider-interface.md
guides-concepts/data-fetching/error-handling.tsx
guides-concepts/data-fetching/index.md
guides-concepts/data-fetching/multiple-data-provider.tsx
guides-concepts/data-fetching/one-to-many.tsx
guides-concepts/data-fetching/one-to-one.tsx
guides-concepts/data-fetching/use-list-with-filters.tsx
guides-concepts/data-fetching/use-list.tsx
guides-concepts/data-fetching/use-one.tsx
guides-concepts/data-fetching/use-update.tsx
guides-concepts/deployment/index.md
guides-concepts/development/index.md
guides-concepts/faq/index.md
guides-concepts/forms/index.md
guides-concepts/forms/save-and-continue.tsx
guides-concepts/forms/server-side-validation-antd.tsx
guides-concepts/forms/server-side-validation-chakra-ui.tsx
guides-concepts/forms/server-side-validation-core.tsx
guides-concepts/forms/server-side-validation-mantine.tsx
guides-concepts/forms/server-side-validation-mui.tsx
guides-concepts/forms/server-side-validation-react-hook-form.tsx
guides-concepts/forms/use-select-antd.tsx
guides-concepts/forms/use-select-headless.tsx
guides-concepts/forms/use-select-mantine.tsx
guides-concepts/general-concepts/auth-pages/antd.tsx
guides-concepts/general-concepts/auth-pages/chakra.tsx
guides-concepts/general-concepts/auth-pages/headless.tsx
guides-concepts/general-concepts/auth-pages/mantine.tsx
guides-concepts/general-concepts/auth-pages/mui.tsx
guides-concepts/general-concepts/index.md
guides-concepts/general-concepts/layout/antd.tsx
guides-concepts/general-concepts/layout/chakra.tsx
guides-concepts/general-concepts/layout/mantine.tsx
guides-concepts/general-concepts/layout/mui.tsx
guides-concepts/i18n/i18n-headless.tsx
guides-concepts/i18n/index.md
guides-concepts/i18n/locales/de/common.json
guides-concepts/i18n/locales/en/common.json
guides-concepts/import-export/index.md
guides-concepts/import-export/use-export.tsx
guides-concepts/import-export/use-import.tsx
guides-concepts/multitenancy/examples/nextjs.tsx
guides-concepts/multitenancy/examples/react-router.tsx
guides-concepts/multitenancy/examples/remix.tsx
guides-concepts/multitenancy/index.md
guides-concepts/notifications/index.md
guides-concepts/notifications/notifications-antd.tsx
guides-concepts/notifications/notifications-chakra-ui.tsx
guides-concepts/notifications/notifications-mantine.tsx
guides-concepts/notifications/notifications-mui.tsx
guides-concepts/realtime/index.md
guides-concepts/routing/index.md
guides-concepts/routing/nextjs/resource-and-routes-usage.tsx
guides-concepts/routing/nextjs/use-table-usage.tsx
guides-concepts/routing/react-router/resource-and-routes-usage.tsx
guides-concepts/routing/react-router/use-form-usage.tsx
guides-concepts/routing/react-router/use-modal-form-usage.tsx
guides-concepts/routing/react-router/use-table-usage.tsx
guides-concepts/routing/remix/resource-and-routes-usage.tsx
guides-concepts/routing/remix/use-table-usage.tsx
guides-concepts/tables/example/antd.tsx
guides-concepts/tables/example/chakra-ui.tsx
guides-concepts/tables/example/core.tsx
guides-concepts/tables/example/filtering.tsx
guides-concepts/tables/example/mantine.tsx
guides-concepts/tables/example/pagination.tsx
guides-concepts/tables/example/relationship.tsx
guides-concepts/tables/example/search-antd.tsx
guides-concepts/tables/example/sorting.tsx
guides-concepts/tables/example/tanstack-table.tsx
guides-concepts/tables/index.md
guides-concepts/ui-libraries/index.md
guides-concepts/usage-with-existing-projects/index.md
guides-concepts/usage-with-existing-projects/nextjs/app/headless.tsx
guides-concepts/usage-with-existing-projects/nextjs/app/layout/antd.tsx
guides-concepts/usage-with-existing-projects/nextjs/app/router.tsx
guides-concepts/usage-with-existing-projects/nextjs/pages/headless.tsx
guides-concepts/usage-with-existing-projects/nextjs/pages/layout/antd.tsx
guides-concepts/usage-with-existing-projects/nextjs/pages/router.tsx
guides-concepts/usage-with-existing-projects/vite/headless.tsx
guides-concepts/usage-with-existing-projects/vite/layout/antd.tsx
guides-concepts/usage-with-existing-projects/vite/router.tsx
i18n/hooks/use-translation/index.md
i18n/i18n-provider/index.md
notification/hooks/use-notification/basic-usage-live-preview.md
notification/hooks/use-notification/index.md
notification/notification-provider/index.md
packages/cli/index.md
packages/command-palette/index.md
packages/inferencer/index.md
packages/list-of-packages/index.md
packages/react-hook-form/introduction/index.md
packages/react-hook-form/use-form/index.md
packages/react-hook-form/use-modal-form/index.md
packages/react-hook-form/use-steps-form/index.md
packages/tanstack-table/examples/_partial-basic-usage-live-preview.md
packages/tanstack-table/examples/_partial-filtering-live-preview.md
packages/tanstack-table/examples/_partial-pagination-live-preview.md
packages/tanstack-table/examples/_partial-relational-live-preview.md
packages/tanstack-table/examples/_partial-sorting-live-preview.md
packages/tanstack-table/examples/chakra-ui.tsx
packages/tanstack-table/examples/headless.tsx
packages/tanstack-table/examples/mantine.tsx
packages/tanstack-table/introduction/index.md
packages/tanstack-table/use-table/index.md
partials/_partial-translation-file-de.md
partials/_partial-translation-file-en.md
partials/tutorial/headless-layout.md
realtime/hooks/use-publish/index.md
realtime/hooks/use-subscription/index.md
realtime/live-provider/index.md
repomix.config.json
routing/components/link/index.md
routing/hooks/use-back/index.md
routing/hooks/use-get-to-path/index.md
routing/hooks/use-go/index.md
routing/hooks/use-link/index.md
routing/hooks/use-navigation/index.md
routing/hooks/use-parsed/index.md
routing/hooks/use-resource-params/index.md
routing/hooks/use-resource/index.md
routing/integrations/react-router/index.md
routing/integrations/react-router/migration-guide-v6-to-v7.md
routing/integrations/remix/index.md
routing/router-provider/index.md
ui-integrations/ant-design/components/auth-page/index.md
ui-integrations/ant-design/components/auto-save-indicator/index.md
ui-integrations/ant-design/components/basic-views/create/index.md
ui-integrations/ant-design/components/basic-views/edit/index.md
ui-integrations/ant-design/components/basic-views/list/index.md
ui-integrations/ant-design/components/basic-views/show/index.md
ui-integrations/ant-design/components/breadcrumb/index.md
ui-integrations/ant-design/components/buttons/clone-button/index.md
ui-integrations/ant-design/components/buttons/create-button/index.md
ui-integrations/ant-design/components/buttons/delete-button/index.md
ui-integrations/ant-design/components/buttons/edit-button/index.md
ui-integrations/ant-design/components/buttons/export-button/index.md
ui-integrations/ant-design/components/buttons/import-button/index.md
ui-integrations/ant-design/components/buttons/list-button/index.md
ui-integrations/ant-design/components/buttons/refresh-button/index.md
ui-integrations/ant-design/components/buttons/save-button/index.md
ui-integrations/ant-design/components/buttons/show-button/index.md
ui-integrations/ant-design/components/fields/boolean-field/index.md
ui-integrations/ant-design/components/fields/date-field/index.md
ui-integrations/ant-design/components/fields/email-field/index.md
ui-integrations/ant-design/components/fields/file-field/index.md
ui-integrations/ant-design/components/fields/image-field/index.md
ui-integrations/ant-design/components/fields/markdown-field/index.md
ui-integrations/ant-design/components/fields/number-field/index.md
ui-integrations/ant-design/components/fields/tag-field/index.md
ui-integrations/ant-design/components/fields/text-field/index.md
ui-integrations/ant-design/components/fields/url-field/index.md
ui-integrations/ant-design/components/filter-dropdown/index.md
ui-integrations/ant-design/components/inferencer/index.md
ui-integrations/ant-design/components/inputs/custom-inputs.md
ui-integrations/ant-design/components/themed-layout/index.md
ui-integrations/ant-design/hooks/use-checkbox-group/index.md
ui-integrations/ant-design/hooks/use-drawer-form/index.md
ui-integrations/ant-design/hooks/use-editable-table/_partial-use-editable-table-live-preview.md
ui-integrations/ant-design/hooks/use-editable-table/index.md
ui-integrations/ant-design/hooks/use-form/index.md
ui-integrations/ant-design/hooks/use-import/index.md
ui-integrations/ant-design/hooks/use-modal-form/index.md
ui-integrations/ant-design/hooks/use-modal/index.md
ui-integrations/ant-design/hooks/use-radio-group/index.md
ui-integrations/ant-design/hooks/use-select/_basic-usage-live-preview.md
ui-integrations/ant-design/hooks/use-select/_crud-live-preview.md
ui-integrations/ant-design/hooks/use-select/_default-value-live-preview.md
ui-integrations/ant-design/hooks/use-select/_on-search-live-preview.md
ui-integrations/ant-design/hooks/use-select/_sort-live-preview.md
ui-integrations/ant-design/hooks/use-select/index.md
ui-integrations/ant-design/hooks/use-simple-list/_basic-usage-live-preview.md
ui-integrations/ant-design/hooks/use-simple-list/_filtering-live-preview.md
ui-integrations/ant-design/hooks/use-simple-list/_search-live-preview.md
ui-integrations/ant-design/hooks/use-simple-list/_sorting-live-preview.md
ui-integrations/ant-design/hooks/use-simple-list/index.md
ui-integrations/ant-design/hooks/use-steps-form/index.md
ui-integrations/ant-design/hooks/use-table/_partial-use-table-basic-usage-live-preview.md
ui-integrations/ant-design/hooks/use-table/_partial-use-table-filtering-live-preview.md
ui-integrations/ant-design/hooks/use-table/_partial-use-table-relational-live-preview.md
ui-integrations/ant-design/hooks/use-table/_partial-use-table-search-live-preview.md
ui-integrations/ant-design/hooks/use-table/_partial-use-table-sorter-live-preview.md
ui-integrations/ant-design/hooks/use-table/index.md
ui-integrations/ant-design/introduction/index.md
ui-integrations/ant-design/introduction/previews/auth-page.tsx
ui-integrations/ant-design/introduction/previews/basic-views.tsx
ui-integrations/ant-design/introduction/previews/example.tsx
ui-integrations/ant-design/introduction/previews/layout-react-router-dom.tsx
ui-integrations/ant-design/introduction/previews/layout-remix.tsx
ui-integrations/ant-design/introduction/previews/theming.tsx
ui-integrations/ant-design/introduction/previews/usage-react-router-dom.tsx
ui-integrations/ant-design/introduction/previews/usage-remix.tsx
ui-integrations/ant-design/migration-guide/index.md
ui-integrations/ant-design/theming/index.md

================================================================
Files
================================================================

================
File: .repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

**/*next-js*
**/*material-ui*

================
File: advanced-tutorials/access-control.md
================
---
id: access-control
title: Access Control
sidebar_label: Access Control
---

```tsx live shared
import {
  newModel as CasbinNewModel,
  StringAdapter as CasbinStringAdapter,
  newEnforcer as CasbinNewEnforcer,
} from "casbin";

const model = CasbinNewModel(`
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act, eft

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

[matchers]
m = g(r.sub, p.sub) && keyMatch(r.obj, p.obj) && regexMatch(r.act, p.act)
`);

import {
  Create as AntdCreate,
  List as AntdList,
  useForm as useAntdForm,
  useTable as useAntdTable,
  EditButton as AntdEditButton,
  ShowButton as AntdShowButton,
  EmailField as AntdEmailField,
  NumberField as AntdNumberField,
} from "@refinedev/antd";
import {
  Table as AntdTable,
  Edit as AntdEdit,
  Form as AntdForm,
  Input as AntdInput,
  Space as AntdSpace,
  Layout as AntdLayout,
  Radio as AntdRadio,
} from "antd";

interface IPost {
  id: number;
  title: string;
  content: string;
}

const PostList = () => {
  const { tableProps } = useAntdTable();

  return (
    <AntdList>
      <AntdTable {...tableProps} rowKey="id">
        <AntdTable.Column dataIndex="id" title="ID" />
        <AntdTable.Column dataIndex="title" title="Title" />
        <AntdTable.Column dataIndex="status" title="Status" />
        <AntdTable.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record) => (
            <AntdSpace>
              <AntdEditButton hideText size="small" recordItemId={record.id} />
              <AntdShowButton hideText size="small" recordItemId={record.id} />
            </AntdSpace>
          )}
        />
      </AntdTable>
    </AntdList>
  );
};

const PostCreate = () => {
  const { formProps, saveButtonProps } = useAntdForm();

  return (
    <AntdCreate saveButtonProps={saveButtonProps}>
      <AntdForm {...formProps} layout="vertical">
        <AntdForm.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
        <AntdForm.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput.TextArea />
        </AntdForm.Item>
      </AntdForm>
    </AntdCreate>
  );
};

const CategoryList = () => {
  const { tableProps } = useAntdTable();

  return (
    <AntdList>
      <AntdTable {...tableProps} rowKey="id">
        <AntdTable.Column dataIndex="id" title="ID" />
        <AntdTable.Column dataIndex="title" title="Title" />
        <AntdTable.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record) => (
            <AntdSpace>
              <AntdEditButton hideText size="small" recordItemId={record.id} />
              <AntdShowButton hideText size="small" recordItemId={record.id} />
            </AntdSpace>
          )}
        />
      </AntdTable>
    </AntdList>
  );
};

const CategoryCreate = () => {
  const { formProps, saveButtonProps } = useAntdForm();

  return (
    <AntdCreate saveButtonProps={saveButtonProps}>
      <AntdForm {...formProps} layout="vertical">
        <AntdForm.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
      </AntdForm>
    </AntdCreate>
  );
};

const UserList = () => {
  const { tableProps } = useAntdTable();

  return (
    <AntdList>
      <AntdTable {...tableProps} rowKey="id">
        <AntdTable.Column dataIndex="firstName" title="First Name" />
        <AntdTable.Column dataIndex="lastName" title="Last Name" />
        <AntdTable.Column
          dataIndex="email"
          title="Email"
          render={(value) => <AntdEmailField value={value} />}
        />
        <AntdTable.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record) => (
            <AntdSpace>
              <AntdEditButton hideText size="small" recordItemId={record.id} />
              <AntdShowButton hideText size="small" recordItemId={record.id} />
            </AntdSpace>
          )}
        />
      </AntdTable>
    </AntdList>
  );
};

const UserCreate = () => {
  const { formProps, saveButtonProps } = useAntdForm();

  return (
    <AntdCreate saveButtonProps={saveButtonProps}>
      <AntdForm {...formProps} layout="vertical">
        <AntdForm.Item
          label="First Name"
          name="firstName"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
        <AntdForm.Item
          label="Last Name"
          name="lastName"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
        <AntdForm.Item
          label="Email"
          name="email"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
      </AntdForm>
    </AntdCreate>
  );
};

const Header = ({ role }) => {
  return (
    <AntdLayout.Header
      style={{
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        height: "48px",
        backgroundColor: "#FFF",
      }}
    >
      <AntdRadio.Group value={role}>
        <AntdRadio.Button value="admin">Admin</AntdRadio.Button>
        <AntdRadio.Button value="editor">Editor</AntdRadio.Button>
      </AntdRadio.Group>
    </AntdLayout.Header>
  );
};
```

## Introduction

Access control is a broad topic where there are lots of advanced solutions that provide a different sets of features. **Refine** is deliberately agnostic for its own API to be able to integrate different methods (RBAC, ABAC, ACL, etc.) and different libraries ([Casbin](https://casbin.org/), [CASL](https://casl.js.org/v5/en/), [Cerbos](https://cerbos.dev/), [AccessControl.js](https://onury.io/accesscontrol/)). `can` method would be the entry point for those solutions.

[Refer to the Access Control Provider documentation for detailed information. &#8594](/docs/authorization/access-control-provider)

**Refine** provides an agnostic API via the `accessControlProvider` to manage access control throughout your app.

An `accessControlProvider` must implement only one async method named `can` to be used to check if the desired access will be granted.

We will be using **[Casbin](https://casbin.org/)** in this guide for users with different roles who have different access rights for parts of the app.

## Installation

We need to install Casbin.

<InstallPackagesCommand args="casbin"/>

:::caution

To make this example more visual, we used the [`@refinedev/antd`](https://github.com/refinedev/refine/tree/main/packages/antd) package. If you are using Refine headless, you need to provide the components, hooks, or helpers imported from the [`@refinedev/antd`](https://github.com/refinedev/refine/tree/main/packages/antd) package.

:::

## Setup

The app will have three resources: **posts**, **users**, and **categories** with CRUD pages(list, create, edit, and show).

[You can refer to CodeSandbox to see how they are implemented &#8594](#example)

`App.tsx` will look like this before we begin implementing access control:

```tsx title="src/App.tsx"
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2, ErrorComponent, RefineThemes } from "@refinedev/antd";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { ConfigProvider } from "antd";
import "@refinedev/antd/dist/reset.css";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "posts",
              list: "/posts",
              create: "/posts/create",
              edit: "/posts/edit/:id",
              show: "/posts/show/:id",
              meta: {
                canDelete: true,
              },
            },
            {
              name: "users",
              list: "/users",
              create: "/users/create",
              edit: "/users/edit/:id",
              show: "/users/show/:id",
            },
            {
              name: "categories",
              list: "/categories",
              create: "/categories/create",
              edit: "/categories/edit/:id",
              show: "/categories/show/:id",
            },
          ]}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="posts">
                <Route index element={<PostList />} />
                <Route path="create" element={<PostCreate />} />
                <Route path="show/:id" element={<PostShow />} />
                <Route path="edit/:id" element={<PostEdit />} />
              </Route>
              <Route path="users">
                <Route index element={<UserList />} />
                <Route path="create" element={<UserCreate />} />
                <Route path="show/:id" element={<UserShow />} />
                <Route path="edit/:id" element={<UserEdit />} />
              </Route>
              <Route path="categories">
                <Route index element={<CategoryList />} />
                <Route path="create" element={<CategoryCreate />} />
                <Route path="show/:id" element={<CategoryShow />} />
                <Route path="edit/:id" element={<CategoryEdit />} />
              </Route>
            </Route>
            <Route path="*" element={<ErrorComponent />} />
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

export default App;
```

## Adding Policy and Model

The way **[Casbin](https://casbin.org/)** works is that access rights are checked according to policies that are defined based on a model. You can find further information about how models and policies work [here](https://casbin.org/docs/how-it-works).

Let's add a model and a policy for a role **editor** that have **list** access for **posts** resource.

```ts title="src/accessControl.ts"
import { newModel, StringAdapter } from "casbin";

export const model = newModel(`
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && keyMatch(r.obj, p.obj) && regexMatch(r.act, p.act)
`);

export const adapter = new StringAdapter(`
p, editor, posts, list
`);
```

:::tip

You can can find more examples in [Casbin documentation](https://casbin.org/docs/supported-models) or play with lots of examples in [Casbin editor](https://casbin.org/editor)

:::

## Adding `accessControlProvider`

Now we will implement the `can` method for `accessControlProvider` to integrate our policy.

```tsx title="src/App.tsx"
// ...
// highlight-next-line
import { newEnforcer } from "casbin";

// highlight-next-line
import { model, adapter } from "./accessControl";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <Refine
        // highlight-start
        accessControlProvider={{
          can: async ({ resource, action }) => {
            const enforcer = await newEnforcer(model, adapter);
            const can = await enforcer.enforce("editor", resource, action);

            return { can };
          },
        }}
        // highlight-end
        //...
      >
        {/* ... */}
      </Refine>
    </BrowserRouter>
  );
};

export default App;
```

Whenever a part of the app checks for access control, Refine passes `resource`, `action`, and `params` parameters to `can` and then we can use these parameters to integrate our specific access control solution which is **Casbin** in this case.

Our model provides that user with role **editor** have access for **list** action on **posts** resource. Even though we have two other resources, since our policy doesn't include them, they will not appear on the sidebar menu. Also in the list page of `posts`, buttons for **create**, **edit** and **show** buttons will be disabled since they are not included in the policy.

```tsx live previewOnly url=http://localhost:5173/posts previewHeight=420px
setInitialRoutes(["/posts"]);
import React from "react";
import { Create, useForm } from "@refinedev/antd";
import { Form, Input } from "antd";

const adapter = new CasbinStringAdapter(`
p, editor, posts, list
`);

setRefineProps({
  accessControlProvider: {
    can: async ({ resource, action }) => {
      const enforcer = await CasbinNewEnforcer(model, adapter);
      const can = await enforcer.enforce("editor", resource, action);

      return { can };
    },
  },
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreate,
    },
  ],
});

render(<RefineAntdDemo />);
```

## Adding Different Roles

We can provide different access rights to a different types of users for different parts of the app. We can do that by adding policies for the different roles.

```ts
export const adapter = new MemoryAdapter(`
p, admin, posts, (list)|(create)
p, admin, users, (list)|(create)
p, admin, categories, (list)|(create)

p, editor, posts, (list)|(create)
p, editor, categories, list
`);
```

- **admin** will have access to **list** and **create** for every resource
- **editor** will have access to **list** and **create** for **posts**
- **editor** won't have any access for **users**
- **editor** will have only **list** access for **categories**

We can demonstrate the effect of different roles by changing the `role` dynamically. Let's implement a switch in the header for selecting either **admin** or **editor** role to see the effect on the app.

```tsx title="src/App.tsx"
// highlight-next-line
import { Header } from "components/header";

const App: React.FC = () => {
  // highlight-start
  import { CanAccess } from "@refinedev/core";
  const role = localStorage.getItem("role") ?? "admin";
  // highlight-end

  return (
    <BrowserRouter>
      <Refine
        // highlight-start
        accessControlProvider={{
          can: async ({ resource, action }) => {
            const enforcer = await newEnforcer(model, adapter);
            // highlight-next-line
            const can = await enforcer.enforce(role, resource, action);

            return {
              can,
            };
          },
        }}
        // highlight-end
        //...
      >
        <Routes>
          <Route
            element={
              // highlight-start
              <ThemedLayoutV2 Header={() => <Header role={role} />}>
                <CanAccess>
                  <Outlet />
                </CanAccess>
              </ThemedLayoutV2>
              // highlight-end
            }
          >
            {/* ... */}
          </Route>
        </Routes>
        {/* ... */}
      </Refine>
    </BrowserRouter>
  );
};

export default App;
```

<details>
<summary>Header Component</summary>

```tsx title="src/components/header.tsx"
import { Layout, Radio } from "antd";

interface HeaderProps {
  role: string;
}

export const Header: React.FC<HeaderProps> = ({ role }) => {
  return (
    <Layout.Header
      style={{
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        height: "48px",
        backgroundColor: "#FFF",
      }}
    >
      <Radio.Group
        value={role}
        onChange={(event) => {
          localStorage.setItem("role", event.target.value);
          location.reload();
        }}
      >
        <Radio.Button value="admin">Admin</Radio.Button>
        <Radio.Button value="editor">Editor</Radio.Button>
      </Radio.Group>
    </Layout.Header>
  );
};
```

</details>
<br/>

Now, let's see how the application will appear when logging in as an `admin` or `editor`.

<Tabs
defaultValue="admin"
values={[ {label: 'admin', value: 'admin'}, {label: 'editor', value: 'editor'} ]}>

<TabItem value="admin">

```tsx live previewOnly url=http://localhost:5173 previewHeight=660px
setInitialRoutes(["/posts"]);
import { useState } from "react";
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import { ConfigProvider, Layout } from "antd";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import dataProvider from "@refinedev/simple-rest";
const API_URL = "https://api.fake-rest.refine.dev";

const adapter = new CasbinStringAdapter(`
p, admin, posts, (list)|(create)
p, admin, users, (list)|(create)
p, admin, categories, (list)|(create)

p, editor, posts, (list)|(create)
p, editor, categories, list
`);

const App: React.FC = () => {
  const role = "admin";

  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "posts",
              list: "/posts",
              create: "/posts/create",
            },
            {
              name: "categories",
              list: "/categories",
              create: "/categories/create",
            },
            {
              name: "users",
              list: "/users",
              create: "/users/create",
            },
          ]}
          accessControlProvider={{
            can: async ({ resource, action }) => {
              const enforcer = await CasbinNewEnforcer(model, adapter);
              const can = await enforcer.enforce(role, resource, action);

              return { can };
            },
          }}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2
                // Header={() => <Header role={role} />}
                >
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="posts">
                <Route index element={<PostList />} />
                <Route path="create" element={<PostCreate />} />
              </Route>
              <Route path="categories">
                <Route index element={<CategoryList />} />
                <Route path="create" element={<CategoryCreate />} />
              </Route>
              <Route path="users">
                <Route index element={<UserList />} />
                <Route path="create" element={<UserCreate />} />
              </Route>
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

render(<App />);
```

</TabItem>

<TabItem value="editor">

```tsx live previewOnly url=http://localhost:5173 previewHeight=660px
setInitialRoutes(["/posts"]);
import { useState } from "react";
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import { ConfigProvider, Layout } from "antd";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import dataProvider from "@refinedev/simple-rest";
const API_URL = "https://api.fake-rest.refine.dev";

const adapter = new CasbinStringAdapter(`
p, admin, posts, (list)|(create)
p, admin, users, (list)|(create)
p, admin, categories, (list)|(create)

p, editor, posts, (list)|(create)
p, editor, categories, list
`);

const App: React.FC = () => {
  const role = "editor";

  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "posts",
              list: "/posts",
              create: "/posts/create",
            },
            {
              name: "categories",
              list: "/categories",
              create: "/categories/create",
            },
            {
              name: "users",
              list: "/users",
              create: "/users/create",
            },
          ]}
          accessControlProvider={{
            can: async ({ resource, action }) => {
              const enforcer = await CasbinNewEnforcer(model, adapter);
              const can = await enforcer.enforce(role, resource, action);

              return { can };
            },
          }}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2
                // Header={() => <Header role={role} />}
                >
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="posts">
                <Route index element={<PostList />} />
                <Route path="create" element={<PostCreate />} />
              </Route>
              <Route path="categories">
                <Route index element={<CategoryList />} />
                <Route path="create" element={<CategoryCreate />} />
              </Route>
              <Route path="users">
                <Route index element={<UserList />} />
                <Route path="create" element={<UserCreate />} />
              </Route>
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

render(<App />);
```

</TabItem>
</Tabs>

## Handling access with params

### ID Based Access

Let's update our policies to handle **id** based access control points like **edit**, **show** pages, and **delete** button.

```ts
export const adapter = new MemoryAdapter(`
p, admin, posts, (list)|(create)
// highlight-next-line
p, admin, posts/*, (edit)|(show)|(delete)

p, admin, users, (list)|(create)
// highlight-next-line
p, admin, users/*, (edit)|(show)|(delete)

p, admin, categories, (list)|(create)
// highlight-next-line
p, admin, categories/*, (edit)|(show)|(delete)

p, editor, posts, (list)|(create)
// highlight-next-line
p, editor, posts/*, (edit)|(show)

p, editor, categories, list
`);
```

- **admin** will have **edit**, **show** and **delete** access for every resource
- **editor** will have **edit** and **show** access for **posts**

:::tip

`*` is a wildcard. Specific ids can be targeted too. For example If you want **editor** role to have **delete** access for **post** with **id** `5`, you can add this policy:

```ts
export const adapter = new MemoryAdapter(`
p, editor, posts/5, delete
`);
```

:::

We must handle id based access controls in the `can` method. **id** parameter will be accessible in `params`.

```tsx title="src/App.tsx"
const App: React.FC = () => {
  return (
    <Refine
      //...
      accessControlProvider={{
        // highlight-start
        can: async ({ resource, action, params }) => {
          const enforcer = await newEnforcer(model, adapter);

          if (action === "delete" || action === "edit" || action === "show") {
            const can = await enforcer.enforce(
              role,
              `${resource}/${params?.id}`,
              action,
            );

            return { can };
          }
          // highlight-end

          const can = await enforcer.enforce(role, resource, action);

          return { can };
        },
      }}
    >
      {/* ... */}
    </Refine>
  );
};

export default App;
```

### Field Based Access

We can also check access control for specific areas in our app like a certain field of a table. This can be achieved by adding a special action for the custom access control point in our policies.

For example, we may want to **deny** **editor** roles to access **hit** field in the **posts** resource without denying the **admin** role. This can be done with [RBAC with deny-override](https://casbin.org/docs/supported-models) model.

```ts
export const model = newModel(`
[request_definition]
r = sub, obj, act

[policy_definition]
// highlight-next-line
p = sub, obj, act, eft

[role_definition]
g = _, _

[policy_effect]
// highlight-next-line
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

[matchers]
m = g(r.sub, p.sub) && keyMatch(r.obj, p.obj) && regexMatch(r.act, p.act)
`);

export const adapter = new MemoryAdapter(`
p, admin, posts, (list)|(create)
p, admin, posts/*, (edit)|(show)|(delete)
// highlight-next-line
p, admin, posts/*, field

p, admin, users, (list)|(create)
p, admin, users/*, (edit)|(show)|(delete)

p, admin, categories, (list)|(create)
p, admin, categories/*, (edit)|(show)|(delete)

p, editor, posts, (list)|(create)
p, editor, posts/*, (edit)|(show)
// highlight-next-line
p, editor, posts/hit, field, deny

p, editor, categories, list
`);
```

- **admin** have **field** access for every field of **posts**
- **editor** won't have **field** access for **hit** field of **posts**

Then we must handle the **field** action in the `can` method:

```tsx title="src/App.tsx"
const App: React.FC = () => {
  return (
    <Refine
      //...
      accessControlProvider={{
        can: async ({ resource, action, params }) => {
          const enforcer = await newEnforcer(model, adapter);

          if (action === "delete" || action === "edit" || action === "show") {
            const can = await enforcer.enforce(
              role,
              `${resource}/${params?.id}`,
              action,
            );

            return { can };
          }

          // highlight-start
          if (action === "field") {
            const can = await enforcer.enforce(
              role,
              `${resource}/${params?.field}`,
              action,
            );
            return { can };
          }
          // highlight-end

          const can = await enforcer.enforce(role, resource, action);

          return { can };
        },
      }}
    >
      {/* ... */}
    </Refine>
  );
};

export default App;
```

Then it can be used with [`useCan`](/docs/authorization/hooks/use-can) in the related area:

```tsx title="src/pages/posts/list.tsx"
import {
  // ...
  useCan,
} from "@refinedev/core";

export const PostList: React.FC = () => {
  // highlight-start
  const { data: canAccess } = useCan({
    resource: "posts",
    action: "field",
    params: { field: "hit" },
  });
  // highlight-end

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        // highlight-start
        {canAccess?.can && (
          <Table.Column
            dataIndex="hit"
            title="Hit"
            render={(value: number) => (
              <NumberField value={value} options={{ notation: "compact" }} />
            )}
          />
        )}
        // highlight-end
      </Table>
    </List>
  );
};
```

:::tip

[`<CanAccess />`](/docs/authorization/components/can-access) can be used too to check access control in custom places in your app.

:::

<br/>

Now, let's see how the application will appear when logging in as an `admin` or `editor`.

<Tabs
defaultValue="admin"
values={[ {label: 'admin', value: 'admin'}, {label: 'editor', value: 'editor'} ]}>

<TabItem value="admin">

```tsx live previewOnly url=http://localhost:5173 previewHeight=660px
setInitialRoutes(["/posts"]);
import { useState } from "react";
import { Refine, useCan } from "@refinedev/core";
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import { ConfigProvider, Layout } from "antd";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import dataProvider from "@refinedev/simple-rest";
const API_URL = "https://api.fake-rest.refine.dev";

const adapter = new CasbinStringAdapter(`
p, admin, posts, (list)|(create)
p, admin, posts/*, (edit)|(show)|(delete)
p, admin, posts/*, field

p, admin, users, (list)|(create)
p, admin, users/*, (edit)|(show)|(delete)

p, admin, categories, (list)|(create)
p, admin, categories/*, (edit)|(show)|(delete)

p, editor, posts, (list)|(create)
p, editor, posts/*, (edit)|(show)
p, editor, posts/hit, field, deny

p, editor, categories, list
`);

const PostListWithHit = () => {
  const { tableProps } = useAntdTable();
  const { data: canAccess } = useCan({
    resource: "posts",
    action: "field",
    params: { field: "hit" },
  });

  return (
    <AntdList>
      <AntdTable {...tableProps} rowKey="id">
        <AntdTable.Column dataIndex="id" title="ID" />
        <AntdTable.Column dataIndex="title" title="Title" />
        <AntdTable.Column dataIndex="status" title="Status" />
        {canAccess?.can && (
          <AntdTable.Column
            dataIndex="hit"
            title="Hit"
            render={(value: number) => (
              <AntdNumberField
                value={value}
                options={{ notation: "compact" }}
              />
            )}
          />
        )}
        <AntdTable.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record) => (
            <AntdSpace>
              <AntdEditButton hideText size="small" recordItemId={record.id} />
              <AntdShowButton hideText size="small" recordItemId={record.id} />
            </AntdSpace>
          )}
        />
      </AntdTable>
    </AntdList>
  );
};

const App: React.FC = () => {
  const role = "admin";

  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "posts",
              list: "/posts",
              create: "/posts/create",
            },
            {
              name: "categories",
              list: "/categories",
              create: "/categories/create",
            },
            {
              name: "users",
              list: "/users",
              create: "/users/create",
            },
          ]}
          accessControlProvider={{
            can: async ({ resource, action, params }) => {
              const enforcer = await CasbinNewEnforcer(model, adapter);

              if (
                action === "delete" ||
                action === "edit" ||
                action === "show"
              ) {
                const can = await enforcer.enforce(
                  role,
                  `${resource}/${params?.id}`,
                  action,
                );

                return { can };
              }

              if (action === "field") {
                const can = await enforcer.enforce(
                  role,
                  `${resource}/${params?.field}`,
                  action,
                );
                return { can };
              }

              const can = await enforcer.enforce(role, resource, action);

              return { can };
            },
          }}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2
                // Header={() => <Header role={role} />}
                >
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="posts">
                <Route index element={<PostListWithHit />} />
                <Route path="create" element={<PostCreate />} />
              </Route>
              <Route path="categories">
                <Route index element={<CategoryList />} />
                <Route path="create" element={<CategoryCreate />} />
              </Route>
              <Route path="users">
                <Route index element={<UserList />} />
                <Route path="create" element={<UserCreate />} />
              </Route>
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

render(<App />);
```

</TabItem>

<TabItem value="editor">

```tsx live previewOnly url=http://localhost:5173 previewHeight=660px
setInitialRoutes(["/posts"]);
import { useState } from "react";
import { Refine, useCan } from "@refinedev/core";
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import { ConfigProvider, Layout } from "antd";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import dataProvider from "@refinedev/simple-rest";
const API_URL = "https://api.fake-rest.refine.dev";

const adapter = new CasbinStringAdapter(`
p, admin, posts, (list)|(create)
p, admin, users, (list)|(create)
p, admin, categories, (list)|(create)

p, editor, posts, (list)|(create)
p, editor, categories, list
`);

const PostListWithHit = () => {
  const { tableProps } = useAntdTable();
  const { data: canAccess } = useCan({
    resource: "posts",
    action: "field",
    params: { field: "hit" },
  });

  return (
    <AntdList>
      <AntdTable {...tableProps} rowKey="id">
        <AntdTable.Column dataIndex="id" title="ID" />
        <AntdTable.Column dataIndex="title" title="Title" />
        <AntdTable.Column dataIndex="status" title="Status" />
        {canAccess?.can && (
          <AntdTable.Column
            dataIndex="hit"
            title="Hit"
            render={(value: number) => (
              <AntdNumberField
                value={value}
                options={{ notation: "compact" }}
              />
            )}
          />
        )}
        <AntdTable.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record) => (
            <AntdSpace>
              <AntdEditButton hideText size="small" recordItemId={record.id} />
              <AntdShowButton hideText size="small" recordItemId={record.id} />
            </AntdSpace>
          )}
        />
      </AntdTable>
    </AntdList>
  );
};

const App: React.FC = () => {
  const role = "editor";

  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "posts",
              list: "/posts",
              create: "/posts/create",
            },
            {
              name: "categories",
              list: "/categories",
              create: "/categories/create",
            },
            {
              name: "users",
              list: "/users",
              create: "/users/create",
            },
          ]}
          accessControlProvider={{
            can: async ({ resource, action, params }) => {
              const enforcer = await CasbinNewEnforcer(model, adapter);

              if (
                action === "delete" ||
                action === "edit" ||
                action === "show"
              ) {
                const can = await enforcer.enforce(
                  role,
                  `${resource}/${params?.id}`,
                  action,
                );

                return { can };
              }

              if (action === "field") {
                const can = await enforcer.enforce(
                  role,
                  `${resource}/${params?.field}`,
                  action,
                );
                return { can };
              }

              const can = await enforcer.enforce(role, resource, action);

              return { can };
            },
          }}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2
                // Header={() => <Header role={role} />}
                >
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="posts">
                <Route index element={<PostListWithHit />} />
                <Route path="create" element={<PostCreate />} />
              </Route>
              <Route path="categories">
                <Route index element={<CategoryList />} />
                <Route path="create" element={<CategoryCreate />} />
              </Route>
              <Route path="users">
                <Route index element={<UserList />} />
                <Route path="create" element={<UserCreate />} />
              </Route>
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

render(<App />);
```

</TabItem>

</Tabs>

## Example

### Casbin

<CodeSandboxExample path="access-control-casbin" />

### Cerbos

<CodeSandboxExample path="access-control-cerbos" />

================
File: advanced-tutorials/auth/auth0.md
================
---
id: auth0
title: Auth0 Login
sidebar_label: Auth0 Login
---

[Auth0](https://auth0.com/) is a flexible, drop-in solution for adding authentication and authorization services to your applications. Your team and organization can avoid the cost, time, and risk that comes with building your own solution to authenticate and authorize users. You can check the [Auth0 document](https://auth0.com/docs) for details.

We will show you how to use Auth0 with Refine

### Installation

Run the following command within your project directory to install the Auth0 React SDK:

<InstallPackagesCommand args="@auth0/auth0-react"/>

#### Configure the Auth0Provider component

Wrap your root component with an Auth0Provider that you can import from the SDK.

```tsx title="index.tsx"
import React from "react";
import { createRoot } from "react-dom/client";

// highlight-next-line
import { Auth0Provider } from "@auth0/auth0-react";

import App from "./App";

const container = document.getElementById("root");
const root = createRoot(container!);
root.render(
  <React.StrictMode>
    // highlight-start
    <Auth0Provider
      domain="YOUR_DOMAIN"
      clientId="YOUR_CLIENT_ID"
      redirectUri={window.location.origin}
    >
      <App />
    </Auth0Provider>
    // highlight-end
  </React.StrictMode>,
);
```

:::caution

Refer to [**Auth0 docs**](https://auth0.com/docs/quickstart/spa/react#configure-auth0) for detailed configuration.

:::

### Override `/login` page

First, we need to override the **Refine** login page. In this way, we will redirect it to the Auth0 login page. We create a `login.tsx` file in the `/pages` folder.

```tsx title="/pages/login.tsx"
import { Layout, Button, Space, Typography } from "antd";
import { ThemedTitleV2 } from "@refinedev/antd";
// highlight-next-line
import { useAuth0 } from "@auth0/auth0-react";

export const Login: React.FC = () => {
  // highlight-next-line
  const { loginWithRedirect } = useAuth0();

  return (
    <Layout
      style={{
        height: "100vh",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Space direction="vertical" align="center" size="large">
        <ThemedTitleV2
          collapsed={false}
          wrapperStyles={{
            fontSize: "22px",
          }}
        />
        <Button
          type="primary"
          size="middle"
          // highlight-next-line
          onClick={() => loginWithRedirect()}
          style={{ width: "240px" }}
        >
          Sign in
        </Button>
        <Typography.Text type="secondary">Powered by Auth0</Typography.Text>
      </Space>
    </Layout>
  );
};
```

After clicking the `Login` button, you will be directed to the auth0 login screen.

<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/auth0/auth0-login-min.gif" className="border border-gray-200 rounded" alt="auth0-login" />

## Auth Provider

In Refine, authentication and authorization processes are performed with the auth provider. Let's write a provider for Auth0.

<details>
<summary>Show Code</summary>
<p>

```tsx title="App.tsx"
import { Refine, AuthProvider, Authenticated } from "@refinedev/core";
import {
  ThemedLayoutV2,
  ReadyPage,
  useNotificationProvider,
  ErrorComponent,
  RefineThemes,
} from "@refinedev/antd";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, {
  NavigateToResource,
  CatchAllNavigate,
} from "@refinedev/react-router";
import { useAuth0 } from "@auth0/auth0-react";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { ConfigProvider } from "antd";
import "@refinedev/antd/dist/reset.css";

import { Login } from "pages/login";

import axios from "axios";

const API_URL = "https://api.fake-rest.refine.dev";

const App = () => {
  const { isLoading, isAuthenticated, user, logout, getIdTokenClaims } =
    useAuth0();

  if (isLoading) {
    return <span>loading...</span>;
  }

  const authProvider: AuthProvider = {
    login: async () => {
      return {
        success: true,
      };
    },
    logout: async () => {
      logout({ returnTo: window.location.origin });
      return {
        success: true,
      };
    },
    onError: async (error) => {
      console.error(error);
      return { error };
    },
    check: async () => {
      try {
        const token = await getIdTokenClaims();
        if (token) {
          axios.defaults.headers.common = {
            Authorization: `Bearer ${token.__raw}`,
          };
          return {
            authenticated: true,
          };
        } else {
          return {
            authenticated: false,
            error: {
              message: "Check failed",
              name: "Token not found",
            },
            redirectTo: "/login",
            logout: true,
          };
        }
      } catch (error: any) {
        return {
          authenticated: false,
          error: new Error(error),
          redirectTo: "/login",
          logout: true,
        };
      }
    },
    getPermissions: async () => null,
    getIdentity: async () => {
      if (user) {
        return {
          ...user,
          avatar: user.picture,
        };
      }
      return null;
    },
  };

  getIdTokenClaims().then((token) => {
    if (token) {
      axios.defaults.headers.common = {
        Authorization: `Bearer ${token.__raw}`,
      };
    }
  });

  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          authProvider={authProvider}
          dataProvider={dataProvider(API_URL, axios)}
          notificationProvider={useNotificationProvider}
          resources={[
            {
              name: "posts",
              list: "/posts",
            },
          ]}
        >
          <Routes>
            <Route
              element={
                <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                  <ThemedLayoutV2>
                    <Outlet />
                  </ThemedLayoutV2>
                </Authenticated>
              }
            >
              <Route path="/posts" element={<div>dummy list page</div>} />
            </Route>
            <Route
              element={
                <Authenticated fallback={<Outlet />}>
                  <NavigateToResource />
                </Authenticated>
              }
            >
              <Route path="/login" element={<Login />} />
            </Route>
            <Route path="*" element={<ErrorComponent />} />
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

export default App;
```

</p>
</details>

### Methods

#### login

`loginWithRedirect` method comes from the `useAuth0` hook.

#### logout

`logout` method comes from the `useAuth0` hook.

#### checkError & getPermissions

We revert to empty promise because Auth0 does not support it.

#### checkAuth

We can use the `isAuthenticated` method, which returns the authentication status of the `useAuth0` hook.

#### getUserIdentity

We can use it with the `user` from the `useAuth0` hook.

## Example

:::caution

Auth0 example doesn't work in CodeSandbox embed mode. With [this](https://cv8k99.csb.app/) link, you can open the example in the browser and try it.

:::

<CodeSandboxExample path="auth-auth0" />

================
File: advanced-tutorials/auth/azure-ad.md
================
---
id: azure-ad
title: Azure AD Login
sidebar_label: Azure AD Login
---

# Azure Active Directory B2C (AAD B2C)

[Azure Active Directory B2C](https://learn.microsoft.com/en-us/azure/active-directory-b2c/overview) provides business-to-customer identity as a service. Your customers use their preferred social, enterprise, or local account identities to get single sign-on access to your applications and APIs.

The Microsoft Authentication Library (MSAL) enables developers to acquire security tokens from the Microsoft identity platform to authenticate users and access secured web APIs. It can be used to provide secure access to Microsoft Graph, other Microsoft APIs, third-party web APIs, or your own web API. MSAL supports many different application architectures and platforms including .NET, JavaScript, Java, Python, Android, and iOS.

:::tip

We use Azure AD B2C in our example but authentication with Azure AD should be very similar.

:::

### Installation

We will be using the javascript version of msal library and a helper for react. You can find more about the msal library here: [docs](https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-overview)

To install the required dependencies, run the following command:

<InstallPackagesCommand args="@azure/msal-browser @azure/msal-react"/>

Detailed documentation for using msal with react can be found here: [docs](https://learn.microsoft.com/en-us/azure/active-directory/develop/single-page-app-quickstart?pivots=devlang-react)

## Configure the MsalProvider component

We've create config file in `src/config.ts` folder. This file contains the configuration for the msal library. You can find more information about the configuration options here: [docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications)

```ts title="src/config.ts"
import { Configuration, LogLevel } from "@azure/msal-browser";

export const msalConfig: Configuration = {
    auth: {
        clientId: "YOUR_CLIENT_ID", //`${process.env.REACT_APP_AZURE_AAD_CLIENT_ID}`,
        authority: "YOUR_AUTHORITY", //`https://${process.env.REACT_APP_AZURE_AAD_TENANT_NAME}.b2clogin.com/${process.env.REACT_APP_AZURE_AAD_TENANT_NAME}.onmicrosoft.com/${process.env.REACT_APP_AZURE_AAD_POLICY_NAME}`,
        knownAuthorities: ["YOUR_KNOWN_AUTHORITIES"], //[`${process.env.REACT_APP_AZURE_AAD_TENANT_NAME}.b2clogin.com`],
        redirectUri: "http://localhost:3000/", // Replace appropriately
        postLogoutRedirectUri: window.location.origin,
    },
    cache: {
        cacheLocation: "sessionStorage", // This configures where your cache will be stored
        storeAuthStateInCookie: false, // Set this to "true" if you are having issues on IE11 or Edge
    },
};

// Add scopes here for ID token to be used at Microsoft identity platform endpoints.
export const loginRequest = {
    scopes: ["User.Read"]
};

export const tokenRequest = {
    scopes: [...] // Replace ... with your custom scopes
};


// Add the endpoints here for Microsoft Graph API services you'd like to use.
export const graphConfig = {
    graphMeEndpoint: "ENTER_THE_GRAPH_ENDPOINT_HERE/v1.0/me"
};
```

:::note

We recommend to use environment variables for the configuration parameters.

:::

Wrap your root component with an `MsalProvider` that you can import from the SDK.

```tsx title="src/index.tsx"
import React from "react";
import ReactDOM from "react-dom/client";

import {
  EventType,
  PublicClientApplication,
  AccountInfo,
  EventPayload,
  SilentRequest,
} from "@azure/msal-browser";
import { MsalProvider } from "@azure/msal-react";

import App, { TOKEN_KEY } from "./App";
import { msalConfig, tokenRequest } from "./config";

const msalInstance = new PublicClientApplication(msalConfig);

msalInstance.addEventCallback(async (event) => {
  if (event.eventType === EventType.LOGIN_SUCCESS) {
    const payload: EventPayload = event.payload;
    msalInstance.setActiveAccount(payload as AccountInfo);

    let account = msalInstance.getActiveAccount();

    const request: SilentRequest = {
      ...tokenRequest,
      account: account!,
    };
    try {
      // Silently acquires an access token which is then attached to a request for API access
      const response = await msalInstance.acquireTokenSilent(request);
      console.log("Fetching access token: success");
      console.log("Scopes", response.scopes);
      console.log("Token Type", response.tokenType);

      localStorage.setItem(TOKEN_KEY, response.accessToken);
    } catch (e) {
      msalInstance.acquireTokenPopup(request).then((response) => {
        localStorage.setItem(TOKEN_KEY, response.accessToken);
      });
    }
  }
});

const root = ReactDOM.createRoot(
  document.getElementById("root") as HTMLElement,
);
root.render(
  <React.StrictMode>
    <MsalProvider instance={msalInstance}>
      <App />
    </MsalProvider>
  </React.StrictMode>,
);
```

## Override `/login` page

First, we need to override the Refine login page. In this way, we will redirect it to the Azure AD login page. We create a `login.tsx` file in the `/src` folder.

```tsx title="src/login.tsx"
import React from "react";
import { useLogin } from "@refinedev/core";
import { Layout, Button } from "antd";

const LoginPage = () => {
  const SignInButton = () => {
    const { mutate: login } = useLogin();

    return (
      <Button type="primary" size="large" block onClick={() => login()}>
        Sign in
      </Button>
    );
  };

  return (
    <Layout
      style={{
        background: `radial-gradient(50% 50% at 50% 50%, #63386A 0%, #310438 100%)`,
        backgroundSize: "cover",
      }}
    >
      <div style={{ height: "100vh", display: "flex" }}>
        <div style={{ maxWidth: "200px", margin: "auto" }}>
          <div style={{ marginBottom: "28px" }}>
            <img src="./refine.svg" alt="Refine" />
          </div>
          <SignInButton />
        </div>
      </div>
    </Layout>
  );
};

export default LoginPage;
```

## Auth Provider

In Refine, authentication and authorization processes are performed with the auth provider. Let's write a provider for Azure AD.

```tsx title="src/App.tsx"
import { Refine, AuthProvider, Authenticated } from "@refinedev/core";
import { Layout, ErrorComponent } from "@refinedev/antd";
import routerProvider, {
  NavigateToResource,
  CatchAllNavigate,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
import { useIsAuthenticated, useMsal } from "@azure/msal-react";
import { AccountInfo, SilentRequest } from "@azure/msal-browser";
import axios from "axios";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import LoginPage from "./login";
import { tokenRequest } from "./config";

export const TOKEN_KEY = "refine-auth";

export const axiosInstance = axios.create();

axiosInstance.interceptors.request.use(
  // Here we can perform any function we'd like on the request
  (config) => {
    // Retrieve the token from local storage
    const token = localStorage.getItem(TOKEN_KEY);

    // Check if the header property exists
    if (config.headers) {
      // Set the Authorization header if it exists
      config.headers["Authorization"] = `Bearer ${token}`;
    }
    return config;
  },
);

const App: React.FC = () => {
  const API_URL = "https://api.fake-rest.refine.dev";

  const isAuthenticated = useIsAuthenticated();
  const { instance, inProgress, accounts } = useMsal();

  if (inProgress === "login" || inProgress === "handleRedirect") {
    return <div>Loading...</div>;
  }

  const account: AccountInfo = accounts[0];

  const request: SilentRequest = {
    ...tokenRequest,
    account,
  };

  const authProvider: AuthProvider = {
    login: async () => {
      instance.loginRedirect(); // Pick the strategy you prefer i.e. redirect or popup
      return {
        success: true,
      };
    },
    register: async () => ({
      success: true,
    }),
    resetPassword: async () => ({
      success: true,
    }),
    updatePassword: async () => ({
      success: true,
    }),
    logout: async () => ({
      success: true,
    }),
    check: async () => {
      try {
        if (account) {
          const token = await instance.acquireTokenSilent(request);
          localStorage.setItem(TOKEN_KEY, token.accessToken);
          return {
            authenticated: true,
          };
        } else {
          return {
            authenticated: false,
            redirectTo: "/login",
          };
        }
      } catch (e) {
        return {
          authenticated: false,
          redirectTo: "/login",
        };
      }
    },
    onError: async (error) => {
      console.error(error);
      return { error };
    },
    getPermissions: async () => null,
    getIdentity: async (): Promise<AccountInfo> => {
      if (account === null || account === undefined) {
        return null;
      }
      return account;
    },
  };

  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider(API_URL, axiosInstance)}
        authProvider={authProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
          },
        ]}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                <Layout>
                  <Outlet />
                </Layout>
              </Authenticated>
            }
          >
            <Route path="/posts" element={<div>dummy list page</div>} />
          </Route>
          <Route
            element={
              <Authenticated fallback={<Outlet />}>
                <NavigateToResource />
              </Authenticated>
            }
          >
            <Route path="/login" element={<LoginPage />} />
          </Route>
          <Route path="*" element={<ErrorComponent />} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};

export default App;
```

================
File: advanced-tutorials/custom-layout.md
================
---
id: custom-layout
title: Custom Layout
sidebar_label: Custom Layout
---

**Refine** supports any layout you want with no restrictions and also provides default layouts with its UI packages. You are free to use them or create your own with the help of **Refine**'s hooks and components. You can also use the [`swizzle`][cli] command to customize the default layouts and adapt them to your needs.

## Layout Elements

### Layout

`<Layout>` components are designed to wrap your pages and provide a dashboard-like layout. `<Layout>` accepts rest of the layout elements in props.

| Prop                              | Type        | Description                                     |
| --------------------------------- | ----------- | ----------------------------------------------- |
| [`Sider`](#sider)                 | `React.FC`  | Component to render menu aside                  |
| [`Header`](#header)               | `React.FC`  | Component to render at the top of the layout    |
| [`Title`](#title)                 | `React.FC`  | Component to render inside `<Sider>`            |
| [`Footer`](#footer)               | `React.FC`  | Component to render at the bottom of the layout |
| [`OffLayoutArea`](#offlayoutarea) | `React.FC`  | Component to render outside of the layout       |
| `children`                        | `ReactNode` | Page content.                                   |

### Sider

`<Sider>` components are designed to render menu items according to the resources you have defined in `<Refine>` components. [`useMenu`][usemenu] hook is used under the hood to generate menu items.

| Prop              | Type                                          | Description                                                               |
| ----------------- | --------------------------------------------- | ------------------------------------------------------------------------- |
| [`Title`](#title) | `React.FC`                                    | Component to render at the top                                            |
| `render`          | [`SiderRenderFunction`](#siderrenderfunction) | Function to render the menu items and other elements inside the `<Sider>` |
| `meta`            | `Record<string,any>`                          | Meta data to use when creating routes for the menu items                  |

### SiderRenderFunction

```tsx
type SiderRenderFunction = (props: {
  items: JSX.Element[];
  logout: React.ReactNode;
  dashboard: React.ReactNode;
  collapsed: boolean;
}) => React.ReactNode;
```

You can use the `render` prop to customize the render of the `<Sider>` without needing to swizzle the whole component.

```tsx title="Using Render Prop"
import { Sider } from "@refinedev/antd";

const CustomSider = () => {
  return (
    <Sider
      render={({ items, logout, collapsed }) => {
        return (
          <>
            <div>My Custom Element</div>
            {items}
            {logout}
          </>
        );
      }}
    />
  );
};
```

### Header

`<Header>` components are designed to render a header at the top of the layout.

### Title

`<Title>` components are designed to render a title inside the `<Sider>` component. By default, it renders the **Refine** logo with a link to the index page.

### Footer

`<Footer>` components are designed to render a footer at the bottom of the layout.

### OffLayoutArea

`<OffLayoutArea>` components are designed to render elements outside of the layout.

## Example

Here's an example of a custom layout, made with help of **Refine**'s hooks and components.

You can find more examples about custom layouts for different UI packages in the [examples](/docs/examples) section.

<CodeSandboxExample path="customization-top-menu-layout" />

[Refine]: /docs/core/refine-component
[cli]: /docs/packages/list-of-packages#swizzle
[usemenu]: /docs/core/hooks/utilities/use-menu

================
File: advanced-tutorials/data-provider/handling-filters.md
================
---
id: handling-filters
title: Handling Filters
---

**Refine** expects an array of type `CrudFilters` to filter results based on some field’s values. So you can use more than one filter. Even the `or` operator can be used to combine multiple filters.

## CrudFilters

`CrudFilters` is an array of objects with the following properties:

```ts
// Supported operators:
type CrudOperators =
  | "eq"
  | "ne"
  | "lt"
  | "gt"
  | "lte"
  | "gte"
  | "in"
  | "nin"
  | "ina"
  | "nina"
  | "contains"
  | "ncontains"
  | "containss"
  | "ncontainss"
  | "between"
  | "nbetween"
  | "null"
  | "nnull"
  | "or"
  | "startswith"
  | "nstartswith"
  | "startswiths"
  | "nstartswiths"
  | "endswith"
  | "nendswith"
  | "endswiths"
  | "nendswiths";

// Supported filter types:
type LogicalFilter = {
  field: string;
  operator: Exclude<CrudOperators, "or">;
  value: any;
};

type ConditionalFilter = {
  operator: "or";
  value: LogicalFilter[];
};

type CrudFilter = LogicalFilter | ConditionalFilter;
//highlight-next-line
type CrudFilters = CrudFilter[];
```

## LogicalFilters

`LogicalFilter` works with `AND` logic. For example, if you want to filter by `name` field and `age` field, you can use the following filter:

```ts
const filter = [
  {
    field: "name",
    operator: "eq",
    value: "John",
  },
  {
    field: "age",
    operator: "lt",
    value: 30,
  },
];
```

Here the query will look like: `"name" = "John" AND "age" < 30`

## ConditionalFilters

`ConditionalFilter` works `or` / `and` operator and expects an array of `LogicalFilter` objects in the `value` property. For example, if you want to filter multiple `OR` by `name` field and `age` field, you can use the following filter:

```ts
const filter = [
  {
    operator: "or",
    value: [
      {
        operator: "and",
        value: [
          {
            field: "name",
            operator: "eq",
            value: "John Doe",
          },
          {
            field: "age",
            operator: "eq",
            value: 30,
          },
        ],
      },
      {
        operator: "and",
        value: [
          {
            field: "name",
            operator: "eq",
            value: "JR.Doe",
          },
          {
            field: "age",
            operator: "eq",
            value: 1,
          },
        ],
      },
    ],
  },
];
```

Here the query will look like: `("name" = John Doe AND "age" = 30) OR ("name" = JR.Doe AND "age" = 1)`

### Top level multiple conditional filters usage

If you create multiple Conditional Filters at the top level, you must add a key to it. Otherwise, you will get a warning in the console and your filters may not be combined correctly.

```ts
const filter = [
  {
    key: "parent",
    operator: "or",
    value: [
      {
        operator: "and",
        value: [
          {
            field: "name",
            operator: "eq",
            value: "John Doe",
          },
          {
            field: "age",
            operator: "eq",
            value: 30,
          },
        ],
      },
      {
        operator: "and",
        value: [
          {
            field: "name",
            operator: "eq",
            value: "Jane Doe",
          },
          {
            field: "age",
            operator: "eq",
            value: 28,
          },
        ],
      },
    ],
  },
  {
    key: "children",
    operator: "or",
    value: [
      {
        operator: "and",
        value: [
          {
            field: "name",
            operator: "eq",
            value: "JR John",
          },
          {
            field: "age",
            operator: "eq",
            value: 1,
          },
        ],
      },
      {
        operator: "and",
        value: [
          {
            field: "name",
            operator: "eq",
            value: "JR Jane",
          },
          {
            field: "age",
            operator: "eq",
            value: 2,
          },
        ],
      },
    ],
  },
];
```

## Combining Filters

You can group multiple parameters in the same query using the logical filters or the conditional filters operators to filter results based on more than one criteria at the same time. This allows you to create more complex queries.

Example query: Find posts with 2 possible dates & a specific status

```ts
filter = [
  {
    operator: "or",
    value: [
      {
        field: "createdAt",
        operator: "eq",
        value: "2022-01-01",
      },
      {
        field: "createdAt",
        operator: "eq",
        value: "2022-01-02",
      },
    ],
  },
  {
    operator: "eq",
    field: "status",
    value: "published",
  },
];
```

Here the query will look like:
`"status" == "published" AND ("createdAt" == "2022-01-01" OR "createdAt" == "2022-01-02")`

## Handle filters in a data provider

```tsx title="dataProvider.ts"
import { DataProvider } from "@refinedev/core";

const dataProvider = (): DataProvider => ({
  getList: async ({ resource, pagination, filters, sorters }) => {
    if (filters) {
      filters.map((filter) => {
        if (
          filter.operator !== "or" &&
          filter.operator !== "and" &&
          "field" in filter
        ) {
          // Handle your logical filters here
          // console.log(typeof filter); // LogicalFilter
        } else {
          // Handle your conditional filters here
          // console.log(typeof filter); // ConditionalFilter
        }
      });
    }
  },
});
```

:::tip

Data providers that support `or` and `and` filtering logic are as follows:

- [NestJS CRUD](https://github.com/refinedev/refine/tree/main/packages/nestjsx-crud)
- [Strapi](https://github.com/refinedev/refine/tree/main/packages/strapi) - [Strapi v4](https://github.com/refinedev/refine/tree/main/packages/strapi-v4)
- [Supabase](https://github.com/refinedev/refine/tree/main/packages/supabase)
- [Hasura](https://github.com/refinedev/refine/tree/main/packages/hasura)

:::

## Handle Custom GraphQL Variables

The [GraphQLQueryOptions](https://refine.dev/docs/core/interface-references/#graphqlqueryoptions) property `gqlVariables` enables dynamic GraphQL variables to be passed to the data provider for more advanced GraphQL queries.

Packages that support custom GraphQL variables for more advanced filtering are as follows:

- [Hasura](https://github.com/refinedev/refine/tree/main/packages/hasura)

The following data providers do not yet support `meta.gqlVariables`;

- [Nestjs-Query](https://github.com/refinedev/refine/tree/main/packages/nestjs-query)
- [GraphQL](https://github.com/refinedev/refine/tree/main/packages/graphql)

```tsx
// Hasura Data Provider Example
import gql from "graphql-tag";
import { useTable } from "@refinedev/antd";
import type { GetFieldsFromList } from "@refinedev/hasura";
import type { GetPostsQuery } from "graphql/types";

const POSTS_QUERY = gql`
    query GetPosts(
        $offset: Int!
        $limit: Int!
        $order_by: [posts_order_by!]
        $where: posts_bool_exp
    ) {
        posts(
            offset: $offset
            limit: $limit
            order_by: $order_by
            where: $where
        ) {
            id
            title
            content
            category_id
            created_at
            category {
                id
                title
            }
        }
        posts_aggregate(where: $where) {
            aggregate {
                count
            }
        }
    }
`;

export const PostList = () => {
  const { tableProps } = useTable<
  GetFieldsFromList<GetPostsQuery>
  >({
  meta: {
    gqlQuery: POSTS_QUERY,
    gqlVariables: {
      where: {
        _and: [
          {
            _not: {
              category: { title: { _eq: "ok" } },
            },
          },
          {
            title: {
              _ilike: "%Updated%",
            },
          },
          {
            title: {
              _ilike: "%3%",
            },
          },
          {
            created_at: {
              _gte: "2023-08-04T08:26:26.489116+00:00",
            },
          },
        ],
      },
    },
  });
  return ( <Table {...tableProps}/> );
}

```

================
File: advanced-tutorials/forms/custom-form-validation.md
================
---
id: custom-form-validation
title: Custom Form Validation
---

In **Refine**, we can use the form validation that comes with `Ant Design` with the [rules](https://ant.design/components/form/#Rule) property of the [Form.Item](https://ant.design/components/form/#Form.Item) component.

```tsx
<Form>
  <Form.Item
    label="Title"
    name="title"
    // highlight-start
    rules={[
      {
        required: true,
      },
      {
        min: 5,
      },
    ]}
    // highlight-end
  >
    <Input />
  </Form.Item>
  ...
</Form>
```

In addition to pre-defined rules, we can also prepare **custom rules** with the validator function.

### Example

Now let's prepare a rule that checks if the titles of the posts are unique. We have an endpoint like the below. We will do the uniqueness check here.

```json title="https://api.fake-rest.refine.dev/posts-unique-check?title=Example"
{
  "isAvailable": true
}
```

```tsx live hideCode url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { useForm, Create, CreateButton } from "@refinedev/antd";
import { Form, Input } from "antd";
// highlight-next-line
import { useApiUrl, useCustom, HttpError } from "@refinedev/core";

// highlight-start
interface IPost {
  title: string;
}

interface PostUniqueCheckResponse {
  isAvailable: boolean;
}

interface PostUniqueCheckRequestQuery {
  title: string;
}
// highlight-end

const PostCreate: React.FC = () => {
  const { formProps, saveButtonProps } = useForm<IPost>({
    defaultFormValues: {
      title: "Test",
    },
  });

  // highlight-next-line
  const [title, setTitle] = useState("Test");

  // highlight-start
  const apiUrl = useApiUrl();
  const url = `${apiUrl}/posts-unique-check`;
  const { refetch } = useCustom<
    PostUniqueCheckResponse,
    HttpError,
    PostUniqueCheckRequestQuery
  >({
    url,
    method: "get",
    config: {
      query: {
        title,
      },
    },
    queryOptions: {
      enabled: false,
    },
  });
  // highlight-end

  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Title"
          name="title"
          // highlight-start
          rules={[
            {
              required: true,
            },
            {
              validator: async (_, value) => {
                if (!value)
                  return Promise.reject(new Error("Please enter a title"));
                const { data } = await refetch();
                if (data && data.data.isAvailable) {
                  return Promise.resolve();
                }
                return Promise.reject(new Error("'title' must be unique"));
              },
            },
          ]}
          // highlight-end
        >
          <Input
            defaultValue="Test"
            // highlight-next-line
            onChange={(event) => setTitle(event.target.value)}
          />
        </Form.Item>
      </Form>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div>
              <p>This page is empty.</p>
              <CreateButton />
            </div>
          }
        />
        <ReactRouter.Route path="/posts/create" element={<PostCreate />} />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::danger important

Value must be kept in the state.

```tsx
<Input onChange={(event) => setTitle(event.target.value)} />
```

:::

================
File: advanced-tutorials/multi-level-menu/multi-level-menu.md
================
---
id: multi-level-menu
title: Multi Level Menu
sidebar_label: Multi Level Menu
---

This document is related to how to create a multi-level menu for **Refine** applications.

### What is Multi-level Menu?

The multi-level menu is a great way to organize your sider menu items. You can create groups and sub menus to keep your menu items organized. This makes it easy to find the menu items you are looking for.

## Usage

To do this, it is necessary to create an object array with the following [resources properties](/docs/core/interface-references#resourceprops):

```tsx title="src/App.tsx"
        <Refine
           ...
            resources={[
                {
                    // highlight-start
                    name: "CMS",
                    // highlight-end
                },
                {
                    // highlight-start
                    name: "posts",
                    meta: { parent: "CMS" },
                    // highlight-end
                    list: "/posts",
                },
                {
                    // highlight-start
                    name: "category",
                    meta: { parent: "CMS", canDelete: true },
                    // highlight-end
                    list: "/categories",
                },
            ]}
        />
```

:::tip

The `meta.parent` you give in the resource objects must be strictly equal to the resource name you want to group under.

:::

### Headless

If you want to create your multi-level menu without any UI framework integration, [`useMenu`](/docs/core/hooks/utilities/use-menu) hook gives your resources.

```tsx title="src/components/layout/sider/index.tsx"
//highlight-next-line
import { useMenu } from "@refinedev/core";

export const Sider: React.FC = () => {
  //highlight-next-line
  const { menuItems, selectedKey, defaultOpenKeys } = useMenu();

  // Here create your Sider to your UI choice
};
```

```tsx title="example output"

// console.log(menuItems);
[
    {
        name: "CMS",
        key: "CMS",
        ...
        children: [
            {
                name: "posts",
                key: "CMS/posts",
                route: "/posts",
                ...
                children: [],
            },
            {
                name: "category",
                key: "CMS/category",
                route: "/category",
                ...
                children: [],
            },
        ],
    },
];
```

<br/>

### Ant Design

The Sider component allows you to create the groups you want in the sider menu. By default, the sider will group menu items by their top-level heading. However, you can also add sub menu items to each group via `meta.parent`.

This gives you more control over the side menu and allows you to customize it to better suit your needs.

<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/multi-level-menu/multi-level-menu.png" alt="multiLevelMenu" />
<br />

<br/>

## Example

You can review the example to examine the multi-level menu concept in more detail.

<CodeSandboxExample path="multi-level-menu" />

================
File: advanced-tutorials/mutation-mode.md
================
---
id: mutation-mode
title: Mutation Mode
---

```tsx live shared
import { Refine } from "@refinedev/core";
import {
  AuthPage,
  RefineThemes,
  ThemedLayoutV2,
  ErrorComponent,
  useNotificationProvider,
} from "@refinedev/antd";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import { ConfigProvider } from "antd";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";
import dataProvider from "@refinedev/simple-rest";

const API_URL = "https://api.fake-rest.refine.dev";

import {
  useMany as CoreUseMany,
  useShow as RefineCoreUseShow,
  useOne as RefineCoreUseOne,
} from "@refinedev/core";
import {
  List as RefineAntdList,
  TextField as RefineAntdTextField,
  useTable as RefineAntdUseTable,
  EditButton as RefineAntdEditButton,
  ShowButton as RefineAntdShowButton,
  useForm as RefineAntdUseForm,
  useSelect as RefineAntdUseSelect,
  Create as RefineAntdCreate,
  Edit as RefineAntdEdit,
  Show as RefineAntdShow,
} from "@refinedev/antd";
import {
  Table as AntdTable,
  Space as AntdSpace,
  Form as AntdForm,
  Select as AntdSelect,
  Input as AntdInput,
  Typography as AntdTypography,
} from "antd";

const PostList: React.FC = () => {
  const { tableProps, sorter } = RefineAntdUseTable<IPost>({
    sorters: {
      initial: [
        {
          field: "$id",
          order: "asc",
        },
      ],
    },
  });

  const categoryIds =
    tableProps?.dataSource?.map((item) => item.category.id) ?? [];
  const { data, isLoading } = CoreUseMany<ICategory>({
    resource: "categories",
    ids: categoryIds,
    queryOptions: {
      enabled: categoryIds.length > 0,
    },
  });

  return (
    <RefineAntdList>
      <AntdTable {...tableProps} rowKey="id">
        <AntdTable.Column dataIndex="id" title="ID" />
        <AntdTable.Column dataIndex="title" title="Title" />
        <AntdTable.Column
          dataIndex={["category", "id"]}
          title="Category"
          render={(value) => {
            if (isLoading) {
              return <RefineAntdTextField value="Loading..." />;
            }

            return (
              <RefineAntdTextField
                value={data?.data.find((item) => item.id === value)?.title}
              />
            );
          }}
        />
        <AntdTable.Column<IPost>
          title="Actions"
          dataIndex="actions"
          render={(_, record) => (
            <AntdSpace>
              <RefineAntdEditButton
                hideText
                size="small"
                recordItemId={record.id}
              />
              <RefineAntdShowButton
                hideText
                size="small"
                recordItemId={record.id}
              />
            </AntdSpace>
          )}
        />
      </AntdTable>
    </RefineAntdList>
  );
};

const PostCreate: React.FC = () => {
  const { formProps, saveButtonProps } = RefineAntdUseForm<IPost>();

  const { selectProps: categorySelectProps } = RefineAntdUseSelect<ICategory>({
    resource: "categories",
  });

  return (
    <RefineAntdCreate saveButtonProps={saveButtonProps}>
      <AntdForm {...formProps} layout="vertical">
        <AntdForm.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
        <AntdForm.Item
          label="Category"
          name={["category", "id"]}
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdSelect {...categorySelectProps} />
        </AntdForm.Item>
        <AntdForm.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput.TextArea />
        </AntdForm.Item>
      </AntdForm>
    </RefineAntdCreate>
  );
};

const PostEdit: React.FC = () => {
  const { formProps, saveButtonProps, query } = RefineAntdUseForm<IPost>();

  const postData = query?.data?.data;
  const { selectProps: categorySelectProps } = RefineAntdUseSelect<ICategory>({
    resource: "categories",
    defaultValue: postData?.category.id,
  });

  return (
    <RefineAntdEdit saveButtonProps={saveButtonProps}>
      <AntdForm {...formProps} layout="vertical">
        <AntdForm.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
        <AntdForm.Item
          label="Category"
          name={["category", "id"]}
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdSelect {...categorySelectProps} />
        </AntdForm.Item>
        <AntdForm.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput.TextArea />
        </AntdForm.Item>
      </AntdForm>
    </RefineAntdEdit>
  );
};

const PostShow: React.FC = () => {
  const { queryResult } = RefineCoreUseShow<IPost>();
  const { data, isLoading } = queryResult;
  const record = data?.data;

  const { data: categoryData, isLoading: categoryIsLoading } =
    RefineCoreUseOne<ICategory>({
      resource: "categories",
      id: record?.category?.id || "",
      queryOptions: {
        enabled: !!record,
      },
    });

  return (
    <RefineAntdShow isLoading={isLoading}>
      <AntdTypography.Title level={5}>Id</AntdTypography.Title>
      <AntdTypography.Text>{record?.id}</AntdTypography.Text>

      <AntdTypography.Title level={5}>
        AntdTypography.Title
      </AntdTypography.Title>
      <AntdTypography.Text>{record?.title}</AntdTypography.Text>

      <AntdTypography.Title level={5}>Category</AntdTypography.Title>
      <AntdTypography.Text>
        {categoryIsLoading ? "Loading..." : categoryData?.data.title}
      </AntdTypography.Text>

      <AntdTypography.Title level={5}>Content</AntdTypography.Title>
      <AntdTypography.Text>{record?.content}</AntdTypography.Text>
    </RefineAntdShow>
  );
};
```

## Overview

Mutation mode determines which mode the mutation runs with. Mutations can run under three different modes: `pessimistic`, `optimistic` and `undoable`.
Each mode corresponds to a different type of user experience.

## Modes

We'll show usages of modes with editing a record examples.

### pessimistic

The mutation runs immediately. Redirection and UI updates are executed after the mutation returns successfully.

You can experience an example of this below using the edit page.

```tsx live previewOnly url=http://localhost:5173/posts previewHeight=600px
setInitialRoutes(["/posts"]);

const App = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "posts",
              list: "/posts",
              show: "/posts/show/:id",
              edit: "/posts/edit/:id",
            },
          ]}
          notificationProvider={useNotificationProvider}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route index element={<NavigateToResource />} />

              <Route path="/posts">
                <Route index element={<PostList />} />
                <Route path="create" element={<PostCreate />} />
                <Route path="edit/:id" element={<PostEdit />} />
                <Route path="show/:id" element={<PostShow />} />
              </Route>

              <Route path="*" element={<ErrorComponent />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

render(<App />);
```

> When the user clicks on save button, request to the API happens directly and after successful response, list page updates with newly edited record.

<br />

### optimistic

The mutation is applied locally, redirection and UI updates are executed immediately as if the mutation is successful. If mutation returns with error, UI updates to show data prior to the mutation.

```tsx live previewOnly url=http://localhost:5173/posts previewHeight=600px
setInitialRoutes(["/posts"]);

const App = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "posts",
              list: "/posts",
              show: "/posts/show/:id",
              edit: "/posts/edit/:id",
            },
          ]}
          notificationProvider={useNotificationProvider}
          options={{ mutationMode: "optimistic" }}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route index element={<NavigateToResource />} />

              <Route path="/posts">
                <Route index element={<PostList />} />
                <Route path="create" element={<PostCreate />} />
                <Route path="edit/:id" element={<PostEdit />} />
                <Route path="show/:id" element={<PostShow />} />
              </Route>

              <Route path="*" element={<ErrorComponent />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

render(<App />);
```

> When the user clicks on save button, request to the API happens directly and list page updates with edited data immediately without waiting API response.

<br />

### undoable

The mutation is applied locally, redirection and UI updates are executed immediately as if the mutation is successful. Waits for a customizable amount of timeout period before mutation is applied. During the timeout, mutation can be cancelled from the notification with an undo button and UI will revert back accordingly.

```tsx live previewOnly url=http://localhost:5173/posts previewHeight=600px
setInitialRoutes(["/posts"]);

const App = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "posts",
              list: "/posts",
              show: "/posts/show/:id",
              edit: "/posts/edit/:id",
            },
          ]}
          notificationProvider={useNotificationProvider}
          options={{ mutationMode: "undoable" }}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route index element={<NavigateToResource />} />

              <Route path="/posts">
                <Route index element={<PostList />} />
                <Route path="create" element={<PostCreate />} />
                <Route path="edit/:id" element={<PostEdit />} />
                <Route path="show/:id" element={<PostShow />} />
              </Route>

              <Route path="*" element={<ErrorComponent />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

render(<App />);
```

> When the user clicks on save button, request isn't sent to API immediately however list page updates with edited data. It waits for a period of time while the user can cancel the mutation. If the mutation is cancelled, locally applied edit is undone.

## Usage

Mutation mode can be set application-wide in [`<Refine>`](/docs/core/refine-component#mutationmode) component.

```tsx title="App.tsx"
<Refine
    ...
    options={{ mutationMode: "optimistic" }}
/>
```

> Its default value is `pessimistic`.

<br />

It can also be set in supported [data hooks](/docs/data/hooks/use-update#mutation-mode) and [form hooks](/docs/data/hooks/use-form/#properties) for fine-grained configuration.

```tsx
import { useUpdate } from "@refinedev/core";

const { mutate } = useUpdate();

mutate({
  resource: "categories",
  id: "2",
  values: { title: "New Category Title" },
  // highlight-next-line
  mutationMode: "optimistic",
});
```

> Mutation mode passed to `<Refine>` will be overridden by the mutation mode passed to data or form hooks and components.

### Supported data hooks

- [`useUpdate` &#8594](/docs/data/hooks/use-update)
- [`useUpdateMany` &#8594](/docs/data/hooks/use-update)
- [`useDelete` &#8594](/docs/data/hooks/use-delete)
- [`useDeleteMany` &#8594](/docs/data/hooks/use-delete)

<br />

## Example

<Tabs
defaultValue="antd"
values={[
{label: 'Ant Design', value: 'antd'},
{label: 'Chakra UI', value: 'chakra-ui'},
{label: 'Mantine', value: 'mantine'},
{label: 'Material UI', value: 'material-ui'}
]}>

<TabItem value="antd">

<CodeSandboxExample path="form-antd-mutation-mode" />

</TabItem>

<TabItem value="chakra-ui">

<CodeSandboxExample path="form-chakra-ui-mutation-mode" />

</TabItem>

<TabItem value="mantine">

<CodeSandboxExample path="form-mantine-mutation-mode" />

</TabItem>

<TabItem value="material-ui">

<CodeSandboxExample path="form-material-ui-mutation-mode" />

</TabItem>

</Tabs>

================
File: advanced-tutorials/real-time.md
================
---
id: real-time
title: Live / Realtime
sidebar_label: Live / Realtime
---

**Refine** lets you add Realtime support to your app via the `liveProvider` prop for [`<Refine />`](/docs/core/refine-component). It can be used to update and show data in Realtime throughout your app. **Refine** remains agnostic in its API to allow different solutions([Ably](https://ably.com), [Socket.IO](https://socket.io/), [Mercure](https://mercure.rocks/), [supabase](https://supabase.com), etc.) to be integrated.

[Refer to the Live Provider documentation for detailed information. &#8594](/docs/realtime/live-provider)

We will be using [Ably](https://ably.com) in this guide to provide Realtime features.

## Installation

We need to install the Ably live provider package from **Refine**.

<InstallPackagesCommand args="@refinedev/ably"/>

:::caution

To make this example more visual, we used the [`@refinedev/antd`](https://github.com/refinedev/refine/tree/main/packages/antd) package. If you are using Refine headless, you need to provide the components, hooks, or helpers imported from the [`@refinedev/antd`](https://github.com/refinedev/refine/tree/main/packages/antd) package.

:::

## Setup

Since we will need `apiKey` from Ably, you must first register and get the key from [Ably](https://ably.com).

The app will have one resource: **posts** with CRUD pages(list, create, edit, and show) similar to [base example](https://github.com/refinedev/refine/tree/main/examples/base-antd/src/pages/posts).

[You can also refer to CodeSandbox to see the final state of the app &#8594](#example)

## Adding `liveProvider`

Firstly we create a Ably client for [`@refinedev/ably`](https://github.com/refinedev/refine/tree/main/packages/ably) live provider.

```ts title="src/utility/ablyClient.ts"
import { Ably } from "@refinedev/ably";

export const ablyClient = new Ably.Realtime("your-api-key");
```

Then pass `liveProvider` from [`@refinedev/ably`](https://github.com/refinedev/refine/tree/main/packages/ably) to `<Refine>`.

```tsx title="src/App.tsx"
import { Refine } from "@refinedev/core";
import {
  ThemedLayoutV2,
  useNotificationProvider,
  ErrorComponent,
} from "@refinedev/antd";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { ConfigProvider } from "antd";
import "@refinedev/antd/dist/reset.css";

//highlight-next-line
import { liveProvider } from "@refinedev/ably";

//highlight-next-line
import { ablyClient } from "utility/ablyClient";

import { PostList, PostCreate, PostEdit, PostShow } from "pages/posts";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          notificationProvider={useNotificationProvider}
          //highlight-start
          liveProvider={liveProvider(ablyClient)}
          options={{ liveMode: "auto" }}
          //highlight-end
          resources={[
            {
              name: "posts",
              list: "/posts",
              show: "/posts/show/:id",
              create: "/posts/create",
              edit: "/posts/edit/:id",
              meta: {
                canDelete: true,
              },
            },
          ]}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route index element={<NavigateToResource />} />
              <Route path="/posts" element={<PostList />} />
              <Route path="/posts/create" element={<PostCreate />} />
              <Route path="/posts/show/:id" element={<PostShow />} />
              <Route path="/posts/edit/:id" element={<PostEdit />} />
            </Route>
            <Route path="*" element={<ErrorComponent />} />
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

export default App;
```

:::note

For live features to work automatically we added `liveMode: "auto"` in the `options` prop.

[Refer to the Live Provider documentation for detailed information. &#8594](/docs/realtime/live-provider#livemode)

:::

<br/>
<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/real-time/real-time.gif" alt="Realtime Demo" />

## Configuring `liveMode`

We may not want to make Realtime changes instantly in some cases. In these cases, we can use `manual` mode to prevent the data from changing instantly. Then we can handle the event manually.

For example in an edit page for a record, It would be better to handle Realtime data manually to prevent synchronization problems caused by multiple editing sources. We would not want the data changing while we are trying to edit a record.

We will be alerted about changes in an alert box on top of the form instead of changing the data instantly.

```tsx title="src/pages/posts/edit.tsx"
// ...

export const PostEdit: React.FC = () => {
  //highlight-start
  const [deprecated, setDeprecated] = useState<
    "deleted" | "updated" | undefined
  >();
  //highlight-end

  const { formProps, saveButtonProps, query } = useForm<IPost>({
    //highlight-start
    liveMode: "manual",
    onLiveEvent: (event) => {
      if (event.type === "deleted" || event.type === "updated") {
        setDeprecated(event.type);
      }
    },
    //highlight-end
  });

  //highlight-start
  const handleRefresh = () => {
    query?.refetch();
    setDeprecated(undefined);
  };
  //highlight-end

  // ...

  return (
    <Edit /* ... */>
      //highlight-start
      {deprecated === "deleted" && (
        <Alert
          message="This post is deleted."
          type="warning"
          style={{ marginBottom: 20 }}
          action={<ListButton size="small" />}
        />
      )}
      {deprecated === "updated" && (
        <Alert
          message="This post is updated. Refresh to see changes."
          type="warning"
          style={{ marginBottom: 20 }}
          action={<RefreshButton size="small" onClick={handleRefresh} />}
        />
      )}
      //highlight-end
      <Form {...formProps} layout="vertical">
        // ....
      </Form>
    </Edit>
  );
};
```

:::note

We can also implement a similar thing on the show page.

[Refer to the CodeSandbox example for detailed information. &#8594](#example)

:::

<br/>
<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/real-time/manual-mode.gif" alt="Manual Mode Demo" />

## Custom Subscriptions

You can subscribe to events emitted within **Refine** in any place in your app with `useSubscription`.

For example, we can subscribe to **_create_** event for **_posts_** resource and we can show a badge for the number of events in the sider menu.

Firstly, let's implement a custom sider like in [this example](https://github.com/refinedev/refine/tree/main/examples/customization-sider).

<details>
<summary>Custom Sider Menu</summary>

<p>

```tsx title="src/components/sider.tsx"
import React, { useState } from "react";
import {
  ITreeMenu,
  CanAccess,
  useIsExistAuthentication,
  useTranslate,
  useLogout,
  useMenu,
  useWarnAboutChange,
} from "@refinedev/core";
import { Link } from "react-router";
import { Sider, ThemedTitleV2 } from "@refinedev/antd";
import { Layout as AntdLayout, Menu, Grid, theme, Button } from "antd";
import {
  LogoutOutlined,
  UnorderedListOutlined,
  RightOutlined,
  LeftOutlined,
} from "@ant-design/icons";
import { antLayoutSider, antLayoutSiderMobile } from "./styles";

const { useToken } = theme;

export const CustomSider: typeof Sider = ({ render }) => {
  const { token } = useToken();
  const [collapsed, setCollapsed] = useState<boolean>(false);
  const isExistAuthentication = useIsExistAuthentication();
  const { warnWhen, setWarnWhen } = useWarnAboutChange();
  const { mutate: mutateLogout } = useLogout();
  const translate = useTranslate();
  const { menuItems, selectedKey, defaultOpenKeys } = useMenu();
  const { SubMenu } = Menu;

  const breakpoint = Grid.useBreakpoint();

  const isMobile =
    typeof breakpoint.lg === "undefined" ? false : !breakpoint.lg;

  const renderTreeView = (tree: ITreeMenu[], selectedKey: string) => {
    return tree.map((item: ITreeMenu) => {
      const { name, children, meta, key, list } = item;

      const icon = meta?.icon;
      const label = meta?.label ?? name;
      const parent = meta?.parent;
      const route =
        typeof list === "string"
          ? list
          : typeof list !== "function"
          ? list?.path
          : key;

      if (children.length > 0) {
        return (
          <SubMenu
            key={route}
            icon={icon ?? <UnorderedListOutlined />}
            title={label}
          >
            {renderTreeView(children, selectedKey)}
          </SubMenu>
        );
      }
      const isSelected = route === selectedKey;
      const isRoute = !(parent !== undefined && children.length === 0);
      return (
        <CanAccess
          key={route}
          resource={name}
          action="list"
          params={{ resource: item }}
        >
          <Menu.Item
            key={route}
            style={{
              textTransform: "capitalize",
            }}
            icon={icon ?? (isRoute && <UnorderedListOutlined />)}
          >
            {route ? <Link to={route || "/"}>{label}</Link> : label}
            {!collapsed && isSelected && (
              <div className="ant-menu-tree-arrow" />
            )}
          </Menu.Item>
        </CanAccess>
      );
    });
  };

  const handleLogout = () => {
    if (warnWhen) {
      const confirm = window.confirm(
        translate(
          "warnWhenUnsavedChanges",
          "Are you sure you want to leave? You have unsaved changes.",
        ),
      );

      if (confirm) {
        setWarnWhen(false);
        mutateLogout();
      }
    } else {
      mutateLogout();
    }
  };

  const logout = isExistAuthentication && (
    <Menu.Item key="logout" onClick={handleLogout} icon={<LogoutOutlined />}>
      {translate("buttons.logout", "Logout")}
    </Menu.Item>
  );

  const items = renderTreeView(menuItems, selectedKey);

  const renderSider = () => {
    if (render) {
      return render({
        dashboard: null,
        items,
        logout,
        collapsed,
      });
    }
    return (
      <>
        {items}
        {logout}
      </>
    );
  };

  const siderStyle = isMobile ? antLayoutSiderMobile : antLayoutSider;

  return (
    <AntdLayout.Sider
      collapsible
      collapsedWidth={isMobile ? 0 : 80}
      collapsed={collapsed}
      breakpoint="lg"
      onCollapse={(collapsed: boolean): void => setCollapsed(collapsed)}
      style={{
        ...siderStyle,
        backgroundColor: token.colorBgContainer,
        borderRight: `1px solid ${token.colorBgElevated}`,
      }}
      trigger={
        !isMobile && (
          <Button
            type="text"
            style={{
              borderRadius: 0,
              height: "100%",
              width: "100%",
              backgroundColor: token.colorBgElevated,
            }}
          >
            {collapsed ? (
              <RightOutlined
                style={{
                  color: token.colorPrimary,
                }}
              />
            ) : (
              <LeftOutlined
                style={{
                  color: token.colorPrimary,
                }}
              />
            )}
          </Button>
        )
      }
    >
      <div
        style={{
          width: collapsed ? "80px" : "200px",
          padding: collapsed ? "0" : "0 16px",
          display: "flex",
          justifyContent: collapsed ? "center" : "flex-start",
          alignItems: "center",
          height: "64px",
          backgroundColor: token.colorBgElevated,
          fontSize: "14px",
        }}
      >
        <ThemedTitleV2 collapsed={collapsed} />
      </div>
      <Menu
        defaultOpenKeys={defaultOpenKeys}
        selectedKeys={[selectedKey]}
        mode="inline"
        style={{
          marginTop: "8px",
          border: "none",
        }}
        onClick={() => {
          if (!breakpoint.lg) {
            setCollapsed(true);
          }
        }}
      >
        {renderSider()}
      </Menu>
    </AntdLayout.Sider>
  );
};
```

</p>
</details>

Now, let's add a badge for the number of create and update events for **_posts_** menu items.

<details>
<summary>Show Custom Sider Menu with subscription bagde code</summary>

<p>

```tsx
import React, { useState } from "react";
import {
  ITreeMenu,
  CanAccess,
  useIsExistAuthentication,
  useTranslate,
  useLogout,
  useMenu,
  useWarnAboutChange,
  useSubscription,
} from "@refinedev/core";
import { Link } from "react-router";
import { Sider, ThemedTitleV2 } from "@refinedev/antd";
import { Layout as AntdLayout, Menu, Grid, theme, Button, Badge } from "antd";
import {
  LogoutOutlined,
  UnorderedListOutlined,
  RightOutlined,
  LeftOutlined,
} from "@ant-design/icons";

import { antLayoutSider, antLayoutSiderMobile } from "./styles";

const { useToken } = theme;

export const CustomSider: typeof Sider = ({ render }) => {
  const { token } = useToken();
  const [collapsed, setCollapsed] = useState<boolean>(false);
  const isExistAuthentication = useIsExistAuthentication();
  const { warnWhen, setWarnWhen } = useWarnAboutChange();
  const { mutate: mutateLogout } = useLogout();
  const translate = useTranslate();
  const { menuItems, selectedKey, defaultOpenKeys } = useMenu();
  const { SubMenu } = Menu;
  const [subscriptionCount, setSubscriptionCount] = useState(0);

  const breakpoint = Grid.useBreakpoint();

  const isMobile =
    typeof breakpoint.lg === "undefined" ? false : !breakpoint.lg;

  useSubscription({
    channel: "resources/posts",
    types: ["created", "updated"],
    onLiveEvent: () => setSubscriptionCount((prev) => prev + 1),
  });

  const renderTreeView = (tree: ITreeMenu[], selectedKey?: string) => {
    return tree.map((item: ITreeMenu) => {
      const { name, children, meta, key, list } = item;

      const icon = meta?.icon;
      const label = meta?.label ?? name;
      const parent = meta?.parent;
      const route =
        typeof list === "string"
          ? list
          : typeof list !== "function"
          ? list?.path
          : key;

      if (children.length > 0) {
        return (
          <SubMenu
            key={key}
            icon={icon ?? <UnorderedListOutlined />}
            title={label}
          >
            {renderTreeView(children, selectedKey)}
          </SubMenu>
        );
      }
      const isSelected = route === selectedKey;
      const isRoute = !(parent !== undefined && children.length === 0);
      return (
        <CanAccess
          key={key}
          resource={name}
          action="list"
          params={{ resource: item }}
        >
          <Menu.Item
            key={route}
            style={{
              textTransform: "capitalize",
            }}
            icon={icon ?? (isRoute && <UnorderedListOutlined />)}
          >
            {route ? <Link to={route || "/"}>{label}</Link> : label}
            {route && (
              <>
                {label.toLowerCase() === "posts" && (
                  <Badge
                    size="small"
                    count={subscriptionCount}
                    offset={[2, -15]}
                  />
                )}
              </>
            )}
            {!collapsed && isSelected && (
              <div className="ant-menu-tree-arrow" />
            )}
          </Menu.Item>
        </CanAccess>
      );
    });
  };

  const handleLogout = () => {
    if (warnWhen) {
      const confirm = window.confirm(
        translate(
          "warnWhenUnsavedChanges",
          "Are you sure you want to leave? You have unsaved changes.",
        ),
      );

      if (confirm) {
        setWarnWhen(false);
        mutateLogout();
      }
    } else {
      mutateLogout();
    }
  };

  const logout = isExistAuthentication && (
    <Menu.Item key="logout" onClick={handleLogout} icon={<LogoutOutlined />}>
      {translate("buttons.logout", "Logout")}
    </Menu.Item>
  );

  const items = renderTreeView(menuItems, selectedKey);

  const renderSider = () => {
    if (render) {
      return render({
        dashboard: null,
        items,
        logout,
        collapsed,
      });
    }
    return (
      <>
        {items}
        {logout}
      </>
    );
  };

  const siderStyle = isMobile ? antLayoutSiderMobile : antLayoutSider;

  return (
    <AntdLayout.Sider
      collapsible
      collapsedWidth={isMobile ? 0 : 80}
      collapsed={collapsed}
      breakpoint="lg"
      onCollapse={(collapsed: boolean): void => setCollapsed(collapsed)}
      style={{
        ...siderStyle,
        backgroundColor: token.colorBgContainer,
        borderRight: `1px solid ${token.colorBgElevated}`,
      }}
      trigger={
        !isMobile && (
          <Button
            type="text"
            style={{
              borderRadius: 0,
              height: "100%",
              width: "100%",
              backgroundColor: token.colorBgElevated,
            }}
          >
            {collapsed ? (
              <RightOutlined
                style={{
                  color: token.colorPrimary,
                }}
              />
            ) : (
              <LeftOutlined
                style={{
                  color: token.colorPrimary,
                }}
              />
            )}
          </Button>
        )
      }
    >
      <div
        style={{
          width: collapsed ? "80px" : "200px",
          padding: collapsed ? "0" : "0 16px",
          display: "flex",
          justifyContent: collapsed ? "center" : "flex-start",
          alignItems: "center",
          height: "64px",
          backgroundColor: token.colorBgElevated,
          fontSize: "14px",
        }}
      >
        <ThemedTitleV2 collapsed={collapsed} />
      </div>
      <Menu
        defaultOpenKeys={defaultOpenKeys}
        selectedKeys={[selectedKey]}
        mode="inline"
        style={{
          marginTop: "8px",
          border: "none",
        }}
        onClick={({ key }) => {
          if (!breakpoint.lg) {
            setCollapsed(true);
          }

          if (key === "/posts") {
            setSubscriptionCount(0);
          }
        }}
      >
        {renderSider()}
      </Menu>
    </AntdLayout.Sider>
  );
};
```

</p>
</details>

:::tip

You can subscribe to specific `ids` with `params`. For example, you can subscribe to **deleted** and **updated** events from **posts** resource with **id** `1` and `2`.

```tsx
useSubscription({
  channel: "resources/posts",
  type: ["deleted", "updated"],
  //highlight-start
  params: {
    ids: ["1", "2"],
  },
  //highlight-end
  onLiveEvent: () => setSubscriptionCount((prev) => prev + 1),
});
```

:::

<br/>
<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/real-time/custom-sider.gif" alt="Custom Sider Demo" />

## Example

<CodeSandboxExample path="live-provider-ably" />

================
File: advanced-tutorials/search/list-search.md
================
---
id: list-search
title: List Search
---

We will examine how to make an extensive search and filtering with the [`useSimpleList`](/docs/ui-integrations/ant-design/hooks/use-simple-list) hook that works with the Ant Design's [`<List>`](https://ant.design/components/list) component.

To do this, let's list posts using the posts resource.

```tsx title="pages/posts/list.tsx"
import { useMany } from "@refinedev/core";
import {
  List,
  // highlight-next-line
  useSimpleList,
  NumberField,
} from "@refinedev/antd";
import { List as AntdList, Typography, Space } from "antd";

const { Text } = Typography;

export const PostList: React.FC = () => {
  // highlight-next-line
  const { listProps } = useSimpleList<IPost>();

  const categoryIds =
    listProps?.dataSource?.map((item) => item.category.id) ?? [];
  const { data } = useMany<ICategory>({
    resource: "categories",
    ids: categoryIds,
    queryOptions: {
      enabled: categoryIds.length > 0,
    },
  });

  const renderItem = (item: IPost) => {
    const { title, hit, content } = item;

    const categoryTitle = data?.data.find(
      (category: ICategory) => category.id === item.category.id,
    )?.title;

    return (
      <AntdList.Item
        actions={[
          <Space key={item.id} direction="vertical" align="end">
            <NumberField
              value={hit}
              options={{
                notation: "compact",
              }}
            />
            <Text>{categoryTitle}</Text>
          </Space>,
        ]}
      >
        <AntdList.Item.Meta title={title} description={content} />
      </AntdList.Item>
    );
  };

  return (
    <List>
      // highlight-next-line
      <AntdList {...listProps} renderItem={renderItem} />
    </List>
  );
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  hit: number;
  category: { id: number };
}
```

After creating the `<PostList>` component, add it to the resource with `list` prop:

```tsx
import { Refine } from "@refinedev/core";
import {
  ThemedLayoutV2,
  useNotificationProvider,
  ErrorComponent,
  RefineThemes,
} from "@refinedev/antd";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { ConfigProvider } from "antd";
import "@refinedev/antd/dist/reset.css";

// highlight-next-line
import { PostList } from "pages/posts";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          notificationProvider={useNotificationProvider}
          // highlight-start
          resources={[
            {
              name: "posts",
              list: "/posts",
            },
          ]}
          //highlight-end
        >
          <Routes>
            <Route index element={<NavigateToResource />} />
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="/posts" element={<PostList />} />
            </Route>
            <Route path="*" element={<ErrorComponent />} />
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

export default App;
```

<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/list-search/basic-list.png" alt="basic list" />
<br />

We will create a form by extracting `searchFormProps` from [`useSimpleList`](/docs/ui-integrations/ant-design/hooks/use-simple-list). We will use this form for search/filtering. We will also create an interface to determine the types of values from the form.

```tsx title="pages/posts/list.tsx"
...

import {
    ...
// highlight-next-line
    CrudFilters,
} from "@refinedev/core";

export const PostList: React.FC = () => {
// highlight-start
    const { listProps, searchFormProps } = useSimpleList<
        IPost,
        IPostFilterVariables
    >({
        onSearch: (params) => {
            const filters: CrudFilters = [];
            const { category, createdAt } = params;

            filters.push(
                {
                    field: "category.id",
                    operator: "eq",
                    value: category,
                },
                {
                    field: "createdAt",
                    operator: "gte",
                    value: createdAt ? createdAt[0].toISOString() : undefined,
                },
                {
                    field: "createdAt",
                    operator: "lte",
                    value: createdAt ? createdAt[1].toISOString() : undefined,
                },
            );

            return filters;
        },
    });
// highlight-end

    // ...

    const { selectProps: categorySelectProps } = useSelect<ICategory>({
        resource: "categories",
    });

    return (
        <List>
// highlight-start
            <Form
                {...searchFormProps}
                layout="vertical"
                onValuesChange={() => searchFormProps.form?.submit()}
            >
                <Space wrap>
                    <Form.Item label="Category" name="category">
                        <Select
                            {...categorySelectProps}
                            allowClear
                            placeholder="Search Categories"
                        />
                    </Form.Item>
                    <Form.Item label="Created At" name="createdAt">
                        <RangePicker />
                    </Form.Item>
                </Space>
            </Form>
            <AntdList {...listProps} renderItem={renderItem} />
// highlight-end
        </List>
    );
};

interface IPostFilterVariables {
    category: string;
    createdAt: [Dayjs, Dayjs];
}
```

When the form is submitted, the `onSearch` method runs and we get the search form values. Then the `listProps` is refreshed according to the criteria.

<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/list-search/form-list.png" alt="form list" />

<br />

:::caution

[`CrudFilters`](/docs/core/interface-references#crudfilters) type object has `field`, `operator`, and `value` properties. These properties help us to filter in which field, with which operator, and with which data.

:::

## Example

<CodeSandboxExample path="use-simple-list-antd" />

================
File: advanced-tutorials/search/search.md
================
---
id: search
title: Search
---

We will create a `<Header>` component for your application with Ant Design's [`<AutoComplete>`](https://ant.design/components/auto-complete) component.
We will now examine how to search within the application with this component.

<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/search/search.gif" alt="search" />
<br/>

To do this, let's first create our `<Header>` component.

```tsx title="src/components/header.tsx"
import { Layout, AutoComplete, Input } from "antd";
import { SearchOutlined } from "@ant-design/icons";

export const Header: React.FC = () => {
  return (
    <Layout.Header
      style={{
        padding: "0px 24px",
        backgroundColor: "#FFF",
      }}
    >
      <AutoComplete
        style={{ width: "100%", maxWidth: "550px" }}
        filterOption={false}
      >
        <Input
          size="large"
          placeholder="Search posts or categories"
          suffix={<SearchOutlined />}
        />
      </AutoComplete>
    </Layout.Header>
  );
};
```

We created the `<Header>` component as we want it to appear. We have not done anything for any search process at this stage. We just created the UI.

<br />

:::note

Let's not forget to pass the `<Header>` component to the `<Layout>` component in `App.tsx` as below.

```tsx title="src/App.tsx"
import { Refine } from "@refinedev/core";
import { Layout } from "@refinedev/antd";
import dataProvider from "@refinedev/simple-rest";

import "@refinedev/antd/dist/reset.css";

// highlight-next-line
import { Header } from "components";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <Refine
      dataProvider={dataProvider(API_URL)}
      /* ... */
    >
      <Layout Header={Header}>{/* ... */}</Layout>
    </Refine>
  );
};

export default App;
```

:::

Now let's get our [`<AutoComplete>`](https://ant.design/components/auto-complete) input ready to search. So, let's fetch our posts according to the value entered in our input.

To fetch more than one record, we will use the [`useList`](/docs/data/hooks/use-list) data hook, and we will filter and fetch this data according to the search value.

Before we start, let's create the interfaces of our [`<AutoComplete>`](https://ant.design/components/auto-complete)'s `options` property and the post source.

```ts title="src/interfaces/index.d.ts"
export interface IPost {
  id: number;
  title: string;
}

export interface ICategory {
  id: number;
  title: string;
}

export interface IOptionGroup {
  value: string;
  label: string | React.ReactNode;
}

export interface IOptions {
  label: string | React.ReactNode;
  options: IOptionGroup[];
}
```

```tsx title="src/components/header.tsx"
import { useState, useEffect } from "react";
import { useList } from "@refinedev/core";
import { Layout, AutoComplete, Input, Icons, Typography } from "antd";
import routerProvider from "@refinedev/react-router";

const { Link } = routerProvider;
const { Text } = Typography;
const { SearchOutlined } = Icons;

import { IOptions, IPost } from "interfaces";

// To be able to customize the option title
const renderTitle = (title: string) => {
  return (
    <Text strong style={{ fontSize: "16px" }}>
      {title}
    </Text>
  );
};

// To be able to customize the option item
const renderItem = (title: string, resource: string, id: number) => {
  return {
    value: title,
    label: (
      <Link to={`/${resource}/show/${id}`}>
        <Text>{title}</Text>
      </Link>
    ),
  };
};

export const Header: React.FC = () => {
  const [value, setValue] = useState<string>("");
  const [options, setOptions] = useState<IOptions[]>([]);

  const { refetch: refetchPosts } = useList<IPost>({
    resource: "posts",
    filters: [{ field: "title", operator: "contains", value }],
    queryOptions: {
      enabled: false,
      onSuccess: (data) => {
        const postOptionGroup = data.data.map((item) =>
          renderItem(item.title, "posts", item.id),
        );
        if (postOptionGroup.length > 0) {
          setOptions([
            {
              label: renderTitle("Posts"),
              options: postOptionGroup,
            },
          ]);
        }
      },
    },
  });

  useEffect(() => {
    setOptions([]);
    refetchPosts();
  }, [value]);

  return (
    <Layout.Header
      style={{
        padding: "0px 24px",
        backgroundColor: "#FFF",
      }}
    >
      <AutoComplete
        style={{ width: "100%", maxWidth: "550px" }}
        filterOption={false}
        options={options}
        onSearch={(value: string) => setValue(value)}
      >
        <Input
          size="large"
          placeholder="Search posts or categories"
          suffix={<SearchOutlined />}
        />
      </AutoComplete>
    </Layout.Header>
  );
};
```

We created states to dynamically manage the `value` and `options` properties of the [`<AutoComplete>`](https://ant.design/components/auto-complete) component. The [`useList`](/docs/data/hooks/use-list) hook is triggered whenever the value changes. Likewise, the filter used to fetch the data is updated each time the value changes.

<br />

Search value is currently only searched and fetched inside posts. Let's update our code to search both posts and categories according to the search value.

```tsx title="src/components/header.tsx"
...
export const Header: React.FC = () => {
    const [value, setValue] = useState<string>("");
    const [options, setOptions] = useState<IOptions[]>([]);

    const { refetch: refetchPosts } = useList<IPost>({
        resource: "posts",
        filters: [{ field: "title", operator: "contains", value }],
        queryOptions: {
            enabled: false,
            onSuccess: (data) => {
                const postOptionGroup = data.data.map((item) =>
                    renderItem(item.title, "posts", item.id),
                );
                if (postOptionGroup.length > 0) {
                    setOptions((prevOptions) => [
                        ...prevOptions
                        {
                            label: renderTitle("Posts"),
                            options: postOptionGroup,
                        },
                    ]);
                }
            },
        },
    });

    const { refetch: refetchCategories } = useList<ICategory>({
        resource: "categories",
        filters: [{ field: "q", operator: "contains", value }],
        queryOptions: {
            enabled: false,
            onSuccess: (data) => {
                const categoryOptionGroup = data.data.map((item) =>
                    renderItem(item.title, "categories", item.id),
                );
                if (categoryOptionGroup.length > 0) {
                    setOptions((prevOptions) => [
                        ...prevOptions,
                        {
                            label: renderTitle("Categories"),
                            options: categoryOptionGroup,
                        },
                    ]);
                }
            },
        },
    });

    useEffect(() => {
        setOptions([]);
        refetchPosts();
        refetchCategories();
    }, [value]);

    return (
        <AntdLayout.Header
            style={{
                padding: "0px 24px",
                backgroundColor: "#FFF",
            }}
        >
            ...
        </AntdLayout.Header>
    );
};
```

:::tip

By doing the same implementation on your other resources, you can search for more than one resource with a value.

:::

## Example

<CodeSandboxExample path="search" />

================
File: advanced-tutorials/search/table-search.md
================
---
id: table-search
title: Table Search
---

We can make extensive search / filter operations using the `useTable` hook on the listing pages.

First, we create a form by extracting `searchFormProps` from `useTable`. We will use this form for search / filtering.

```tsx title="pages/list.tsx"
import {
  // highlight-next-line
  useTable,
  List,
} from "@refinedev/antd";
import {
  // highlight-start
  Form,
  Table,
  // highlight-end
  Row,
  Col,
  Button,
  DatePicker,
  Space,
  Input,
} from "antd";
// highlight-next-line
import { SearchOutlined } from "@ant-design/icons";

const { RangePicker } = DatePicker;

export const ListPage: React.FC = () => {
  // highlight-next-line
  const { searchFormProps } = useTable<IPost>();

  return (
    // highlight-start
    <Row gutter={[16, 16]}>
      <Col lg={6} xs={24}>
        <Form layout="vertical" {...searchFormProps}>
          <Form.Item label="Search" name="q">
            <Input
              placeholder="ID, Title, Content, etc."
              prefix={<SearchOutlined />}
            />
          </Form.Item>
          <Form.Item label="Created At" name="createdAt">
            <RangePicker />
          </Form.Item>
          <Form.Item>
            <Button htmlType="submit" type="primary">
              Filter
            </Button>
          </Form.Item>
        </Form>
      </Col>
      <Col lg={18} xs={24}>
        <List>
          <Table>...</Table>
        </List>
      </Col>
    </Row>
    // highlight-end
  );
};

interface IPost {
  id: number;
  title: string;
  createdAt: string;
}
```

<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/table-search/form.png" />

<br />

When the form is submitted, the `onSearch` method runs and we get the search form values. We have to return an object of type [`CrudFilters`](/docs/core/interface-references#crudfilters) for this method.

```tsx title="pages/list.tsx"
...
import { HttpError } from "@refinedev/core";
import { Dayjs } from "dayjs";

const { searchFormProps } = useTable<IPost, HttpError, { title: string; createdAt: [Dayjs, Dayjs] }>({
    onSearch: (params) => {
        const filters: CrudFilters = [];
        const { q, createdAt } = params;

            filters.push(
                {
                    field: "q",
                    operator: "eq",
                    value: q,
                },
                {
                    field: "createdAt",
                    operator: "gte",
                    value: createdAt ? createdAt[0].toISOString() : undefined,
                },
                {
                    field: "createdAt",
                    operator: "lte",
                    value: createdAt ? createdAt[1].toISOString() : undefined,
                },
            );

        return filters;
    },
});
...
```

:::caution

`CrudFilters` types object has `field`, `operator`, and `value` properties. These properties help us to filter in which field, with which operator, and with which data.

:::

## Example

<CodeSandboxExample path="table-antd-table-filter" />

================
File: advanced-tutorials/upload/base64-upload.md
================
---
id: base64-upload
title: Base64 Upload
---

By encoding your files and images from your forms to Base64 you can change all files needed for the upload to Base64 format before the submit. This can be done via the `onFinish` property of the [`<Form>`](https://ant.design/components/form/#Form) component that comes with [Ant Design](https://ant.design/)

# Example

Now let's make a small example to see how its done. In this example, the file we are going to be uploading files in Base64 type is going to be called `avatar`

```tsx title="pages/users/create.tsx"
import {
  //highlight-start
  file2Base64,
  //highlight-end
} from "@refinedev/core";

import {
  Create,
  useForm,
  // highlight-next-line
  getValueFromEvent,
} from "@refinedev/antd";
import { Form, Upload, Input } from "antd";

export const UserCreate: React.FC = () => {
  const { form, formProps, saveButtonProps } = useForm<IUser>();

  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form
        {...formProps}
        layout="vertical"
        // highlight-start
        onFinish={async (values) => {
          const base64Files = [];
          // @ts-ignore
          const { avatar } = values;

          for (const file of avatar) {
            if (file.originFileObj) {
              const base64String = await file2Base64(file);

              base64Files.push({
                ...file,
                base64String,
              });
            } else {
              base64Files.push(file);
            }
          }

          return (
            formProps.onFinish &&
            formProps.onFinish({
              ...values,
              avatar: base64Files,
            })
          );
        }}
        // highlight-end
      >
        <Form.Item
          label="First Name"
          name="firstName"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input />
        </Form.Item>
        <Form.Item label="Avatar">
          <Form.Item
            name="avatar"
            valuePropName="fileList"
            // highlight-start
            getValueFromEvent={getValueFromEvent}
            noStyle
            rules={[
              {
                required: true,
              },
            ]}
          >
            <Upload.Dragger
              listType="picture"
              multiple
              // highlight-start
              beforeUpload={() => false}
            >
              <p className="ant-upload-text">Drag & drop a file in this area</p>
            </Upload.Dragger>
          </Form.Item>
        </Form.Item>
      </Form>
    </Create>
  );
};

interface IUser {
  id: number;
  firstName: string;
  avatar: [
    {
      uid: string;
      name: string;
      url: string;
      status: "error" | "success" | "done" | "uploading" | "removed";
    },
  ];
}
```

You can change files to Base64 by using the `file2Base64` function.

:::tip

An edit form can be made by using the `<Edit>` component instead of `<Create>` without changing the rest of the code.

:::

## Example

<CodeSandboxExample path="upload-antd-base64" />

================
File: advanced-tutorials/upload/multipart-upload.md
================
---
id: multipart-upload
title: Multipart Upload
---

```tsx live shared
import { Refine } from "@refinedev/core";
import { AuthPage, RefineThemes, ThemedLayoutV2, ErrorComponent, useNotificationProvider } from "@refinedev/antd";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import { ConfigProvider } from "antd";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";
import dataProvider from "@refinedev/simple-rest";

const API_URL = "https://api.fake-rest.refine.dev";

import {
    useMany as CoreUseMany,
    useShow as RefineCoreUseShow,
    useOne as RefineCoreUseOne,
    useApiUrl as RefineCoreUseApiUrl,
} from "@refinedev/core";
import {
    List as RefineAntdList,
    TextField as RefineAntdTextField,
    useTable as RefineAntdUseTable,
    EditButton as RefineAntdEditButton,
    ShowButton as RefineAntdShowButton,
    useForm as RefineAntdUseForm,
    useSelect as RefineAntdUseSelect,
    Create as RefineAntdCreate,
    Edit as RefineAntdEdit,
    Show as RefineAntdShow,
    getValueFromEvent as RefineAntdGetValueFromEvent,
} from "@refinedev/antd";
import {
    Table as AntdTable,
    Space as AntdSpace,
    Form as AntdForm,
    Select as AntdSelect,
    Input as AntdInput,
    Typography as AntdTypography,
    Upload as AntdUpload,
} from "antd";

const PostList: React.FC = () => {
    const { tableProps, sorter } = RefineAntdUseTable<IPost>();

    const categoryIds =
        tableProps?.dataSource?.map((item) => item.category.id) ?? [];
    const { data, isLoading } = CoreUseMany<ICategory>({
        resource: "categories",
        ids: categoryIds,
        queryOptions: {
            enabled: categoryIds.length > 0,
        },
    });

    return (
        <RefineAntdList>
            <AntdTable {...tableProps} rowKey="id">
                <AntdTable.Column
                    dataIndex="id"
                    title="ID"
                />
                <AntdTable.Column dataIndex="title" title="Title" />
                <AntdTable.Column
                    dataIndex={["category", "id"]}
                    title="Category"
                    render={(value) => {
                        if (isLoading) {
                            return <RefineAntdTextField value="Loading..." />;
                        }

                        return (
                            <RefineAntdTextField
                                value={
                                    data?.data.find((item) => item.id === value)
                                        ?.title
                                }
                            />
                        );
                    }}
                />
                <AntdTable.Column<IPost>
                    title="Actions"
                    dataIndex="actions"
                    render={(_, record) => (
                        <AntdSpace>
                            <RefineAntdEditButton
                                hideText
                                size="small"
                                recordItemId={record.id}
                            />
                            <RefineAntdShowButton
                                hideText
                                size="small"
                                recordItemId={record.id}
                            />
                        </AntdSpace>
                    )}
                />
            </AntdTable>
        </RefineAntdList>
    );
};

const PostCreate: React.FC = () => {
    const { formProps, saveButtonProps } = RefineAntdUseForm<IPost>();

    const { selectProps: categorySelectProps } = RefineAntdUseSelect<ICategory>(
        {
            resource: "categories",
        },
    );

    const apiUrl = RefineCoreUseApiUrl();

    return (
        <RefineAntdCreate saveButtonProps={saveButtonProps}>
            <AntdForm {...formProps} layout="vertical">
                <AntdForm.Item
                    label="Title"
                    name="title"
                    rules={[
                        {
                            required: true,
                        },
                    ]}
                >
                    <AntdInput />
                </AntdForm.Item>
                <AntdForm.Item label="Image">
                    <AntdForm.Item
                        name="image"
                        valuePropName="fileList"
                        getValueFromEvent={RefineAntdGetValueFromEvent}
                        noStyle
                    >
                        <AntdUpload.Dragger
                            name="file"
                            action={`${apiUrl}/media/upload`}
                            listType="picture"
                            maxCount={5}
                            multiple
                        >
                            <p className="ant-upload-text">
                                Drag & drop a file in this area
                            </p>
                        </AntdUpload.Dragger>
                    </AntdForm.Item>
                </AntdForm.Item>
            </AntdForm>
        </RefineAntdCreate>
    );
};

const PostEdit: React.FC = () => {
    const { formProps, saveButtonProps, query } =
        RefineAntdUseForm<IPost>();

    const postData = query?.data?.data;
    const { selectProps: categorySelectProps } = RefineAntdUseSelect<ICategory>({
        resource: "categories",
        defaultValue: postData?.category.id,
    });

    const apiUrl = RefineCoreUseApiUrl();

    return (
        <RefineAntdEdit saveButtonProps={saveButtonProps}>
            <AntdForm {...formProps} layout="vertical">
                <AntdForm.Item
                    label="Title"
                    name="title"
                    rules={[
                        {
                            required: true,
                        },
                    ]}
                >
                    <AntdInput />
                </AntdForm.Item>
                <AntdForm.Item label="Image">
                    <AntdForm.Item
                        name="image"
                        valuePropName="fileList"
                        getValueFromEvent={RefineAntdGetValueFromEvent}
                        noStyle
                    >
                        <AntdUpload.Dragger
                            name="file"
                            action={`${apiUrl}/media/upload`}
                            listType="picture"
                            maxCount={5}
                            multiple
                        >
                            <p className="ant-upload-text">
                                Drag & drop a file in this area
                            </p>
                        </AntdUpload.Dragger>
                    </AntdForm.Item>
                </Form.Item>
            </AntdForm>
        </RefineAntdEdit>
    );
};

const PostShow: React.FC = () => {
    const { queryResult } = RefineCoreUseShow<IPost>();
    const { data, isLoading } = queryResult;
    const record = data?.data;

    const { data: categoryData, isLoading: categoryIsLoading } =
        RefineCoreUseOne<ICategory>({
            resource: "categories",
            id: record?.category?.id || "",
            queryOptions: {
                enabled: !!record,
            },
        });

    return (
        <RefineAntdShow isLoading={isLoading}>
            <AntdTypography.Title level={5}>Id</AntdTypography.Title>
            <AntdTypography.Text>{record?.id}</AntdTypography.Text>

            <AntdTypography.Title level={5}>
                AntdTypography.Title
            </AntdTypography.Title>
            <AntdTypography.Text>{record?.title}</AntdTypography.Text>

            <AntdTypography.Title level={5}>Category</AntdTypography.Title>
            <AntdTypography.Text>
                {categoryIsLoading ? "Loading..." : categoryData?.data.title}
            </AntdTypography.Text>

            <AntdTypography.Title level={5}>Content</AntdTypography.Title>
            <AntdTypography.Text>{record?.content}</AntdTypography.Text>
        </RefineAntdShow>
    );
};
```

We will demonstrate how to perform a multipart upload with **Refine**.

Let's start with the `creation form` first.

### Create Form

Let's add the image field to the post `creation form`.

```tsx title="pages/posts/create.tsx"
import {
  // highlight-start
  useApiUrl,
  // highlight-end
} from "@refinedev/core";
import {
  // highlight-start
  getValueFromEvent,
  // highlight-end
  Create,
  useForm,
} from "@refinedev/antd";
import {
  // highlight-next-line
  Upload,
  Form,
  Input,
} from "antd";

export const PostCreate: React.FC = () => {
  const { formProps, saveButtonProps } = useForm<IPost>();

  // highlight-next-line
  const apiUrl = useApiUrl();

  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input />
        </Form.Item>
        <Form.Item label="Image">
          <Form.Item
            name="image"
            valuePropName="fileList"
            // highlight-next-line
            getValueFromEvent={getValueFromEvent}
            noStyle
          >
            // highlight-start
            <Upload.Dragger
              name="file"
              action={`${apiUrl}/media/upload`}
              listType="picture"
              maxCount={5}
              multiple
            >
              <p className="ant-upload-text">Drag & drop a file in this area</p>
            </Upload.Dragger>
            // highlight-end
          </Form.Item>
        </Form.Item>
      </Form>
    </Create>
  );
};

interface IPost {
  id: number;
  title: string;
  image: [
    {
      uid: string;
      name: string;
      url: string;
      status: "error" | "success" | "done" | "uploading" | "removed";
    },
  ];
}
```

<br />

:::tip

We can reach the API URL by using the [`useApiUrl`](/docs/data/hooks/use-api-url) hook.

:::

It will look like this.

```tsx live previewOnly url=http://localhost:5173 previewHeight=600px
setInitialRoutes(["/posts/create"]);

const App = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "posts",
              list: "/posts",
              create: "/posts/create",
              show: "/posts/show/:id",
              edit: "/posts/edit/:id",
            },
          ]}
          notificationProvider={useNotificationProvider}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route index element={<NavigateToResource />} />

              <Route path="/posts">
                <Route index element={<PostList />} />
                <Route path="create" element={<PostCreate />} />
                <Route path="edit/:id" element={<PostEdit />} />
                <Route path="show/:id" element={<PostShow />} />
              </Route>

              <Route path="*" element={<ErrorComponent />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

render(<App />);
```

We currently require an upload endpoint that accepts multipart uploads. This address should be passed into the `action` property of the `Upload` component.

```json title="[POST] https://api.fake-rest.refine.dev/media/upload"
{
  "file": "binary"
}
```

:::caution

This end-point should be `Content-type: multipart/form-data` and `Form Data: file: binary`.

:::

This end-point should respond similarly.

```json title="[POST] https://api.fake-rest.refine.dev/media/upload"
{
  "url": "https://example.com/uploaded-file.jpeg"
}
```

:::caution

We have to use the `getValueFromEvent` method to convert the uploaded files to [Antd UploadFile](https://ant.design/components/upload/#UploadFile) object.

:::

This data is sent to the API when the form is submitted.

```json title="[POST] https://api.fake-rest.refine.dev/posts"
{
  "title": "Test",
  "image": [
    {
      "uid": "rc-upload-1620630541327-7",
      "name": "greg-bulla-6RD0mcpY8f8-unsplash.jpg",
      "url": "https://refine.ams3.digitaloceanspaces.com/78c82c0b2203e670d77372f4c20fc0e2",
      "type": "image/jpeg",
      "size": 70922,
      "percent": 100,
      "status": "done"
    }
  ]
}
```

:::caution

The following data are required for the [Antd Upload](https://ant.design/components/upload) component and all should be saved.

:::

| Property | Description                              |
| -------- | ---------------------------------------- |
| uid      | Unique id                                |
| name     | File Name                                |
| url      | Download URL                             |
| status   | error, success, done, uploading, removed |

### Edit Form

Let's add the image field to the post editing form.

```tsx title="pages/posts/edit.tsx"
import {
  // highlight-start
  useApiUrl,
  // highlight-end
} from "@refinedev/core";
import {
  // highlight-start
  getValueFromEvent,
  // highlight-end
  Edit,
  useForm,
} from "@refinedev/antd";
import {
  // highlight-next-line
  Upload,
  Form,
  Input,
} from "antd";

export const PostEdit: React.FC = () => {
  const { formProps, saveButtonProps } = useForm<IPost>();

  // highlight-next-line
  const apiUrl = useApiUrl();

  return (
    <Edit saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input />
        </Form.Item>
        <Form.Item label="Image">
          <Form.Item
            name="image"
            valuePropName="fileList"
            // highlight-next-line
            getValueFromEvent={getValueFromEvent}
            noStyle
          >
            // highlight-start
            <Upload.Dragger
              name="file"
              action={`${apiUrl}/media/upload`}
              listType="picture"
              maxCount={5}
              multiple
            >
              <p className="ant-upload-text">Drag & drop a file in this area</p>
            </Upload.Dragger>
            // highlight-end
          </Form.Item>
        </Form.Item>
      </Form>
    </Edit>
  );
};
```

```tsx live previewOnly url=http://localhost:5173 previewHeight=600px
setInitialRoutes(["/posts/edit/111"]);

const App = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "posts",
              list: "/posts",
              create: "/posts/create",
              show: "/posts/show/:id",
              edit: "/posts/edit/:id",
            },
          ]}
          notificationProvider={useNotificationProvider}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route index element={<NavigateToResource />} />

              <Route path="/posts">
                <Route index element={<PostList />} />
                <Route path="create" element={<PostCreate />} />
                <Route path="edit/:id" element={<PostEdit />} />
                <Route path="show/:id" element={<PostShow />} />
              </Route>

              <Route path="*" element={<ErrorComponent />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

render(<App />);
```

The request, like the one below, is sent for the edit form.

```json title="[GET] https://api.fake-rest.refine.dev/posts/1"
{
  "id": 1,
  "title": "Test",
  "image": [
    {
      "uid": "rc-upload-1620630541327-7",
      "name": "greg-bulla-6RD0mcpY8f8-unsplash.jpg",
      "url": "https://refine.ams3.digitaloceanspaces.com/78c82c0b2203e670d77372f4c20fc0e2",
      "type": "image/jpeg",
      "size": 70922,
      "percent": 100,
      "status": "done"
    }
  ]
}
```

This data is sent to the API when form is submitted.

```json title="[PUT] https://api.fake-rest.refine.dev/posts/1"
{
  "title": "Test",
  "image": [
    {
      "uid": "rc-upload-1620630541327-7",
      "name": "greg-bulla-6RD0mcpY8f8-unsplash.jpg",
      "url": "https://refine.ams3.digitaloceanspaces.com/78c82c0b2203e670d77372f4c20fc0e2",
      "type": "image/jpeg",
      "size": 70922,
      "percent": 100,
      "status": "done"
    }
  ]
}
```

### Uploading State

You may want to disable the "Save" button in the form while the upload is going on. To do this, you can use the `useFileUploadState` hook.

```tsx title="pages/posts/create.tsx"
import { useApiUrl } from "@refinedev/core";
import {
  getValueFromEvent,
  // highlight-next-line
  useFileUploadState,
  Create,
  useForm,
} from "@refinedev/antd";
import { Upload, Form, Input } from "antd";

export const PostCreate: React.FC = () => {
  const { formProps, saveButtonProps } = useForm<IPost>();

  // highlight-next-line
  const { isLoading, onChange } = useFileUploadState();

  const apiUrl = useApiUrl();

  return (
    <Create
      // highlight-start
      saveButtonProps={{
        ...saveButtonProps,
        disabled: isLoading,
      }}
      // highlight-end
    >
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input />
        </Form.Item>
        <Form.Item label="Image">
          <Form.Item
            name="image"
            valuePropName="fileList"
            getValueFromEvent={getValueFromEvent}
            noStyle
          >
            <Upload.Dragger
              name="file"
              action={`${apiUrl}/media/upload`}
              listType="picture"
              maxCount={5}
              multiple
              // highlight-next-line
              onChange={onChange}
            >
              <p className="ant-upload-text">Drag & drop a file in this area</p>
            </Upload.Dragger>
          </Form.Item>
        </Form.Item>
      </Form>
    </Create>
  );
};
```

## Example

<CodeSandboxExample path="upload-antd-multipart" />

================
File: advanced-tutorials/web3/ethereum-signin.md
================
---
id: ethereum-signin
title: Sign in with Ethereum Web3 Wallet
---

## Introduction

In this guide, you will examine what a web3 wallet is, how to sign in to your wallet, and how to use the popular wallet [MetaMask](https://metamask.io/). We will learn to log in to your Metamask wallet using **Refine** and [Web3](https://web3js.readthedocs.io/en/v1.5.2/).

A web3 wallet is a software that allows you to send, receive, or store cryptocurrency securely without the need for a 3rd party. Web3 wallet is your key to accessing your cryptocurrency. If you want to send cryptocurrency or receive it you will need a wallet.

We will show you how to log in to your Metamask wallet with **Refine**.

## Installation

We will need [web3](https://github.com/ChainSafe/web3.js) and [web3-modal](https://github.com/web3modal/web3modal) packages in our project. Let's start by downloading these packages.

<InstallPackagesCommand args="web3 web3modal"/>

:::caution

To make this example more visual, we used the [`@refinedev/antd`](https://github.com/refinedev/refine/tree/main/packages/antd) package. If you are using Refine headless, you need to provide the components, hooks or helpers imported from the [`@refinedev/antd`](https://github.com/refinedev/refine/tree/main/packages/antd) package.

:::

## Configure Refine Auth provider

First, we need to define a web3modal and create a provider. We can get information about the wallet by connecting this provider that we have created to web3.

:::note

In this example, we will show the login with Metamask Wallet. If you want, you can connect to other wallets using web3modal's providers.

:::

<details>
<summary>Show Code</summary>
<p>

```tsx title="/src/authprovider.ts"
import { AuthProvider } from "@refinedev/core";
import Web3 from "web3";
import Web3Modal from "web3modal";

import { getBalance } from "./utility";

export const TOKEN_KEY = "refine-auth";

const providerOptions = {};
const web3Modal = new Web3Modal({
  cacheProvider: true,
  providerOptions,
});

let provider: any | null = null;

export const authProvider: AuthProvider = {
  login: async () => {
    if (window.ethereum) {
      provider = await web3Modal.connect();
      const web3 = new Web3(provider);
      const accounts = await web3.eth.getAccounts();
      localStorage.setItem(TOKEN_KEY, accounts[0]);
      return {
        success: true,
        redirectTo: "/",
      };
    } else {
      return {
        success: false,
        error: new Error(
          "Not set ethereum wallet or invalid. You need to install Metamask",
        ),
      };
    }
  },
  logout: async () => {
    localStorage.removeItem(TOKEN_KEY);
    if (provider && provider.close) {
      await provider.close;

      provider = null;
      await web3Modal.clearCachedProvider();
    }
    return {
      success: true,
      redirectTo: "/login",
    };
  },
  onError: async (error) => {
    console.error(error);
    return { error };
  },
  check: async () => {
    const token = localStorage.getItem(TOKEN_KEY);
    if (token) {
      return {
        authenticated: true,
      };
    }

    return {
      authenticated: false,
      redirectTo: "/login",
      logout: true,
    };
  },
  getPermissions: async () => null,
  getIdentity: async () => {
    const address = localStorage.getItem(TOKEN_KEY);
    if (!address) {
      return null;
    }

    const balance = await getBalance(address);

    return {
      address,
      balance,
    };
  },
};
```

</p>
</details>

We use web3's `getBalance()` function to find out the ethereum amount of the account logged in.

```ts title="src/utility.ts"
const web3 = new Web3(window.ethereum);

export const getBalance = async (account: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    web3.eth.getBalance(account, (err: any, result: any) => {
      if (err) {
        reject(err);
      } else {
        resolve(web3.utils.fromWei(result, "ether"));
      }
    });
  });
};
```

### Override Login page​

We need to override the Refine login page. In this way, we will redirect it to the Metamask Wallet login page. We create a `login.tsx` file in the /pages folder.

<details>
<summary>Show Code</summary>
<p>

```tsx title="/src/page/login.tsx"
import { Layout, Button, Space, Typography } from "antd";
import { ThemedTitleV2 } from "@refinedev/antd";
// highlight-next-line
import { useLogin } from "@refinedev/core";

export const Login: React.FC = () => {
  // highlight-next-line
  const { mutate: login, isLoading } = useLogin();

  return (
    <Layout
      style={{
        height: "100vh",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Space direction="vertical" align="center" size="large">
        <ThemedTitleV2
          collapsed={false}
          wrapperStyles={{
            fontSize: "22px",
          }}
        />
        <Button
          type="primary"
          size="middle"
          loading={isLoading}
          onClick={() => login({})}
        >
          Sign in with Ethereum
        </Button>
        <Typography.Text type="secondary">Powered by Auth0</Typography.Text>
      </Space>
    </Layout>
  );
};
```

</p>
</details>

<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/web3/login-min.gif" alt="ethereum-login" className="border border-gray-200 rounded" />

## Create Dashboard

After connecting with our account, we can now retrieve account information. We will display this information on the dashboard of the **Refine**.

<details>
<summary>Show Code</summary>
<p>

```tsx title="src/pages/dashboard.tsx"
import React from "react";
import { useGetIdentity } from "@refinedev/core";
import { useModal } from "@refinedev/antd";
import {
  Row,
  Col,
  Card,
  Typography,
  Space,
  Button,
  Modal,
  Form,
  Input,
} from "antd";

const { Text } = Typography;

export const DashboardPage: React.FC = () => {
  const { data, isLoading } = useGetIdentity<{
    address: string;
    balance: string;
  }>();

  return (
    <Row gutter={24}>
      <Col span={12}>
        <Card
          title="Ethereum Public ID"
          style={{ height: "150px", borderRadius: "15px" }}
          headStyle={{ textAlign: "center" }}
        >
          <Space align="center" direction="horizontal">
            <Text>{isLoading ? "loading" : data?.address}</Text>
          </Space>
        </Card>
      </Col>
      <Col span={8}>
        <Card
          title="Account Balance"
          style={{ height: "150px", borderRadius: "15px" }}
          headStyle={{ textAlign: "center" }}
        >
          <Text>{`${isLoading ? "loading" : data?.balance} Ether`}</Text>
        </Card>
      </Col>
    </Row>
  );
};
```

</p>
</details>

<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/web3/dashboard.jpg" alt="refine-dashboard" className="border border-gray-200 rounded" />

Now lets customize **Refine** dashboard. Send your test ethereum via **Refine** dashboard and Metamask.

## Send Test Ethereum with Refine Dashboard

Here we use the `sendTransaction` function to send ethereum with your browser-enabled web3 wallet.

```tsx title="src/utility.ts"
export const sendEthereum = async (
  sender: string,
  receiver: string,
  amount: string,
) => {
  try {
    const params = {
      from: sender,
      to: receiver,
      value: web3.utils.toHex(web3.utils.toWei(amount, "ether")),
      gas: 39000,
    };
    await window.ethereum.enable();
    return await web3.eth.sendTransaction(params);
  } catch (error) {
    new Error("Something went wrong!");
  }
};
```

<details>
<summary>Show Code</summary>
<p>

```tsx title="src/pages/dashboard.tsx"
import React, { useState } from "react";
import { useGetIdentity } from "@refinedev/core";
import { useModal } from "@refinedev/antd";
import {
  Row,
  Col,
  Card,
  Typography,
  Space,
  Button,
  Modal,
  Form,
  Input,
  notification,
} from "antd";

import { sendEthereum } from "../utility";

const { Text } = Typography;

export const DashboardPage: React.FC = () => {
  const { data, isLoading } = useGetIdentity<{
    address: string;
    balance: string;
  }>();
  const { modalProps, show, close } = useModal();
  const [form] = Form.useForm();
  const [loading, setLoading] = useState(false);

  const handleModal = async (values: any) => {
    setLoading(true);
    const tx: any | undefined = await sendEthereum(
      data?.address!!,
      values.receiver,
      values.amount,
    );
    const status = tx ? tx.status : undefined;
    setLoading(false);

    if (status) {
      close();
      notification["success"]({
        message: "Transaction Success",
        description: "Transaction successful you can check on Etherscan.io",
      });
    } else {
      notification["warning"]({
        message: "Transaction Failed",
        description: "Transaction failed try again",
      });
    }
  };

  return (
    <>
      <Row gutter={24}>
        <Col span={12}>
          <Card
            title="Ethereum Public ID"
            style={{ height: "150px", borderRadius: "15px" }}
            headStyle={{ textAlign: "center" }}
          >
            <Space align="center" direction="horizontal">
              <Text>{isLoading ? "loading" : data?.address}</Text>
            </Space>
          </Card>
        </Col>
        <Col span={8}>
          <Card
            title="Account Balance"
            style={{ height: "150px", borderRadius: "15px" }}
            headStyle={{ textAlign: "center" }}
          >
            <Text>{`${isLoading ? "loading" : data?.balance} Ether`}</Text>
          </Card>
        </Col>
        <Col span={12}>
          <Button
            style={{ maxWidth: 300, marginTop: 24 }}
            type="primary"
            size="large"
            onClick={() => show()}
          >
            Send Ethereum
          </Button>
          <Button
            style={{ maxWidth: 300, marginTop: 24, marginLeft: 12 }}
            type="primary"
            size="large"
            href={`https://ropsten.etherscan.io/address/${data?.address}`}
          >
            View on Etherscan
          </Button>
        </Col>
      </Row>
      <Modal
        {...modalProps}
        okText={"Send"}
        title={"Send Test Ethereum via Ropsten Chain"}
        onOk={form.submit}
        okButtonProps={{ loading: loading }}
      >
        <Form layout="vertical" onFinish={handleModal} form={form}>
          <Form.Item name="receiver" label="Receiver Public Address">
            <Input />
          </Form.Item>
          <Form.Item name="amount" label="Amaount Ether">
            <Input />
          </Form.Item>
        </Form>
      </Modal>
    </>
  );
};
```

</p>
</details>

<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/web3/customize.jpg" alt="refine-customize" className="border border-gray-200 rounded" />

We can now request to send ethereum through our **Refine** dashboard and also view your account details on [Etherscan Ropsten Test Network](https://ropsten.etherscan.io/)

<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/web3/overview-min.gif" alt="refine-overview" className="border border-gray-200 rounded" />

## Example

<CodeSandboxExample path="with-web3" />

================
File: audit-logs/audit-log-provider/index.md
================
---
title: Audit Log Provider
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Refine allows you to track changes and who made them in your data by sending a new log event record whenever a new record is created, updated or deleted. Mutations made with data hooks are automatically sent to the `auditLogProvider` as an event. You can also manually send events to the `auditLogProvider` via hooks.

To use `auditLogProvider`, you just need to pass it to `<Refine>`:

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";

import auditLogProvider from "./auditLogProvider";

const App = () => (
  <Refine
    /* ... */
    auditLogProvider={auditLogProvider}
  />
);
```

An `auditLogProvider` must have the following methods:

- `create`: Logs an event to the audit log.
- `get`: Returns a list of events.
- `update`: Updates an event in the audit log.

Below are the corresponding interfaces for each of these methods:

```ts
const auditLogProvider = {
    create: (params: {
        resource: string;
        action: string;
        data?: any;
        author?: {
            name?: string;
            [key: string]: any;
        };
        previousData?: any;
        meta?: Record<string, any>;
    }) => void;
    get: (params: {
        resource: string;
        action?: string;
        meta?: Record<string, any>;
        author?: Record<string, any>;
        metaData?: MetaDataQuery;
    }) => Promise<any>;
    update: (params: {
        id: BaseKey;
        name: string;
    }) => Promise<any>;
}
```

:::note

Refine provides the `useLog` and `useLogList` hooks that can be used to access your `auditLogProvider` methods from anywhere in your application.

:::

## Creating an Audit Log Provider

Let's create an `auditLogProvider` to understand how it works better. Though we will be using `dataProvider` to handle events, you can do it however you want thanks to Refine providing an agnostic API.

### get

This method is used to get a list of audit log events.

For example, using the `useLogList` hook to list all resource activities by a specific record id creates an event like this:

```json
{
  "resource": "posts",
  "meta": {
    "id": "1"
  }
}
```

Now let's see how we can handle these events in our audit log provider.

```ts title="audit-log-provider.ts"
export const auditLogProvider: AuditLogProvider = {
  get: async (params) => {
    const { resource, meta, action, author, metaData } = params;

    const response = await fetch(
      `https://example.com/api/audit-logs/${resource}/${meta.id}`,
      {
        method: "GET",
      },
    );

    const data = await response.json();

    return data;
  },
};
```

### create

:::simple Caution

We recommend you create audit logs on the API side for security concerns since the data can be changed on the client side.

:::

This method is used to create an audit log event. It is triggered when a new successful mutation is made or when you use `useLog`'s `log` method. The incoming parameters show the values of the new record to be created.

When the mutations is successful, the `create` method is called with the following parameters, depending on the mutation type:

:::simple Log parameters for each mutation type

- Refine returns the `previousData` from the react-query cache if it can find it, returns `undefined` otherwise.

- In create mutations, if the request response has an `id` field, it will be added to the `meta` object.

- If [`getUserIdentity`](/docs/authentication/auth-provider) is defined in your auth provider, the `author` object will be added to the event with the value returned by `getUserIdentity`.

:::

<Tabs
defaultValue="create"
values={[
{label: 'Create', value: 'create'},
{label: 'Update', value: 'update'},
{label: 'Delete', value: 'delete'},
{label: 'Create Many', value: 'createMany'},
{label: 'Update Many', value: 'updateMany'},
{label: 'Delete Many', value: 'deleteMany'}
]}>
<TabItem value="create">

When a record is created, Refine automatically sends an event to `create` method like this:

```json
{
  "action": "create",
  "resource": "posts",
  "data": {
    "title": "Hello World",
    "content": "Hello World"
  },
  "meta": {
    "dataProviderName": "simple-rest",
    // If request response has a `id` field, it will be add in the `meta` field.
    "id": 1
  }
}
```

</TabItem>
<TabItem value="update">

When a record is updated, Refine automatically sends an event to `create` method like this:

```json
{
  "action": "update",
  "resource": "posts",
  "data": {
    "title": "New Hello World",
    "content": "New Hello World"
  },
  "previousData": {
    "title": "Hello World",
    "content": "Hello World"
  },
  "meta": {
    "dataProviderName": "simple-rest",
    "id": 1
  }
}
```

</TabItem>
<TabItem value="delete">

When a record is deleted, Refine automatically sends an event to `create` method like this:

```json
{
  "action": "delete",
  "resource": "posts",
  "meta": {
    "dataProviderName": "simple-rest",
    "id": 1
  }
}
```

</TabItem>
<TabItem value="createMany">

When a record is created with the `useCreateMany` hook, Refine automatically sends an event to the `create` method like this:

```json
{
  "action": "createMany",
  "resource": "posts",
  "data": [
    {
      "title": "Hello World 1"
    },
    {
      "title": "Hello World 2"
    }
  ],
  "meta": {
    "dataProviderName": "simple-rest",
    // If request response has a `id` field, it will be add in the `meta` field.
    "ids": [1, 2]
  }
}
```

</TabItem>
<TabItem value="updateMany">

When a record is updated with the `useUpdateMany` hook, Refine automatically sends an event to the `create` method like this:

```json
{
  "action": "updateMany",
  "resource": "posts",
  "data": {
    "status": "published"
  },
  "previousData": [
    {
      "status": "draft"
    },
    {
      "status": "archived"
    }
  ],
  "meta": {
    "dataProviderName": "simple-rest",
    "ids": [1, 2]
  }
}
```

</TabItem>
<TabItem value="deleteMany">

When a record is deleted with the `useDeleteMany` hook, Refine automatically sends an event to the `create` method like this:

```json
{
  "action": "deleteMany",
  "resource": "posts",
  "meta": {
    "dataProviderName": "simple-rest",
    "id": [1, 2]
  }
}
```

</TabItem>
</Tabs>

And here is how we can handle these events in our audit log provider:

```ts title="audit-log-provider.ts"
export const auditLogProvider: AuditLogProvider = {
  create: (params) => {
    const { resource, meta, action, author, data, previousData } = params;

    console.log(resource); // "produts", "posts", etc.
    console.log(meta); // { id: "1" }, { id: "2" }, etc.
    console.log(action); // "create", "update", "delete"
    // author object is `useGetIdentity` hook's return value.
    console.log(author); // { id: "1", name: "John Doe" }
    console.log(data); // { name: "Product 1", price: 100 }
    console.log(previousData); // { name: "Product 1", price: 50 }

    await fetch("https://example.com/api/audit-logs", {
      method: "POST",
      body: JSON.stringify(params),
    });

    return { success: true };
  },
};
```

For more information, refer to the [`useLog` documentation&#8594](/docs/audit-logs/hooks/use-log)

### update

This method is used to update an audit log event.

For example, using `useLog`'s `log` method creates an event like below:

```json
{
  "id": "1",
  "name": "event name"
}
```

```ts title="audit-log-provider.ts"
export const auditLogProvider: AuditLogProvider = {
  update: async (params) => {
    const { id, name, ...rest } = params;
    console.log(id); // "1"
    console.log(name); // "Created Product 1"
    console.log(rest); // { foo: "bar" }

    await fetch(`https://example.com/api/audit-logs/${id}`, {
      method: "PATCH",
      body: JSON.stringify(params),
    });

    return { success: true };
  },
};
```

For more information, refer to the [`useLog` documentation&#8594](/docs/audit-logs/hooks/use-log)

## Supported Hooks

The following hooks will call **Audit Log Provider**'s `create` method when a mutation is successful.

| Package                    | Hooks                                                                                                                                                                                                                                                                             |
| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| @refinedev/core            | [useForm](/docs/data/hooks/use-form/)                                                                                                                                                                                                                                             |
| @refinedev/antd            | [useForm](/docs/ui-integrations/ant-design/hooks/use-form), [useModalForm](/docs/ui-integrations/ant-design/hooks/use-modal-form), [useDrawerForm](/docs/ui-integrations/ant-design/hooks/use-drawer-form), [useStepsForm](/docs/ui-integrations/ant-design/hooks/use-steps-form) |
| @refinedev/mantine         | [useForm](/docs/ui-integrations/mantine/hooks/use-form), [useModalForm](/docs/ui-integrations/mantine/hooks/use-modal-form), [useDrawerForm](/docs/ui-integrations/mantine/hooks/use-drawer-form), [useStepsForm](/docs/ui-integrations/mantine/hooks/use-steps-form)             |
| @refinedev/react-hook-form | [useForm](/docs/packages/list-of-packages), [useModalForm](/docs/packages/list-of-packages), [useStepsForm](/docs/packages/list-of-packages)                                                                                                                                      |

Here are the parameters each hook send to `create`:

### useCreate

```ts
const { mutate } = useCreate();

mutate({
  resource: "posts",
  values: {
    title: "New Post",
    status: "published",
    content: "New Post Content",
  },
  metaData: {
    foo: "bar",
  },
});

// Calls Audit Log Provider's `create` method with the following parameters:

{
  "action": "create",
  "resource": "posts",
  "data": {
    "title": "Title",
    "status": "published",
    "content": "New Post Content"
  },
  "meta": {
    "id": "1",
    // `metaData` is included in `meta`.
    "foo": "bar"
  }
}
```

### useCreateMany

```ts
const { mutate } = useCreateMany();

mutate({
  resource: "posts",
  values: [
    {
      title: "Title1",
      status: "published",
      content: "New Post Content1",
    },
    {
      title: "Title2",
      status: "published",
      content: "New Post Content2",
    },
  ],
  metaData: {
    foo: "bar",
  },
});

// Calls Audit Log Provider's `create` method with the following parameters:

{
  "action": "createMany",
  "resource": "posts",
  "data": [
    {
      "title": "Title1",
      "status": "published",
      "content": "New Post Content1"
    },
    {
      "title": "Title2",
      "status": "published",
      "content": "New Post Content2"
    }
  ],
  "meta": {
    "ids": [1, 2],
    // `metaData` is included in `meta`.
    "foo": "bar"
  }
}
```

### useUpdate

```ts
const { mutate } = useUpdate();

mutate({
  id: 1,
  resource: "posts",
  values: {
    title: "Updated New Title",
  },
});

// Calls Audit Log Provider's `create` method with the following parameters:

{
  "action": "update",
  "resource": "posts",
  "data": {
    "title": "Updated New Title",
    "status": "published",
    "content": "New Post Content"
  },
  "previousData": {
    "title": "Title",
    "status": "published",
    "content": "New Post Content"
  },
  "meta": {
    "id": 1
  }
}
```

### useUpdateMany

```ts
const { mutate } = useUpdateMany();

mutate({
  ids: [1, 2],
  resource: "posts",
  values: {
    title: "Updated New Title",
  },
});

// Calls Audit Log Provider's `create` method with the following parameters:

{
  "action": "updateMany",
  "resource": "posts",
  "data": {
    "title": "Updated New Title"
  },
  "previousData": [
    {
      "title": "Title1"
    },
    {
      "title": "Title2"
    }
  ],
  "meta": {
    "ids": [1, 2]
  }
}
```

### useDelete

```ts
const { mutate } = useDelete();

mutate({
  id: 1,
  resource: "posts",
});

// Calls Audit Log Provider's `create` method with the following parameters:

{
  "action": "delete",
  "resource": "posts",
  "meta": {
    "id": 1
  }
}
```

### useDeleteMany

```ts
const { mutate } = useDeleteMany();

mutate({
  ids: [1, 2],
  resource: "posts",
});

// Calls Audit Log Provider's `create` method with the following parameters:

{
  "action": "deleteMany",
  "resource": "posts",
  "meta": {
    "ids": [1, 2]
  }
}
```

## Enable/Disable to Audit Log by Mutation Type for a Resource

With `meta.audit`, you can specify which mutations trigger audit logs; otherwise, all create, update, and delete actions will be logged by default.

For example, if you have the code below, only events will be created for the `create` mutation.

```ts title="App.tsx"
<Refine
  dataProvider={dataProvider(API_URL)}
  resources={[
    {
      name: "posts",
      // highlight-start
      meta: {
        audit: ["create"],
      },
      // highlight-end
    },
  ]}
/>
```

## Example

<CodeSandboxExample path="audit-log-provider" />

================
File: audit-logs/hooks/use-log-list/index.md
================
---
title: useLogList
---

If you need to list audit log events, you can use the `useLogList` hook of Refine, which uses the `get` method from [`auditLogProvider`](/docs/audit-logs/audit-log-provider#get) under the hood.

## Usage

```tsx
import { useLogList } from "@refinedev/core";

const postAuditLogResults = useLogList({
  resource: "posts",
});
```

## API Reference

### Properties

| Property                      | Type                                                         | Default                         |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------- |
| resource <PropTag asterisk /> | `string`                                                     | Action that it reads from route |
| action                        | `string`                                                     |                                 |
| author                        | `Record<string, any>`                                        |                                 |
| meta                          | `Record<string, any>`                                        |                                 |
| metaData                      | [`MetaDataQuery`](/docs/core/interface-references#metaquery) |                                 |
| queryOptions                  | `UseQueryOptions<TQueryFnData, TError, TData>`               |                                 |

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Description                              | Type                                                                                      |
| ---------------------------------------- | ----------------------------------------------------------------------------------------- |
| Result of the `react-query`'s `useQuery` | [`UseQueryResult<{ data: TData; }>`](https://react-query.tanstack.com/reference/useQuery) |

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: audit-logs/hooks/use-log/index.md
================
---
title: useLog
---

If you need to create or update an audit log, you can use Refine's `useLog` hook. This hook will return two mutations called `log` and `rename`

```tsx
import { useLog } from "@refinedev/core";

const { log, rename } = useLog();
```

## log

The `log` mutation is used to create an audit log event using the `create` method from [`auditLogProvider`](/docs/audit-logs/audit-log-provider#create) under the hood.

```tsx
import { useLog } from "@refinedev/core";

const { log } = useLog();
const { mutate } = log;

mutate({
  resource: "posts",
  action: "create",
  author: {
    username: "admin",
  },
  data: {
    id: 1,
    title: "New post",
  },
  meta: {
    id: 1,
  },
});
```

### Properties

| Property                      | Type                  |
| ----------------------------- | --------------------- |
| resource <PropTag asterisk /> | `string`              |
| action <PropTag asterisk />   | `string`              |
| author                        | `Record<string, any>` |
| meta                          | `Record<string, any>` |
| data                          | `Record<string, any>` |
| previousData                  | `Record<string, any>` |

### Type Parameters

| Property   | Description                                                                                     | Type                                                       | Default                                                    |
| ---------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| TData      | Result data of the mutation. Extends [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) |
| TError     | Custom error object that extends [`HttpError`](/docs/core/interface-references#httperror)       | [`HttpError`](/docs/core/interface-references#httperror)   | [`HttpError`](/docs/core/interface-references#httperror)   |
| TVariables | Values for mutation function                                                                    | `{}`                                                       | `{}`                                                       |

### Return value

| Description                               | Type                                                                                                                                           |
| ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| Result of the `react-query`'s useMutation | [`UseMutationResult<{ data: TData}, TError, { id: BaseKey; name: string; }, unknown>`](https://react-query.tanstack.com/reference/useMutation) |

## rename

The `rename` mutation is used to update an audit log event using the `update` method from [`auditLogProvider`](/docs/audit-logs/audit-log-provider#update) under the hood.

```tsx
import { useLog } from "@refinedev/core";

const { rename } = useLog();
const { mutate } = rename;

mutate({
  id: 1,
  name: "Updated Name",
});
```

### Properties

| Property                  | Type      |
| ------------------------- | --------- |
| id <PropTag asterisk />   | `BaseKey` |
| name <PropTag asterisk /> | `string`  |

### Type Parameters

| Property   | Description                                                                                     | Type                                                       | Default                                                    |
| ---------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| TData      | Result data of the mutation. Extends [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) |
| TError     | Custom error object that extends [`HttpError`](/docs/core/interface-references#httperror)       | [`HttpError`](/docs/core/interface-references#httperror)   | [`HttpError`](/docs/core/interface-references#httperror)   |
| TVariables | Values for mutation function                                                                    | `{}`                                                       | `{}`                                                       |

### Return value

| Description                               | Type                                                                                                                                           |
| ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| Result of the `react-query`'s useMutation | [`UseMutationResult<{ data: TData}, TError, { id: BaseKey; name: string; }, unknown>`](https://react-query.tanstack.com/reference/useMutation) |

================
File: authentication/auth-provider/index.md
================
---
title: Auth Provider
---

import AuthProviderExamplesLinks from "@site/src/partials/auth-provider/auth-provider-examples-links.md";

Auth provider is an object that contains methods to handle authentication and access control in your app by having Refine consume them. These methods expect to return a promise, so they can be used with async methods.

:::simple Good to know

- You can use any third-party authentication service like [Auth0, Okta, etc.](#examples) or your own custom methods while creating an auth provider from scratch.
- Auth Provider is not required for Refine to work, if it is not provided, your application will not have any authentication capabilities. As a result, you will not be able to use any of the auth hooks or components.
- To learn more about how to create your own auth provider, refer to the [Create an Auth Provider tutorial &#8594][create-auth-provider-tutorial].

:::

## Usage

To activate authentication in your app, you need to pass an ` authProvider` to the `<Refine/>` as a prop:

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";

// highlight-next-line
import authProvider from "./auth-provider";

const App = () => {
  // highlight-next-line
  return <Refine authProvider={authProvider} />;
};
```

## Examples

<AuthProviderExamplesLinks/>

## Methods

An `authProvider` can contain the following methods:

```tsx
import type { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
    // required methods
    login: async (params: any): AuthActionResponse,
    check: async (params: any): CheckResponse,
    logout: async (params: any): AuthActionResponse,
    onError: async (params: any): OnErrorResponse,
    // optional methods
    register: async (params: any): AuthActionResponse,
    forgotPassword: async (params: any): AuthActionResponse,
    updatePassword: async (params: any): AuthActionResponse,
    getPermissions: async (params: any): unknown,
    getIdentity: async (params: any): unknown,
};
```

All methods can have any parameters that you want to pass to them. However, the return types of the methods are fixed. You can find the details below.

## Required Methods

### login

`login` method is used to authenticate users. It expects to return a resolved promise with the following type:

```ts
type AuthActionResponse = {
  success: boolean;
  redirectTo?: string;
  error?: Error;
  [key: string]: unknown;
};
```

- `success`: Determines whether the operation is successful or not.
- `redirectTo`: The path of the page that the user will be redirected to after the operation is completed.
- `error`: An object containing details about any errors encountered during the operation.
- `[key: string]`: Any additional data you wish to include in the response, keyed by a string identifier.

<br />

As an example, let's create a simple `login` method that checks if the user exists in the mock data. If the user exists, we will save the user's data to the local storage and redirect the user to the home page. If the user doesn't exist, we will return an error.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const mockUsers = [{ email: "john@mail.com" }, { email: "jane@mail.com" }];

const authProvider: AuthProvider = {
  login: async ({ email, password }) => {
    // Suppose we actually send a request to the back end here.
    const user = mockUsers.find((item) => item.email === email);

    if (user) {
      localStorage.setItem("auth", JSON.stringify(user));
      return {
        success: true,
        redirectTo: "/",
      };
    }

    return {
      success: false,
      error: {
        message: "Login Error",
        name: "Invalid email or password",
      },
    };
  },
  // ---
};
```

Refine will consume this method using the `useLogin` hook which is used for login operations.

For example, if we call the `useLogin` hook's mutation like this:

```tsx
import { useLogin } from "@refinedev/core";

const { mutate } = useLogin();

mutate({ email: "john@mail.com", password: "123456" });
```

The `login` method will get the mutation's parameters as arguments.

> For more information, refer to the [`useLogin`][use-login] documentation.

**FAQ**

<details>
  <summary><strong>Can I pass any parameters to the <code>login</code> method?</strong></summary>

You can pass any parameters to the `login` method. `useLogin` hook's mutation will pass the mutation's parameters to the method without any type constraints.

```ts
const { mutate } = useLogin<{
  username: string;
  password: string;
  foo: string;
  remember: boolean;
}>();
```

</details>

<details>
  <summary><strong>How can I redirect the user to a specific page after login?</strong></summary>

If you want to redirect the user to a specific page, you can resolve the promise with an object that has the `redirectTo` property.

```ts
const authProvider: AuthProvider = {
  // ---
  login: async () => {
    // ---
    if (user) {
      return {
        success: true,
        redirectTo: "/custom-page",
      };
    } else {
      return {
        success: false,
        redirectTo: "/register",
      };
    }
  },
};
```

You can also use the `useLogin` hook's for this purpose:

```tsx
const { mutate } = useLogin();

mutate({ redirectPath: "/custom-page" });
```

Then use the `redirectPath` parameter in the `login` method to redirect the user to the specific page:

```ts
const authProvider: AuthProvider = {
  // ---
  login: async ({ redirectPath }) => {
    //---
    return {
      success: false,
      redirectTo: redirectPath,
    };
  },
};
```

If you don't want to redirect the user anywhere, you can resolve the `login` method's promise with `redirectTo: undefined`.

```ts
const authProvider: AuthProvider = {
  // ---
  login: async () => {
    // ---
    return {
      success: false,
      redirectTo: undefined,
    };
  },
};
```

</details>

<details>
  <summary><strong>How can I customize the error message?</strong></summary>

Refine automatically displays an error notification when the `login` method resolves the promise with `success: false`. If you want to customize the error message, you can resolve the promise with an `error` object that has `name` and `message` properties.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  login: async ({ email, password }) => {
    // ---
    return {
      success: false,
      error: {
        name: "Login Failed!",
        message:
          "The email or password that you've entered doesn't match any account.",
      },
    };
  },
  // ---
};
```

</details>

### check

The `check` method is used to check if the user is authenticated. It is internally called when the user navigates to a page that requires authentication. This method expects to return a resolved promise with the following type:

```ts
type CheckResponse = {
  authenticated: boolean;
  redirectTo?: string;
  logout?: boolean;
  error?: Error;
};
```

- `authenticated`: A boolean value indicating whether the user is authenticated or not.
- `redirectTo`: A string value indicating the URL to redirect to if authentication is required.
- `logout`: A boolean value indicating whether the user should be logged out.
- `error`: An Error object representing any errors that may have occurred during the check.

<br />

Since we saved the user data to the local storage in the `login` method, we will check that to determine if the user is authenticated:

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ---
  check: async () => {
    const user = localStorage.getItem("auth");

    if (user) {
      return {
        authenticated: true,
      };
    }

    return {
      authenticated: false,
      logout: true,
      redirectTo: "/login",
      error: {
        message: "Check failed",
        name: "Unauthorized",
      },
    };
  },
  // ---
};
```

<br />

Refine will consume this method using the `useIsAuthenticated` hook which is used for checking if the user is authenticated.

```tsx
import { useIsAuthenticated } from "@refinedev/core";

const { data, isSuccess, isLoading, isError } = useIsAuthenticated();
```

> For more information, refer to the [`useIsAuthenticated`][use-is-authenticated] documentation.

**FAQ**

<details>
  <summary><strong>How can I redirect the user if they are not authenticated?</strong></summary>

If you want to redirect the user to a specific page, you can resolve the Promise with an object that has `redirectTo` property.

```ts
const authProvider: AuthProvider = {
  // ---
  check: async () => {
    // ---
    return {
      authenticated: false,
      redirectTo: "/custom-page",
    };
  },
};
```

</details>

### logout

The `logout` method is used to log out users. It expects to return a resolved promise with the following type:

```ts
type AuthActionResponse = {
  success: boolean;
  redirectTo?: string;
  error?: Error;
  [key: string]: unknown;
};
```

- `success`: Determines whether the operation is successful or not.
- `redirectTo`: The path of the page that the user will be redirected to after the operation is completed.
- `error`: An object containing details about any errors encountered during the operation.
- `[key: string]`: Any additional data you wish to include in the response, keyed by a string identifier.

<br />

Opposite to what we did in the `login` method, we now need to remove the user data from the local storage upon log out:

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ---
  logout: async () => {
    localStorage.removeItem("auth");
    return {
      success: true,
      redirectTo: "/login",
    };
  },
  // ---
};
```

<br />

Refine will consume this method using the `useLogout` hook which is used for logging out users.

For example, if we call the `useLogout` hook's mutation like this:

```tsx
import { useLogout } from "@refinedev/core";

const { mutate } = useLogout();

mutate({ userId: "123" });
```

The `logout` method will get the mutation's parameters as an argument.

> For more information, refer to the [`useLogout`][use-logout] documentation.

**FAQ**

<details>
  <summary><strong>Can I pass any parameters to the <code>logout</code> method?</strong></summary>

Yes, you can pass any parameters to the `logout` method. The `useLogout` hook's mutation will pass the mutation's parameters to the `logout` method without any type constraints.

```ts
const { mutate } = useLogout<{
  id: string;
  name: string;
}>();
```

</details>

<details>
  <summary><strong>How can I redirect the user to a specific page after logout?</strong></summary>

If you want to redirect the user to a specific page, you can resolve the promise with an object that has the `redirectTo` property.

```ts
const authProvider: AuthProvider = {
  // ---
  logout: async () => {
    // ---
    return {
      success: true,
      redirectTo: "/login",
    };
  },
};
```

You can also use the `useLogout` hook for this purpose:

```tsx
const { mutate } = useLogout();

mutate({ redirectPath: "/custom-page" });
```

Then use the `redirectPath` parameter in the `logout` method to redirect the user to the specific page:

```ts
const authProvider: AuthProvider = {
  // ---
  logout: ({ redirectPath }) => {
    // ---
    return {
      success: true,
      redirectTo: redirectPath,
    };
  },
};
```

If you don't want to redirect the user to anywhere, you can resolve the `logout` method's Promise with `redirectTo: undefined`.

```ts
const authProvider: AuthProvider = {
  // ---
  logout: async () => {
    // ---
    return {
      success: true,
      redirectTo: undefined,
    };
  },
};
```

</details>

<details>
  <summary><strong>How can I customize the error message?</strong></summary>

Refine automatically displays an error notification when the `logout` method resolves the Promise with `success: false`. If you want to customize the error message, you can resolve the Promise with an `error` object that has `name` and `message` properties.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  logout: async () => {
    // ---
    return {
      success: false,
      error: {
        name: "Logout Failed!",
        message: "Something went wrong.",
      },
    };
  },
  // ---
};
```

</details>

### onError

`onError` method is called when you get an error response from the API. You can create your own business logic to handle the error such as refreshing the token, logging out the user, etc.

`onError` method expects to return a Promise with the following type:

```ts
type OnErrorResponse = {
  redirectTo?: string;
  logout?: boolean;
  error?: Error;
};
```

- `redirectTo`: If has a value, the app will be redirected to the given URL.
- `logout`: If is `true`, useOnError calls the `logout` method.
- `error`: An Error object representing any errors that may have occurred during the operation.

<br />

We'll use the `onError` method to log out the user if the API returns a `401` or `403` error. If `redirectTo` is set, `logout` method will be called with the `redirectTo` value.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ---
  onError: async (error) => {
    if (error.status === 401 || error.status === 403) {
      return {
        logout: true,
        redirectTo: "/login",
        error,
      };
    }

    return {};
  },
  // ---
};
```

<br />

Refine will consume this method using the `useOnError` hook which is used for handling errors.

```tsx
import { useOnError } from "@refinedev/core";

const { mutate } = useOnError();

fetch("http://example.com/payment")
  .then(() => console.log("Success"))
  .catch((error) => mutate(error));
```

> For more information, refer to the [`useOnError`][use-on-error] documentation.

**FAQ**

<details>
  <summary><strong>How can I redirect the user to a specific page after logout?</strong></summary>

If you want to redirect the user to a specific page, you can resolve the promise with an object that has `redirectTo` property.

```ts
const authProvider: AuthProvider = {
  // ---
  onError: async (error) => {
    if (error.status === 401 || error.status === 403) {
      return {
        redirectTo: "/custom-page",
      };
    }

    return {};
  },
  // ---
};
```

</details>

## Optional Methods

### getPermissions

`getPermissions` method is used to get the user's permissions. It expects to return a resolved promise.

We will use the `getPermissions` method to get the user's permissions from the `localStorage`.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const mockUsers = [
  { email: "john@mail.com", roles: ["admin"] },
  { email: "jane@mail.com", roles: ["editor"] },
];

const authProvider: AuthProvider = {
  // You can also pass a parameter but it is optional
  getPermissions: (params) => {
    if (params) {
      // do some logic or make a request to server
    } else {
      const user = localStorage.getItem("auth");

      if (user) {
        const { roles } = JSON.parse(user);

        return roles;
      }
    }

    return null;
  },
  // ---
};
```

<br />

Refine will consume this method using the `usePermissions` hook which is used for getting the user's permissions.

For example, if you want to check if the user has a specific permission, you can use the `usePermissions` hook like this:

```tsx
import { usePermissions } from "@refinedev/core";

const { data } = usePermissions();

if (data?.includes("admin")) {
  console.log("User has admin permissions");
}
```

> For more information, refer to the [`usePermissions`][use-permissions] documentation.

:::info

Though `usePermissions` hook can be used for simple authorization purposes, if you need more complex authorization logic, we recommend using the access control provider.

For more information, refer to the [`accessControlProvider` documentation&#8594](/docs/authorization/access-control-provider)

:::

### getIdentity

`getIdentity` method is used to get the user's identity. It expects to return a resolved promise.

To get the user's identity from the local storage and resolve the promise:

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const mockUsers = [
  { email: "john@mail.com", roles: ["admin"] },
  { email: "jane@mail.com", roles: ["editor"] },
];

const authProvider: AuthProvider = {
  // ---
  getIdentity: async () => {
    const user = localStorage.getItem("auth");

    if (user) {
      const { email, roles } = JSON.parse(user);

      return { email, roles };
    }

    return null;
  },
  // ---
};
```

Refine will consume this method using the `useGetIdentity` hook which is used for getting the user's identity.

For example, if you want to get the user's email, you can use the `useGetIdentity` hook like this:

```tsx
import { useGetIdentity } from "@refinedev/core";

const { data } = useGetIdentity();

if (data) {
  console.log(data.email);
}
```

> For more information, refer to the [`useGetIdentity`][use-get-identity] documentation.

### register

`register` method is used to register a new user. It is similar to the `login` method. It expects to return a resolved promise with the following type:

```ts
type AuthActionResponse = {
  success: boolean;
  redirectTo?: string;
  error?: Error;
  [key: string]: unknown;
};
```

- `success`: Determines whether the operation is successful or not.
- `redirectTo`: The path of the page that the user will be redirected to after the operation is completed.
- `error`: An object containing details about any errors encountered during the operation.
- `[key: string]`: Any additional data you wish to include in the response, keyed by a string identifier.

<br />

We'll register a new user and resolve the promise.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const mockUsers = [{ email: "john@mail.com" }, { email: "jane@mail.com" }];

const authProvider: AuthProvider = {
  // ---
  register: async ({ email }) => {
    const user = mockUsers.find((user) => user.email === email);

    if (user) {
      return {
        success: false,
        error: {
          name: "Register Error",
          message: "User already exists",
        },
      };
    }

    mockUsers.push({ email });

    return {
      success: true,
      redirectTo: "/login",
    };
  },
  // ---
};
```

Refine will consume this method using the `useRegister` hook which is used for registering a new user.

For example, if you want to register a new user, you can use the `useRegister` hook like this:

```tsx
import { useRegister } from "@refinedev/core";

const { mutate } = useRegister();

const handleRegister = (values) => {
  mutate(values);
};
```

The `register` method will get the mutation's parameters as arguments.

> For more information, refer to the [`useRegister`][use-register] documentation.

**FAQ**

<details>
  <summary><strong>Can I pass any parameters to the <code>register</code> method?</strong></summary>

Yes, you can pass any parameters to the `register` method. `useRegister` hook's mutation will pass the mutation's parameters to the `register` method without any type constraints.

```ts
const { mutate } = useRegister<{
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
  remember: boolean;
}>();
```

</details>

<details>
  <summary><strong>How can I redirect the user to a specific page after registration?</strong></summary>

If you want to redirect the user to a specific page, you can resolve the Promise with an object that has `redirectTo` property.

```ts
const authProvider: AuthProvider = {
  // ---
  register: async () => {
    // ---
    return {
      success: true, // or false
      redirectTo: "/custom-page",
    };
  },
};
```

You can also use the `useRegister` hook's for this purpose:

```tsx
const { mutate } = useRegister();

mutate({ redirectPath: "/custom-page" });
```

Then use the `redirectPath` parameter in the `register` method to redirect the user to the specific page:

```ts
const authProvider: AuthProvider = {
  // ---
  register: async ({ redirectPath }) => {
    // ---
    return {
      success: true, // or false
      redirectTo: redirectPath,
    };
  },
};
```

If you don't want to redirect the user to anywhere, you can resolve the `register` method's Promise with `redirectTo: undefined`.

```ts
const authProvider: AuthProvider = {
  // ---
  register: async () => {
    // ---
    return {
      success: true, // or false
      redirectTo: undefined,
    };
  },
};
```

</details>

<details>
  <summary><strong>How can I customize the error message?</strong></summary>

Refine automatically displays an error notification when the `register` method resolves the Promise with `success: false`. If you want to customize the error message, you can resolve the Promise with an `error` object that has `name` and `message` properties.

```tsx title="src/authProvider.ts"
const authProvider: AuthProvider = {
  // ---
  register: async () => {
    // ---
    return {
      success: false,
      error: {
        name: "Error",
        message: "Something went wrong!",
      },
    };
  },
};
```

</details>

### forgotPassword

`forgotPassword` method is used to send a password reset link to the user's email address. It expects to return a resolved promise with the following type:

```ts
type AuthActionResponse = {
  success: boolean;
  redirectTo?: string;
  error?: Error;
  [key: string]: unknown;
};
```

- `success`: Determines whether the operation is successful or not.
- `redirectTo`: The path of the page that the user will be redirected to after the operation is completed.
- `error`: An object containing details about any errors encountered during the operation.
- `[key: string]`: Any additional data you wish to include in the response, keyed by a string identifier.

<br />

To send a password reset link to the user's email address and resolve the promise:

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ---
  forgotPassword: async ({ email }) => {
    // send password reset link to the user's email address here

    // if request is successful
    return {
      success: true,
      redirectTo: "/login",
    };

    // if request is not successful
    return {
      success: false,
      error: {
        name: "Forgot Password Error",
        message: "Email address does not exist",
      },
    };
  },
  // ---
};
```

Refine will consume this method using the `useForgotPassword` hook which is used for sending a password reset link to the user's email address.

For example, if you want to send a password reset link to the user's email address, you can use the `useForgotPassword` hook like this:

```tsx
import { useForgotPassword } from "@refinedev/core";

const { mutate } = useForgotPassword();

const handleForgotPassword = (values) => {
  mutate(values);
};
```

The `forgotPassword` method will get the mutation's parameters as arguments.

> For more information, refer to the [`useForgotPassword`][use-forgot-password] documentation.

**FAQ**

<details>
  <summary><strong>Can I pass any parameters to the <code>forgotPassword</code> method?</strong></summary>

Yes, you can pass any parameters to the `forgotPassword` method. `useForgotPassword` hook's mutation will pass the mutation's parameters to the `forgotPassword` method without any type constraints.

```ts
const { mutate } = useForgotPassword<{
  email: string;
}>();
```

</details>

<details>
  <summary><strong>How can I redirect the user to a specific page after sending the password reset link?</strong></summary>

If you want to redirect the user to a specific page, you can resolve the `forgotPassword` method's Promise with the path of the page.

```ts
const authProvider: AuthProvider = {
  // ---
  forgotPassword: async () => {
    // ---
    return {
      success: true,
      redirectTo: "/login",
    };
  },
};
```

Also, you can use the `useForgotPassword` hook's for this purpose.

```ts
const { mutate } = useForgotPassword();

useForgotPassword({ redirectPath: "/custom-page" });
```

Then, you can use the `redirectPath` parameter in the `forgotPassword` method to redirect the user to the specific page.

```ts
const authProvider: AuthProvider = {
  // ---
  forgotPassword: async ({ redirectPath }) => {
    // ---
    return {
      success: true,
      redirectTo: redirectPath,
    };
  },
};
```

</details>

<details>
  <summary><strong>How can I customize the error message?</strong></summary>

Refine automatically displays an error notification when the `forgotPassword` method resolves the Promise with `success: false`. If you want to customize the error message, you can resolve the Promise with an object that has `name` and `message` properties.

```tsx title="src/authProvider.ts"
const authProvider: AuthProvider = {
  // ---
  forgotPassword: async () => {
    // ---
    return {
      success: false,
      error: {
        name: "Error",
        message: "Something went wrong!",
      },
    };
  },
};
```

</details>

### updatePassword

`updatePassword` method is used to update the user's password. It expects to return a resolved promise with the following type:

```ts
type AuthActionResponse = {
  success: boolean;
  redirectTo?: string;
  error?: Error;
  [key: string]: unknown;
};
```

- `success`: Determines whether the operation is successful or not.
- `redirectTo`: The path of the page that the user will be redirected to after the operation is completed.
- `error`: An object containing details about any errors encountered during the operation.
- `[key: string]`: Any additional data you wish to include in the response, keyed by a string identifier.

<br />

To update the user's password and resolve the promise:

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ---
  updatePassword: async ({ password }) => {
    // update the user's password here

    // if request is successful
    return {
      success: true,
      redirectTo: "/login",
    };

    // if request is not successful
    return {
      success: false,
      error: {
        name: "Forgot Password Error",
        message: "Email address does not exist",
      },
    };
  },
  // ---
};
```

Refine will consume this method using the `useUpdatePassword` hook which is used to update the user's password.

For example, if you want to update the user's password, you can use the `useUpdatePassword` hook like this:

```tsx
import { useUpdatePassword } from "@refinedev/core";

const { mutate } = useUpdatePassword();

const handleUpdatePassword = ({ password, confirmPassword }) => {
    mutate({ password, confirmPassword }});
};
```

Additionally, the `updatePassword` method will take query parameters as arguments from the URL.

If we assume that the URL is `http://localhost:3000/reset-password?token=123`, the `updatePassword` method will get the mutation's parameters as arguments and the `token` query parameter as well.

```ts
const authProvider: AuthProvider = {
  // ---
  updatePassword: async ({ password, confirmPassword, token }) => {
    console.log(token); // 123

    // if request is successful
    return {
      success: true,
      redirectTo: "/login",
    };
  },
};
```

> For more information, refer to the [`useUpdatePassword`][use-update-password] documentation.

**FAQ**

<details>
  <summary><strong>Can I pass any parameters to the <code>updatePassword</code> method?</strong></summary>

Yes, you can pass any parameters to the `updatePassword` method. `useUpdatePassword` hook's mutation will pass the mutation's parameters to the `updatePassword` method without any type constraints.

```ts
const { mutate } = useUpdatePassword<{
  password: string;
  newPassword: string;
}>();
```

</details>

<details>
  <summary><strong>How can I redirect the user to a specific page after updating the password?</strong></summary>

If you want to redirect the user to a specific page, you can resolve the Promise with an object that has `redirectTo` property.

```ts
const authProvider: AuthProvider = {
  // ---
  updatePassword: async () => {
    // ---
    return {
      success: true,
      redirectTo: "/login",
    };
  },
};
```

You can also use the `useUpdatePassword` hook's for this purpose:

```ts
const { mutate } = useUpdatePassword();

useUpdatePassword({ redirectPath: "/custom-page" });
```

Then use the `redirectPath` parameter in the `updatePassword` method to redirect the user to the specific page:

```ts
const authProvider: AuthProvider = {
  // ---
  updatePassword: async ({ redirectPath }) => {
    // ---
    return {
      success: true,
      redirectTo: redirectPath,
    };
  },
};
```

</details>

<details>
  <summary><strong>How can I customize the error message?</strong></summary>

Refine automatically displays an error notification when the `updatePassword` method resolves the Promise with `success: false`. If you want to customize the error message, you can resolve the Promise with an `error` object that has `name` and `message` properties.

```tsx title="src/authProvider.ts"
const authProvider: AuthProvider = {
  // ---
  updatePassword: async () => {
    // ---
    return {
      success: false,
      error: {
        name: "Error",
        message: "Something went wrong!",
      },
    };
  },
};
```

</details>

## Legacy Auth Provider

Refine's v4 release is backward compatible and supports legacy auth provider implementations until v5.

If you want to use a legacy auth provider, you can pass them to the `<Refine />` component using the `legacyAuthProvider` prop.

[Refer to the Migration Guide for more information. &#8594](/docs/migration-guide/auth-provider/)

```tsx
import { LegacyAuthProvider, Refine } from "@refinedev/core";

const legacyAuthProvider: LegacyAuthProvider = {
  /* --- */
};

const App = () => {
  return (
    <Refine
      // ---
      legacyAuthProvider={legacyAuthProvider}
    >
      {/* --- */}
    </Refine>
  );
};
```

## FAQ

### How can I create an auth provider?

[Refer to the "Create Auth Provider From Scratch" section in the tutorial for more information &#8594][create-auth-provider-tutorial]

### How can I set authorization credentials?

[Refer to the "Setting Authorization Credentials" section in the tutorial for more information &#8594](/docs/guides-concepts/authentication)

### How can I implement refresh token mechanism?

[Refer to the "Implementing Refresh Token Mechanism" section in the tutorial for more information &#8594](/docs/guides-concepts/authentication)

[use-login]: /docs/authentication/hooks/use-login
[use-logout]: /docs/authentication/hooks/use-logout
[use-is-authenticated]: /docs/authentication/hooks/use-is-authenticated
[use-on-error]: /docs/authentication/hooks/use-on-error
[use-get-identity]: /docs/authentication/hooks/use-get-identity
[use-permissions]: /docs/authentication/hooks/use-permissions
[use-register]: /docs/authentication/hooks/use-register
[use-forgot-password]: /docs/authentication/hooks/use-forgot-password
[use-update-password]: /docs/authentication/hooks/use-update-password
[create-auth-provider-tutorial]: /docs/guides-concepts/authentication

================
File: authentication/components/auth-page/index.md
================
---
title: <AuthPage />
description: <AuthPage> component from Refine is an authentication page that can be used to login, register, forgot password, and update password.
source: packages/core/src/components/pages/auth/index.tsx
---

`<AuthPage>` component from Refine contains authentication pages that can be used to login, register, forgot password, and update password.

Before using `<AuthPage>` component you need to add [authProvider](/docs/authentication/auth-provider) that will be used to handle authentication.

```css live shared
body {
  background-color: #f5f5f5;
}
```

```tsx live shared
const { useLogout: useLogoutShared } = RefineCore;

window.__refineAuthStatus = false;

const authProvider = {
  login: async () => {
    window.__refineAuthStatus = true;
    return {
      success: true,
      redirectTo: "/",
    };
  },
  register: async () => {
    return {
      success: true,
    };
  },
  forgotPassword: async () => {
    return {
      success: true,
    };
  },
  updatePassword: async () => {
    return {
      success: true,
    };
  },
  logout: async () => {
    window.__refineAuthStatus = false;
    return {
      success: true,
      redirectTo: "/login",
    };
  },
  check: async () => ({
    authenticated: window.__refineAuthStatus,
  }),
  onError: async (error) => {
    console.error(error);
    return { error };
  },
  getPermissions: async () => ["admin"],
  getIdentity: async () => null,
};

const DashboardPage = () => {
  const { mutate: logout } = useLogoutShared();

  return (
    <div>
      <h1>Dashboard Page</h1>
      <button
        onClick={() => {
          logout();
        }}
      >
        Logout
      </button>
    </div>
  );
};

const Wrapper = (children) => {
  return (
    <div
      style={{
        display: "flex",
        justifyContent: "center",
      }}
    >
      <div
        style={{
          width: "400px",
        }}
      >
        {children}
      </div>
    </div>
  );
};
```

## Usage

The `<AuthPage>` component can be used like this:

```tsx live disableScroll  previewHeight=333px url=http://localhost:3000/login
setInitialRoutes(["/login"]);

// visible-block-start
import { Refine, AuthPage, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { CatchAllNavigate } from "@refinedev/react-router";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "./authProvider";

import { DashboardPage } from "pages/dashboard";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        routerProvider={routerProvider}
        authProvider={authProvider}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                <Outlet />
              </Authenticated>
            }
          >
            <Route index element={<DashboardPage />} />
          </Route>
          <Route element={<Authenticated fallback={<Outlet />} />}>
            {/* highlight-next-line */}
            <Route path="/login" element={<AuthPage />} />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
// visible-block-end
render(<App />);
```

## Types

The `<AuthPage>` component has the following types:

- [`login`](#login) - a type of login page and default type.
- [`register`](#register) - a type of registration page.
- [`forgotPassword`](#forgotpassword) - a type of forgot password page.
- [`updatePassword`](#updatepassword) - a type of update password page.

### Login

You can use the following props for the `<AuthPage>` component when the type is `"login"`:

```tsx live disableScroll hideCode url=http://localhost:3000/login previewHeight=390px
setInitialRoutes(["/login"]);

// visible-block-start
import { Refine, AuthPage, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { CatchAllNavigate } from "@refinedev/react-router";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "./authProvider";

import { DashboardPage } from "pages/dashboard";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        routerProvider={routerProvider}
        authProvider={authProvider}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                <Outlet />
              </Authenticated>
            }
          >
            <Route index element={<DashboardPage />} />
          </Route>
          <Route element={<Authenticated fallback={<Outlet />} />}>
            {/* highlight-next-line */}
            <Route path="/login" element={<AuthPage />} />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
// visible-block-end
render(<App />);
```

After form submission, the [`login`][login] method of the [`authProvider`][auth-provider] will be called with the form values.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // --
  login: async ({ email, password, remember, providerName }) => {
    // You can handle the login process according to your needs.

    // If the process is successful.
    return {
      success: true,
    };

    return {
      success: false,
      error: {
        name: "Login Error",
        message: "Invalid email or password",
      },
    };
  },
  // --
};
```

### Register

The register page will be used to register new users. You can use the following props for the `<AuthPage>` component when the type is `"register"`:

```tsx live disableScroll hideCode url=http://localhost:3000/login previewHeight=390px
setInitialRoutes(["/register"]);

// visible-block-start
import { Refine, AuthPage, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { CatchAllNavigate } from "@refinedev/react-router";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "./authProvider";

import { DashboardPage } from "pages/dashboard";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        routerProvider={routerProvider}
        authProvider={authProvider}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                <Outlet />
              </Authenticated>
            }
          >
            <Route index element={<DashboardPage />} />
          </Route>
          <Route element={<Authenticated fallback={<Outlet />} />}>
            <Route path="/login" element={<AuthPage />} />
            {/* highlight-next-line */}
            <Route path="/register" element={<AuthPage type="register" />} />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
// visible-block-end
render(<App />);
```

After form submission, the [`register`][register] method of the [`authProvider`][auth-provider] will be called with the form values.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // --
  register: async ({ email, password, providerName }) => {
    // You can handle the register process according to your needs.

    // If the process is successful.
    return {
      success: true,
    };

    return {
      success: false,
      error: {
        name: "Register Error",
        message: "Invalid email or password",
      },
    };
  },
  // --
};
```

### ForgotPassword

The `forgotPassword` type is a page that allows users to reset their passwords. You can use this page to reset your password.

```tsx live url=http://localhost:3000/forgot-password
setInitialRoutes(["/forgot-password"]);
setRefineProps({ Sider: () => null });

// visible-block-start
import { Refine, AuthPage, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { CatchAllNavigate } from "@refinedev/react-router";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "./authProvider";

import { DashboardPage } from "pages/dashboard";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        routerProvider={routerProvider}
        authProvider={authProvider}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                <Outlet />
              </Authenticated>
            }
          >
            <Route index element={<DashboardPage />} />
          </Route>
          <Route element={<Authenticated fallback={<Outlet />} />}>
            <Route path="/login" element={<AuthPage />} />
            <Route path="/register" element={<AuthPage type="register" />} />
            {/* highlight-next-line */}
            <Route
              path="/forgot-password"
              element={<AuthPage type="forgotPassword" />}
            />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
// visible-block-end
render(<App />);
```

After form submission, the [`forgotPassword`][forgot-password] method of the [`authProvider`][auth-provider] will be called with the form values.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // --
  forgotPassword: async ({ email }) => {
    // You can handle the reset password process according to your needs.

    // If process is successful.
    return {
      success: true,
    };

    return {
      success: false,
      error: {
        name: "Forgot Password Error",
        message: "Invalid email or password",
      },
    };
  },
  // --
};
```

### UpdatePassword

The `updatePassword` type is the page used to update the password of the user.

```tsx live url=http://localhost:3000/update-password
setInitialRoutes(["/update-password"]);
setRefineProps({ Sider: () => null });

// visible-block-start
import { Refine, AuthPage, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { CatchAllNavigate } from "@refinedev/react-router";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "./authProvider";

import { DashboardPage } from "pages/dashboard";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        routerProvider={routerProvider}
        authProvider={authProvider}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                <Outlet />
              </Authenticated>
            }
          >
            <Route index element={<DashboardPage />} />
          </Route>
          <Route element={<Authenticated fallback={<Outlet />} />}>
            <Route path="/login" element={<AuthPage />} />
            <Route path="/register" element={<AuthPage type="register" />} />
            <Route
              path="/forgot-password"
              element={<AuthPage type="forgotPassword" />}
            />
            {/* highlight-next-line */}
            <Route
              path="/update-password"
              element={<AuthPage type="updatePassword" />}
            />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
// visible-block-end
render(<App />);
```

After form submission, the [`updatePassword`][update-password] method of the [`authProvider`][auth-provider] will be called with the form values.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // --
  updatePassword: async ({ password, confirmPassword }) => {
    // You can handle the update password process according to your needs.

    // If the process is successful.
    return {
      success: true,
    };

    return {
      success: false,
      error: {
        name: "Update Password Error",
        message: "Invalid email or password",
      },
    };
  },
  // --
};
```

## Props

### hideForm

When you set `hideForm` to `true`, the form will be hidden. You can use this property to show only providers.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login" // or "register"
      hideForm={true}
      providers={[
        {
          name: "google",
          icon: GoogleIcon,
          label: "Sign in with Google",
        },
        {
          name: "github",
          icon: GithubIcon,
          label: "Sign in with GitHub",
        },
      ]}
    />
  );
};
```

### providers

`providers` property defines the list of providers used to handle login authentication. `providers` accepts an array of `Provider` type. This property is only available for `login` and `register` types.

```tsx
const LoginPage = () => {
  return (
    <AuthPage
      providers={[
        {
          name: "github",
          icon: <svg>{/* ... */}</svg>,
          label: "Sign in with GitHub",
        },
        {
          name: "google",
          icon: <svg>{/* ... */}</svg>,
          label: "Sign in with Google",
        },
      ]}
    />
  );
};
```

> For more information, refer to the [Interface section down below](#interface)

### rememberMe

`rememberMe` property defines to render your own remember me component or you can pass `false` to don't render it. This property is only available for `login` type.

```tsx
const LoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      rememberMe={
        <div
          style={{
            border: "1px dashed cornflowerblue",
            padding: 3,
          }}
        >
          <input name="CustomRememberMe" type="checkbox" /> Custom remember me
        </div>
      }
      // highlight-end
    />
  );
};
```

### loginLink

`loginLink` property defines the link to the login page and also you can give a node to render. The default value is `"/login"`. This property is only available for `register` and `forgotPassword` types.

```tsx
const MyRegisterPage = () => {
  return (
    <AuthPage
      type="register"
      // highlight-start
      loginLink={
        <div
          style={{
            border: "1px dashed cornflowerblue",
            padding: 3,
          }}
        >
          <Link to="/login">Login</Link>
        </div>
      }
      // highlight-end
    />
  );
};
```

### registerLink

`registerLink` property defines the link to the registration page and also you can give a node to render. The default value is `"/register"`. This property is only available for `login` type.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      registerLink={
        <div
          style={{
            border: "1px dashed cornflowerblue",
            marginTop: 5,
            padding: 5,
          }}
        >
          <Link to="/register">Register</Link>
        </div>
      }
      // highlight-end
    />
  );
};
```

### forgotPasswordLink

`forgotPasswordLink` property defines the link to the forgot password page and also you can give a node to render. The default value is `"/forgot-password"`. This property is only available for `login` type.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      forgotPasswordLink={
        <div
          style={{
            border: "1px dashed cornflowerblue",
            marginTop: 5,
            padding: 5,
          }}
        >
          <Link to="/forgot-password">Forgot Password</Link>
        </div>
      }
      // highlight-end
    />
  );
};
```

### wrapperProps

`wrapperProps` uses for passing props to the wrapper component. In the example below you can see that the background color is changed with `wrapperProps`

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      wrapperProps={{
        style: {
          background: "linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)",
          position: "absolute",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px",
        },
      }}
      // highlight-end
    />
  );
};
```

### contentProps

`contentProps` uses for passing props to the content component which is the card component. In the example below you can see that the title, header, and content styles are changed with `contentProps`.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      contentProps={{
        style: {
          background: "linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)",
        },
      }}
      // highlight-end
    />
  );
};
```

### formProps

`formProps` uses for passing props to the form component.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      formProps={{
        onSubmit: (e: any) => {
          e.preventDefault();

          const email = e.target.email.value;
          const password = e.target.password.value;

          alert(
            JSON.stringify({
              email,
              password,
            }),
          );
        },
      }}
      // highlight-end
    />
  );
};
```

### renderContent

`renderContent` is used to render the form content. You can use this property to render your own content. `renderContent` gives you default content you can use to add some extra elements to the content.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      renderContent={(content: React.ReactNode) => {
        return (
          <div
            style={{
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              alignItems: "center",
            }}
          >
            <h1>Extra Header</h1>
            {content}
            <h2>Extra Footer</h2>
          </div>
        );
      }}
      // highlight-end
    />
  );
};
```

### mutationVariables

`mutationVariables` is used to pass additional variables to the `authProvider` methods.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login" // all other types are also supported.
      // highlight-start
      mutationVariables={{
        foo: "bar",
        xyz: "abc",
      }}
      // highlight-end
    />
  );
};

// all mutation methods are supported.
const authProvider = {
  login: async ({ foo, xyz, ...otherProps }) => {
    console.log(foo); // bar
    console.log(xyz); // abc
    // ...
  },
  register: async ({ foo, xyz, ...otherProps }) => {
    console.log(foo); // bar
    console.log(xyz); // abc
    // ...
  },
  // ...
};
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/AuthPage"/>

### Interface

```tsx
interface OAuthProvider {
  name: string;
  icon?: React.ReactNode;
  label?: string;
}
```

[auth-provider]: /docs/authentication/auth-provider
[login]: /docs/authentication/auth-provider#login-
[register]: /docs/authentication/auth-provider#register
[forgot-password]: /docs/authentication/auth-provider#forgotpassword
[update-password]: /docs/authentication/auth-provider#updatepassword

================
File: authentication/components/authenticated/index.md
================
---
title: <Authenticated />
---

`<Authenticated>` is the component form of [`useIsAuthenticated`][use-is-authenticated].

It internally uses `useIsAuthenticated`'s return values (`data.authenticated`, `data.error`, and, `isLoading`) to provide its functionality.

When:

- `data.authenticated` is `true`, it renders its children.
- `data.authenticated` is `false`, it renders [`fallback`](#fallback) prop if provided. Otherwise, it redirects to `data.redirectTo` page.
- `isLoading` is `true`, it renders the [`loading`](#loading) prop.

You may want to use this component when rendering a page that requires authentication. You will be able to render a fallback or redirect to an authentication page depending on your case. `Authenticated` can also be used to render a conditional content based on the user's authentication status.

## Basic Usage

```tsx
import { Authenticated } from "@refinedev/core";

const MyPage = () => (
  <Authenticated>
    <YourComponent />
  </Authenticated>
);
```

## Properties

### key <PropTag required />

A differentiator prop for the `<Authenticated />` component. This is crucial for the authentication logic to work properly in certain scenarios where `<Authenticated />` is used multiple times in same tree level. key prop will signal React to remount the component rather than updating the current props.

#### Why is it required?

Due to the [nature of React](https://react.dev/learn/rendering-lists#why-does-react-need-keys), components are not unmounted and remounted again if props are changed. While this is mostly a good practice for performance, in some cases you'll want your component to re-mount instead of updating; for example if you don't want to use any of the previous states and effects initiated with the old props.

The `<Authenticated />` component has this kind of scenario when its used for page level authentication checks. If the previous check results were used for the rendering of the content (`fallback` or `children`) this may lead to unexpected behaviors and flashing of the unwanted content.

To avoid this, a `key` prop must be set with different values for each use of the `<Authenticated />` components. This will make sure that React will unmount and remount the component instead of updating the props.

```tsx
import { Authenticated } from "@refinedev/core";

const MyPage = () => (
  <Authenticated key="dashboard">
    <h1>Dashboard Page</h1>
  </Authenticated>
);
```

### redirectOnFail

The path to redirect to if the user is not logged in. If left empty, the user will be redirected to the value in the `redirectTo` property of the `check` function of the `AuthProvider`.

:::info

This property only works if the `fallback` prop is not provided.

:::

### appendCurrentPathToQuery

If `true`, the current path will be appended to the `to` query parameter. This is useful when you want to redirect the user to the page they were trying to access after they log in.

### fallback

Component to render if the user is not logged in. If `undefined`, the page will be redirected to `/login`.

```tsx
<Authenticated fallback={<div>You cannot access this section</div>}>
  <YourComponent />
</Authenticated>
```

### loading

Component to render while checking whether the user is logged in.

```tsx
<Authenticated loading={<div>loading...</div>}>
  <YourComponent />
</Authenticated>
```

### params

Additional params to be passed to Auth Provider's `check` method via `useIsAuthenticated` hook.

```tsx
<Authenticated params={{ foo: "bar" }}>
  <YourComponent />
</Authenticated>
```

## API Reference

### Properties

<PropsTable
  module="@refinedev/core/Authenticated"
  v3LegacyAuthProviderCompatible-required={false}
  v3LegacyAuthProviderCompatible-type="boolean"
  v3LegacyAuthProviderCompatible-description="This must be set to `true` if legacy auth provider is being used."
/>

[use-is-authenticated]: /docs/authentication/hooks/use-is-authenticated

================
File: authentication/hooks/use-forgot-password/index.md
================
---
title: useForgotPassword
description: useForgotPassword data hook from Refine is a modified version of react-query's useMutation for registration.
source: /packages/core/src/hooks/auth/useForgotPassword/index.ts
---

`useForgotPassword` calls the `forgotPassword` method from [`authProvider`](/docs/authentication/auth-provider) under the hood.

It returns the result of `react-query`'s [useMutation](https://react-query.tanstack.com/reference/useMutation) which includes many properties, some of which being `isSuccess` and `isError`.

Data that is resolved from `forgotPassword` will be returned as the `data` in the query result with the following type:

```ts
type SuccessNotificationResponse = {
  message: string;
  description?: string;
};

type AuthActionResponse = {
  success: boolean;
  redirectTo?: string;
  error?: Error;
  [key: string]: unknown;
  successNotification?: SuccessNotificationResponse;
};
```

- `success`: A boolean indicating whether the operation was successful. If `success` is false, a notification will be shown.
  - If `error` is provided, the notification will contain the error message and name. Otherwise, a generic error message will be shown with the following values: `{ name: "Forgot Password Error", message: "Invalid credentials" }`.
- `redirectTo`: If it has a value, the app will be redirected to the given URL.
- `error`: If it has a value, a notification will be shown with the error message and name.
- `[key: string]`: Any additional data you wish to include in the response, keyed by a string identifier.
- `successNotification`: If provided, a success notification will be shown. The structure is as follows:

```ts
type SuccessNotificationResponse = {
  message: string;
  description?: string;
};
```

## Usage

Refine provides a default 'forgot password' page which handles the forgot password flow manually.

If you want to use a custom 'forgot password' page however, you can use the `useForgotPassword` hook like this:

```tsx title="pages/customForgotPasswordPage"
import { useForgotPassword } from "@refinedev/core";

type forgotPasswordVariables = {
  email: string;
};

export const ForgotPasswordPage = () => {
  const { mutate: forgotPassword } =
    useForgotPassword<forgotPasswordVariables>();

  const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const values = {
      email: e.currentTarget.email.value,
    };

    forgotPassword(values);
  };

  return (
    <form onSubmit={onSubmit}>
      <label>Email</label>
      <input name="email" value="test@refine.com" />
      <button type="submit">Submit</button>
    </form>
  );
};
```

`mutate` acquired from the `useForgotPassword` hook can accept any kind of object for values because the `forgotPassword` method from `authProvider` doesn't have a restriction on its parameters.
A type parameter for the values can be provided to `useForgotPassword`:

```tsx
import { useForgotPassword } from "@refinedev/core";

const { mutate: forgotPassword } = useForgotPassword<{ email: string }>();
```

## Redirection after forgotPassword

A custom URL can be given to mutate the function from the `useForgotPassword` hook if you want to redirect yourself to a certain URL.

```tsx
import { useForgotPassword } from "@refinedev/core";

const { mutate: forgotPassword } = useForgotPassword();

forgotPassword({ redirectPath: "/custom-url" });
```

Then, you can handle this URL in your `forgotPassword` method of the `authProvider`.

```tsx
import type { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ...
  forgotPassword: async ({ redirectPath }) => {
    // ...
    return {
      success: true,
      redirectTo: redirectPath,
      successNotification: {
        message: "Password reset successful",
        description: "Your password has been successfully reset.",
      },
    };
  },
};
```

## Error handling

Since the methods of `authProvider` always return a resolved promise, you can handle errors by using the `success` value in the response.

```tsx
import { useForgotPassword } from "@refinedev/core";

const { mutate: forgotPassword } = useForgotPassword();

forgotPassword(
  {
    email: "refine@example.com",
  },
  {
    onSuccess: (data) => {
      if (!data.success) {
        // handle error
      }

      // handle success
    },
  },
);
```

:::caution

The `onError` callback of the `useForgotPassword` hook will not be called if `success` is `false`. This is because the `authProvider` methods always return a resolved promise, and the callback is only triggered when the promise is rejected.

:::

================
File: authentication/hooks/use-get-identity/index.md
================
---
title: useGetIdentity
description: useGetIdentity data hook from Refine is a modified version of react-query's useQuery for retrieving user data
source: /packages/core/src/hooks/auth/useGetIdentity/index.ts
---

`useGetIdentity` calls the `getIdentity` method from the [`authProvider`](/docs/authentication/auth-provider) under the hood.

It returns the result of `react-query`'s `useQuery` which includes many properties, some of which being `isSuccess` and `isError`.

Data that is resolved from the `getIdentity` will be returned as the `data` in the query result.

## Usage

`useGetIdentity` can be useful when you want to get user information anywhere in your code.

Let's say that you want to show the user's name.

We have a logic in [`authProvider`](/docs/authentication/auth-provider)'s `getIdentity` method like below:

```tsx
import type { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ...
  // highlight-start
  getIdentity: async () => {
    return {
      id: 1,
      fullName: "Jane Doe",
    };
  },
  // highlight-end
};
```

You can access identity data like below:

```tsx
// highlight-next-line
import { useGetIdentity } from "@refinedev/core";

export const User = () => {
  // highlight-next-line
  const { data: identity } = useGetIdentity<IIdentity>();

  return <span>{identity?.fullName}</span>;
};

type IIdentity = {
  id: number;
  fullName: string;
};
```

================
File: authentication/hooks/use-is-authenticated/index.md
================
---
title: useIsAuthenticated
description: useIsAuthenticated data hook from Refine is a modified version of react-query's useMutation for create mutations
source: /packages/core/src/hooks/auth/useIsAuthenticated/index.ts
---

`useIsAuthenticated` calls the `check` method from the [`authProvider`](/docs/authentication/auth-provider) under the hood.

It returns the result of `react-query`'s `useQuery` which includes many properties, some of which being `isSuccess` and `isError`.

Data that is resolved from the `useIsAuthenticated` will be returned as the `data` in the query result with the following type:

```ts
type CheckResponse = {
  authenticated: boolean;
  redirectTo?: string;
  logout?: boolean;
  error?: Error;
};
```

- `authenticated`: A boolean value indicating whether the user is authenticated or not.
- `redirectTo`: A string value indicating the URL to redirect to if authentication is required.
- `logout`: A boolean value indicating whether the logout method should be called.
- `error`: An Error object representing any errors that may have occurred during the check.

## Usage

`useIsAuthenticated` can be useful when you want to check for authentication and handle the result manually.

We have used this hook in Refine's [`<Authenticated>`](/docs/authentication/components/authenticated) component, which allows only authenticated users to access the page or any part of the code.

We will demonstrate a similar basic implementation below. Imagine that you have a public page, but you want to make some specific fields private.

We have a logic in [`authProvider`](/docs/authentication/auth-provider)'s `check` method like below:

```tsx
const authProvider: AuthProvider = {
  // ...
  // highlight-start
  check: () => {
    if (localStorage.getItem("email")) {
      return {
        authenticated: true,
      };
    }
    return {
      authenticated: false,
      error: {
        message: "Check failed",
        name: "Not authenticated",
      },
      logout: true,
      redirectTo: "/login",
    };
  },
  // highlight-end
};
```

<br/>

Let's create a wrapper component that renders children if `check` method returns the Promise resolved:

```tsx title="components/authenticated.tsx"
// highlight-next-line
import { useIsAuthenticated, useGo } from "@refinedev/core";

export const Authenticated: React.FC<AuthenticatedProps> = ({
  children,
  fallback,
  loading,
}) => {
  // highlight-next-line
  const { isLoading, data } = useIsAuthenticated();

  const go = useGo();

  if (isLoading) {
    return <>{loading}</> || null;
  }

  if (data.error) {
    if (!fallback) {
      go({ to: redirectTo, type: "replace" });
      return null;
    }

    return <>{fallback}</>;
  }

  if (data.authenticated) {
    return <>{children}</>;
  }

  return null;
};

type AuthenticatedProps = {
  fallback?: React.ReactNode;
  loading?: React.ReactNode;
};
```

<br />

Now, only authenticated users can see the price field:

```tsx title="components/postShow"
// highlight-next-line
import { Authenticated } from "components/authenticated";

export const PostShow: React.FC = () => (
  <div>
    // highlight-start
    <Authenticated>
      <span>Only authenticated users can see</span>
    </Authenticated>
    // highlight-end
  </div>
);
```

================
File: authentication/hooks/use-login/index.md
================
---
title: useLogin
description: useLogin data hook from Refine is a modified version of react-query's useMutation for authentication.
source: /packages/core/src/hooks/auth/useLogin/index.ts
---

`useLogin` calls `login` method from [`authProvider`](/docs/authentication/auth-provider) under the hood.

It returns the result of `react-query`'s [useMutation](https://react-query.tanstack.com/reference/useMutation) which includes many properties, some of which being `isSuccess` and `isError`.

Data that is resolved from `login` will be returned as the `data` in the query result with the following type:

```ts
type SuccessNotificationResponse = {
  message: string;
  description?: string;
};

type AuthActionResponse = {
  success: boolean;
  redirectTo?: string;
  error?: Error;
  [key: string]: unknown;
  successNotification?: SuccessNotificationResponse;
};
```

- `success`: A boolean indicating whether the operation was successful. If `success` is false, a notification will be shown.
  - If `error` is provided, the notification will contain the error message and name. Otherwise, a generic error message will be shown with the following values: `{ name: "Login Error", message: "Invalid credentials" }`.
- `redirectTo`: If it has a value, the app will be redirected to the given URL.
- `error`: If it has a value, a notification will be shown with the error message and name.
- `[key: string]`: Any additional data you wish to include in the response, keyed by a string identifier.
- `successNotification`: If provided, a success notification will be shown. The structure is as follows:

```ts
type SuccessNotificationResponse = {
  message: string;
  description?: string;
};
```

## Usage

Refine provides a default login page which handles the login flow manually.

If you want to use a custom login page however, you can use the `useLogin` hook like this:

```tsx title="pages/custom-login.tsx"
import { useLogin } from "@refinedev/core";
import { Form } from "antd";

type LoginVariables = {
  username: string;
  password: string;
};

export const LoginPage = () => {
  const { mutate: login } = useLogin<LoginVariables>();

  const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    login({
      username: event.currentTarget.username.value,
      password: event.currentTarget.password.value,
    });
  };

  return (
    <Form
      // ...
      onFinish={onSubmit}
    >
      {/* ... */}
    </Form>
  );
};
```

`mutate` acquired from `useLogin` can accept any kind of object for values since `login` method from `authProvider` doesn't have a restriction on its parameters.

A type parameter for the values can be provided to `useLogin`.

```tsx
const { mutate: login } = useLogin<{ username: string; password: string }>();
```

## Redirection after login

A custom URL can be given to mutate the function from the `useLogin` hook if you want to redirect yourself to a certain URL.

```tsx
import { useLogin } from "@refinedev/core";

const { mutate: login } = useLogin();

login({ redirectPath: "/custom-url" });
```

Then, you can handle this URL in your `login` method of the `authProvider`.

```tsx
import type { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ...
  login: async ({ redirectPath }) => {
    // ...
    return {
      success: true,
      redirectTo: redirectPath,
      successNotification: {
        message: "Login Successful",
        description: "You have successfully logged in.",
      },
    };
  },
};
```

## Error handling

Since the methods of `authProvider` always return a resolved promise, you can handle errors by using the `success` value in the response:

```tsx
import { useLogin } from "@refinedev/core";

const { mutate: login } = useLogin();

login(
  {
    email: "refine@example.com",
    password: "refine",
  },
  {
    onSuccess: (data) => {
      if (!data.success) {
        // handle error
      }

      // handle success
    },
  },
);
```

:::caution

The `onError` callback of the `useLogin` hook will not be called if `success` is `false`. This is because the `authProvider` methods always return a resolved promise, and the callback is only triggered when the promise is rejected.

:::

================
File: authentication/hooks/use-logout/index.md
================
---
title: useLogout
description: useLogout data hook from Refine is a modified version of react-query's useMutation for unauthentication.
source: /packages/core/src/hooks/auth/useLogout/index.ts
---

`useLogout` calls the `logout` method from the [`authProvider`](/docs/authentication/auth-provider) under the hood.

It returns the result of `react-query`'s [useMutation](https://react-query.tanstack.com/reference/useMutation) which includes many properties, some of which being `isSuccess` and `isError`.

Data that is resolved from `logout` will be returned as the `data` in the query result with the following type:

```ts
type SuccessNotificationResponse = {
  message: string;
  description?: string;
};

type AuthActionResponse = {
  success: boolean;
  redirectTo?: string;
  error?: Error;
  [key: string]: unknown;
  successNotification?: SuccessNotificationResponse;
};
```

- `success`: A boolean indicating whether the operation was successful. If `success` is false, a notification will be shown.
  - If `error` is provided, the notification will contain the error message and name. Otherwise, a generic error message will be shown with the following values: `{ name: "useLogout Error", message: "Something went wrong during logout" }`.
- `redirectTo`: If it has a value, the app will be redirected to the given URL.
- `error`: If it has a value, a notification will be shown with the error message and name.
- `[key: string]`: Any additional data you wish to include in the response, keyed by a string identifier.
- `successNotification`: If provided, a success notification will be shown. The structure is as follows:

```ts
type SuccessNotificationResponse = {
  message: string;
  description?: string;
};
```

## Usage

Refine provides a default logout page which handles the logout flow manually.

If you want to use a custom logout page however, you can use the `useLogout` hook like this:

```tsx title="components/customLogoutButton"
import { useLogout } from "@refinedev/core";

export const LogoutButton = () => {
  const { mutate: logout } = useLogout();

  return <button onClick={() => logout()}>Logout</button>;
};
```

`mutate` acquired from the `useLogout` can accept any kind of object for values since the `logout` method from the `authProvider` doesn't have a restriction on its parameters.
A type parameter for the values can be provided to `useLogout`.

```tsx
const { mutate: logout } = useLogout<{ redirectPath: string }>();
```

## Redirection after logout

A custom URL can be given to mutate the function from the `useLogin` hook if you want to redirect yourself to a certain URL.

```tsx
import { useLogout } from "@refinedev/core";

const { mutate: logout } = useLogout();

logout({ redirectPath: "/custom-url" });
```

Then, you can handle this URL in your `logout` method of the `authProvider`:

```tsx
import type { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ...
  logout: async ({ redirectPath }) => {
    // ...
    return {
      success: true,
      redirectTo: redirectPath,
      successNotification: {
        message: "Logout Successful",
        description: "You have successfully logged out.",
      },
    };
  },
};
```

## Error handling

Since the methods of `authProvider` always return a resolved promise, you can handle errors by using the `success` value in the response.

```tsx
import { useLogout } from "@refinedev/core";

const { mutate: logout } = useLogout();

logout(
  {
    redirectPath: "/custom-url",
  },
  {
    onSuccess: (data) => {
      if (!data.success) {
        // handle error
      }

      // handle success
    },
  },
);
```

:::caution

The `onError` callback of the `useLogout` hook will not be called if `success` is `false`. This is because the `authProvider` methods always return a resolved promise, and the callback is only triggered when the promise is rejected.

:::

================
File: authentication/hooks/use-on-error/index.md
================
---
title: useOnError
description: useOnError data hook from Refine is a modified version of react-query's useMutation for create mutations
source: /packages/core/src/hooks/auth/useOnError/index.ts
---

`useOnError` calls the [`onError`][on-error] method from the [`authProvider`][auth-provider] under the hood.

It returns the result of `react-query`'s [useMutation](https://tanstack.com/query/v4/docs/react/reference/useMutation), which includes many properties like `isSuccess` and `isError`.

Data that is resolved from the [`onError`][on-error] will be returned as the `data` in the query result with the following type:

```ts
type OnErrorResponse = {
  redirectTo?: string;
  logout?: boolean;
  error?: Error;
};
```

According to the `onError` method's returned values, the following process will be executed:

- `redirectTo`: If it has a value, the app will be redirected to the given URL.
- `logout`: If it is `true`, `useOnError` calls the `logout` method.
- `error`: An Error object representing any errors that may have occurred during the operation.

## Internal Usage

Refine uses `useOnError` internally in the data hooks to handle errors in a unified way.

When an error is thrown by any data hook, the `useOnError` function is triggered with the error object. Afterward, the error object is passed to the [`onError`][on-error] method of the [`authProvider`][auth-provider], which can be utilized to redirect the user or to log them out.

```tsx
import type { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ...
  // highlight-start
  onError: (error) => {
    const status = error.status;
    if (status === 418) {
      return {
        logout: true,
        redirectTo: "/login",
        error: new Error(error),
      };
    }
    return {};
  },
  // highlight-end
  // ---
};
```

> For more information about data hooks, refer to the [Data Provider documentation&#8594](/docs/data/data-provider#supported-hooks)

## Usage

Let's say that a payment request was declined by the API. If the error status code is `418`, the user will be logged out for security reasons:

```tsx
import { useOnError } from "@refinedev/core";

// highlight-next-line
const { mutate: onError } = useOnError();

fetch("http://example.com/payment")
  .then(() => console.log("Success"))
  // highlight-next-line
  .catch((error) => onError(error));
```

We have a logic in [`authProvider`](/docs/authentication/auth-provider)'s `onError` method like below.

```tsx
import type { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // highlight-start
  onError: (error) => {
    const status = error.status;
    if (status === 418) {
      return {
        logout: true,
        redirectTo: "/login",
        error: new Error(error),
      };
    }
    return {};
  },
  // highlight-end
  // ---
};
```

[on-error]: /docs/authentication/auth-provider#onerror-
[auth-provider]: /docs/authentication/auth-provider

================
File: authentication/hooks/use-permissions/index.md
================
---
title: usePermissions
description: usePermissions data hook from Refine is a modified version of react-query's useQuery for retrieving user data
source: /packages/core/src/hooks/auth/usePermissions/index.ts
---

`usePermissions` calls the `getPermissions` method from the [`authProvider`](/docs/authentication/auth-provider) under the hood.

It returns the result of `react-query`'s `useQuery` which includes many properties, some of which being `isSuccess` and `isError`.

Data that is resolved from the `getPermissions` will be returned as the `data` in the query result.

## Usage

`usePermissions` can be useful when you want to get user's permission's anywhere in your code.

For example, if you want only the users with the admin role to see the create button in a list page, we have a logic in [`authProvider`](/docs/authentication/auth-provider)'s `getPermissions` method like below:

```tsx
import type { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ...
  // highlight-start
  getPermissions: async (params) => {
    if (params) {
      // do some logic like for example you can get roles for specific tenant
      return ["admin"];
    }

    return ["admin"];
  },
  // highlight-end
  // ...
};
```

Get permissions data in the list page with `usePermissions` and check if the user has `"admin"` role:

```tsx title="pages/post/list"
// highlight-next-line
import { usePermissions } from "@refinedev/core";
import { List } from "@refinedev/antd";

export const PostList: React.FC = () => {
  // highlight-next-line
  const { data: permissionsData } = usePermissions({
    params: { tenantId: "id" }, // you can pass parameters to getPermissions
  });

  return <List canCreate={permissionsData?.includes("admin")}>...</List>;
};
```

To learn more about the `List` component and CRUD views, refer to the [UI Libraries](/docs/guides-concepts/ui-libraries/#views) guide.

================
File: authentication/hooks/use-register/index.md
================
---
title: useRegister
description: useRegister data hook from Refine is a modified version of react-query's useMutation for registration.
source: /packages/core/src/hooks/auth/useRegister/index.ts
---

`useRegister` calls `register` method from [`authProvider`](/docs/authentication/auth-provider) under the hood.

It returns the result of `react-query`'s [useMutation](https://react-query.tanstack.com/reference/useMutation) which includes many properties, some of which being isSuccess and isError.

Data that is resolved from `register` will be returned as the `data` in the query result with the following type:

```ts
type SuccessNotificationResponse = {
  message: string;
  description?: string;
};

type AuthActionResponse = {
  success: boolean;
  redirectTo?: string;
  error?: Error;
  [key: string]: unknown;
  successNotification?: SuccessNotificationResponse;
};
```

- `success`: A boolean indicating whether the operation was successful. If `success` is false, a notification will be shown.
  - When an `error` is provided, the notification will contain the error message and name. Otherwise, a generic error message will be shown with the following values: `{ name: "Register Error", message: "Error while registering" }`.
- `redirectTo`: If has a value, the app will be redirected to the given URL.
- `error`: If has a value, a notification will be shown with the error message and name.
- `[key: string]`: Any additional data you wish to include in the response, keyed by a string identifier.
- `successNotification`: If provided, a success notification will be shown. The structure is as follows:

```ts
type SuccessNotificationResponse = {
  message: string;
  description?: string;
};
```

## Usage

Refine provides a default registration page, page which handles the registration flow manually.
If you want to use a custom registration page however, you can use the `useRegister` hook like this:

```tsx title="pages/customRegisterPage"
import { useRegister } from "@refinedev/core";

type RegisterVariables = {
  email: string;
  password: string;
};

export const RegisterPage = () => {
  const { mutate: register } = useRegister<RegisterVariables>();

  const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const values = {
      email: e.currentTarget.email.value,
      password: e.currentTarget.password.value,
    };

    register(values);
  };

  return (
    <form onSubmit={onSubmit}>
      <label>Email</label>
      <input name="email" value="test@refine.com" />
      <label>Password</label>
      <input name="password" value="refine" />
      <button type="submit">Submit</button>
    </form>
  );
};
```

`mutate` acquired from the `useRegister` hook can accept any kind of object for values since the `register` method from `authProvider` doesn't have a restriction on its parameters.
A type parameter for the values can be provided to `useRegister`.

```tsx
const { mutate: register } = useRegister<{ email: string; password: string }>();
```

## Logged In after successful registration

If you want to log in to the user after successful registration, you can use `useLogin` hook after the `useRegister` hook's `onSuccess` callback:

```tsx title="pages/customRegisterPage"
import { useRegister, useLogin } from "@refinedev/core";

type FormVariables = {
  email: string;
  password: string;
};

export const RegisterPage = () => {
  const { mutate: register } = useRegister<FormVariables>();
  const { mutate: login } = useLogin<FormVariables>();

  const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const values = {
      email: e.currentTarget.email.value,
      password: e.currentTarget.password.value,
    };

    register(values, {
      //highlight-start
      onSuccess: () => {
        login(values);
      },
      //highlight-end
    });
  };

  return (
    <form onSubmit={onSubmit}>
      <label>Email</label>
      <input name="email" value="test@refine.com" />
      <label>Password</label>
      <input name="password" value="refine" />
      <button type="submit">Submit</button>
    </form>
  );
};
```

## Redirection after register

A custom URL can be given to mutate the function from the `useRegister` hook if you want to redirect yourself to a certain URL:

```tsx
import { useRegister } from "@refinedev/core";

const { mutate: register } = useRegister();

register({ redirectPath: "/custom-url" });
```

Then, you can handle this URL in your `register` method of the `authProvider`:

```tsx
const authProvider: AuthProvider = {
  // ...
  register: ({ redirectPath }) => {
    // ...
    return {
      success: true,
      redirectTo: redirectPath,
      successNotification: {
        message: "Registration Successful",
        description: "You have successfully registered.",
      },
    };
  },
};
```

## Error handling

Since the methods of `authProvider` always return a resolved promise, you can handle errors by using the `success` value in the response:

```tsx
import { useRegister } from "@refinedev/core";

const { mutate: register } = useRegister();

register(
  {
    email: "refine@example.com",
    password: "refine",
  },
  {
    onSuccess: (data) => {
      if (!data.success) {
        // handle error
      }

      // handle success
    },
  },
);
```

:::caution

The `onError` callback of the `useRegister` hook will not be called if `success` is `false`. This is because the `authProvider` methods always return a resolved promise, and the callback is only triggered when the promise is rejected.

:::

================
File: authentication/hooks/use-update-password/index.md
================
---
title: useUpdatePassword
description: useUpdatePassword data hook from Refine is a modified version of react-query's useMutation for registration.
source: /packages/core/src/hooks/auth/useUpdatePassword/index.ts
---

`useUpdatePassword` calls `updatePassword` method from [`authProvider`](/docs/authentication/auth-provider) under the hood.

It returns the result of `react-query`'s [useMutation](https://react-query.tanstack.com/reference/useMutation).

Data that is resolved from `updatePassword` will be returned as the `data` in the query result with the following type:

```ts
type SuccessNotificationResponse = {
  message: string;
  description?: string;
};

type AuthActionResponse = {
  success: boolean;
  redirectTo?: string;
  error?: Error;
  [key: string]: unknown;
  successNotification?: SuccessNotificationResponse;
};
```

- `success`: A boolean indicating whether the operation was successful. If `success` is false, a notification will be shown.
  - When `error` is provided, the notification will contain the error message and name. Otherwise, a generic error message will be shown with the following values: `{ name: "Update Password Error", message: "Error while resetting password" }`.
- `redirectTo`: If has a value, the app will be redirected to the given URL.
- `error`: If has a value, a notification will be shown with the error message and name.
- `[key: string]`: Any additional data you wish to include in the response, keyed by a string identifier.
- `successNotification`: If provided, a success notification will be shown. The structure is as follows:

```ts
type SuccessNotificationResponse = {
  message: string;
  description?: string;
};
```

## Usage

Refine provides a default 'update password' page, page which handles the update password flow manually.
If you want to use a custom 'update password' however, you can use the `useUpdatePassword` hook like this:

```tsx title="pages/customupdatePasswordPage"
import { useUpdatePassword } from "@refinedev/core";

type updatePasswordVariables = {
  password: string;
};

export const UpdatePasswordPage = () => {
  const { mutate: updatePassword } =
    useUpdatePassword<updatePasswordVariables>();

  const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const values = {
      password: e.currentTarget.password.value,
    };

    updatePassword(values);
  };

  return (
    <form onSubmit={onSubmit}>
      <label>Password</label>
      <input name="password" value="refine" />
      <button type="submit">Submit</button>
    </form>
  );
};
```

`mutate` acquired from `useUpdatePassword` can accept any kind of object for values since the `updatePassword` method from `authProvider` doesn't have a restriction on its parameters.
A type parameter for the values can be provided to `useUpdatePassword`.

```tsx
const { mutate: updatePassword } = useUpdatePassword<{ newPassword: string }>();
```

`useUpdatePassword` gives you query strings for the `updatePassword` method from `authProvider`. If you have logic that sends a password regeneration email to the email address while resetting the password and proceeds through the access token, you can use the `queryStrings` variable's `updatePassword` method from `authProvider`. For example, if your regeneration link is `YOUR_DOMAIN/update-password?token=123`, you can access the token from the parameters of the URL.

```tsx
import type { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ...
  updatePassword: (params) => {
    // you can access query strings from params.queryStrings
    console.log(params.token);
    if (params.token === "123") {
      // your logic to update the password
    }
    // ...
  },
};
```

## Redirection after updatePassword

A custom URL can be given to mutate the function from the `useUpdatePassword` hook if you want to redirect yourself to a certain URL:

```tsx
import { useUpdatePassword } from "@refinedev/core";

const { mutate: updatePassword } = useUpdatePassword();

updatePassword({ redirectPath: "/custom-url" });
```

Then, you can handle this URL in your `updatePassword` method of the `authProvider`:

```tsx
import type { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // ...
  updatePassword: async ({ redirectPath }) => {
    // ...
    return {
      success: true,
      redirectTo: redirectPath,
      successNotification: {
        message: "Update password successful",
        description: "You have successfully updated password.",
      },
    };
  },
};
```

## Error handling

Since the methods of `authProvider` always return a resolved promise, you can handle errors by using the `success` value in the response:

```tsx
import { useUpdatePassword } from "@refinedev/core";

const { mutate: updatePassword } = useUpdatePassword();

updatePassword(
  {
    newPassword: "refine",
  },
  {
    onSuccess: (data) => {
      if (!data.success) {
        // handle error
      }

      // handle success
    },
  },
);
```

:::caution

The `onError` callback of the `useUpdatePassword` hook will not be called if `success` is `false`. This is because the `authProvider` methods always return a resolved promise, and the callback is only triggered when the promise is rejected.

:::

================
File: authorization/access-control-provider/index.md
================
---
title: Access Control Provider
---

Access control is a broad topic with lots of advanced solutions that provide different sets of features.

Refine provides an agnostic API via the `accessControlProvider` to manage access control throughout your app, which allows you to integrate different methods, such as `RBAC`, `ABAC`, `ACL`, etc., and libraries, such as [Casbin](https://casbin.org/), [CASL](https://casl.js.org/v5/en/), [Cerbos](https://cerbos.dev/) and [AccessControl.js](https://onury.io/accesscontrol/).

To check if a desired access will be granted, the `accessControlProvider` should at least have an asynchronous method named `can` with the following interface:

:::simple Interface References

- [`CanParams`](/docs/core/interface-references#canparams): Arguments for the `can` method.
- [`CanResponse`](/docs/core/interface-references#canresponse): Return type of the `can` method.

:::

```ts
export interface IAccessControlContext {
  can?: ({ resource, action, params }: CanParams) => Promise<CanResponse>;
  options?: {
    buttons?: {
      enableAccessControl?: boolean;
      hideIfUnauthorized?: boolean;
    };
    queryOptions?: UseQueryOptions<CanReturnType>;
  };
}

const accessControlProvider: IAccessControlContext = {
  can: async ({
    resource,
    action,
    params,
  }: CanParams): Promise<CanResponse> => {
    return { can: true };
  },
  options: {
    buttons: {
      enableAccessControl: true,
      hideIfUnauthorized: false,
    },
    queryOptions: {
      // ... default global query options
    },
  },
};
```

It's possible to globally configure buttons' behavior by passing `options` to the `accessControlProvider`.
You can still change the behavior of the buttons independently; however, if no configuration is found, buttons will fallback to configuration defined in `options.buttons`.
By default, `enableAccessControl` is **true**, `hideIfUnauthorized` is **false**, and `queryOptions` is **undefined**.

## Usage

```tsx
const App: React.FC = () => {
  return (
    <Refine
      // other providers and props
      accessControlProvider={{
        can: async ({ resource, action, params }) => {
          if (resource === "posts" && action === "edit") {
            return {
              can: false,
              reason: "Unauthorized",
            };
          }

          return { can: true };
        },
        options: {
          buttons: {
            enableAccessControl: true,
            hideIfUnauthorized: false,
          },
          queryOptions: {
            // ... default global query options
          },
        },
      }}
    >
      {/* your app */}
    </Refine>
  );
};
```

:::caution

Providing `accessControlProvider` to the `<Refine />` component **won't enforce** access control by itself; you will need to wrap protected routes with the `<CanAccess />` component.

Refer to one of the following documentations, based on your preferred router:

- [React Router Access Control](/docs/packages/list-of-packages#usage-with-access-control-providers)
- [NextJS Router Access Control](/docs/packages/list-of-packages#access-control)
- [Remix Router Access Control](/docs/packages/list-of-packages#access-control)

:::

### Meta Access

In the `can` method, you'll have access to the `resource` object you passed to the `<Refine/>` component.

In the example below, the `can` function receives the `resource`([ResourceProps][iresourceitem]) object you pass to the `<Refine/>` component, which allows you to use Attribute Based Access Control (ABAC), which allows you to grant permissions based on the value of a field in the resource object.

```tsx
export const accessControlProvider = {
  can: async ({ resource, action, params }) => {
    const resourceName = params?.resource?.name;
    const anyUsefulMeta = params?.resource?.meta?.yourUsefulMeta;

    if (
      resourceName === "posts" &&
      anyUsefulMeta === true &&
      action === "edit"
    ) {
      return {
        can: false,
        reason: "Unauthorized",
      };
    }
  },
};
```

### Using `reason` property

If your response from the `can` method has a `reason` property, it will be shown at the tooltip of the buttons if they are disabled.

## Hooks and Components

Refine provides a hook and a component to use the `can` method from the `accessControlProvider`.

### useCan

`useCan` uses the `can` for the query function for **react-query**'s `useQuery`. It takes the parameters that `can` takes, can be configured with `queryOptions` of `useQuery` and returns the result of `useQuery`.

```tsx
const { data } = useCan({
  resource: "resource-you-ask-for-access",
  action: "action-type-on-resource",
  params: { foo: "optional-params" },
  queryOptions: {
    cacheTime: 5000,
    // ... other query options
  },
});
```

```ts
const useCan: ({
    action,
    resource,
    params,
    queryOptions,
}: CanParams) => UseQueryResult<CanReturnType*>
```

### `<CanAccess />`

`<CanAccess />` is a wrapper component that uses `useCan` to check for access control. It takes the parameters that `can` method takes and also a `fallback`. If access control returns true, it renders its children; otherwise, it renders `fallback`, if it was provided.

```tsx
<CanAccess
  resource="posts"
  action="edit"
  params={{ id: 1 }}
  fallback={<CustomFallback />}
  queryOptions={{ cacheTime: 25000 }}
>
  <YourComponent />
</CanAccess>
```

## Performance

As the number of points that check for access control in your app increases, the performance of your app may take a hit, especially if its access control involves remote endpoints. Caching the access control checks helps quite a lot, which can be done easily by configuring the [`staleTime` and `cacheTime`](https://react-query.tanstack.com/reference/useQuery) properties since Refine uses react-query.

```ts
// inside your component

const { data } = useCan({
  resource: "resource-you-ask-for-access",
  action: "action-type-on-resource",
  params: { foo: "optional-params" },
  queryOptions: {
    staleTime: 5 * 60 * 1000, // 5 minutes
    // ... other query options
  },
});
```

:::note

By default, Refine uses 5 minutes for `cacheTime` and 0 minutes for `staleTime` for its own access control points.

:::

## List of Default Access Control Points

Here is a list of components and pages Refine checks for access control:

### Sider

Sider is integrated, which means that unaccessible resources won't appear in the sider menu.

Menu items will check access control with `{ resource, action: "list" }`. For example, if your app has a resource called `posts`, it will be checked with `{ resource: "posts", action: "list" }`.

### Buttons

These buttons will be checked for access control.

Let's say they are rendered where `resource` is `posts` and `id` is `1` where applicable. The `can` function will receive the `resource`([ResourceProps][iresourceitem]) object you passed to the `<Refine/>` component, which allows you to use Attribute Based Access Control (ABAC), which allows you to grant permissions based on the value of a field in the resource object.

These buttons will be disabled if access control returns `{ can: false }`

<!-- prettier-ignore-start -->
```tsx title=my-page.tsx

import { EditButton, ShowButton, ListButton, CreateButton, CloneButton, DeleteButton } from "@refinedev/antd"; // or @refinedev/mui, @refinedev/chakra-ui, @refinedev/mantine

export const MyPage = () => {
  return (
    <>
      My Page
      {/* These buttons will be disabled if access control returns { can: false } */}
      <ListButton resource="posts" /> {/* { resource: "posts", action: "list", params: { *resource } } */}
      <CreateButton resource="posts" /> {/* { resource: "posts", action: "create", params: { *resource } } */}
      <CloneButton resource="posts" recordItemId={1} /> {/* { resource: "posts", action: "create", params: { id: 1, *resource } } */}
      <EditButton resource="posts" recordItemId={1} /> {/* { resource: "posts", action: "edit", params: { id: 1, *resource } } */}
      <DeleteButton resource="posts" recordItemId={1} /> {/* { resource: "posts, action: "delete", params: { id: 1, *resource } } */}
      <ShowButton resource="posts" recordItemId={1} /> {/* { resource: "posts", action: "show", params: { id: 1, *resource } } */}
    </>
  );
};

```
<!-- prettier-ignore-end -->

:::simple
If you want to hide buttons instead of disabling them, you can pass `hideIfUnauthorized: true` to the `options` of the `accessControlProvider`
:::

## Examples

This example is for **Casbin** access control provider. You can check our other access control provider, [**Cerbos**](/docs/examples/access-control/cerbos/) as well.
<CodeSandboxExample path="access-control-casbin" />

[iresourceitem]: /docs/core/interface-references#resourceprops
[basekey]: /docs/core/interface-references#basekey
[canparams]: /docs/core/interface-references#canparams
[canresponse]: /docs/core/interface-references#canresponse

================
File: authorization/components/can-access/index.md
================
---
title: <CanAccess />
siderbar_label: <CanAccess />
source: packages/core/src/components/canAccess/index.tsx
---

`<CanAccess>` is the component form of [`useCan`][use-can].

It internally uses [`useCan`][use-can]'s return values to provide its functionality.

Passes the given properties to the `can` method from your access control provider. After, if it returns `true`, it renders the children, otherwise, if it returns `false`, it renders [`fallback`](#fallback) prop if provided. Otherwise, it renders `null`.

To learn more about authorization, check out the [Authorization](/docs/guides-concepts/authorization) guide and [Access Control Provider](/docs/authorization/access-control-provider) documentation.

## Basic Usage

By default, the `CanAccess` component will infer the current `resource` and the `action` based on your route automatically. `id` will also be inferred if the current route includes one.

So if you are at the `/posts` route, `CanAccess` will check authorization for the `posts` resource and the `list` action.

For `/posts/show/:id` route, the action will be `show`.

```tsx
import { CanAccess } from "@refinedev/core";

const MyComponent = () => (
  <CanAccess fallback={<CustomFallback />}>
    <YourComponent />
  </CanAccess>
);
```

### Usage with props

You may have a case like in the `/posts/show/:id` page, where, inferred resource is `posts` and action is `show`, but you want to authorize a different resource eg. `category`.

In this case, you can explicitly pass props to the `CanAccess` component for authorizing a different resource.

```tsx
import { CanAccess } from "@refinedev/core";

export const MyComponent = () => {
  return (
    <Buttons>
      <CreateButton>Create</CreateButton>
      <CanAccess resource="posts" action="delete">
        <DeleteButton>Delete</DeleteButton>
      </CanAccess>
    </Buttons>
  );
};
```

## Properties

It also accepts all the properties of [`useCan`](/docs/authorization/hooks/use-can#properties).

### onUnauthorized

Callback to be called when [`useCan`][use-can] returns false.

```tsx
<CanAccess
  onUnauthorized={({ resource, reason, action, params }) =>
    console.log(
      `You cannot access ${resource}-${params.id} resource with ${action} action because ${reason}`,
    )
  }
>
  <YourComponent />
</CanAccess>
```

### fallback

Component to render if [`useCan`][use-can] returns false. If `undefined`, it renders `null`.

```tsx
<CanAccess fallback={<div>You cannot access this section</div>}>
  <YourComponent />
</CanAccess>
```

### queryOptions

Accepts `UseQueryOptions<CanReturnType>` to customize the caching behavior of the underlying query.

```tsx
<CanAccess queryOptions={{ cacheTime: 25000 }}>
  <YourComponent />
</CanAccess>
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/CanAccess"/>

[use-can]: /docs/authorization/hooks/use-can
[access-control-provider]: /docs/authorization/access-control-provider

================
File: authorization/hooks/use-can/index.md
================
---
title: useCan
siderbar_label: useCan
---

`useCan` uses the [Access Control Provider's][access-control-provider] `can` function as the query function for [TanStack Query's][tanstack-query] [`useQuery`][use-query]. It takes the [parameters][can-params] that `can` takes. It can also be configured with [`queryOptions`][query-options] for `useQuery`. Returns the result of `useQuery`.

## Usage

```tsx
import { useCan } from "@refinedev/core";

const { data } = useCan({
  resource: "resource-you-ask-for-access",
  action: "action-type-on-resource",
  params: { foo: "optional-params" },
});
```

## Performance

As the number of points that check for access control in your app increases, the performance of your app may take a hit, especially if its access control involves remote endpoints. Caching the access control checks helps quite a bit, and since Refine uses [TanStack Query][tanstack-query], it can be easily done by confiruging the [`staleTime` and `cacheTime`][query-options] properties.

```ts
import { useCan } from "@refinedev/core";

// inside your component

const { data } = useCan({
    resource: "resource-you-ask-for-access",
    action: "action-type-on-resource",
    params: { foo: "optional-params" } },
    queryOptions: {
        staleTime: 5 * 60 * 1000, // 5 minutes
    }
});
```

## Properties

### resource <PropTag required />

Passes to [Access Control Provider's][access-control-provider] `can` function's `resource` parameter

```ts
useCan({
  resource: "resource-you-ask-for-access",
});
```

### action <PropTag required />

Passes to [Access Control Provider's][access-control-provider] `can` function's `action` parameter

```ts
useCan({
  action: "resource-you-ask-for-access",
});
```

### params

Passes to [Access Control Provider's][access-control-provider] `can` function's `params` parameter

```ts
useCan({
  params: { foo: "optional-params" },
});
```

### queryOptions

Query options for [TanStack Query's][tanstack-query] [`useQuery`][use-query].

```ts
useCan({
  queryOptions: {
    staleTime: 5 * 60 * 1000, // 5 minutes
  },
});
```

## Return values

`useCan` will return the Query result of [TanStack Query's][tanstack-query] [`useQuery`][use-query].

For example, if you want to check if the user can create a post based on the return value:

```tsx
const App = (
  <Refine
    // ...
    accessControlProvider={{
      can: async ({ resource, action }) => {
        if (resource === "post" && action === "create") {
          return {
            can: false,
            reason: "Unauthorized",
          };
        }

        return { can: true };
      },
    }}
  />
);

const MyComponent = () => {
  const { data: canCreatePost } = useCan({
    action: "create",
    resource: "post",
  });

  console.log(canCreatePost); // { can: false, reason: "Unauthorized" }
};
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/useCan"  />

### Type Parameters

| Property                                                   | Description                                                                       |
| ---------------------------------------------------------- | --------------------------------------------------------------------------------- |
| [CanResponse](/docs/core/interface-references#canresponse) | Result data of the query [`HttpError`](/docs/core/interface-references#httperror) |

### Return values

| Description                                                              | Type                                                             |
| ------------------------------------------------------------------------ | ---------------------------------------------------------------- |
| Result of the [TanStack Query's][tanstack-query] [`useQuery`][use-query] | [`QueryObserverResult<{ data: CanReturnType; }>`][query-options] |

[access-control-provider]: /docs/authorization/access-control-provider
[use-query]: https://tanstack.com/query/latest/docs/react/guides/queries
[tanstack-query]: https://tanstack.com/query/latest
[query-options]: https://tanstack.com/query/v4/docs/react/reference/useQuery
[can-params]: /docs/core/interface-references#canparams

================
File: core/components/auto-save-indicator/index.md
================
---
title: <AutoSaveIndicator />
description: <AutoSaveIndicator> component shows `autoSave` status on edit actions.
source: packages/core/src/components/autoSaveIndicator/index.tsx
---

Refine's forms provide a built-in auto-save feature. This allows you to automatically save the form when the user makes changes to the form which can be useful for forms that are long or complex and the user may not want to lose their progress.

The `<AutoSaveIndicator />` component is a utility component that can be used to show a visual indicator to the user about the auto-save status of the form.

:::simple Good to know

- Refine's core [`useForm`](/docs/data/hooks/use-form) hook does not automatically trigger the auto-save feature. You need to manually trigger the `onFinishAutoSave` function returned from the `useForm` hook to trigger the auto-save feature.

- Extended implementations of Refine's `useForm` such as; [`@refinedev/antd`'s `useForm`](/docs/ui-integrations/ant-design/hooks/use-form), [`@refinedev/react-hook-form`'s `useForm`](/docs/packages/react-hook-form/use-form) and [`@refinedev/mantine`'s `useForm`](/docs/ui-integrations/mantine/hooks/use-form) automatically trigger the auto-save feature when a form value changes.

- The `<AutoSaveIndicator />` component is only designed to display a visual feedback to the user about the auto-save status of the form. It does not contain any logic to trigger the auto-save feature.

- To learn more about the auto-save feature check out [Auto Save section in Forms guide](/docs/guides-concepts/forms/#auto-save)

:::

## Usage

Usage is as simple as spreading the `autoSaveProps` object returned from the [`useForm`](/docs/data/hooks/use-form) hook into the `<AutoSaveIndicator />` component. It will automatically determine the auto-save status and display the appropriate indicator.

```tsx
import { AutoSaveIndicator, useForm } from "@refinedev/core";

const EditPage = () => {
  const { autoSaveProps } = useForm({
    autoSave: {
      enabled: true,
    },
  });

  console.log(autoSaveProps);
  /*
    {
      status: "success",  // "loading" | "error" | "idle" | "success"
      error: null,        // HttpError | null
      data: { ... },      // UpdateResponse | undefined,
    }
  */

  return (
    <div>
      {/* highlight-start */}
      {/* We'll pass the autoSaveProps from useForm's response to the <AutoSaveIndicator /> component. */}
      <AutoSaveIndicator {...autoSaveProps} />
      {/* highlight-end */}
      <form
      // ...
      >
        {/* ... */}
      </form>
    </div>
  );
};
```

Example below shows the `<AutoSaveIndicator />` component in action.

import Usage from "./usage.tsx";

<Usage />

### Customizing the indicator

The `<AutoSaveIndicator />` component accepts an `elements` prop which can be used to customize the indicator for each status.

```tsx
import { AutoSaveIndicator, useForm } from "@refinedev/core";

const EditPage = () => {
  const { autoSaveProps } = useForm({
    autoSave: {
      enabled: true,
    },
  });

  return (
    <div>
      <AutoSaveIndicator
        {...autoSaveProps}
        // highlight-start
        elements={{
          loading: <span>saving...</span>,
          error: <span>auto save error.</span>,
          idle: <span>waiting for changes.</span>,
          success: <span>saved.</span>,
        }}
        // highlight-end
      />
      {/* ... */}
    </div>
  );
};
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/AutoSaveIndicator" elements-type={'Partial<Record<"loading" \\| "error" \\| "idle" \\| "success", ReactNode>>'} />

================
File: core/components/auto-save-indicator/usage.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BasicUsage() {
  return (
    <Sandpack
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/products/edit/123"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "/edit.tsx": {
          code: EditTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { BrowserRouter, Route, Routes, Navigate, Link, Outlet } from "react-router";
import routerProvider from "@refinedev/react-router";
import "./style.css";
import { Edit } from "./edit.tsx";
export default function App() {
    return (
        <BrowserRouter>
            <Refine
                routerProvider={routerProvider}
                dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
                resources={[
                    {
                        name: "products",
                        edit: "/products/edit/:id",
                    }
                ]}
            >
                <Routes>
                    <Route index element={<Navigate to="/products/edit/123" />} />
                    <Route path="/products" element={<Outlet />}>
                        <Route path="edit/:id" element={<Edit />} />
                    </Route>
                </Routes>
            </Refine>
        </BrowserRouter>
    );
}
`.trim();
const StyleCssCode = `
html {
    margin: 0;
    padding: 0;
}
body {
    margin: 0;
    padding: 12px;
}
* {
    box-sizing: border-box;
}
body {
    font-family: sans-serif;
}
form button {
    display: block;
    // width: 100%;
    margin-bottom: 6px;
}
.page {
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.page form {
  display: flex;
  flex-direction: column;
  gap: 12px;
  width: 100%;
  max-width: 400px;
}
.page form label {
  display: flex;
  align-items: center;
}
.page form label input, .page form label textarea, .page form label select {
  flex: 1;
}
.page form label span {
  width: 90px;
}
.auto-save-wrapper {
  padding: 6px 0;
  font-weight: 600;
}
`.trim();
const EditTsxCode = /* jsx */ `import React from "react";
import { useForm, useSelect, AutoSaveIndicator, HttpError, BaseKey } from "@refinedev/core";
export const Edit: React.FC = () => {
  const { query, isLoading, onFinish, autoSaveProps, onFinishAutoSave } = useForm<
    IProduct,
    HttpError,
    FormValues
  >({
    autoSave: {
      enabled: true,
      interval: 1000,
    },
  });
  const { options: categorySelectOptions } = useSelect({
    resource: "categories",
  });
  const defaultValues = query?.data?.data;
  return (
    <div className="page">
      <div className="auto-save-wrapper">
        <AutoSaveIndicator {...autoSaveProps} />
      </div>
      <form
        onChange={(event) => {
          const formData = new FormData(event.currentTarget);
          onFinishAutoSave(transformValues(Object.fromEntries(formData.entries()) as RawFormValues));
        }}
        onSubmit={(event) => {
          event.preventDefault();
          const formData = new FormData(event.currentTarget);
          onFinish(transformValues(Object.fromEntries(formData.entries()) as RawFormValues));
        }}
      >
        <label htmlFor="name">
          <span>Name</span>
          <input name="name" placeholder="Name" defaultValue={defaultValues?.name} />
        </label>
        <label htmlFor="description">
          <span>Description</span>
          <textarea name="description" placeholder="Description" defaultValue={defaultValues?.description} />
        </label>
        <label htmlFor="material">
          <span>Material</span>
          <input name="material" placeholder="Material" defaultValue={defaultValues?.material} />
        </label>
        <label htmlFor="category">
          <span>Category</span>
          <select name="category" defaultValue={defaultValues?.category?.id}>
            {categorySelectOptions.map((option) => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
        </label>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
};
const transformValues = (values: RawFormValues): FormValues => {
  return {
    ...values,
    category: values.category ? { id: values.category } : undefined,
  };
};
interface IProduct {
  id: BaseKey;
  name: string;
  material: string;
  description: string;
  category: { id: BaseKey; name: string };
}
interface FormValues {
  name?: string;
  material?: string;
  description?: string;
  category?: { id: BaseKey };
}
interface RawFormValues extends FormValues {
  category?: BaseKey;
}
`.trim();

================
File: core/components/inferencer/index.md
================
---
title: Inferencer
---

You can automatically generate views for your resources using `@refinedev/inferencer`. Inferencer exports `HeadlessListInferencer`, `HeadlessShowInferencer`, `HeadlessEditInferencer`, `HeadlessCreateInferencer`, and finally `HeadlessInferencer` components, the last of which combines all in one place.

:::simple Good to know

- Headless elements of `@refinedev/inferencer` uses [`@refinedev/react-hook-form`](/docs/packages/list-of-packages) and [`@refinedev/react-table`](/docs/packages/list-of-packages) to create views. These dependencies should be installed in your project in order to use inferencer components.
- To learn more about the `@refinedev/inferencer` package, please check out [Inferencer](/docs/packages/inferencer) docs.

:::

## Usage

Inferencer components can be imported from `@refinedev/inferencer/headless`. You can directly use the components in your routes without passing any props. If you use a `routerProvider`, it will infer the `resource`, `action` and `id` from the current route.

<Tabs
defaultValue="resources"
values={[
{label: 'Without Props', value: 'resources'},
{label: 'With Explicit Props', value: 'custom'}
]}>
<TabItem value="resources">

```tsx
import routerProvider from "@refinedev/react-router";
import { BrowserRouter } from "react-router";
// highlight-next-line
import { HeadlessInferencer } from "@refinedev/inferencer/headless";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        resources={[
          {
            name: "samples",
            list: "/posts",
          },
        ]}
      >
        <Routes>
          {/* highlight-next-line */}
          <Route path="/posts" element={<HeadlessInferencer />} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
```

  </TabItem>
  <TabItem value="custom">

```tsx
// highlight-next-line
import { HeadlessInferencer } from "@refinedev/inferencer/headless";

const SampleList = () => {
  return (
    // highlight-next-line
    <HeadlessInferencer resource="samples" action="list" />
  );
};

const SampleShow = () => {
  return (
    // highlight-next-line
    <HeadlessInferencer resource="samples" action="show" id="1" />
  );
};

const SampleCreate = () => {
  return (
    // highlight-next-line
    <HeadlessInferencer resource="samples" action="create" />
  );
};

const SampleEdit = () => {
  return (
    // highlight-next-line
    <HeadlessInferencer resource="samples" action="edit" id="1" />
  );
};
```

  </TabItem>
</Tabs>

## Views

### List

Generates a sample list view for your resources according to the API response. It uses the `useTable` hook from `@refinedev/react-table`.

```tsx live hideCode previewHeight=600px url=http://localhost:3000/samples
setInitialRoutes(["/samples"]);

// visible-block-start
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { BrowserRouter, Routes, Route } from "react-router";

// highlight-next-line
import { HeadlessInferencer } from "@refinedev/inferencer/headless";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider(API_URL)}
        resources={[
          {
            // highlight-next-line
            name: "samples",
            list: "/samples",
            show: "/samples/show/:id",
            create: "/samples/create",
            edit: "/samples/edit/:id",
          },
        ]}
      >
        <Routes>
          {/** highlight-next-line */}
          <Route path="/samples" element={<HeadlessInferencer />} />
          <Route path="/samples/create" element={<HeadlessInferencer />} />
          <Route path="/samples/show/:id" element={<HeadlessInferencer />} />
          <Route path="/samples/edit/:id" element={<HeadlessInferencer />} />
          <Route path="*" element={<div>Not Found</div>} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

### Show

Generates a sample show view for your resources according to the API response. It uses the `useShow` hook from `@refinedev/core`.

```tsx live hideCode previewHeight=600px url=http://localhost:3000/samples/show/123
setInitialRoutes(["/samples/show/123"]);

// visible-block-start
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { BrowserRouter, Routes, Route } from "react-router";

// highlight-next-line
import { HeadlessInferencer } from "@refinedev/inferencer/headless";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider(API_URL)}
        resources={[
          {
            name: "samples",
            list: "/samples",
            // highlight-next-line
            show: "/samples/show/:id",
            create: "/samples/create",
            edit: "/samples/edit/:id",
          },
        ]}
      >
        <Routes>
          <Route path="/samples" element={<HeadlessInferencer />} />
          <Route path="/samples/create" element={<HeadlessInferencer />} />
          {/** highlight-next-line */}
          <Route path="/samples/show/:id" element={<HeadlessInferencer />} />
          <Route path="/samples/edit/:id" element={<HeadlessInferencer />} />
          <Route path="*" element={<div>Not Found</div>} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

### Create

Generates a sample create view for your resources according to the first record in list API response. It uses the `useForm` hook from `@refinedev/react-hook-form`.

```tsx live hideCode previewHeight=600px url=http://localhost:3000/samples/create
setInitialRoutes(["/samples/create"]);

// visible-block-start
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { BrowserRouter, Routes, Route } from "react-router";

// highlight-next-line
import { HeadlessInferencer } from "@refinedev/inferencer/headless";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider(API_URL)}
        resources={[
          {
            name: "samples",
            list: "/samples",
            // highlight-next-line
            create: "/samples/create",
            show: "/samples/show/:id",
            edit: "/samples/edit/:id",
          },
        ]}
      >
        <Routes>
          <Route path="/samples" element={<HeadlessInferencer />} />
          {/** highlight-next-line */}
          <Route path="/samples/create" element={<HeadlessInferencer />} />
          <Route path="/samples/show/:id" element={<HeadlessInferencer />} />
          <Route path="/samples/edit/:id" element={<HeadlessInferencer />} />
          <Route path="*" element={<div>Not Found</div>} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

### Edit

Generates a sample edit view for your resources according to the API response. It uses the `useForm` hook from `@refinedev/react-hook-form`.

```tsx live hideCode previewHeight=600px url=http://localhost:3000/samples/edit/123
setInitialRoutes(["/samples/edit/123"]);

// visible-block-start
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { BrowserRouter, Routes, Route } from "react-router";

// highlight-next-line
import { HeadlessInferencer } from "@refinedev/inferencer/headless";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider(API_URL)}
        resources={[
          {
            name: "samples",
            list: "/samples",
            show: "/samples/show/:id",
            create: "/samples/create",
            // highlight-next-line
            edit: "/samples/edit/:id",
          },
        ]}
      >
        <Routes>
          <Route path="/samples" element={<HeadlessInferencer />} />
          <Route path="/samples/create" element={<HeadlessInferencer />} />
          <Route path="/samples/show/:id" element={<HeadlessInferencer />} />
          {/** highlight-next-line */}
          <Route path="/samples/edit/:id" element={<HeadlessInferencer />} />
          <Route path="*" element={<div>Not Found</div>} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

## Example

Below you'll find a Live CodeSandbox Example displaying a fully setup Refine app with `@refinedev/inferencer/headless` components.

<CodeSandboxExample path="inferencer-headless" />

================
File: core/hooks/utilities/buttons/index.md
================
---
title: Buttons
source: packages/core/src/hooks/button
---

Refine offers a set of buttons in UI integrations that you can use to perform actions like navigation, deletion and refresh. These buttons include many useful features such as confirmation dialogs, access control, i18n and inferring parameters from the current route.

All these buttons are powered by respective hooks that you can use to create your own custom buttons or customizing the existing ones without having to write the logic from scratch.

## Hooks

### useListButton

`useListButton` provides set of values to be used for navigating to a list view of a resource.

```ts
const {
  to, // The path to navigate to.
  label, // The label to be displayed on the button.
  title, // If the button is disabled, the title will contain the reason for the button being disabled.
  hidden, // Whether the button should be hidden or not.
  disabled, // Whether the button should be disabled or not.
  LinkComponent, // The component to be used as a link. This is provided by the router provider from `<Refine />`.
} = useListButton({
  resource: "posts", // Resource name/identifier, if not provided, it will be inferred from the current route.
  accessControl, // To enable/disable the access control checks and hide/disable the button based on the permissions.
  meta, // Meta object to be passed to the navigation. This can be used to pass additional parameters to the route if needed.
});
```

### useCreateButton

`useCreateButton` provides set of values to be used for navigating to a create view of a resource.

```ts
const {
  to, // The path to navigate to.
  label, // The label to be displayed on the button.
  title, // If the button is disabled, the title will contain the reason for the button being disabled.
  hidden, // Whether the button should be hidden or not.
  disabled, // Whether the button should be disabled or not.
  LinkComponent, // The component to be used as a link. This is provided by the router provider from `<Refine />`.
} = useCreateButton({
  resource: "posts", // Resource name/identifier, if not provided, it will be inferred from the current route.
  accessControl, // To enable/disable the access control checks and hide/disable the button based on the permissions.
  meta, // Meta object to be passed to the navigation. This can be used to pass additional parameters to the route if needed.
});
```

### useShowButton

`useShowButton` provides set of values to be used for navigating to a show view of a resource for a given record.

```ts
const {
  to, // The path to navigate to.
  label, // The label to be displayed on the button.
  title, // If the button is disabled, the title will contain the reason for the button being disabled.
  hidden, // Whether the button should be hidden or not.
  disabled, // Whether the button should be disabled or not.
  LinkComponent, // The component to be used as a link. This is provided by the router provider from `<Refine />`.
} = useShowButton({
  resource: "posts", // Resource name/identifier, if not provided, it will be inferred from the current route.
  id, // Record identifier to navigate to the show view. If not provided, it will be inferred from the current route.
  accessControl, // To enable/disable the access control checks and hide/disable the button based on the permissions.
  meta, // Meta object to be passed to the navigation. This can be used to pass additional parameters to the route if needed.
});
```

### useEditButton

`useEditButton` provides set of values to be used for navigating to an edit view of a resource for a given record.

```ts
const {
  to, // The path to navigate to.
  label, // The label to be displayed on the button.
  title, // If the button is disabled, the title will contain the reason for the button being disabled.
  hidden, // Whether the button should be hidden or not.
  disabled, // Whether the button should be disabled or not.
  LinkComponent, // The component to be used as a link. This is provided by the router provider from `<Refine />`.
} = useEditButton({
  resource: "posts", // Resource name/identifier, if not provided, it will be inferred from the current route.
  id, // Record identifier to navigate to the edit view. If not provided, it will be inferred from the current route.
  accessControl, // To enable/disable the access control checks and hide/disable the button based on the permissions.
  meta, // Meta object to be passed to the navigation. This can be used to pass additional parameters to the route if needed.
});
```

### useCloneButton

`useCloneButton` provides set of values to be used for navigating to a clone view of a resource for a given record.

```ts
const {
  to, // The path to navigate to.
  label, // The label to be displayed on the button.
  title, // If the button is disabled, the title will contain the reason for the button being disabled.
  hidden, // Whether the button should be hidden or not.
  disabled, // Whether the button should be disabled or not.
  LinkComponent, // The component to be used as a link. This is provided by the router provider from `<Refine />`.
} = useCloneButton({
  resource: "posts", // Resource name/identifier, if not provided, it will be inferred from the current route.
  id, // Record identifier to navigate to the clone view. If not provided, it will be inferred from the current route.
  accessControl, // To enable/disable the access control checks and hide/disable the button based on the permissions.
  meta, // Meta object to be passed to the navigation. This can be used to pass additional parameters to the route if needed.
});
```

### useDeleteButton

`useDeleteButton` provides set of values to be used for deleting a record. This hook will also provide labels for the confirmation dialog.

```ts
const {
  onConfirm, // The function to be called when the user confirms the deletion. This will call the mutation of `useDelete` under the hood.
  label, // The label to be displayed on the button.
  title, // If the button is disabled, the title will contain the reason for the button being disabled.
  disabled, // Whether the button should be disabled or not.
  hidden, // Whether the button should be hidden or not.
  loading, // Whether the button should be in loading state or not.
  confirmTitle, // The title of the confirmation dialog.
  confirmOkLabel, // The label of the confirmation dialog's confirm button.
  cancelLabel, // The label of the confirmation dialog's cancel button.
} = useDeleteButton({
  resource, // Resource name/identifier, if not provided, it will be inferred from the current route.
  id, // Record identifier to delete. If not provided, it will be inferred from the current route.
  onSuccess, // The function to be called when the deletion is successful.
  mutationMode, // The mode of the mutation. If not passed, globally defined mutation mode will be used.
  successNotification, // The notification to be shown when the deletion is successful.
  errorNotification, // The notification to be shown when the deletion fails.
  accessControl, // To enable/disable the access control checks and hide/disable the button based on the permissions.
  meta, // Meta object to be passed to the deletion.
  dataProviderName, // The name of the data provider to be used for the deletion. If not provided, the default data provider will be used.
  invalidates, // The list of scopes of a resource to be invalidated after the deletion.
});
```

### useRefreshButton

`useRefreshButton` provides set of values to be used for refreshing the record of a resource.

```ts
const {
  onClick, // The function to be called when the user clicks the button. This will trigger an invalidation of the query cache.
  label, // The label to be displayed on the button.
  loading, // Whether the button should be in loading state or not.
} = useRefreshButton({
  resource, // Resource name/identifier, if not provided, it will be inferred from the current route.
  id, // Record identifier to refresh. If not provided, it will be inferred from the current route.
  dataProviderName, // The name of the data provider to be used for the refresh. If not provided, the default data provider will be used.
});
```

### useSaveButton

`useSaveButton` provides a label for a save button that can be used in forms. Props related to submission of the form will be provided by the [`useForm`](/docs/data/hooks/use-form) hook.

```ts
const {
  label, // The label to be displayed on the button.
} = useSaveButton();
```

### useExportButton

`useExportButton` provides a label for an export button for a resource. Props related to exporting bulk data from the resource will be provided by the [`useExport`](/docs/core/hooks/utilities/use-export) hook.

```ts
const {
  label, // The label to be displayed on the button.
} = useExportButton();
```

### useImportButton

`useImportButton` provides a label for an import button for a resource. Props related to importing bulk data to the resource will be provided by the [`useImport`](/docs/core/hooks/utilities/use-import) hook.

```ts
const {
  label, // The label to be displayed on the button.
} = useImportButton();
```

================
File: core/hooks/utilities/use-breadcrumb/index.md
================
---
title: useBreadcrumb
source: packages/core/src/hooks/breadcrumb
---

:::simple Congratulations 🥇

The feature won first place with the joint votes of our team members in a May 2022 internal hackathon!

Congratulations [@salihozdemir](https://github.com/salihozdemir)! It was great seeing your project take first place! We're all very proud of you. Keep up the good work and don't forget to have fun while working here 🎉

:::

It is a hook that returns `breadcrumbs` to create breadcrumbs for the current page. The `breadcrumbs` is an array of objects with the following properties:

- `label`: the label of the resource.
- `href`: the route of the resource's list action.
- `icon`: the icon of the resource.

## Usage

```tsx
import React from "react";
import { useBreadcrumb } from "@refinedev/core";

export const Breadcrumb: React.FC = () => {
  const { breadcrumbs } = useBreadcrumb();

  return (
    <ul>
      {breadcrumbs.map(({ label, href, icon }) => (
        <li key={label}>
          {icon}
          {href ? <a href={href}>{label}</a> : label}
        </li>
      ))}
    </ul>
  );
};
```

## Examples

### Resource

The `breadcrumbs` are created with your resource definitions. For example, if you have a resource with the following definition:

```tsx
[
  {
    name: "posts",
    icon: <PostsIcon />,
    list: "/posts",
    create: "/posts/create",
  },
];
```

- On the `list` page of the `posts` resource, the breadcrumbs look like this:

  ```tsx
  [
    {
      label: "Posts",
      href: "/posts",
      icon: <PostsIcon />,
    },
  ];
  ```

- On the `create` page of the `posts` resource, the breadcrumbs look like this:

  ```tsx
  [
    {
      label: "Posts",
      href: "/posts",
      icon: <PostsIcon />,
    },
    { label: "Create" },
  ];
  ```

If the resource has no `icon` property, the `icon` property of the breadcrumbs is `undefined`. Likewise, if the resource's list page is not found, the `href` property of the breadcrumbs is `undefined`.

### Nested resource

If you have a nested resource definition as below:

```tsx
[
  {
    name: "cms",
  },
  {
    name: "users",
    list: "/users",
    create: "/users/create",
    meta: { parent: "cms" },
  },
];
```

- On the `list` page of the `users` resource, the breadcrumbs look like this:

  ```tsx
  [
    { label: "Cms" },
    {
      label: "Users",
      href: "/users",
    },
  ];
  ```

- On the `create` page of the `users` resource, the breadcrumbs look like this:

  ```tsx
  [
    { label: "Cms" },
    {
      label: "Users",
      href: "/users",
    },
    { label: "Create" },
  ];
  ```

### Adding a Home/Root Page

In earlier versions of Refine, `<Refine>` component accepted `DashboardPage` which could be used to add an index page to your app. With the changes in `routerProvider` API of Refine, `DashboardPage` is deprecated. You can now define an index route manually in your router package.

In earlier versions, the home icon in the `Breadcrumb` was created by the `DashboardPage`, but now it is rendered if you define an action route as `/` in any one of your resources. It will be rendered with the home icon regardless of the current route. You can also hide the home icon by setting `showHome` to `false`.

```tsx
[
  {
    name: "dashboard", // name of the resource is not important for the `useBreadcrumb` hook
    list: "/", // If any one of your resources has a list action with `/` route, the home icon will be rendered
  },
];
```

## i18n support

If the `resource` definition has a `label` property, `useBreadcrumbs` uses the `label` property. Otherwise, the `name` property of the `resource` is used. Likewise, if the `resource` definition has `route` property, `useBreadcrumbs` uses the `route` property. Otherwise, the `name` property of the `resource` is used.

If a `label` is not provided in your `posts` resource, `useBreadcrumb` uses the [`useTranslate`](/docs/i18n/hooks/use-translate) hook to translate the names.

For CRUD operations (`list`,`create`,`edit`,`show`) the `useBreadcrumb` uses the `actions` key to translate the key `` translate(`actions.${action}`) ``.

For example, `create` action should look like: `` translate(`actions.create`) ``

## API Reference

### Return values

| Property    | Description           | Type              |
| ----------- | --------------------- | ----------------- |
| breadcrumbs | The breadcrumbs array | `BreadcrumbsType` |

#### BreadcrumbsType

```tsx
type BreadcrumbsType = {
  label: string;
  href?: string;
  icon?: React.ReactNode;
};
```

================
File: core/hooks/utilities/use-export/index.md
================
---
title: useExport
---

`useExport` hook allows you to export data as a `CSV` file. It calls the `getList` method of your data provider and downloads the data as a `CSV` file.

Internally, it uses [Papa Parse][papaparse] to create the `CSV` file.

## Usage

Here is a basic usage example of the `useExport` hook:

```tsx
import { useExport } from "@refinedev/core";

interface IPost {
  id: number;
  slug: string;
  title: string;
  content: string;
}

export const PostList: React.FC = () => {
  const { triggerExport } = useExport<IPost>();

  return <button onClick={triggerExport}>Export Button</button>;
};
```

## Properties

### resource

Determines which resource is passed to the `getList` method of your data provider. By default, it reads the resource name from the current route.

```ts
useExport({
  resource: "posts",
});
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### mapData

If you want to map the data before exporting it, you can use the `mapData` property.

```ts
interface IPost {
  id: number;
  slug: string;
  title: string;
  content: string;
  category: {
    id: number;
  };
}

useExport<IPost>({
  mapData: (item) => {
    return {
      id: item.id,
      slug: item.slug,
      title: item.title,
      content: item.content,
      categoryId: item.category.id,
    };
  },
});
```

### sorters

If you want to sort the data before exporting it, you can use the `sorters` property. It will be passed to the `getList` method of your data provider.

> For more information, refer to the [`CrudSorting` interface&#8594](/docs/core/interface-references#crudsorting)

```ts
useExport({
  sorters: [
    {
      field: "title",
      order: "asc",
    },
  ],
});
```

### filters

If you want to filter the data before exporting it, you can use the `filters` property. It will be passed to the `getList` method of your data provider.

> For more information, refer to the [`CrudFilters` interface &#8594](/docs/core/interface-references#crudfilters)

```ts
useExport({
  filters: [
    {
      field: "title",
      operator: "contains",
      value: "foo",
    },
  ],
});
```

### maxItemCount

By default, the `useExport` hook will export all the data. If you want to limit the number of items to be exported, you can use the `maxItemCount` property.

```ts
useExport({
  maxItemCount: 100,
});
```

### pageSize

Requests to fetch data are made in batches of 20 by default. The `pageSize` property determines the number of items to be fetched in each request.

```ts
useExport({
  pageSize: 50,
});
```

### download

Whether to generate download of the CSV in browser environments, defaults to `true`.

```ts
useExport({
  download: false,
});
```

### unparseConfig

You can pass additional options to the [Papa Parse][papaparse] package by using the `unparseConfig` property.

> For more information, refer to the [`Papa Parse` options &#8594](https://www.papaparse.com/docs#config)

```ts
useExport({
  unparseConfig: {
    complete: (results, file) => {
      console.log("Parsing complete:", results, file);
    },
  },
});
```

### meta

If you want to send additional data to the `create` or `createMany` method of your data provider, you can use the `meta` property.

```ts
useExport({
  meta: {
    foo: "bar",
  },
});
```

### dataProviderName

If there is more than one `dataProvider`, you can specify which one to use by passing the `dataProviderName` prop. It is useful when you have a different data provider for different resources.

```tsx
useExport({
  dataProviderName: "second-data-provider",
});
```

### onError

Callback function that is called when an error occurs while fetching data.

```ts
useExport({
  onError: (error) => {
    console.log(error);
  },
});
```

### ~~exportOptions~~ <PropTag deprecated />

Use [`unparseConfig`](#unparseconfig) prop instead.

You can pass additional options to the `export-to-csv` package by using the `exportOptions` property.

> For more information, refer to the [`ExportToCsv` options &#8594](https://github.com/alexcaza/export-to-csv#api)

```ts
useExport({
  exportOptions: {
    filename: "posts",
  },
});
```

### ~~resourceName~~ <PropTag deprecated />

Use `resource` instead.

### ~~sorter~~ <PropTag deprecated />

Use `sorters` instead.

## Return Values

### triggerExport

A function that triggers the export process.

```tsx
const { triggerExport } = useExport();

return <button onClick={triggerExport}>Export Button</button>;
```

### isLoading

A boolean value that indicates whether the export process is in progress.

```tsx
const { isLoading } = useExport();

return isLoading ? <div>Loading...</div> : <div>Loaded</div>;
```

## FAQ

### Handling Relational Data

A mapping function can be run on all entries before saving them, which is useful in cases where you need to reference relational data or save files in a specific format for processing in other applications.

Consider this endpoint containing some relational data:

```json
[
 {
    "id": 2,
    "title": "Et architecto et aut ex.",
    "slug": "dolorum-et-quia",
    "content": "Reprehenderit qui voluptatem in cum qui odio et.",
    "category": {
      "id": 35
    },
    "user": {
      "id": 10
    },
  },
  {
    "id": 3,
    "title": "Quam maiores officia suscipit quia vel asperiores nisi non excepturi.",
    "slug": "delectus-laborum-provident",
    "content": "Placeat eos esse.",
    "category": {
      "id": 4
    },
    "user": {
      "id": 50
    },
  },
  ...
]
```

We have the `category` and `user` fields as possible relational data keys. Their data is not responsibility of this export operation.

If we want to save their `id`'s without any other related data, we can use a mapping function to save `category.id` as `categoryId` and `user.id` as `userId`.

```ts
useExport<IPost>({
  mapData: (item) => {
    return {
      id: item.id,
      title: item.title,
      slug: item.slug,
      content: item.content,
      categoryId: item.category.id,
      userId: item.user.id,
    };
  },
});

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  slug: string;
  category: { id: number };
  user: { id: number };
}
```

This will save the data as follows:

```json
[
  {
    "id": 2,
    "title": "Et architecto et aut ex.",
    "slug": "dolorum-et-quia",
    "content": "Reprehenderit qui voluptatem in cum qui odio et.",
    "categoryId": 35,
    "userId": 10
  },
  {
    "id": 3,
    "title": "Quam maiores officia suscipit quia vel asperiores nisi non excepturi.",
    "slug": "delectus-laborum-provident",
    "content": "Placeat eos esse.",
    "categoryId": 4,
    "userId": 50
  },
  ...
]
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/useExport" />

### Return Values

| Key           | Description                                | Type               |
| ------------- | ------------------------------------------ | ------------------ |
| isLoading     | Shows true when there is an export process | `boolean`          |
| triggerExport | When invoked, starts the exporting process | `async () => void` |

### Type Parameters

| Property   | Description                                                                | Default                    |
| ---------- | -------------------------------------------------------------------------- | -------------------------- |
| TData      | Result type of the data query type that extends [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TVariables | Values for params                                                          | `any`                      |

[papaparse]: https://www.papaparse.com/
[baserecord]: /docs/core/interface-references#baserecord

================
File: core/hooks/utilities/use-import/index.md
================
---
title: useImport
description: useImport hook API references of @refinedev/core
---

`useImport` hook allows you to import data from a `CSV` file. For each row in the file, it calls the `create` or `createMany` method of your data provider according to your configuration.

Internally, it uses [Papa Parse][papaparse] to parse the file contents.

## Usage

Here is a basic usage example of the `useImport` hook:

```tsx
import { useImport } from "@refinedev/core";

interface IPostFile {
  title: string;
  categoryId: string;
}

export const PostList: React.FC = () => {
  const { inputProps } = useImport<IPostFile>();

  return <input {...inputProps} />;
};
```

## Properties

### resource

Determines which resource is passed to the `create` or `createMany` method of your data provider. By default, it reads the resource name from the current route.

```ts
useImport({
  resource: "posts",
});
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### mapData

If you want to map the data before sending it to a data provider method, you can use the `mapData` property.

```ts
useImport({
  mapData: (data) => ({
    ...data,
    category: {
      id: data.categoryId,
    },
  }),
});
```

### paparseOptions

You can pass any Papa Parse [options](https://www.papaparse.com/docs#config) to the `paparseOptions` property.

```ts
useImport({
  paparseOptions: {
    header: true,
  },
});
```

### batchSize

If you want to send the data in batches, you can use the `batchSize` property. When the `batchSize` is 1, it calls the `create` method of your data provider for each row in the file. When the `batchSize` is greater than 1, it calls the `createMany` method of your data provider for each batch. By default, it is set to [`Number.MAX_SAFE_INTEGER`][number.max_safe_integer]

```ts
useImport({
  batchSize: 1,
});
```

### onFinish

If you want to do something after the import is finished, you can use the `onFinish` property. It returns an object with two properties: `succeeded` and `errored`, which contain the responses of the successful and failed requests.

```ts
useImport({
  onFinish: (result) => {
    // success requests response
    result.succeeded.forEach((item) => {
      console.log(item);
    });

    // failed requests response
    result.errored.forEach((item) => {
      console.log(item);
    });
  },
});
```

### meta

If you want to send additional data to the `create` or `createMany` method of your data provider, you can use the `meta` property.

```ts
useImport({
  meta: {
    foo: "bar",
  },
});
```

### onProgress

A callback function that is called when the import progress changes. It returns an object with two properties: `totalAmount` and `processedAmount` which contain the total amount of rows and the processed amount of rows.

```ts
useImport({
  onProgress: ({ totalAmount, processedAmount }) => {
    // progress percentage
    console.log((processedAmount / totalAmount) * 100);
  },
});
```

### dataProviderName

If there is more than one `dataProvider`, you can specify which one to use by passing the `dataProviderName` prop. It is useful when you have a different data provider for different resources.

```tsx
useImport({
  dataProviderName: "second-data-provider",
});
```

### ~~resourceName~~ <PropTag deprecated />

Use `resource` instead.

## Return Values

### inputProps

`inputProps` is an object that contains the props of the `input` element. You can spread it to the `input` element.

```tsx
const { inputProps } = useImport();

return <input {...inputProps} />;
```

#### type

It is set to `file` by default.

#### accept

It is set to `.csv` by default.

#### onChange

It handles the file change event. If the file exists, it will call the `handleChange` method with the file as an argument.

### handleChange

`handleChange` is a function that handles the file change event. It accepts an object with a `file` property which is the file that is selected by the user.

```tsx
const { handleChange } = useImport();

return (
  <input
    type="file"
    onChange={(event) => {
      if (event.target.files) {
        handleChange({
          file: event.target.files[0],
        });
      }
    }}
  />
);
```

### isLoading

`isLoading` is a boolean that indicates whether the import is in progress or not.

### mutationResult

Returns the result of either the [`useCreate`](/docs/data/hooks/use-create) or the [`useCreateMany`](/docs/data/hooks/use-create) hook.

## FAQ

### Handling Relational Data

Sometimes you need to process your parsed `CSV` data for certain cases, such as when your data includes relational data and references to other data or when your backend API requires a specific data format. To handle this, you can use the `mapData` option in `useImport` to customize the process.

For example, the `CSV` file is as follows:

```csv title="dummy.csv"
"title","content","status","categoryId","userId"
"dummy title 1","dummy content 1","rejected","3","8"
"dummy title 2","dummy content 2","draft","44","8"
"dummy title 3","cummy content 3","published","41","10"
```

Since the `user` and `category` are relational fields, we store only their `id` fields in the exported file as `userId` and `categoryId` respectively. To create resources from this file, we need to map the data back to the required format of the backend API. To do this, we use the mapData option in `useImport`. Here's an example:

When creating these resources back, we should map it back to our backend API's required format. `mapData` option allows us to do this. Here is an example:

```ts
useImport<IPostFile>({
  mapData: (item) => {
    return {
      title: item.title,
      content: item.content,
      status: item.status,
      category: {
        id: item.categoryId,
      },
      user: {
        id: item.userId,
      },
    };
  },
});

interface IPostFile {
  title: string;
  status: string;
  content: string;
  categoryId: string;
  userId: string;
}
```

With this code, the parsed data will be mapped to conform to the API requirements.

## API Reference

### Properties

<PropsTable module="@refinedev/core/useImport" />

### Return Values

| Property       | Description                                                            | Type                                                                                                                                                                                                                                   |
| -------------- | ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| inputProps     | Props to that you can pass `<input />` element props.                  | [`UseImportInputPropsType`][useimportinputpropstype]                                                                                                                                                                                   |
| handleChange   | Props to handle `<input type="file">` element `onChange`               | `function`                                                                                                                                                                                                                             |
| isLoading      | It can be used to handle the `loading` status for the Import operation | `boolean`                                                                                                                                                                                                                              |
| mutationResult | Result of the mutation/mutations of creating imported resources        | [`UseMutationResult<{ data: TData }, TError, { resource: string; values: TVariables; }, unknown>`][usemutation]) \| [`UseMutationResult<{ data: TData[]},TError, { resource: string; values: TVariables[]; }, unknown>`][usemutation]) |

### Type Parameters

| Property   | Description                                                                | Default                    |
| ---------- | -------------------------------------------------------------------------- | -------------------------- |
| TItem      | Interface of parsed csv data                                               | `any`                      |
| TData      | Result type of the data query type that extends [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError     | Custom error object that extends [`HttpError`][httperror]                  | [`HttpError`][httperror]   |
| TVariables | Values for mutation function                                               | `any`                      |

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[papaparse]: https://www.papaparse.com/
[usemutation]: https://tanstack.com/query/latest/docs/react/reference/useMutation
[number.max_safe_integer]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER
[useimportinputpropstype]: /docs/core/interface-references#useimportinputpropstype

## Example

<CodeSandboxExample path="core-use-import" />

================
File: core/hooks/utilities/use-menu/index.md
================
---
title: useMenu
source: packages/core/src/hooks/menu/useMenu.tsx
---

```css live shared
body {
  padding: 4px;
  background: white;
}
```

`useMenu` is used to get menu items derived from the resources. These items include a link to the dashboard page (if it exists) and links to the user-defined resources (passed as children to `<Refine>`).

This hook can also be used to build custom menus, including multi-level support. `<Sider/>` components inside the [`@refinedev/antd`](/docs/ui-integrations/ant-design/introduction), [`@refinedev/mui`](/docs/ui-integrations/material-ui/introduction), [`@refinedev/chakra-ui`](/docs/ui-integrations/chakra-ui/introduction) and, [`@refinedev/mantine`](/docs/ui-integrations/mantine/introduction) packages for example use this hook as a base for their menus.

```ts
const { selectedKey, menuItems, defaultOpenKeys } = useMenu();
```

- `menuItems` is a list of style agnostic menu items. Each of them has a key.
- `selectedKey` is the key of the resource user is viewing at the moment. Its inferred from the route.
- `defaultOpenKeys` is the array with the keys of default opened menus.

:::simple Deprecation Notice

`useMenu` hooks exported from `@refinedev/antd` and `@refinedev/mui` packages are now **deprecated** and will be removed. Please use `useMenu` from `@refinedev/core`.

:::

## Usage

If you are using [`@refinedev/antd`](/docs/ui-integrations/ant-design/introduction), [`@refinedev/mui`](/docs/ui-integrations/material-ui/introduction), [`@refinedev/chakra-ui`](/docs/ui-integrations/chakra-ui/introduction) or [`@refinedev/mantine`](/docs/ui-integrations/mantine/introduction) as a UI framework integration, you can find out more info about their structure and how to use `useMenu` in the [Custom Layout][customlayout]

### Creating a Menu

We will show you how to use `useMenu` to create a simple menu for your Refine application.

```tsx live hideCode url=http://localhost:3000
setInitialRoutes(["/"]);

// visible-block-start
import React from "react";
import { useMenu, LayoutProps, ITreeMenu } from "@refinedev/core";

import { Link } from "react-router";

const Layout: React.FC<LayoutProps> = ({ children }) => {
  // highlight-start
  const { menuItems, selectedKey } = useMenu();
  // highlight-end

  // highlight-start
  const renderMenuItems = (items: ITreeMenu[]) => {
    return (
      <>
        {items.map(({ key, name, label, icon, route }) => {
          const isSelected = key === selectedKey;
          return (
            <li key={name}>
              <Link
                to={route}
                style={{
                  fontWeight: isSelected ? "bold" : "normal",
                }}
              >
                {icon}
                <span>{label ?? name}</span>
              </Link>
            </li>
          );
        })}
      </>
    );
  };
  // highlight-end

  return (
    <div>
      <div>
        <Link to="/">
          <img src="https://refine.dev/img/refine_logo.png" alt="Logo" />
        </Link>
        {/* highlight-start */}
        <ul>{renderMenuItems(menuItems)}</ul>
        {/* highlight-end */}
      </div>
      <div>{children}</div>
    </div>
  );
};

import { Refine } from "@refinedev/core";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { Layout } from "components";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider(API_URL)}
        routerProvider={routerProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
          },
          {
            name: "categories",
            list: "/categories",
          },
        ]}
      >
        <Routes>
          <Route
            element={
              <Layout>
                <Outlet />
              </Layout>
            }
          >
            <Route index element={<NavigateToResource />} />
            <Route path="/posts" element={<div>dummy posts page</div>} />
            <Route
              path="/categories"
              element={<div>dummy categories page</div>}
            />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
// visible-block-end

render(App);
```

We created `<Layout>` with a header with a logo and a list of links to all menu items (resources). The links are clickable and will navigate to the corresponding resource. To do this, we used the `useMenu` hook to get the menu items from the `<Refine/>` and the `useRouterContext` hook to get the `<Link/>` component from the router provider. The [`useNavigation`][use-navigation] hook can be used for navigating between routes as well.

`children` is the content of the layout. In our case, it is the content of the **Page** components.

After creating the `<Layout/>` component, we can use it in our application. We need to pass it to the `<Refine/>` component as a prop.

> For more information on layout customization, refer to the [Custom Layout guide &#8594](/docs/advanced-tutorials/custom-layout/)

### Multi Level Menus

`useMenu` hook comes out of the box with multi level menu support, you can render menu items recursively to get a multi level menu.

Update your `resources` in `<Refine/>` with `meta.parent` to nest them inside a label:

```tsx title="src/App.tsx"
import { Refine } from "@refinedev/core";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { Layout } from "components/layout";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider(API_URL)}
        // highlight-start
        resources={[
          {
            name: "CMS",
          },
          {
            name: "posts",
            list: "/CMS/posts",
            meta: { parent: "CMS" },
          },
          {
            name: "categories",
            list: "/CMS/categories",
            meta: { parent: "CMS" },
          },
        ]}
        // highlight-end
      >
        <Routes>
          <Route
            element={
              <Layout>
                <Outlet />
              </Layout>
            }
          >
            <Route index element={<NavigateToResource />} />
            <Route path="/posts" element={<div>dummy posts page</div>} />
            <Route
              path="/categories"
              element={<div>dummy categories page</div>}
            />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};

export default App;
```

Now you can update your `<Layout/>` to support multi level rendering with following code:

```tsx title="src/components/Layout.tsx"
import React from "react";
import { useMenu, LayoutProps, ITreeMenu } from "@refinedev/core";

import { Link } from "react-router";

export const Layout: React.FC<LayoutProps> = ({ children }) => {
  const { menuItems, selectedKey } = useMenu();

  // highlight-start
  const renderMenuItems = (items: ITreeMenu[]) => {
    return (
      <>
        {items.map(({ key, name, label, icon, route, children, list }) => {
          if (!list) {
            return (
              <li key={label}>
                <span>{label ?? name}</span>
                {children ? renderMenuItems(children) : null}
              </li>
            );
          }

          const isSelected = key === selectedKey;

          return (
            <li key={label}>
              <Link
                to={route}
                style={{
                  fontWeight: isSelected ? "bold" : "normal",
                }}
              >
                {icon}
                <span>{label ?? name}</span>
              </Link>
            </li>
          );
        })}
      </>
    );
  };
  // highlight-end

  return (
    <div>
      <div>
        <Link to="/">
          <img src="https://refine.dev/img/refine_logo.png" alt="Logo" />
        </Link>
        <ul>{renderMenuItems(menuItems)}</ul>
      </div>
      <div>{children}</div>
    </div>
  );
};
```

## Properties

### hideOnMissingParameter

It only affects menu items that require additional parameters to generate their URL. If the parameters are missing in the current URL neither in the `meta` property of the `useMenu` or in the `meta` property of the resource definition, the menu items that require a parameter will be hidden. By default, this property is set to `true`.

For example, suppose you have a resource with a list path defined as `/authors/:authorId/books`. If there is no `authorId` parameter in the current URL or in the `meta` object, the menu item for this resource will be hidden.

However, if you set `hideOnMissingParameter` to `false` when calling `useMenu`, the menu item for this resource will still be shown, even if the `authorId` parameter is missing.

### meta

An object of parameters to use when additional parameters are present in the resource paths. For example, if you have a resource with list path defined as `/:authorId/posts` and want to show this resource in your menu:

```ts
const { menuItems } = useMenu({ meta: { authorId: 123 } });
```

If there is already an `authorId` parameter in the current URL or in the `meta` property of the resource definition, `useMenu` will use this parameter by default. You can override this behavior by passing the `meta` property to the `useMenu` hook.

## Return Values

### selectedKey

If the current URL matches a resource path, the key of the resource will be returned. Otherwise, `undefined` will be returned.

### menuItems

List of the menu tems returned based on the `resources` prop of the `<Refine/>` component.

### defaultOpenKeys

Array with the keys of default opened menus.

## API Reference

### Properties

| Property               | Description                                                                                 | Type                      | Default |
| ---------------------- | ------------------------------------------------------------------------------------------- | ------------------------- | ------- |
| hideOnMissingParameter | Whether to hide menu items that require additional parameters to generate their URL or not. | `boolean`                 | `true`  |
| meta                   | It is used when creating menu item URL with additional parameters.                          | `Record<string, unknown>` | `{}`    |

### Return values

| Property        | Description                                                        | Type                            |
| --------------- | ------------------------------------------------------------------ | ------------------------------- |
| selectedKey     | Key of the resource the user is viewing at the moment.             | `string` \| `undefined`         |
| menuItems       | List of the menu items returned based on the resource definitions. | [`TreeMenuItem[]`](#interfaces) |
| defaultOpenKeys | Array with the keys of default opened menus.                       | `string[]`                      |

#### Interfaces

```ts
// highlight-start
export type TreeMenuItem = IResourceItem & {
  key: string;
  route?: string;
  icon?: React.ReactNode;
  label?: string;
  children: TreeMenuItem[];
};
// highlight-end
```

## Example

<CodeSandboxExample path="core-use-menu" />

[use-navigation]: /docs/routing/hooks/use-navigation
[customlayout]: /docs/advanced-tutorials/custom-layout/

================
File: core/hooks/utilities/use-modal/index.md
================
---
title: useModal
source: packages/core/src/hooks/modal/useModal/index.tsx
---

`useModal` hook allows you to manage a modal. Since it is designed as headless, it returns the `show` and `close` functions and the `visible` state. It expects you to handle the UI.

```ts
const { show, close, visible } = useModal();
```

You can use the `visible` state to show or hide the modal. The `show` and `close` functions' only use is changing the `visible` state. You can use this hook anywhere.

## Usage

Let's see an example:

```tsx title="src/pages/posts/list.tsx"
import {
  // highlight-next-line
  useModal,
} from "@refinedev/core";

export const PostList: React.FC = () => {
  // highlight-next-line
  const { visible, show, close } = useModal();

  return (
    <>
      // highlight-start
      <button onClick={show}>Show Modal</button>
      {visible && (
        <YourModalComponent>
          <p>Dummy Modal Content</p>
          <button onClick={close}>Close Modal</button>
        </YourModalComponent>
      )}
      // highlight-end
    </>
  );
};
```

Here, we show a button somewhere on the page and use `show` on its `onClick` callback to trigger the opening of the `<YourModalComponent>`. When the user clicks on the button, the `<YourModalComponent>` appears.

To demonstrate the `close` function, we created a `<button>` that uses it in its `onClick` property to close `<YourModalComponent>`

## Properties

### defaultVisible

`defaultVisible` is a boolean value that determines whether the modal is visible by default. By default, it is `false`.

```tsx
useModal({
  defaultVisible: true,
});
```

## Return Values

### visible

Visible state of the modal.

### show

A function that can change the `visible` state to `true`.

### close

A function that can change the `visible` state to `false`.

## API Reference

### Properties

<PropsTable module="@refinedev/core/useModal"  />

### Return Value

| Key     | Description                               | Type         |
| ------- | ----------------------------------------- | ------------ |
| visible | Returns the `visible` state of the modal. | `boolean`    |
| show    | A function that can open the modal.       | `() => void` |
| close   | A function that can close the modal.      | `() => void` |

## Example

<CodeSandboxExample path="core-use-modal" />

[modal]: https://ant.design/components/modal/#API

================
File: core/interface-references/index.md
================
---
title: Interface References
---

### CrudFilters

```tsx
type CrudFilters = CrudFilter[];
```

### CrudFilter

```tsx
type CrudFilter = LogicalFilter | ConditionalFilter;
```

### LogicalFilter

```tsx
type LogicalFilter = {
  field: string;
  operator: Exclude<CrudOperators, "or" | "and">;
  value: any;
};
```

### ConditionalFilter

```tsx
type ConditionalFilter = {
  key?: string;
  operator: Extract<CrudOperators, "or" | "and">;
  value: (LogicalFilter | ConditionalFilter)[];
};
```

### CrudOperators

```tsx
type CrudOperators =
  | "eq" // Equal
  | "ne" // Not equal
  | "lt" // Less than
  | "gt" // Greater than
  | "lte" // Less than or equal to
  | "gte" // Greater than or equal to
  | "in" // Included in an array
  | "nin" // Not included in an array
  | "ina" // Column contains every element in an array
  | "nina" // Column doesn't contain every element in an array
  | "contains" // Contains
  | "ncontains" // Doesn't contain
  | "containss" // Contains, case sensitive
  | "ncontainss" // Doesn't contain, case sensitive
  | "between" // Between
  | "nbetween" // Not between
  | "null" // Is null
  | "nnull" // Is not null
  | "startswith" // Starts with
  | "nstartswith" // Doesn't start with
  | "startswiths" // Starts with, case sensitive
  | "nstartswiths" // Doesn't start with, case sensitive
  | "endswith" // Ends with
  | "nendswith" // Doesn't end with
  | "endswiths" // Ends with, case sensitive
  | "nendswiths" // Doesn't end with, case sensitive
  | "or" // Logical OR
  | "and"; // Logical AND
```

### CrudSorting

```tsx
type CrudSorting = CrudSort[];
```

### CrudSort

```tsx
type CrudSort = {
  field: string;
  order:
    | "asc" // Ascending order
    | "desc"; // Descending order
};
```

### Pagination

```tsx
type Pagination = {
  current?: number; // Initial page index
  pageSize?: number; // Initial number of items per page
  mode?: "client" | "server" | "off"; // Whether to use server side pagination or not.
};
```

### BaseKey

```tsx
type BaseKey = string | number;
```

### BaseRecord

```tsx
type BaseRecord = {
  id?: BaseKey;
  [key: string]: any;
};
```

### HttpError

```tsx
type HttpError = {
  message: string;
  statusCode: number;
  errors?: ValidationErrors;
  [key: string]: any;
};
```

### ValidationErrors

```tsx
type ValidationErrors = {
  [field: string]:
    | string // Single error message
    | string[] // Multiple error messages
    | boolean // `true` if there is an error
    | { key: string; message: string }; // Error message with a translation key and a default message
};
```

### MutationMode

```tsx
type MutationMode = "pessimistic" | "optimistic" | "undoable";
```

### UseImportInputPropsType

```tsx
type UseImportInputPropsType = {
  type: "file";
  accept: string; // ".cvs"
  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
};
```

### SuccessErrorNotification

```tsx
type SuccessErrorNotification<
  TData = unknown,
  TError = unknown,
  TVariables = unknown,
> = {
  successNotification?:
    | OpenNotificationParams
    | false
    | ((
        data?: TData,
        values?: TVariables,
        resource?: string,
      ) => OpenNotificationParams | false);
  errorNotification?:
    | OpenNotificationParams
    | false
    | ((
        error?: TError,
        values?: TVariables,
        resource?: string,
      ) => OpenNotificationParams | false);
};
```

### OpenNotificationParams

```tsx
type OpenNotificationParams = {
  key?: string; // The key of the notification, used to manage the notification state.
  message: string; // The title of the notification.
  type: "success" | "error" | "progress"; // The type of the notification.
  description?: string; // The description of the notification.
  cancelMutation?: () => void; // If the notification is undoable, the function to call when the user clicks on the undo button.
  undoableTimeout?: number; // If the notification is undoable, the timeout in milliseconds after which the notification will be automatically closed.
};
```

### MetaQuery

```tsx
type MetaQuery = {
  queryContext?: Omit<QueryFunctionContext, "meta">;
  [key: string]: any;
} & QueryBuilderOptions &
  GraphQLQueryOptions;
```

### GraphQLQueryOptions

```tsx
import type { DocumentNode } from "graphql";

type GraphQLQueryOptions = {
  gqlQuery?: DocumentNode;
  gqlMutation?: DocumentNode;
  gqlVariables?: {
    [key: string]: any;
  };
};
```

### QueryFunctionContext

Context to be passed to the query function. Refer to [Query Function Context](https://tanstack.com/query/v4/docs/guides/query-functions#queryfunctioncontext) for more information.

### QueryBuilderOptions

```tsx
type QueryBuilderOptions = {
  operation?: string;
  fields?: Array<string | object | NestedField>;
  variables?: VariableOptions;
};
```

### NestedField

```tsx
type NestedField = {
  operation: string;
  variables: QueryBuilderOptions[];
  fields: Array<string | object | NestedField>;
};
```

### VariableOptions

```tsx
type VariableOptions = {
  type?: string;
  name?: string;
  value: any;
  list?: boolean;
  required?: boolean;
  [key: string]: any;
};
```

### CanParams

```tsx
type CanParams = {
  resource: string; // Resource name
  action: string; // Intended action name
  params?: {
    resource?: IResourceItem; // Resource item if can be determined
    id?: BaseKey; // Id of the record if the check is for a specific record
    [key: string]: unknown;
  };
};
```

### CanResponse

```tsx
type CanResponse = {
  can: boolean;
  reason?: string;
  [key: string]: unknown;
};
```

### DataProvider

```tsx
type DataProvider {
    getList: <TData extends BaseRecord = BaseRecord>(
        params: GetListParams,
    ) => Promise<GetListResponse<TData>>;

    getMany?: <TData extends BaseRecord = BaseRecord>(
        params: GetManyParams,
    ) => Promise<GetManyResponse<TData>>;

    getOne: <TData extends BaseRecord = BaseRecord>(
        params: GetOneParams,
    ) => Promise<GetOneResponse<TData>>;

    create: <TData extends BaseRecord = BaseRecord, TVariables = {}>(
        params: CreateParams<TVariables>,
    ) => Promise<CreateResponse<TData>>;

    createMany?: <TData extends BaseRecord = BaseRecord, TVariables = {}>(
        params: CreateManyParams<TVariables>,
    ) => Promise<CreateManyResponse<TData>>;

    update: <TData extends BaseRecord = BaseRecord, TVariables = {}>(
        params: UpdateParams<TVariables>,
    ) => Promise<UpdateResponse<TData>>;

    updateMany?: <TData extends BaseRecord = BaseRecord, TVariables = {}>(
        params: UpdateManyParams<TVariables>,
    ) => Promise<UpdateManyResponse<TData>>;

    deleteOne: <TData extends BaseRecord = BaseRecord, TVariables = {}>(
        params: DeleteOneParams<TVariables>,
    ) => Promise<DeleteOneResponse<TData>>;

    deleteMany?: <TData extends BaseRecord = BaseRecord, TVariables = {}>(
        params: DeleteManyParams<TVariables>,
    ) => Promise<DeleteManyResponse<TData>>;

    getApiUrl: () => string;

    custom?: <
        TData extends BaseRecord = BaseRecord,
        TQuery = unknown,
        TPayload = unknown,
    >(
        params: CustomParams<TQuery, TPayload>,
    ) => Promise<CustomResponse<TData>>;
};
```

### LiveEvent

```tsx
type LiveEvent = {
  channel: string;
  type: "deleted" | "updated" | "created" | "*" | string;
  payload: {
    ids?: BaseKey[];
    [x: string]: any;
  };
  date: Date;
  meta?: MetaQuery & {
    dataProviderName?: string;
  };
};
```

### LiveModeProps

```tsx
type LiveModeProps = {
  liveMode?: "auto" | "manual" | "off";
  onLiveEvent?: (event: LiveEvent) => void;
  liveParams?: {
    ids?: BaseKey[];
    [key: string]: any;
  };
};
```

### ResourceProps

```tsx
type ResourceProps = {
  name: string;
  identifier?: string;
  meta?: ResourceMeta;
};
```

### ResourceMeta

```tsx
type ResourceMeta = {
  label?: string; // Label of the resource, can be used to pretty print the resource name.
  hide?: boolean; // Whether to hide the resource from the menus or not. Used by the <Sider /> components.
  dataProviderName?: string; // Dedicated data provider name for the resource.
  parent?: string; // To nest a resource under another resource.
  canDelete?: boolean; // To determine if the resource has ability to delete or not.
  audit?: ResourceAuditLogPermissions[]; // To permit the audit log for actions on the resource.
  icon?: ReactNode; // Icon of the resource, used in the menus and breadcrumbs
  [key: string]: any;
};
```

### ResourceAuditLogPermissions

```tsx
type ResourceAuditLogPermissions = "create" | "update" | "delete" | string;
```

### SyncWithLocationParams

```tsx
type SyncWithLocationParams = {
  pagination: { current?: number; pageSize?: number };
  sorters: CrudSorting;
  filters: CrudFilters;
};
```

================
File: core/refine-component/index.md
================
---
title: <Refine>
---

`<Refine>` component is the entry point of a Refine app. It is where the highest level of configuration of the app occurs.

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";

const App = () => (
  <Refine
    dataProvider={dataProvider("https://api.example.com")}
    resources={[
      {
        name: "posts",
        list: "/posts",
      },
    ]}
  />
);
```

## dataProvider <PropTag asterisk />

A [`dataProvider`](/docs/data/data-provider) is the place where a Refine app communicates with an API.
Data providers also act as adapters for Refine, making it possible for it to consume different API's and data services.
A [`dataProvider`](/docs/data/data-provider) makes HTTP requests and returns response data back using predefined methods.

[Refer to the Data Provider documentation for detailed information. &#8594](/docs/data/data-provider)

Multiple data providers can be used with Refine, if you have multiple data providers, you can pass them to the `dataProvider` prop as an object.

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";
import { defaultDataProvider, exampleDataProvider } from "./data-providers";

const App = () => (
  <Refine
    dataProvider={{
      // `default` key must be defined to determine the default data provider
      default: defaultDataProvider,
      example: exampleDataProvider,
    }}
  />
);
```

## routerProvider

Refine provides a simple interface from the `routerProvider` prop to infer the resource from route, pass, parse and sync the query parameters and handle navigation operations. This provider and its properties are optional but it is recommended to use it to get the most out of Refine. Bindings to pass to the `routerProvider` prop are provided for the following libraries:

- React Router via `@refinedev/react-router`
- Next.js via `@refinedev/nextjs-router`
- Remix via `@refinedev/remix-router`

It's also possible to create a custom router bindings for your routing needs.

[Refer to the Router Provider documentation for detailed information. &#8594][routerprovider]

:::simple Legacy Router

In prior versions from v4 of Refine, `routerProvider` had a different interface and it was required. This is no longer the case and `routerProvider` is optional. If you want to keep using the legacy router provider, you can use the `legacyRouterProvider` prop instead.

:::

## resources

`resources` is the main building block of a Refine app. A resource represents an entity in an endpoint in the API (e.g. https://api.fake-rest.refine.dev/posts). It serves as a bridge between the data from the API and the pages in the app, allowing pages to interact with the data from the API.

Here's an app that consumes the https://api.fake-rest.refine.dev/posts endpoint as a resource to list multiple items, edit or create an item and show a single item.

Routes for the action pages that are for interacting with the CRUD API operations are passed as a resource element to `resources`.

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/json-server";

const App = () => (
  <Refine
    dataProvider={dataProvider("https://api.example.com")}
    // highlight-start
    resources={[
      {
        name: "posts",
        list: "/posts", // Means that the list action of this resource will be available at /posts in your app
        create: "/posts/create", // Means that the create action of this resource will be available at /posts/create in your app
        edit: "/posts/edit/:id", // Means that the edit action of this resource will be available at /posts/edit/:id in your app
        show: "/posts/show/:id", // Means that the show action of this resource will be available at /posts/show/:id in your app
      },
    ]}
    // highlight-end
  />
);
```

:::simple Accessing the Resource

You can use [useResource](/docs/routing/hooks/use-resource) hook to get the current active resource by the route or you can pass the `name` or the `identifier` of a resource to the `useResource` hook to get the resource object.

:::

### name <PropTag asterisk />

A string value that identifies a resource in the API. Interacting with the data in a resource will be done using an endpoint determined by the `name`:

```
https://api.fake-rest.refine.dev/posts
https://api.fake-rest.refine.dev/posts/1
```

### identifier

The `identifier` value serves as the main matching key for a resource. It allows you to effectively differentiate between multiple resources that share the same `name`.

There are scenarios where you may have multiple resources with the same `name` but different `meta` values. For instance, you might want a `posts` resource utilizing the default data provider and another `posts` resource utilizing the "typicode" data provider. In this case, you can use the `identifier` to differentiate between them.

```tsx
import { Refine } from "@refinedev/core";

<Refine
    ...
    dataProvider={{
        default: defaultDataProvider,
        typicode: typicodeDataProvider,
    }}
    resources={[
        {
            name: "posts",
            identifier: "posts",
            meta: {
                foo: "bar",
            },
        },
        {
            name: "posts",
            identifier: "featured-posts",
            meta: {
                foo: "baz",
                filter: {
                    featured: true,
                },
                dataProviderName: "typicode",
            },
        },
    ]}
>
...
</Refine>;
```

As you can see in the example above, we have two resources with the same `name` but different `identifier` values. Also, both resources have different `meta` values. Using the `identifier`, we can differentiate between the two resources like so:

```tsx
import { useTable } from "@refinedev/core";

useTable({
  resource: "featured-posts",
});

const typicodeDataProvider = {
  //...
  getList: async ({ resource, meta }) => {
    console.log(resource); // "posts"
    console.log(meta); // { foo: "baz", filter: { featured: true } }
  },
  //...
};
```

### list

The list path of the resource. The value assigned to the `list` will be treated as the `list` action path for the resource and the navigation operations will be performed on this path.

You can also pass a component to this property. In this case the default value for the path will be used, which is the `/${name}`.

There's also a third option, which is to pass an object with the `component` and `path` properties. This allows you to customize the path of the list action.

### create

The create path of the resource. The value assigned to the `create` will be treated as the `create` action path for the resource and the navigation operations will be performed on this path.

You can also pass a component to this property. In this case the default value for the path will be used, which is the `/${name}/create`.

There's also a third option, which is to pass an object with the `component` and `path` properties. This allows you to customize the path of the list action.

### edit

The edit path of the resource. The value assigned to the `edit` will be treated as the `edit` action path for the resource and the navigation operations will be performed on this path.

You can also pass a component to this property. In this case the default value for the path will be used, which is the `/${name}/edit/:id`.

There's also a third option, which is to pass an object with the `component` and `path` properties. This allows you to customize the path of the list action.

### show

The show path of the resource. The value assigned to the `show` will be treated as the `show` action path for the resource and the navigation operations will be performed on this path.

You can also pass a component to this property. In this case the default value for the path will be used, which is the `/${name}/show/:id`.

There's also a third option, which is to pass an object with the `component` and `path` properties. This allows you to customize the path of the list action.

:::simple Action definitions

- Additional parameters can also be used in the paths for the actions of the resources. Paths like `/:authorId/posts/:id/details` are also valid and supported. When these actions are used in the navigation helpers, the existing parameters from the URL and the `meta` property of these functions will be used to determine the additional parameters when composing the path.

- Passing a component or an object to the action will only take effect if the RefineRoutes component from one of the [Router Packages](/docs/guides-concepts/routing/#router-integrations) is used in the app to render the routes.

- When using the legacy router provider, only the component values will be used. Custom paths are not supported.

:::

### meta

`meta` can have any kind of property. It is used to store additional information about the resource. This property you pass can be received from the [useResource](/docs/routing/hooks/use-resource). Listed below are the properties that are used by Refine or its libraries.

#### label

Name to show in the menu. The plural form of the resource name is shown by default.

```tsx
<Refine
  resources={[
    {
      /* ... */
      // highlight-next-line
      meta: { label: "custom" },
    },
  ]}
/>
```

#### icon

An icon element can be passed as properties for the icon in the menu.

```tsx
<Refine
  resources={[
    {
      /* ... */
      // highlight-next-line
      meta: { icon: <CustomIcon /> },
    },
  ]}
/>
```

#### canDelete

This value is used by the Crud views to determine whether to show the delete button or not.

```tsx
<Refine
  resources={[
    {
      /* ... */
      // highlight-next-line
      meta: { canDelete: true },
    },
  ]}
/>
```

#### parent

You can set this value if you want to nest your resource into another resource. Usually this value represents the name of the parent resource but you can also pass a custom string. In this case, it will still be interpreted as a parent resource. This value is used by the `useMenu` and `useBreadcrumb` hooks.

```tsx
<Refine
  resources={[
    { name: "parent" },
    {
      name: "child",
      // highlight-next-line
      meta: { parent: "parent" },
    },
  ]}
/>
```

#### dataProviderName

Default data provider name to use for the resource. If not specified, the default data provider will be used.

```tsx
<Refine
  dataProvider={{
    default: defaultDataProvider,
    typicode: typicodeDataProvider,
  }}
  resources={[
    {
      /* ... */
      // highlight-next-line
      meta: { dataProviderName: "typicode" },
    },
  ]}
/>
```

#### hide

Can be used to hide a `resource` in `Sider`. This resource is also filtered in the `useMenu` hook.

```tsx
<Refine
  resources={[
    {
      /* ... */
      // highlight-next-line
      meta: { hide: true },
    },
  ]}
/>
```

#### ~~route~~ <PropTag deprecated />

Custom route name for the resource.

## authProvider

`authProvider` handles authentication logic like login, logout flow, and checking user credentials. It is an object with methods that Refine uses when necessary.

[Refer to Auth Provider documentation for detailed information. &#8594](/docs/authentication/auth-provider)

## i18nProvider

The `i18nProvider` property lets you add i18n support to your app. Making you able to use any i18n framework.

[Refer to i18n documentation for detailed information. &#8594](/docs/i18n/i18n-provider)

## accessControlProvider

`accessControlProvider` is the entry point for implementing access control for Refine apps.

[Refer to access control documentation for detailed information. &#8594](/docs/authorization/access-control-provider)

## liveProvider

Refine lets you add Realtime support to your app via `liveProvider`. It can be used to update and show data in Realtime throughout your app.

[Refer to live provider documentation for detailed information. &#8594](/docs/realtime/live-provider)

## notificationProvider

`notificationProvider` handles notification logic. It is an object with methods that Refine uses when necessary.

[Refer to the Notification Provider documentation for detailed information. &#8594](/docs/notification/notification-provider)

## options

`options` is used to configure the app.

### disableServerSideValidation

When the `dataProvider` returns rejected promise with [`errors`][http-error] field, the `useForm` hook will set the [`errors`][http-error] state with the `errors` returned from the `dataProvider`.

[Refer to Server Side Validation section of the Forms guide for detailed information. &#8594](/docs/guides-concepts/forms/#server-side-validation-)

To disable this behavior, you can set the `disableServerSideValidation` option to `true`.

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";

const App = () => (
  <Refine
    // highlight-start
    options={{ disableServerSideValidation: true }}
    // highlight-end
  >
    {/* ... */}
  </Refine>
);
```

### breadcrumb

Customize or disable the breadcrumb. By default it uses the Breadcrumb component from the respective package.

[Refer to the Layouts and Menus section of UI Libraries guide for further information. &#8594](/docs/guides-concepts/ui-libraries/#layouts-and-menus)

```tsx title="App.tsx"
import { Breadcrumb } from "@refinedev/antd";

const App = () => (
  <Refine
    // highlight-start
    options={{
      // Or you can pass `false` to disable the breadcrumbs
      breadcrumb: (
        <div
          style={{
            padding: "3px 6px",
            border: "2px dashed cornflowerblue",
          }}
        >
          <Breadcrumb />
        </div>
      ),
    }}
    // highlight-end
  />
);
```

### mutationMode

`mutationMode` determines which mode the mutations run with. (e.g. useUpdate, useDelete).

```tsx title="App.tsx"
const App = () => (
  <Refine
    // highlight-next-line
    options={{ mutationMode: "optimistic" }}
  />
);
```

`pessimistic`: The mutation runs immediately. Redirection and UI updates are executed after the mutation returns successfully. This is the default setting.

`optimistic`: The mutation is applied locally, and redirection and UI updates are executed immediately as if the mutation is successful. If the mutation returns with an error, UI updates accordingly.

`undoable`: The mutation is applied locally, and redirection and UI updates are executed immediately as if the mutation is successful. Waits for a customizable amount of timeout before mutation is applied. During the timeout, mutation can be canceled from the notification with the ?undo? button. UI will revert accordingly.

[Refer to the Mutation Mode docs for further information. &#8594](/docs/guides-concepts/forms/#mutation-modes-)

### undoableTimeout

The duration of the timeout period in **undoable** mode is shown in milliseconds. Mutations can be canceled during this period. This period can also be set on the supported data hooks.
The value set in hooks will override the value set with `undoableTimeout`.
`undoableTimeout` has a default value of `5000`.

```tsx title="App.tsx"
const App = () => (
  <Refine
    // highlight-next-line
    options={{ mutationMode: "undoable", undoableTimeout: 3500 }}
  />
);
```

### syncWithLocation

List query parameter values can be edited manually by typing directly in the URL.
`syncWithLocation`'s default value is `false`, so you need to set it to `true` to activate the feature.

Form hooks like `useDrawerForm` and `useModalForm` also have a `syncWithLocation` property but the value of this option has no effect on these hooks. You'll still need to set the `syncWithLocation` property in hooks to `true` to activate this feature.

When `syncWithLocation` is active, the URL on the listing page shows query parameters like those shown below:

```
/posts?current=1&pageSize=8&sort[]=createdAt&order[]=desc
```

Users can change the current page, items count per page, and sort and filter parameters.

### warnWhenUnsavedChanges

When you have unsaved changes and try to leave the current page, Refine shows a confirmation modal box.
`warnWhenUnsavedChanges`'s default value is `false`, so you need to set it to `true` to activate the feature.

This feature also **requires** `UnsavedChangesNotifier` component to be mounted. You can import this component from your router package.

<Image className="p-3 object-none" src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/warnwhen.png" />

### liveMode

`liveMode` controls whether to update data automatically or not, with `auto` and `manual` respectively if a related live event is received. The `off` value can be used to avoid creating a subscription all together.

> For more information, refer to the [live provider documentation &#8594](/docs/realtime/live-provider#livemode)

### disableTelemetry

Refine implements a simple and transparent telemetry module for collecting usage statistics defined in a very limited scope. This telemetry module is used to improve the Refine experience. You can disable this by setting `disableTelemetry` to `true`.

> For more information, refer to the [Refine telemetry documentation &#8594](/further-readings/telemetry.md)

### redirect

By default, Refine redirects to the `list` page of the resource after a successful form mutation. To change this behavior based on the form [action](/docs/data/hooks/use-form/#actions), set `redirect` as follows:

```tsx title="App.tsx"
const App = () => (
  <Refine
    // highlight-start
    options={{
      redirect: {
        // If the resource doesn't have a show page defined, the user will be redirected to the list page.
        afterCreate: "show",
        // If the mutation mode is `undoable` or `optimistic`, the redirect happens before the mutation succeeds. Therefore, if there is no known `id` value, the user will be redirected to the list page.
        afterClone: "edit",
        // If set to `false`, no redirect is performed after a successful form mutation.
        afterEdit: false,
      },
    }}
    // highlight-end
  />
);
```

### reactQuery

#### clientConfig

Config for React Query client that Refine uses.

:::simple Defaults

- `refetchOnWindowFocus`: `false`
- `keepPreviousData`: `true`

:::

```tsx
const App = () => (
  <Refine
    // highlight-start
    options={{
      reactQuery: {
        clientConfig: {
          defaultOptions: {
            queries: {
              staleTime: Infinity,
            },
          },
        },
      },
    }}
    // highlight-end
  />
);
```

Also, you can use your own [QueryClient](https://react-query.tanstack.com/reference/QueryClient#queryclient).

```tsx
import { QueryClient } from "@tanstack/react-query";

const myQueryClient = new QueryClient();

const App = () => (
  <Refine
    // highlight-start
    options={{
      reactQuery: {
        clientConfig: myQueryClient,
      },
    }}
    // highlight-end
  />
);
```

> For more information, refer to the [QueryClient documentation &#8594](https://react-query.tanstack.com/reference/QueryClient#queryclient)

#### ~~devtoolConfig~~ <PropTag deprecated />

React Query Devtools are removed from the `@refinedev/core` and this prop is no longer supported for the configuration of the devtools. You can use the `@tanstack/react-query-devtools` in your app directly to use the devtools. For more information, please check out [FAQ - How to use React Query Devtools with Refine?](/docs/guides-concepts/faq/#how-to-use-react-query-devtools-with-refine)

> For more information, refer to the [Devtools documentation &#8594](https://react-query.tanstack.com/devtools#options)

### textTransformers

The `textTransformers` option in Refine is used to transform the resource name displayed on the user interface (UI). By default, if you define a resource named `posts`, Refine will display it as `Posts`. Similarly, when you delete a record, notification messages will be shown as `Post deleted successfully.`.

You have the flexibility to customize these messages by using the `textTransformers` option. For instance, if you wish to disable any transformation, you can set the `textTransformers` option as shown in the example below:

```tsx
const App = () => (
  <Refine
    // ...
    options={{
      textTransformers: {
        humanize: (text) => text,
        plural: (text) => text,
        singular: (text) => text,
      },
    }}
  />
);
```

#### humanize

The function converts the resource name to a more human-readable format. The default value uses the [`humanize-string`](https://www.npmjs.com/package/humanize-string) library.

#### plural

The function converts the resource name to its plural form. The default value uses the [`pluralize`](https://www.npmjs.com/package/pluralize) library.

#### singular

The function converts the resource name to its singular form. The default value uses the [`pluralize`](https://www.npmjs.com/package/pluralize) library.

### overtime

If you want loading overtime for the request, you can use the `overtime` object. It is useful when you want to show a loading indicator when the request takes too long.

```tsx
const App = () => (
  <Refine
    // highlight-start
    options={{
      overtime: {
        enabled: true,
        interval: 1000, // default value is 1000
        onInterval: (elapsedInterval, context) => {
          console.log(elapsedInterval, context);
        },
      },
    }}
    // highlight-end
  />
);
```

#### enabled

If true, the elapsed time will be calculated. If set to false, the elapsed time will always be `undefined`.

#### interval

The interval value in milliseconds. The default value is `1000`.

#### onInterval

The callback function that will be called on every interval. The default value is `undefined`.

The callback function receives two parameters:

- `elapsedInterval`: The elapsed interval in milliseconds.
- `context`: `{ resource?: IResourceItem; resourceName?: string; id?: BaseKey, action?: Action }`

### useNewQueryKeys

With `@refinedev/core`'s `v4.35.0`, Refine introduced new query and mutation keys which are more structured and easy to construct. These keys are used in all data, auth, access control and audit log queries and mutations.

By default, Refine uses the legacy keys for backward compatibility and in the future versions it will switch to using the new query keys. You can easily switch to using new keys by setting `useNewQueryKeys` to `true`.

### title

Refine's predefined layout and auth components displays a title for the app, which consists of the app name and an icon. These values can be customized globally by passing `options.title` to the `<Refine>` component.

`title` is an object that can have the following properties:

- `icon`: A React Node to be used as the app icon. By default, it's Refine logo.
- `text`: A React Node to be used as the app name. By default, it's `"Refine Project"`.

```tsx title="App.tsx"
const App = () => (
  <Refine
    options={{
      // highlight-start
      title: {
        icon: <CustomIcon />,
        text: "Custom App Name",
      },
      // highlight-end
    }}
  />
);
```

If you wish to use separate values for your `<AuthPage />` and `<ThemedLayoutV2 />` components, you can `Title` prop to override the default title component (which is the `<ThemedTitleV2 />` component from the respective package).

```tsx
import { Refine } from "@refinedev/core";
// ThemedTitleV2 accepts `text` and `icon` props with same types as `options.title`
// This component is used in both AuthPage and ThemedLayoutV2 components.
import { ThemedLayoutV2, AuthPage, ThemedTitleV2 } from "@refinedev/antd";

const App = () => {
  return (
    <Refine
      options={{
        // highlight-start
        title: {
          text: "My App",
          icon: <IconA />,
        },
        // highlight-end
      }}
    >
      {/* ... */}
      <ThemedLayoutV2
        // highlight-start
        Title={(props) => (
          <ThemedTitleV2
            // These values will override the global title values
            text="A Different Value"
            icon={<IconB />}
            {...props}
          />
        )}
        // highlight-end
      >
        {/* ... */}
      </ThemedLayoutV2>
      {/* ... */}
      <AuthPage
        type="login"
        // highlight-start
        title={
          <ThemedTitleV2
            collapsed={false}
            // These values will override the global title values
            text="A Different Value"
            icon={<IconC />}
          />
        }
        // highlight-end
      />
    </Refine>
  );
};
```

## onLiveEvent

Callback to handle all live events.

> For more information, refer to the [live provider documentation &#8594](/docs/realtime/live-provider#Refine)

## ~~catchAll~~ <PropTag deprecated />

| 🚨 Use the `<CustomErrorPage />` component in your routes instead.

When the app is navigated to a non-existent route, Refine shows a default error page. A custom error component can be used for this error page by passing the customized component to the `catchAll` property:

```tsx title="App.tsx"
// highlight-next-line
const CustomErrorPage = <div>Page not found</div>;

const App = () => (
  <Refine
    // highlight-next-line
    catchAll={CustomErrorPage}
  />
);
```

## ~~LoginPage~~ <PropTag deprecated />

| 🚨 Use the `<AuthPage />` component in your routes instead.

Refine has a default login page form which is served on the `/login` route when the `authProvider` configuration is provided.

Custom login component can be passed to the `LoginPage` property.

```tsx title="App.tsx"
// highlight-next-line
const CustomLoginPage = () => <div> Custom Login Page </div>;

const App = () => (
  <Refine
    // highlight-next-line
    LoginPage={CustomLoginPage}
  />
);
```

## ~~DashboardPage~~ <PropTag deprecated />

| 🚨 Use the `<CustomDashboardPage />` component in your routes instead.

A custom dashboard page can be passed to the `DashboardPage` prop which is accessible on the root route.

The dashboard item will appear at the top of the sider menu. If `DashboardPage` is not given, the first resource of `resources` will be shown.

```tsx title="App.tsx"
// highlight-next-line
const CustomDashboardPage = () => <div> Custom Dashboard Page </div>;

const App = () => (
  <Refine
    // highlight-next-line
    DashboardPage={CustomDashboardPage}
  />
);
```

## ~~ReadyPage~~ <PropTag deprecated />

Refine shows a default ready page on the root route when no `resources` is passed to the `<Refine>`.

Custom ready page component can be set by passing to the `ReadyPage` property?.

```tsx title="App.tsx"
// highlight-next-line
const CustomReadyPage = () => <div> Custom Ready Page </div>;

const App = () => (
  <Refine
    // highlight-next-line
    ReadyPage={CustomReadyPage}
  />
);
```

## ~~Sider~~ <PropTag deprecated />

| 🚨 Use `Sider` prop of `<ThemedLayoutV2 />` component instead.

The default sidebar can be customized by using Refine hooks and passing custom components to the `Sider` property.

> For more information, refer to the [`useMenu` hook documentation &#8594](/docs/core/hooks/utilities/use-menu)

## ~~Footer~~ <PropTag deprecated />

| 🚨 Use `Footer` prop of `<ThemedLayoutV2 />` component instead.

The default app footer can be customized by passing the `Footer` property.

```tsx title="App.tsx"
// highlight-next-line
const CustomFooter = () => <div>Custom Footer</div>;

const App = () => (
  <Refine
    // highlight-next-line
    Footer={CustomFooter}
  />
);
```

## ~~Header~~ <PropTag deprecated />

| 🚨 Use `Header` prop of `<ThemedLayoutV2 />` component instead.

```tsx title="App.tsx"
// highlight-next-line
const CustomHeader = () => <div>Custom Header</div>;

const App = () => (
  <Refine
    // highlight-next-line
    Header={CustomHeader}
  />
);
```

## ~~Layout~~ <PropTag deprecated />

| 🚨 Use `<ThemedLayoutV2 />` as children of `<Refine />` instead.

The default layout can be customized by passing the `Layout` property.

Layout property will receive individual layout components as property.

```tsx title="App.tsx"
const App = () => (
  <Refine
    // highlight-start
    Layout={({ children, Sider, Footer, Header, OffLayoutArea }) => (
      <AntdLayout style={{ minHeight: "100vh", flexDirection: "row" }}>
        {Sider && <Sider />}
        <AntdLayout>
          {Header && <Header />}
          <AntdLayout.Content>
            <div style={{ padding: 24, minHeight: 360 }}>{children}</div>
          </AntdLayout.Content>
          {Footer && <Footer />}
        </AntdLayout>
        {OffLayoutArea && <OffLayoutArea />}
      </AntdLayout>
    )}
    // highlight-end
  />
);
```

A completely custom layout can also be implemented instead of the Refine's default:

```tsx title="App.tsx"
const App = () => (
  <Refine
    // highlight-start
    Layout={({ children }) => (
      <div style={{ display: "flex", flexDirection: "column" }}>
        <div>Custom Layout</div>
        <div>{children}</div>
      </div>
    )}
    // highlight-end
  />
);
```

## ~~OffLayoutArea~~ <PropTag deprecated />

| 🚨 Use `OffLayoutArea` prop of `<ThemedLayoutV2 />` component instead.

The component wanted to be placed out of the app layout structure can be set by passing to the `OffLayoutArea` prop.

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";

const App = () => (
  <Refine
    // highlight-next-line
    OffLayoutArea={() => <div>Some elements to place outside the layout</div>}
  />
);
```

## ~~Title~~ <PropTag deprecated />

| 🚨 Use `Title` prop of `<ThemedLayoutV2 />` component instead.

The app title can be set by passing the `Title` property.

```tsx title="App.tsx"
// highlight-start
const CustomTitle = ({ collapsed }) => (
  <div>{collapsed ? "Collapsed Title" : "Full Title"}</div>
);
// highlight-end

const App = () => (
  <Refine
    // highlight-next-line
    Title={CustomTitle}
  />
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/Refine"/>

[routerprovider]: /docs/routing/router-provider
[http-error]: /docs/core/interface-references#httperror

================
File: data/data-provider/index.md
================
---
title: Data Provider
---

import SupportedDataProviders from "@site/src/partials/data-provider/supported-data-providers.md";

Data provider acts as a data layer for your app, making HTTP requests and encapsulating how the data is retrieved. The methods of these requests are then consumed by Refine via data hooks.

You don’t need to worry about creating data providers from scratch, as Refine offers built-in data provider support for the most popular [API providers](#supported-data-providers).

:::simple Good to know

- Data hooks use [TanStack Query](https://tanstack.com/query) to manage data fetching, which handles important concerns like caching, invalidation, loading states, etc.
- If you want to create your own data provider, check out the ["Creating a data provider from scratch" tutorial][create-a-data-provider]

:::

<Image src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/providers/data-provider/api-consuming-flow.png" />

## Usage

To activate the data provider in Refine, we have to pass the `dataProvider` to the `<Refine />` component.

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";

import dataProvider from "./dataProvider";

const App = () => (
  <Refine
    /* ... */
    dataProvider={dataProvider}
  />
);
```

[Refer to the Data Provider tutorial for more information and usage examples →][data-provider-tutorial]

## Multiple Data Providers

Refine allows you to use multiple data providers in your app. All you need to do is pass key and value pairs to the `dataProvider` prop of the `<Refine />` component. In the pair object, the key corresponds to the data provider name, and the value corresponds to the data provider itself.

When defining multiple data providers, `default` key is required for defining the default data provider.

Here is an example which uses multiple data providers:

```tsx live hideCode url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);
setRefineProps({ Sider: () => null });

// visible-block-start
import { Refine, useList } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { BrowserRouter, Route, Routes } from "react-router";

import { Collapse, Tag } from "antd";

const API_URL = "https://api.fake-rest.refine.dev";
const FINE_FOODS_API_URL = "https://api.finefoods.refine.dev";

interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}

interface IProduct {
  id: number;
  name: string;
  price: number;
}

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        // highlight-start
        dataProvider={{
          // `default` is required to determine the default data provider
          default: dataProvider(API_URL),
          fineFoods: dataProvider(FINE_FOODS_API_URL),
        }}
        // highlight-end
        resources={[
          {
            // highlight-next-line
            // Refine will use the `default` data provider for this resource
            name: "posts",
            list: "/posts",
          },
          {
            name: "products",
            meta: {
              // highlight-start
              // Refine will use the `fineFoods` data provider for this resource
              dataProviderName: "fineFoods",
              // highlight-end
            },
          },
        ]}
      >
        <Routes>
          <Route path="/posts" element={<PostList />} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};

const PostList = () => {
  const { data: posts } = useList<IPost>({
    resource: "posts",
    // highlight-start
    // Data provider can be selected through props
    dataProviderName: "default",
    // highlight-end
  });
  // highlight-start
  // We've defined the data provider for this resource as "fineFoods" in its config so we don't need to pass it here
  const { data: products } = useList<IProduct>({ resource: "products" });
  // highlight-end

  console.log({
    posts,
    products,
  });

  return (
    <Collapse defaultActiveKey={["products"]}>
      <Collapse.Panel header="Posts" key="posts">
        {posts?.data.map((post) => (
          <div
            key={post.title}
            style={{
              display: "flex",
              flexDirection: "row",
              gap: "0.5rem",
              marginBottom: "0.25rem",
            }}
          >
            {post.title}
            <Tag>{post.status}</Tag>
          </div>
        ))}
      </Collapse.Panel>
      <Collapse.Panel header="Products" key="products">
        {products?.data.map((product) => (
          <div
            key={product.name}
            style={{
              display: "flex",
              flexDirection: "row",
              gap: "0.5rem",
              marginBottom: "0.25rem",
            }}
          >
            {product.name}
            <Tag>{product.price / 10}</Tag>
          </div>
        ))}
      </Collapse.Panel>
    </Collapse>
  );
};
// visible-block-end

render(<App />);
```

### Usage

You can pick data providers in two ways:

You can either use the `dataProviderName` prop in data hooks and data-related components/functions:

```tsx
useTable({
  meta: {
    dataProviderName: "example",
  },
});
```

Or use the `meta.dataProviderName` property in your resource config, which will be the default data provider but can be overridden in data hooks and components:

```tsx
const App = () => (
  <Refine
    dataProvider={{
      default: defaultDataProvider,
      example: exampleDataProvider,
    }}
    resources={[
      {
        // `default` data provider will be used for this resource
        name: "posts",
      },
      {
        name: "products",
        // `exampleDataProvider` data provider will be used for this resource
        meta: { dataProviderName: "exampleDataProvider" },
      },
    ]}
  />
);
```

## Methods

Data provider's methods are expected to return a promise, meaning that they are async and can be used to create a data provider.
Refine consumes these data provider methods using [data hooks](#supported-hooks), which are used for CRUD actions like creating a new record, listing a resource or deleting a record, etc.

```tsx
import { DataProvider } from "@refinedev/core";

const dataProvider: DataProvider = {
  // required methods
  getList: ({ resource, pagination, sorters, filters, meta }) => Promise,
  create: ({ resource, variables, meta }) => Promise,
  update: ({ resource, id, variables, meta }) => Promise,
  deleteOne: ({ resource, id, variables, meta }) => Promise,
  getOne: ({ resource, id, meta }) => Promise,
  getApiUrl: () => "",
  // optional methods
  getMany: ({ resource, ids, meta }) => Promise,
  createMany: ({ resource, variables, meta }) => Promise,
  deleteMany: ({ resource, ids, variables, meta }) => Promise,
  updateMany: ({ resource, ids, variables, meta }) => Promise,
  custom: ({ url, method, filters, sorters, payload, query, headers, meta }) =>
    Promise,
};
```

[Refer to the Data Provider tutorial for more information and usage examples&#8594][data-provider-tutorial]

### getList <PropTag required />

The `getList` method is used to get a list of resources with sorting, filtering, and pagination features. It takes `resource`, `sorters`, `pagination`, and, `filters` as parameters. And it returns both `data` and `total` fields, regardless of the data provider used.

Refine will consume this method using the [`useList`][use-list] or [`useInfiniteList`][use-infinite-list] data hook.

#### Retrieving the Total Row Count

- Different data providers have specific ways to determine the total row count, and these are just some examples:
  - **Simple REST Providers:** The `x-total-count` header is commonly used to get the row count.
  - **GraphQL Providers:** The total count is often sourced from specific data fields, like `response.data.pageInfo.total`.

This documentation provides only illustrative examples. It's up to the data provider to determine how to best source the total count.

The method signature remains the same, and Refine expects a consistent format:

```ts
getList: async ({ resource, pagination, sorters, filters, meta }) => {
  const { current, pageSize } = pagination ?? {};

  // Adjust request parameters to meet the requirements of your API
  const response = await apiClient.get(`/${resource}`, {
    params: { _page: current, _limit: pageSize },
  });

  // The total row count could be sourced differently based on the provider
  const total = response.headers["x-total-count"] ?? response.data.length;

  return {
    data: response.data,
    total,
  };
};
```

:::tip

`getList` can also support cursor-based pagination. Refer to [related section in the `useInfiniteList` documentation](/docs/data/hooks/use-infinite-list#how-to-use-cursor-based-pagination) for more information.

:::

**Parameter Types:**

| Name        | Type                          |
| ----------- | ----------------------------- |
| resource    | `string`                      |
| pagination? | [`Pagination`][pagination]    |
| sorters?    | [`CrudSorting`][crud-sorting] |
| filters?    | [`CrudFilters`][crud-filters] |
| meta?       | [`MetaDataQuery`][meta-data]  |

### create <PropTag required/>

The `create` method creates a new record with the `resource` and `variables` parameters.

Refine will consume this method using the [`useCreate`][use-create] data hook.

```ts
create: async ({ resource, variables, meta }) => {
  // You can handle the request according to your API requirements.

  return {
    data,
  };
};
```

**Parameter Types**

| Name      | Type                         | Default |
| --------- | ---------------------------- | ------- |
| resource  | `string`                     |         |
| variables | `TVariables`                 | `{}`    |
| meta?     | [`MetaDataQuery`][meta-data] |

> `TVariables` is a user defined type which can be passed to [`useCreate`](/docs/data/hooks/use-create#type-parameters) to type `variables`.

### update <PropTag required />

The `update` method updates the record with the `resource`, `id`, and, `variables` parameters.

Refine will consume this method using the [`useUpdate`][use-update] data hook.

```ts
update: async ({ resource, id, variables, meta }) => {
  // You can handle the request according to your API requirements.

  return {
    data,
  };
};
```

**Parameter Types:**

| Name      | Type                         | Default |
| --------- | ---------------------------- | ------- |
| resource  | `string`                     |         |
| id        | [BaseKey][basekey]           |         |
| variables | `TVariables`                 | `{}`    |
| meta?     | [`MetaDataQuery`][meta-data] |

> `TVariables` is a user defined type which can be passed to [`useUpdate`](/docs/data/hooks/use-update#type-parameters) to type `variables`.

### deleteOne <PropTag required />

The `deleteOne` method delete the record with the `resource` and `id` parameters.

Refine will consume this method using the [`useDelete`][use-delete] data hook.

```ts
deleteOne: async ({ resource, id, variables, meta }) => {
  // You can handle the request according to your API requirements.

  return {
    data,
  };
};
```

**Parameter Types:**

| Name      | Type                         | Default |
| --------- | ---------------------------- | ------- |
| resource  | `string`                     |         |
| id        | [BaseKey][basekey]           |         |
| variables | `TVariables[]`               | `{}`    |
| meta?     | [`MetaDataQuery`][meta-data] |

> `TVariables` is a user defined type which can be passed to [`useDelete`](/docs/data/hooks/use-delete) to type `variables`.

### getOne <PropTag required />

The `getOne` method gets the record with the `resource` and `id` parameters.

Refine will consume this method using the [`useOne`][use-one] data hook.

```ts
getOne: async ({ resource, id, meta }) => {
  // You can handle the request according to your API requirements.

  return {
    data,
  };
};
```

**Parameter Types:**

| Name     | Type                         | Default |
| -------- | ---------------------------- | ------- |
| resource | `string`                     |         |
| id       | [BaseKey][basekey]           |         |
| meta?    | [`MetaDataQuery`][meta-data] |

### getApiUrl <PropTag required />

The `getApiUrl` method returns the `apiUrl` value.

Refine will consume this method using the [`useApiUrl`][use-api-url] data hook.

```ts title="src/data-provider.ts"
import { DataProvider } from "@refinedev/core";

export const dataProvider = (apiUrl: string): DataProvider => ({
  getApiUrl: () => apiUrl,
  // ...
});
```

### custom

An optional method named `custom` can be added to handle requests with custom parameters like URL, CRUD methods and configurations.
It's useful if you have non-standard REST API endpoints or want to make a connection with external resources.

Refine will consume this method using the [`useCustom`][use-custom] data hook.

```ts
custom: async ({
  url,
  method,
  filters,
  sorters,
  payload,
  query,
  headers,
  meta,
}) => {
  // You can handle the request according to your API requirements.

  return {
    data,
  };
};
```

**Parameter Types**

| Name     | Type                                                       |
| -------- | ---------------------------------------------------------- |
| url      | `string`                                                   |
| method   | `get`, `delete`, `head`, `options`, `post`, `put`, `patch` |
| sorters? | [`CrudSorting`][crud-sorting]                              |
| filters? | [`CrudFilters`][crud-filters]                              |
| payload? | `{}`                                                       |
| query?   | `{}`                                                       |
| headers? | `{}`                                                       |
| meta?    | [`MetaDataQuery`][meta-data]                               |

## Bulk Actions

Bulk actions are actions that can be performed on multiple items at once to improve speed and efficiency. They are commonly used in admin panels. They can be used for data [`import`](/docs/core/hooks/utilities/use-import) and [`export`](/docs/core/hooks/utilities/use-export), and are also atomic, meaning that they are treated as a single unit.

If your API supports bulk actions, you can implement them in your data provider.

### getMany

The `getMany` method gets the records with the `resource` and `ids` parameters. This method is optional, and Refine will use the [`getOne`](#getone-) method to handle multiple requests if you don't implement it.

Refine will consume this `getMany` method using the [`useMany`][use-many] data hook.

```ts
getMany: async ({ resource, ids, meta }) => {
  // You can handle the request according to your API requirements.

  return {
    data,
  };
};
```

**Parameter Types:**

| Name     | Type                         | Default |
| -------- | ---------------------------- | ------- |
| resource | `string`                     |         |
| ids      | [[BaseKey][basekey]]         |         |
| meta?    | [`MetaDataQuery`][meta-data] |

### createMany

This method allows us to create multiple items in a resource. This method is optional, and Refine will use the [`create`](#create-) method to handle multiple requests if you don't implement it.

Refine will consume this `createMany` method using the [`useCreateMany`][use-create-many] data hook.

```ts
createMany: async ({ resource, variables, meta }) => {
  // You can handle the request according to your API requirements.

  return {
    data,
  };
};
```

**Parameter Types:**

| Name      | Type                         | Default |
| --------- | ---------------------------- | ------- |
| resource  | `string`                     |         |
| variables | `TVariables[]`               | `{}`    |
| meta?     | [`MetaDataQuery`][meta-data] |

> `TVariables` is a user defined type which can be passed to [`useCreateMany`][use-create-many] to type `variables`.

### deleteMany

This method allows us to delete multiple items in a resource. This method is optional, and Refine will use the [`deleteOne`](#deleteone-) method to handle multiple requests if you don't implement it.

Refine will consume this `deleteMany` method using the [`useDeleteMany`][use-delete-many] data hook.

```ts
deleteMany: async ({ resource, ids, variables, meta }) => {
  // You can handle the request according to your API requirements.

  return {
    data,
  };
};
```

| Name      | Type                         | Default |
| --------- | ---------------------------- | ------- |
| resource  | `string`                     |         |
| ids       | [[BaseKey][basekey]]         |         |
| variables | `TVariables[]`               | `{}`    |
| meta?     | [`MetaDataQuery`][meta-data] |

> `TVariables` is a user defined type which can be passed to [`useDeleteMany`][use-delete-many] to type `variables`.

### updateMany

This method allows us to update multiple items in a resource. This method is optional, and Refine will use the [`update`](#update-) method to handle multiple requests if you don't implement it.

Refine will consume this `updateMany` method using the [`useUpdateMany`][use-update-many] data hook.

```ts
updateMany: async ({ resource, ids, variables, meta }) => {
  // You can handle the request according to your API requirements.

  return {
    data,
  };
};
```

| Name      | Type                         | Default |
| --------- | ---------------------------- | ------- |
| resource  | `string`                     |         |
| ids       | [[BaseKey][basekey]]         |         |
| variables | `TVariables[]`               | `{}`    |
| meta?     | [`MetaDataQuery`][meta-data] |

> `TVariables` is a user defined type which can be passed to [`useUpdateMany`][use-update-many] to type `variables`.

## Error Format

Refine expects errors to be extended from [`HttpError`][http-error].

Here is a basic example of how to implement error handling in your data provider.

```ts title="src/data-provider.ts"
import { DataProvider, HttpError } from "@refinedev/core";

export const dataProvider = (apiUrl: string): DataProvider => ({
  getOne: async ({ resource, id }) => {
    try {
      const response = await fetch(`https://api.example.com/${resource}/${id}`);

      // highlight-start
      if (!response.ok) {
        const error: HttpError = {
          message: response.statusText,
          statusCode: response.status,
        };
        return Promise.reject(error);
      }
      // highlight-end

      return {
        data: response.data,
      };
    } catch (error) {
      // highlight-start
      const error: HttpError = {
        message: error?.message || "Something went wrong",
        statusCode: error?.status || 500,
      };
      return Promise.reject(error);
      // highlight-end
    }
  },
  // ...
});
```

Also, the Axios interceptor can be used to transform the error from the response before Axios returns the response to your code.

```ts title="src/data-provider.ts"
// highlight-start
import axios from "axios";
import { DataProvider, HttpError } from "@refinedev/core";
// highlight-end
import { stringify } from "query-string";

// highlight-start
// Error handling with axios interceptors
const axiosInstance = axios.create();

axiosInstance.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    const customError: HttpError = {
      ...error,
      message: error.response?.data?.message,
      statusCode: error.response?.status,
    };

    return Promise.reject(customError);
  },
);
// highlight-end

export const dataProvider = (apiUrl: string): DataProvider => ({
  // Methods
});
```

## meta Usage

When using APIs, you may wish to include custom parameters, such as a custom header. To accomplish this, you can utilize the `meta` field, which allows the sent parameter to be easily accessed by the data provider.

Here is an example of how to send a custom header parameter to the `getOne` method using `meta`:

We first need to send a custom header parameter to the [`getOne`](#getone-) method using `meta`.

```ts title="post/edit.tsx"
import { useOne } from "@refinedev/core";

useOne({
  resource: "post",
  id: "1",
  meta: {
    headers: {
      "x-custom-header": "hello world",
    },
  },
});
```

Then we can get the `meta` parameter from the data provider:

```ts title="src/data-provider.ts"
import { DataProvider } from "@refinedev/core";

export const dataProvider = (apiUrl: string): DataProvider => ({
  ...
  getOne: async ({ resource, id, variables, meta }) => {
    // highlight-next-line
    const { headers } = meta;
    const url = `${apiUrl}/${resource}/${id}`;

    // highlight-start
    httpClient.defaults.headers = {
      ...headers,
    };
    // highlight-end

    const { data } = await httpClient.get(url, variables);

    return {
      data,
    };
  },
});
```

## Supported Data Providers

<SupportedDataProviders/>

## Supported Hooks

Refine will consume:

- [`getList`](#getlist-) method using the [`useList`][use-list] or [`useInfiniteList`][use-infinite-list] data hook.
- [`create`](#create-) method using the [`useCreate`][use-create] data hook.
- [`update`](#update-) method using the [`useUpdate`][use-update] data hook.
- [`deleteOne`](#deleteone-) method using the [`useDeleteOne`][use-delete] data hook.
- [`getOne`](#getone-) method using the [`useOne`][use-one] data hook.
- [`getApiUrl`](#getapiurl-) method using the [`useApiUrl`][use-api-url] data hook.
- [`custom`](#custom) method using the [`useCustom`][use-custom] data hook.
- [`getMany`](#getmany) method using the [`useMany`][use-many] data hook.
- [`createMany`](#createmany) method using the [`useCreateMany`][use-create-many] data hook.
- [`deleteMany`](#deletemany) method using the [`useDeleteMany`][use-delete-many] data hook.
- [`updateMany`](#updatemany) method using the [`useUpdateMany`][use-update-many] data hook.

## FAQ

### How can I create a custom data provider?

[Refer to the "Create Data Provider From Scratch" section in the tutorial for more information →][create-a-data-provider]

### How can I customize existing data providers?

[You can swizzle the data provider using the Refine CLI and customize it as needed.][swizzle-a-data-provider]

### How I can override a specific method of Data Providers?

In some cases, you may need to override the method of Refine data providers. The simplest way to do this is to use the [Spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

For example, Let's override the `update` function of the [`@refinedev/simple-rest`](https://github.com/refinedev/refine/tree/main/packages/simple-rest). `@refinedev/simple-rest` uses the `PATCH` HTTP method for `update`, let's change it to `PUT` without forking the whole data provider.

```tsx
import dataProvider from "@refinedev/simple-rest";

const simpleRestProvider = dataProvider("API_URL");
const myDataProvider = {
  ...simpleRestProvider,
  update: async ({ resource, id, variables }) => {
    const url = `${apiUrl}/${resource}/${id}`;

    const { data } = await httpClient.put(url, variables);

    return {
      data,
    };
  },
};

<Refine dataProvider={myDataProvider}>{/* ... */}</Refine>;
```

[basekey]: /docs/core/interface-references#basekey
[create-a-data-provider]: https://refine.dev/tutorial/essentials/data-fetching/intro/#creating-a-data-provider
[swizzle-a-data-provider]: /docs/packages/cli/#swizzle
[data-provider-tutorial]: https://refine.dev/tutorial/essentials/data-fetching/intro/
[use-api-url]: /docs/data/hooks/use-api-url
[use-create]: /docs/data/hooks/use-create
[use-create-many]: /docs/data/hooks/use-create
[use-custom]: /docs/data/hooks/use-custom
[use-delete]: /docs/data/hooks/use-delete
[use-delete-many]: /docs/data/hooks/use-delete
[use-list]: /docs/data/hooks/use-list
[use-infinite-list]: /docs/data/hooks/use-infinite-list
[use-many]: /docs/data/hooks/use-many
[use-one]: /docs/data/hooks/use-one
[use-update]: /docs/data/hooks/use-update
[use-update-many]: /docs/data/hooks/use-update
[crud-sorting]: /docs/core/interface-references#crudsorting
[crud-filters]: /docs/core/interface-references#crudfilters
[pagination]: /docs/core/interface-references#pagination
[http-error]: /docs/core/interface-references#httperror
[meta-data]: /docs/core/interface-references#metaquery

================
File: data/hooks/use-api-url/index.md
================
---
title: useApiUrl
source: packages/core/src/hooks/data/useApiUrl.ts
---

`useApiUrl` is a React hook that returns the API URL. It uses the `getApiUrl` method to get the API URL from the [`dataProvider`][data provider].

It is useful when you want to use the API URL in your custom hooks.

## Usage

`useApiUrl` hook will invoke the `getApiUrl` method from the current resource's `dataProvider` and return the result. If no resource can be inferred, it will return default data provider's URL.

```tsx
//highlight-next-line
import { useCustom, useApiUrl } from "@refinedev/core";

interface PostUniqueCheckResponse {
  isAvailable: boolean;
}

//highlight-next-line
const apiUrl = useApiUrl();

const { data, isLoading } = useCustom<PostUniqueCheckResponse>({
  //highlight-next-line
  url: `${apiUrl}/posts-unique-check`,
  method: "get",
  config: {
    query: {
      title: "Foo bar",
    },
  },
});
```

`useApiUrl` hook also accepts optional `dataProviderName` parameter to explicitly get specific `dataProvider`'s URL regardless of current resource's `dataProvider`.

```tsx
export const App: React.FC = () => {
    return (
        <Refine
            // highlight-start
            dataProvider={{
                default: dataProvider("https://api.fake-rest.refine.dev/"),
                other: dataProvider("https://other-api.fake-rest.refine.dev/"),
            }}
            // highlight-end
        >
            {/* ... */}
        </Refine>
    );
};
    ...
</Refine>


const apiUrl = useApiUrl("other");
//    ^ https://other-api.fake-rest.refine.dev/
```

## API Reference

### Return value

| Description | Type     |
| ----------- | -------- |
| API URL     | `string` |

[data provider]: /docs/data/data-provider

================
File: data/hooks/use-create-many/index.md
================
---
title: useCreateMany
source: packages/core/src/hooks/data/useCreateMany.ts
---

`useCreateMany` is used for creating multiple records. It is an extended version of TanStack Query's [`useMutation`](https://tanstack.com/query/v4/docs/react/reference/useMutation) and not only supports all features of the mutation but also adds some extra features.

It uses the `createMany` method as the **mutation function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine />`.

If your data provider does not have a `createMany` method, `useCreateMany` will use the `create` method instead. This is not recommended, since it will make requests one by one for each record.

It is better to implement the `createMany` method in the data provider.

## Usage

The `useCreateMany` hook returns many useful properties and methods. One of them is the `mutate` method which is used to trigger a mutation with the given [parameters](#mutation-parameters).

```tsx
import { useCreateMany } from "@refinedev/core";

const { mutate } = useCreateMany({
  resource: "products",
});

mutate({
  values: [
    {
      name: "Product 1",
      material: "Wood",
    },
    {
      name: "Product 2",
      material: "Metal",
    },
  ],
});
```

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useCreateMany` mutation runs successfully, it will call the `publish` method from `liveProvider` with some parameters such as `channel`, `type` etc. It is useful when you want to publish the changes to the subscribers on the client side.

## Invalidating Queries

When the `useCreateMany` mutation runs successfully, it will invalidate the following queries from the current `resource`: `"list"` and `"many"` by default. Which means that, if you use `useList` or `useMany` hooks in the same page, they will refetch the data after the mutation is completed. You can change this behavior by passing [`invalidates`](#invalidates) prop.

> For more information, refer to the [invalidation documentation &#8594](https://tanstack.com/query/v4/docs/react/guides/query-invalidation)

## Audit Logs

> This feature is only available if you use a [Audit Log Provider](/docs/audit-logs/audit-log-provider).

When the `useCreateMany` mutation runs successfully, it will call the `log` method from `auditLogProvider` with some parameters such as `resource`, `action`, `data` etc. It is useful when you want to log the changes to the database.

## Properties

### mutationOptions

`mutationOptions` is used to pass options to the `useMutation` hook. It is useful when you want to pass additional options to the `useMutation` hook.

[Refer to the `useMutation` documentation for more information &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

```tsx
useCreateMany({
  mutationOptions: {
    retry: 3,
  },
  onSuccess: (data, variables, context) => {
    // Let's celebrate!
  },
  onError: (error, variables, context) => {
    // An error occurred!
  },
});
```

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useCreateMany({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## Mutation Parameters

Mutation parameters are passed to the `mutate` function and can also be provided as props to the `useCreateMany` hook. Parameters given to the `mutate` function override those from the hook. Think of the hook's parameters as default values, and the `mutate` function's parameters as specific or dynamic values for each mutation.

```tsx
import { useCreateMany } from "@refinedev/core";

const { mutate } = useCreateMany({
  /* parameters */
});

mutate({
  /* this will override the parameters given to the useCreateMany hook */
});
```

> 🚨 Parameters marked as required can be provided either as props to the `useCreateMany` hook or as parameters to the `mutate` function.

### resource <PropTag required />

This parameter will be passed to the `create` method from the `dataProvider` as a parameter. It is usually used as an API endpoint path but it all depends on how you handle the `resource` in the `create` method.

```tsx
const { mutate } = useCreateMany();

mutate({
  resource: "categories",
});
```

> For more information, refer to the [creating a data provider tutorial &#8594](/docs/data/data-provider)

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### values <PropTag required />

This prop will be passed to the `create` method from the `dataProvider` as a parameter. It is usually used as the data to be created and contains the data that will be sent to the server.

```tsx
const { mutate } = useCreateMany();

mutate({
  values: [
    {
      name: "Product 1",
      material: "Wood",
    },
    {
      name: "Product 2",
      material: "Metal",
    },
  ],
});
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the success notification that shows up when the data is fetched successfully and `useCreateMany` calls the `open` function from `NotificationProvider`:

```tsx
const { mutate } = useCreateMany();

mutate({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the error notification that shows up when the data fetching fails and the `useCreateMany` calls the `open` function from `NotificationProvider`

```tsx
const { mutate } = useCreateMany();

mutate({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `create` method. You can pass any properties to specifically handle the data provider methods with similar logic,.

```tsx
const { mutate } = useCreateMany();

mutate({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  createMany: async ({
    resource,
    variables,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;

    //...
    //...

    // highlight-next-line
    const { data } = await httpClient.post(url, variables, { headers });

    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### dataProviderName

This prop allows you to specify which `dataProvider` if you have more than one. Just pass it like in the example:

```tsx
const { mutate } = useCreateMany();

mutate({
  dataProviderName: "second-data-provider",
});
```

### invalidates

`invalidates` is used to specify which queries should be invalidated after the mutation is completed.

By default, it invalidates the following queries from the current `resource`: `"list"` and `"many"`. That means, if you use `useList` or `useMany` hooks on the same page, they will refetch the data after the mutation is completed.

```tsx
const { mutate } = useCreateMany();

mutate({
  invalidates: ["list", "many"],
});
```

## Return Values

Returns an object with TanStack Query's `useMutation` return values.

> For more information, refer to the [`useMutation` documentation &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useCreateMany();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## API Reference

### Mutation Parameters

| Property                      | Description                                                                                        | Type                                                                                   | Default                                                              |
| ----------------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| resource <PropTag asterisk /> | Resource name for API data interactions                                                            | `string`                                                                               |                                                                      |
| values <PropTag asterisk />   | Values for mutation function                                                                       | `TVariables[]`                                                                         | [{}]                                                                 |
| successNotification           | Successful Mutation notification                                                                   | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "Successfully created `resource`s"                                   |
| errorNotification             | Unsuccessful Mutation notification                                                                 | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "There was an error creating `resource` (status code: `statusCode`)" |
| meta                          | Meta data query for `dataProvider`                                                                 | [`MetaDataQuery`](/docs/core/interface-references#metaquery)                           | {}                                                                   |
| dataProviderName              | If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use. | `string`                                                                               | `default`                                                            |
| invalidates                   | You can use it to manage the invalidations that will occur at the end of the mutation.             | `all`, `resourceAll`, `list`, `many`, `detail`, `false`                                | `["list", "many"]`                                                   |

### Type Parameters

| Property   | Description                                                                                     | Type                                                       | Default                                                    |
| ---------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| TData      | Result data of the mutation. Extends [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) |
| TError     | Custom error object that extends [`HttpError`](/docs/core/interface-references#httperror)       | [`HttpError`](/docs/core/interface-references#httperror)   | [`HttpError`](/docs/core/interface-references#httperror)   |
| TVariables | Values for mutation function                                                                    | `{}`                                                       | `{}`                                                       |

### Return value

| Description                                | Type                                                                                                                                                                  |
| ------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Result of the TanStack Query's useMutation | [`UseMutationResult<{ data: TData[]}, TError, { resource: string; values: TVariables[]; }, unknown>`](https://tanstack.com/query/v4/docs/react/reference/useMutation) |
| overtime                                   | `{ elapsedTime?: number }`                                                                                                                                            |

================
File: data/hooks/use-create/index.md
================
---
title: useCreate
source: packages/core/src/hooks/data/useCreate.ts
---

`useCreate` is used when creating new records. It is an extended version of TanStack Query's [`useMutation`](https://tanstack.com/query/v4/docs/react/reference/useMutation) and not only supports all features of the mutation but also adds some extra features.

It uses the `create` method as the **mutation function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine />`.

## Usage

The `useCreate` hook returns many useful properties and methods. One of them is the `mutate` method which is used to trigger a mutation with the given [parameters](#mutation-parameters).

```tsx
import { useCreate } from "@refinedev/core";

const { mutate } = useCreate({
  resource: "products",
});

mutate({
  values: {
    name: "New Product",
    material: "Wood",
  },
});
```

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useCreate` mutation runs successfully, it will call the `publish` method from `liveProvider` with some parameters such as `channel`, `type` etc. This is useful when you want to publish the changes to the subscribers on the client side.

## Invalidating Queries

When the `useCreate` mutation runs successfully, it will invalidate the following queries from the current `resource`: `"list"` and `"many"` by default. Which means that, if you use `useList` or `useMany` hooks on the same page, they will refetch the data after the mutation is completed. You can change this behavior by passing the [`invalidates`](#invalidates) prop.

> For more information, refer to the [query invalidation documentation&#8594](https://tanstack.com/query/v4/docs/react/guides/query-invalidation)

## Audit Logs

> This feature is only available if you use a [Audit Log Provider](/docs/audit-logs/audit-log-provider).

When the `useCreate` mutation runs successfully, it will call the `log` method from `auditLogProvider` with some parameters such as `resource`, `action`, `data` etc. This is useful when you want to log the changes to the database.

## Properties

### mutationOptions

`mutationOptions` is used to pass options to the `useMutation` hook. It is useful when you want to pass additional options to the `useMutation` hook.

```tsx
const { mutate } = useCreate({
  resource: "products",
  mutationOptions: {
    retry: 3,
    onSuccess: (data, variables, context) => {
      // Let's celebrate!
    },
    onError: (error, variables, context) => {
      // An error occurred!
    },
  },
});

mutate({
  values: {
    name: "New Product",
    material: "Wood",
  },
});
```

[Refer to the `useMutation` documentation for more information &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useCreate({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## Mutation Parameters

Mutation parameters are passed to the `mutate` function and can also be provided as props to the `useCreate` hook. Parameters given to the `mutate` function override those from the hook. Think of the hook's parameters as default values, and the `mutate` function's parameters as specific or dynamic values for each mutation.

```tsx
import { useCreate } from "@refinedev/core";

const { mutate } = useCreate({
  /* parameters */
});

mutate({
  /* this will override the parameters given to the useCreate hook */
});
```

> 🚨 Parameters marked as required can be provided either as props to the `useCreate` hook or as parameters to the `mutate` function.

### resource <PropTag required />

This parameter will be passed to the `create` method from the `dataProvider` as a parameter. It is usually used as an API endpoint path but it all depends on how you handle the `resource` in the `create` method.

```tsx
const { mutate } = useCreate();

mutate({
  resource: "categories",
});
```

> For more information, refer to the [creating a data provider tutorial &#8594](/docs/data/data-provider)

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### values <PropTag required />

This prop will be passed to the `create` method from the `dataProvider` as a parameter. It is usually used as the data to be created and contains the data that will be sent to the server.

```tsx
const { mutate } = useCreate();

mutate({
  values: {
    name: "New Category",
    description: "New Category Description",
  },
});
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the success notification that shows up when the data is fetched successfully and `useCreate` calls the `open` function from `NotificationProvider`:

```tsx
const { mutate } = useCreate();

mutate({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the error notification that shows up when the data fetching fails and the `useCreate` calls the `open` function from `NotificationProvider`

```tsx
const { mutate } = useCreate();

mutate({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `create` method. You can pass any properties to specifically handle the data provider methods with similar logic.

```tsx
const { mutate } = useCreate();

mutate({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  create: async ({
    resource,
    variables,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;

    //...
    //...

    // highlight-next-line
    const { data } = await httpClient.post(url, variables, { headers });

    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### dataProviderName

This prop allows you to specify which `dataProvider` if you have more than one. Just pass it like in the example:

```tsx
const { mutate } = useCreate();

mutate({
  dataProviderName: "second-data-provider",
});
```

### invalidates

`invalidates` is used to specify which queries should be invalidated after the mutation is completed.

By default, it invalidates the following queries from the current `resource`: `"list"` and `"many"`. That means, if you use `useList` or `useMany` hooks on the same page, they will refetch the data after the mutation is completed.

```tsx
const { mutate } = useCreate();

mutate({
  invalidates: ["list", "many"],
});
```

## Return Values

Returns an object with TanStack Query's `useMutation` return values.

> For more information, refer to the [`useMutation` documentation &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useCreate();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## API Reference

### Mutation Parameters

| Property                      | Description                                                                                        | Type                                                                                   | Default                                                              |
| ----------------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| resource <PropTag asterisk /> | Resource name for API data interactions                                                            | `string`                                                                               |                                                                      |
| values <PropTag asterisk />   | Values for mutation function                                                                       | `TVariables`                                                                           | {}                                                                   |
| successNotification           | Successful Mutation notification                                                                   | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "Successfully created `resource`"                                    |
| errorNotification             | Unsuccessful Mutation notification                                                                 | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "There was an error creating `resource` (status code: `statusCode`)" |
| meta                          | Meta data query for `dataProvider`                                                                 | [`MetaDataQuery`](/docs/core/interface-references#metaquery)                           | {}                                                                   |
| dataProviderName              | If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use. | `string`                                                                               | `default`                                                            |
| invalidates                   | You can use it to manage the invalidations that will occur at the end of the mutation.             | `all`, `resourceAll`, `list`, `many`, `detail`, `false`                                | `["list", "many"]`                                                   |

### Type Parameters

| Property   | Description                                                                                     | Type                                                       | Default                                                    |
| ---------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| TData      | Result data of the mutation. Extends [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) |
| TError     | Custom error object that extends [`HttpError`](/docs/core/interface-references#httperror)       | [`HttpError`](/docs/core/interface-references#httperror)   | [`HttpError`](/docs/core/interface-references#httperror)   |
| TVariables | Values for mutation function                                                                    | `{}`                                                       | `{}`                                                       |

### Return value

| Description                                | Type                                                                                                                                                               |
| ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Result of the TanStack Query's useMutation | [`UseMutationResult<{ data: TData }, TError, { resource: string; values: TVariables; }, unknown>`](https://tanstack.com/query/v4/docs/react/reference/useMutation) |
| overtime                                   | `{ elapsedTime?: number }`                                                                                                                                         |

================
File: data/hooks/use-custom-mutation/index.md
================
---
title: useCustomMutation
source: packages/core/src/hooks/data/useCustomMutation.ts
---

`useCustomMutation` is used when sending custom mutation requests using the TanStack Query advantages. It is an extended version of TanStack Query's [`useMutation`](https://tanstack.com/query/v4/docs/react/reference/useMutation) and not only supports all features of the mutation but also adds some extra features.

It uses the `custom` method as the **mutation function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine>`.

:::caution Use Cases

`useCustomMutation` should **not** be used when creating, updating, or deleting a resource. Following hooks should be used for these instead: [useCreate](/docs/data/hooks/use-create), [useUpdate](/docs/data/hooks/use-update) or [useDelete](/docs/data/hooks/use-delete).

This is because `useCustomMutation`, unlike other data hooks, does not [invalidate queries](https://tanstack.com/query/latest/docs/react/guides/query-invalidation) and therefore will not update the application state either.

If you need to custom query request, use the [useCustom](/docs/data/hooks/use-custom) hook.

:::

## Basic Usage

The `useCustomMutation` hook returns many useful properties and methods. One of them is the `mutate` method which expects `values`, `method`, and `url` as parameters. These parameters will be passed to the `custom` method from the `dataProvider` as parameters.

```tsx
import { useCustomMutation, useApiUrl } from "@refinedev/core";

interface ICategory {
  id: number;
  title: string;
}

const apiUrl = useApiUrl();

const { mutate } = useCustomMutation<ICategory>();

mutate({
  url: `${API_URL}/categories`,
  method: "post",
  values: {
    title: "New Category",
  },
});
```

## Properties

### mutationOptions

`mutationOptions` is used to pass options to the `useMutation` hook. It is useful when you want to pass additional options to the `useMutation` hook.

> For more information, refer to the [`useMutation` documentation &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

```tsx
useCustomMutation({
  mutationOptions: {
    retry: 3,
  },
});
```

`mutationOptions` does not support `onSuccess` and `onError` props because they override the default `onSuccess` and `onError` functions. If you want to use these props, you can pass them to mutate functions like this:

```tsx
const { mutate } = useCustomMutation();

mutate(
  {
    url: `${API_URL}/categories`,
    method: "post",
    values: {
      title: "New Category",
    },
  },
  {
    onError: (error, variables, context) => {
      // An error occurred!
    },
    onSuccess: (data, variables, context) => {
      // Let's celebrate!
    },
  },
);
```

## Mutation Parameters

### url <PropTag required />

It will be passed to the `custom` method from the `dataProvider` as a parameter. It is usually used to specify the endpoint of the request.

```tsx
const { mutate } = useCustomMutation();

mutate({
  url: "www.example.com/api/update-products",
});
```

### method <PropTag required />

It will be passed to the `custom` method from the `dataProvider` as a parameter. It is usually used to specify the HTTP method of the request.

```tsx
const { mutate } = useCustomMutation();

mutate({
  method: "post",
});
```

### values <PropTag required />

It will be passed to the `custom` method from the `dataProvider` as a parameter. The parameter is usually used as the data to be sent with the request.

```tsx
const { mutate } = useCustomMutation();

mutate({
  values: {
    name: "New Category",
    description: "New Category Description",
  },
});
```

### config.headers

It will be passed to the `custom` method from the `dataProvider` as a parameter. It can be used to specify the headers of the request.

```tsx
const { mutate } = useCustomMutation();

mutate({
  config: {
    headers: {
      "x-custom-header": "foo-bar",
    },
  },
});
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the success notification that shows up when the data is fetched successfully and `useCustomMutation` calls the `open` function from `NotificationProvider`:

```tsx
const { mutate } = useCustomMutation();

mutate({
  successNotification: (data, values) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useCustomMutation` will call `open` function from `NotificationProvider` to show an error notification. With this prop, you can customize the error notification.

```tsx
const { mutate } = useCustomMutation();

mutate({
  errorNotification: (data, values) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, `meta` is passed to the `custom` method from the `dataProvider` as a parameter.

```tsx
const { mutate } = useCustomMutation();

mutate({
  meta: {
    foo: "bar",
  },
});

const myDataProvider = {
  //...
  custom: async ({
    url,
    method,
    sort,
    filters,
    payload,
    query,
    headers,
    meta,
  }) => {
    const foo = meta?.foo;

    console.log(foo); // "bar"

    //...
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### dataProviderName

If there is more than one `dataProvider`, you can specify which one to use by passing the `dataProviderName` prop. It is useful when you have a different data provider for different resources.

```tsx
const { mutate } = useCustomMutation();

mutate({
  dataProviderName: "second-data-provider",
});
```

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useCustomMutation({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## Return Values

Returns an object with TanStack Query's `useMutation` return values.

[Refer to the `useMutation` documentation for more information &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useCustomMutation();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## API Reference

### Mutation Parameters

| Property                    | Description                                                                                        | Type                                                                                   |
| --------------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| url <PropTag asterisk />    | URL                                                                                                | string                                                                                 |
| method <PropTag asterisk /> | Method                                                                                             | `post`, `put`, `patch`, `delete`                                                       |
| values <PropTag asterisk /> | Values for mutation function                                                                       | `TVariables`                                                                           |
| config                      | The config of your request. You can send `headers` using this field.                               | { headers?: {}; }                                                                      |
| successNotification         | Successful mutation notification                                                                   | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) |
| errorNotification           | Unsuccessful mutation notification                                                                 | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) |
| meta                        | Meta data query for `dataProvider`                                                                 | [`MetaDataQuery`](/docs/core/interface-references#metaquery)                           |
| dataProviderName            | If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use. | `string`                                                                               |

### Type Parameters

| Property | Description                                                                                  | Type                                                       | Default                                                    |
| -------- | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| TData    | Result data of the query. Extends [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) |
| TError   | Custom error object that extends [`HttpError`](/docs/core/interface-references#httperror)    | [`HttpError`](/docs/core/interface-references#httperror)   | [`HttpError`](/docs/core/interface-references#httperror)   |
| TQuery   | Values for query params.                                                                     | `TQuery`                                                   | unknown                                                    |
| TPayload | Values for params.                                                                           | `TPayload`                                                 | unknown                                                    |

### Return value

| Description                                | Type                                                                                                                                                               |
| ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Result of the TanStack Query's useMutation | [`UseMutationResult<{ data: TData }, TError, { resource: string; values: TVariables; }, unknown>`](https://tanstack.com/query/v4/docs/react/reference/useMutation) |
| overtime                                   | `{ elapsedTime?: number }`                                                                                                                                         |

================
File: data/hooks/use-custom/index.md
================
---
title: useCustom
source: packages/core/src/hooks/data/useCustom.ts
---

`useCustom` is used to send custom query requests using the Tanstack Query advantages. It is an extended version of TanStack Query's [`useQuery`](https://tanstack.com/query/v4/docs/react/reference/useQuery) and not only supports all features of the mutation but also adds some extra features.

It uses the `custom` method as the **query function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine>`.

:::caution Use Cases

`useCustom` should **not** be used when creating, updating, or deleting a resource. Following hooks should be used for these instead: [useCreate](/docs/data/hooks/use-create), [useUpdate](/docs/data/hooks/use-update) or [useDelete](/docs/data/hooks/use-delete)

This is because `useCustom`, unlike other data hooks, does not [invalidate queries](https://tanstack.com/query/latest/docs/react/guides/query-invalidation) and therefore will not update the application state either.

If you need to customize the mutation request, use the [useCustomMutation](/docs/data/hooks/use-custom-mutation) hook instead.

:::

## Basic Usage

The `useCustom` hook expects the `url` and `method` properties, which will be passed to the `custom` method from the `dataProvider` as parameters.

When properties are changed, the `useCustom` hook will trigger a new request.

```tsx
import { useCustom, useApiUrl } from "@refinedev/core";

interface PostUniqueCheckResponse {
  isAvailable: boolean;
}

const apiUrl = useApiUrl();

const { data, isLoading } = useCustom<PostUniqueCheckResponse>({
  url: `${apiUrl}/posts-unique-check`,
  method: "get",
  config: {
    headers: {
      "x-custom-header": "foo-bar",
    },
    query: {
      title: "Foo bar",
    },
  },
});
```

## Properties

### url <PropTag required />

This prop will be passed to the `custom` method from the `dataProvider` as a parameter. It is usually used to specify the endpoint of the request.

```tsx
useCustom({
  url: "www.example.com/api/get-products",
});
```

### method <PropTag required />

It will be passed to the `custom` method from the `dataProvider` as a parameter. It is usually used to specify the HTTP method of the request.

```tsx
useCustom({
  method: "get",
});
```

### config.headers

It will be passed to the `custom` method from the `dataProvider` as a parameter. It can be used to specify the headers of the request.

```tsx
useCustom({
  config: {
    headers: {
      "x-custom-header": "foo-bar",
    },
  },
});
```

### config.query

It will be passed to the `custom` method from the `dataProvider` as a parameter. It can be used to specify the query parameters of the request.

```tsx
useCustom({
  config: {
    query: {
      title: "Foo bar",
    },
  },
});
```

### config.payload

It will be passed to the `custom` method from the `dataProvider` as a parameter. It can be used to specify the payload of the request.

```tsx
useCustom({
  config: {
    payload: {
      title: "Foo bar",
    },
  },
});
```

### config.sorters

It will be passed to the `custom` method from the `dataProvider` as a parameter. It can be used to send the sort query parameters of the request.

```tsx
useCustom({
  config: {
    sorters: [
      {
        field: "title",
        order: "asc",
      },
    ],
  },
});
```

### config.filters

It will be passed to the `custom` method from the `dataProvider` as a parameter. It can be used to send the filter query parameters of the request.

```tsx
useCustom({
  config: {
    filters: [
      {
        field: "title",
        operator: "contains",
        value: "Foo",
      },
    ],
  },
});
```

### ~~`config.sort`~~ <PropTag deprecated />

Use `config.sorters` instead.

### queryOptions

`queryOptions` is used to pass additional options to the `useQuery` hook. It is useful when you want to pass additional options to the `useQuery` hook.

> For more information, refer to the [`useQuery` documentation &#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

```tsx
useCustom({
  queryOptions: {
    retry: 3,
    enabled: false,
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, `meta` is passed to the `custom` method from the `dataProvider` as a parameter:

```tsx
useCustom({
  meta: {
    foo: "bar",
  },
});

const myDataProvider = {
  //...
  custom: async ({
    url,
    method,
    sort,
    filters,
    payload,
    query,
    headers,
    meta,
  }) => {
    const foo = meta?.foo;

    console.log(foo); // "bar"

    //...
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### dataProviderName

This prop allows you to specify which `dataProvider` if you have more than one. Just pass it like in the example:

```tsx
useCustom({
  dataProviderName: "second-data-provider",
});
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the success notification that shows up when the data is fetched successfully and `useCustom` calls the `open` function from `NotificationProvider`:

```tsx
useCustom({
  successNotification: (data, values) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the error notification that shows up when the data fetching fails and the `useCustom` calls the `open` function from `NotificationProvider`

```tsx
useCustom({
  errorNotification: (data, values) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useCustom({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## FAQ

### How to invalidate the custom query?

To invalidate a query, you can use the `invalidateQueries` method from the `useQueryClient` hook provided by the `@tanstack/react-query` library:

```tsx
import { useQueryClient } from "@tanstack/react-query";

const queryClient = useQueryClient();

queryClient.invalidateQueries(["custom-key"]);
```

Note that you'll need to know the query key to invalidate the query. If you don't know the query key, you can use the `queryOptions` property of the `useCustom` hook:

```tsx
import { useCustom } from "@refinedev/core";

useCustom({
  queryOptions: {
    queryKey: ["custom-key"],
  },
});
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/useCustom" />

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TQuery       | Values for query params.                                                                                                                                            | `TQuery`                   | unknown                    |
| TPayload     | Values for params.                                                                                                                                                  | `TPayload`                 | unknown                    |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return value

| Description                             | Type                                                                                                                |
| --------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| Result of the TanStack Query's useQuery | [`QueryObserverResult<CustomResponse<TData>, TError>`](https://tanstack.com/query/v4/docs/react/reference/useQuery) |
| overtime                                | `{ elapsedTime?: number }`                                                                                          |

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: data/hooks/use-data-provider/index.md
================
---
title: useDataProvider
source: packages/core/src/hooks/data/useDataProvider.tsx
---

`useDataProvider` is a React hook that returns the `dataProvider` which is passed to [`<Refine>`][Refine] component.

It is useful when you have multiple data providers and you want to access one of them.

## Usage

Let's say we have two data providers:

```tsx
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";

const App = () => (
  <Refine
    dataProvider={{
      default: dataProvider("API_URL"),
      second: dataProvider("SECOND_API_URL"),
    }}
  >
    {/* ... */}
  </Refine>
);
```

Now we can access the data providers with the `useDataProvider` hook:

```tsx
import { useDataProvider } from "@refinedev/core";

const dataProvider = useDataProvider();

const defaultDataProvider = dataProvider(); // return default data provider
const secondDataProvider = dataProvider("second"); // return second data provider
```

## API Reference

### Properties

| Property         | Description                                      | Type     | Default   |
| ---------------- | ------------------------------------------------ | -------- | --------- |
| dataProviderName | The name of the data provider you want to access | `string` | `default` |

### Return value

| Description   | Type                                        |
| ------------- | ------------------------------------------- |
| Data Provider | [`Data Provider`](/docs/data/data-provider) |

[Refine]: /docs/core/refine-component
[data provider]: /docs/data/data-provider

================
File: data/hooks/use-delete-many/index.md
================
---
title: useDeleteMany
siderbar_label: useDeleteMany
source: packages/core/src/hooks/data/useDeleteMany.ts
---

`useDeleteMany` is used when you want to delete multiple records at once. It is an extended version of TanStack Query's [`useMutation`](https://tanstack.com/query/v4/docs/react/reference/useMutation) and not only supports all features of the mutation but also adds some extra features.

It uses the `deleteMany` method as the **mutation function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine>`.

If your data provider does not have a `deleteMany` method, `useDeleteMany` will use the `deleteOne` method instead. This is not recommended since it will make requests one by one for each id.

It is better to implement the `deleteMany` method in the data provider.

## Usage

The `useDeleteMany` hook returns many useful properties and methods. One of them is the `mutate` method which expects `resource` and `ids` as parameters. These parameters will be passed to the `deleteMany` method from the `dataProvider` as parameters.

```tsx
import { useDeleteMany } from "@refinedev/core";

const { mutate } = useDeleteMany();

mutate({
  resource: "products",
  ids: [1, 2, 3],
});
```

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useDeleteMany` mutation runs successfully, it will call the `publish` method from `liveProvider` with some parameters such as `channel`, `type` etc. This is useful when you want to publish the changes to the subscribers on the client side.

## Invalidating Queries

When the `useDeleteMany` mutation runs successfully, it will invalidate the following queries from the current `resource`: `"list"` and `"many"` by default. Which means that, if you use `useList` or `useMany` hooks on the same page, they will refetch the data after the mutation is completed. You can change this behavior by passing [`invalidates`](#invalidates) prop.

> For more information, refer to the [invalidation documentation &#8594](https://tanstack.com/query/v4/docs/react/guides/query-invalidation)

## Properties

### mutationOptions

`mutationOptions` is used to pass options to the `useMutation` hook. It is useful when you want to pass additional options to the `useMutation` hook.

[Refer to the `useMutation` documentation for more information &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

```tsx
useDeleteMany({
  mutationOptions: {
    retry: 3,
  },
});
```

`mutationOptions` does not support `onSuccess` and `onError` props because they override the default `onSuccess` and `onError` functions. If you want to use these props, you can pass them to mutate functions like this:

```tsx
const { mutate } = useDeleteMany();

mutate(
  {
    resource: "products",
    ids: [1, 2, 3],
  },
  {
    onError: (error, variables, context) => {
      // An error occurred!
    },
    onSuccess: (data, variables, context) => {
      // Let's celebrate!
    },
  },
);
```

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useDeleteMany({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## Mutation Parameters

### resource <PropTag required />

This parameter will be passed to the `deleteMany` method from the `dataProvider` as a parameter. It is usually used as an API endpoint path but it all depends on how you handle the `resource` in the `deleteMany` method.

```tsx
const { mutate } = useDeleteMany();

mutate({
  resource: "categories",
});
```

> For more information, refer to the [creating a data provider tutorial &#8594](/docs/data/data-provider)

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### ids <PropTag required />

This parameter will be passed to the `deleteMany` method from the `dataProvider` as a parameter. It is used to determine which records to deleted.

```tsx
const { mutate } = useDeleteMany();

mutate({
  ids: [1, 2, 3],
});
```

### mutationMode

Mutation mode determines which mode the mutation runs with. Mutations can run under three different modes: `pessimistic`, `optimistic`, and `undoable`. The default mode is `pessimistic`.
Each mode corresponds to a different type of user experience.

> For more information, refer to the [mutation mode documentation &#8594](/docs/advanced-tutorials/mutation-mode)

```tsx
const { mutate } = useDeleteMany();

mutate({
  mutationMode: "undoable",
});
```

### undoableTimeout

When `mutationMode` is set to `undoable`, `undoableTimeout` is used to determine the duration to wait before executing the mutation. The default value is `5000` milliseconds.

```tsx
const { mutate } = useDeleteMany();

mutate({
  mutationMode: "undoable",
  undoableTimeout: 10000,
});
```

### onCancel

The `onCancel` property can be utilized when the `mutationMode` is set to `"undoable"`. It provides a function that can be used to cancel the ongoing mutation.

By defining `onCancel`, undoable notification will not be shown automatically. This gives you the flexibility to handle the cancellation process in your own way, such as showing a custom notification or implementing any other desired behavior to allow users to cancel the mutation.

```tsx
import { useRef } from "react";
import { useDeleteMany } from "@refinedev/core";

const MyComponent = () => {
  const { mutate } = useDeleteMany();
  const cancelRef = useRef<(() => void) | null>(null);

  const deleteItems = () => {
    mutate({
      //...
      mutationMode: "undoable",
      onCancel: (cancelMutation) => {
        cancelRef.current = cancelMutation;
      },
    });
  };

  const cancelDelete = () => {
    cancelRef.current?.();
  };

  return (
    <>
      <button onClick={deleteItems}>Delete</button>
      <button onClick={cancelDelete}>Cancel</button>
    </>
  );
};
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the success notification that shows up when the data is fetched successfully and `useDeleteMany` calls `open` function from `NotificationProvider`:

```tsx
const { mutate } = useDeleteMany();

mutate({
  successNotification: (data, ids, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the error notification that shows up when the data fetching fails and the `useDeleteMany` calls `open` function from `NotificationProvider`:

```tsx
const { mutate } = useDeleteMany();

mutate({
  errorNotification: (data, ids, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `deleteMany` method. You can pass any properties to specifically handle the data provider methods with similar logic.

```tsx
const { mutate } = useDeleteMany();

mutate({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  deleteMany: async ({
    resource,
    ids,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;

    //...
    //...

    // highlight-start
    const { data } = await httpClient.delete(url, { ids }, { headers });
    // highlight-end

    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### dataProviderName

This prop allows you to specify which `dataProvider` if you have more than one. Just pass it like in the example:

```tsx
const { mutate } = useDeleteMany();

mutate({
  dataProviderName: "second-data-provider",
});
```

### invalidates

`invalidates` is used to specify which queries should be invalidated after the mutation is completed.

By default, it invalidates the following queries from the current `resource`: `"list"` and `"many"`. That means, if you use `useList` or `useMany` hooks on the same page, they will refetch the data after the mutation is completed.

```tsx
const { mutate } = useDeleteMany();

mutate({
  invalidates: ["list", "many", "detail"],
});
```

## Return Values

Returns an object with TanStack Query's `useMutation` return values.

> For more information, refer to the [`useMutation` documentation &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useDeleteMany();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## API Reference

### Mutation Parameters

| Property                      | Description                                                                                        | Type                                                                                   | Default                                                      |
| ----------------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| resource <PropTag asterisk /> | Resource name for API data interactions                                                            | `string`                                                                               |                                                              |
| ids <PropTag asterisk />      | ids for mutation function                                                                          | [`BaseKey[]`](/docs/core/interface-references#basekey)                                 |                                                              |
| mutationMode                  | [Determines when mutations are executed](/docs/advanced-tutorials/mutation-mode)                   | ` "pessimistic` \| `"optimistic` \| `"undoable"`                                       | `"pessimistic"`\*                                            |
| undoableTimeout               | Duration to wait before executing the mutation when `mutationMode = "undoable"`                    | `number`                                                                               | `5000ms`\*                                                   |
| onCancel                      | Provides a function to cancel the mutation when `mutationMode = "undoable"`                        | `(cancelMutation: () => void) => void`                                                 |                                                              |
| successNotification           | Successful Mutation notification                                                                   | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "Successfully deleted `resource`"                            |
| errorNotification             | Unsuccessful Mutation notification                                                                 | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "Error when updating `resource` (status code: `statusCode`)" |
| meta                          | Meta data query for `dataProvider`                                                                 | [`MetaDataQuery`](/docs/core/interface-references#metaquery)                           | {}                                                           |
| dataProviderName              | If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use. | `string`                                                                               | `default`                                                    |
| invalidates                   | You can use it to manage the invalidations that will occur at the end of the mutation.             | `all`, `resourceAll`, `list`, `many`, `detail`, `false`                                | `["list", "many"]`                                           |

:::simple Global Configuration

These props have default values in `RefineContext` and can also be set on [`<Refine>`](/docs/core/refine-component) component. `useDeleteMany` will use what is passed to `<Refine>` as default but a local value will override it.

:::

### Type Parameters

| Property   | Description                                                                                     | Type                                                       | Default                                                    |
| ---------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| TData      | Result data of the mutation. Extends [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) |
| TError     | Custom error object that extends [`HttpError`](/docs/core/interface-references#httperror)       | [`HttpError`](/docs/core/interface-references#httperror)   | [`HttpError`](/docs/core/interface-references#httperror)   |
| TVariables | Values for mutation function                                                                    | `{}`                                                       | `{}`                                                       |

### Return value

| Description                                | Type                                                                                                                                                                   |
| ------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Result of the TanStack Query's useMutation | [`UseMutationResult<{ data: TData }, TError, { resource: string; ids: BaseKey[]; }, DeleteContext>`](https://tanstack.com/query/v4/docs/react/reference/useMutation)\* |
| overtime                                   | `{ elapsedTime?: number }`                                                                                                                                             |

================
File: data/hooks/use-delete/index.md
================
---
title: useDelete
siderbar_label: useDelete
source: packages/core/src/hooks/data/useDelete.ts
---

`useDelete` is used when you want to delete a record. It is an extended version of TanStack Query's [`useMutation`](https://tanstack.com/query/v4/docs/react/reference/useMutation) and not only supports all features of the mutation but also adds some extra features.

It uses the `deleteOne` method as the **mutation function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine>`.

## Usage

The `useDelete` hook returns many useful properties and methods. One of them is the `mutate` method which expects `resource` and `id` as parameters. These parameters will be passed to the `deleteOne` method from the `dataProvider` as parameters.

```tsx
import { useDelete } from "@refinedev/core";

const { mutate } = useDelete();

mutate({
  resource: "products",
  id: 1,
});
```

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useDelete` mutation runs successfully, it will call the `publish` method from `liveProvider` with some parameters such as `channel`, `type` etc. This is useful when you want to publish the changes to the subscribers on the client side.

## Invalidating Queries

When the `useDelete` mutation runs successfully, it will invalidate the following queries from the current `resource`: `"list"` and `"many"` by default. Which means that, if you use `useList` or `useMany` hooks on the same page, they will refetch the data after the mutation is completed. You can change this behavior by passing [`invalidates`](#invalidates) prop.

> For more information, refer to the [invalidation documentation &#8594](https://tanstack.com/query/v4/docs/react/guides/query-invalidation)

## Audit Logs

> This feature is only available if you use a [Audit Log Provider](/docs/audit-logs/audit-log-provider).

When the `useDelete` mutation runs successfully, it will call the `log` method from `auditLogProvider` with some parameters such as `resource`, `action`, `data`, `previousData` etc. This is useful when you want to log the changes to the database.

## Properties

### mutationOptions

`mutationOptions` is used to pass options to the `useMutation` hook. It is useful when you want to pass additional options to the `useMutation` hook.

[Refer to the `useMutation` documentation for more information &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

```tsx
useDelete({
  mutationOptions: {
    retry: 3,
  },
});
```

`mutationOptions` does not support `onSuccess` and `onError` props because they override the default `onSuccess` and `onError` functions. If you want to use these props, you can pass them to mutate functions like this:

```tsx
const { mutate } = useDelete();

mutate(
  {
    resource: "products",
    id: 1,
  },
  {
    onError: (error, variables, context) => {
      // An error occurred!
    },
    onSuccess: (data, variables, context) => {
      // Let's celebrate!
    },
  },
);
```

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useDelete({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## Mutation Parameters

### resource <PropTag required />

This parameter will be passed to the `deleteOne` method from the `dataProvider` as a parameter. It is usually used as an API endpoint path but it all depends on how you handle the `resource` in the `deleteOne` method.

```tsx
const { mutate } = useDelete();

mutate({
  resource: "categories",
});
```

> For more information, refer to the [creating a data provider tutorial &#8594](/docs/data/data-provider)

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### id <PropTag required />

This parameter will be passed to the `deleteOne` method from the `dataProvider` as a parameter. It is used to determine which record to delete.

```tsx
const { mutate } = useDelete();

mutate({
  id: 123,
});
```

### mutationMode

Mutation mode determines which mode the mutation runs with. Mutations can run under three different modes: `pessimistic`, `optimistic`, and `undoable`. The default mode is `pessimistic`.
Each mode corresponds to a different type of user experience.

> For more information, refer to the [mutation mode documentation &#8594](/docs/advanced-tutorials/mutation-mode)

```tsx
const { mutate } = useDelete();

mutate({
  mutationMode: "undoable",
});
```

### undoableTimeout

When `mutationMode` is set to `undoable`, `undoableTimeout` is used to determine the duration to wait before executing the mutation. The default value is `5000` milliseconds.

```tsx
const { mutate } = useDelete();

mutate({
  mutationMode: "undoable",
  undoableTimeout: 10000,
});
```

### onCancel

The `onCancel` property can be utilized when the `mutationMode` is set to `"undoable"`. It provides a function that can be used to cancel the ongoing mutation.

By defining `onCancel`, undoable notification will not be shown automatically. This gives you the flexibility to handle the cancellation process in your own way, such as showing a custom notification or implementing any other desired behavior to allow users to cancel the mutation.

```tsx
import { useRef } from "react";
import { useDelete } from "@refinedev/core";

const MyComponent = () => {
  const { mutate } = useDelete();
  const cancelRef = useRef<(() => void) | null>(null);

  const deleteItem = () => {
    mutate({
      //...
      mutationMode: "undoable",
      onCancel: (cancelMutation) => {
        cancelRef.current = cancelMutation;
      },
    });
  };

  const cancelDelete = () => {
    cancelRef.current?.();
  };

  return (
    <>
      <button onClick={deleteItem}>Delete</button>
      <button onClick={cancelDelete}>Cancel</button>
    </>
  );
};
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the success notification that shows up when the data is fetched successfully and `useDelete` calls the `open` function from `NotificationProvider`:

```tsx
const { mutate } = useDelete();

mutate({
  successNotification: (data, id, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the error notification that shows up when the data fetching fails and the `useDelete` calls the `open` function from `NotificationProvider`:

```tsx
const { mutate } = useDelete();

mutate({
  errorNotification: (data, id, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `deleteOne` method. You can pass any properties to specifically handle the data provider methods with similar logic.

```tsx
const { mutate } = useDelete();

mutate({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  deleteOne: async ({
    resource,
    id,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}/${id}`;

    //...
    //...

    // highlight-next-line
    const { data } = await httpClient.delete(url, undefined, { headers });

    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### dataProviderName

This prop allows you to specify which `dataProvider` if you have more than one. Just pass it like in the example:

```tsx
const { mutate } = useDelete();

mutate({
  dataProviderName: "second-data-provider",
});
```

### invalidates

`invalidates` is used to specify which queries should be invalidated after the mutation is completed.

By default, it invalidates the following queries from the current `resource`: `"list"` and `"many"`. That means, if you use `useList` or `useMany` hooks on the same page, they will refetch the data after the mutation is completed.

```tsx
const { mutate } = useDelete();

mutate({
  invalidates: ["list", "many"],
});
```

## Return Values

Returns an object with TanStack Query's `useMutation` return values.

> For more information, refer to the [`useMutation` documentation &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useDelete();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## API Reference

### Mutation Parameters

| Property                      | Description                                                                                        | Type                                                                                   | Default                             |
| ----------------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | ----------------------------------- |
| resource <PropTag asterisk /> | Resource name for API data interactions                                                            | `string`                                                                               |                                     |
| id <PropTag asterisk />       | id for mutation function                                                                           | [`BaseKey`](/docs/core/interface-references#basekey)                                   |                                     |
| mutationMode                  | [Determines when mutations are executed](/docs/advanced-tutorials/mutation-mode)                   | ` "pessimistic` \| `"optimistic` \| `"undoable"`                                       | `"pessimistic"`\*                   |
| undoableTimeout               | Duration to wait before executing the mutation when `mutationMode = "undoable"`                    | `number`                                                                               | `5000ms`\*                          |
| onCancel                      | Provides a function to cancel the mutation when `mutationMode = "undoable"`                        | `(cancelMutation: () => void) => void`                                                 |                                     |
| successNotification           | Successful Mutation notification                                                                   | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "Successfully deleted a `resource`" |
| errorNotification             | Unsuccessful Mutation notification                                                                 | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "Error (status code: `status`"      |
| meta                          | Meta data query for `dataProvider`                                                                 | [`MetaDataQuery`](/docs/core/interface-references#metaquery)                           | {}                                  |
| dataProviderName              | If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use. | `string`                                                                               | `default`                           |
| invalidates                   | You can use it to manage the invalidations that will occur at the end of the mutation.             | `all`, `resourceAll`, `list`, `many`, `detail`, `false`                                | `["list", "many"]`                  |

:::simple Global Configuration

These props have default values in `RefineContext` and can also be set on [`<Refine>`](/docs/core/refine-component) component. `useDelete` will use what is passed to `<Refine>` as default but a local value will override it.

:::

### Type Parameters

| Property   | Description                                                                                     | Type                                                       | Default                                                    |
| ---------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| TData      | Result data of the mutation. Extends [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) |
| TError     | Custom error object that extends [`HttpError`](/docs/core/interface-references#httperror)       | [`HttpError`](/docs/core/interface-references#httperror)   | [`HttpError`](/docs/core/interface-references#httperror)   |
| TVariables | Values for mutation function                                                                    | `{}`                                                       | `{}`                                                       |

### Return value

| Description                                | Type                                                                                                                                            |
| ------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| Result of the TanStack Query's useMutation | [`UseMutationResult<{ data: TData }, TError, { id: BaseKey; }, DeleteContext>`](https://tanstack.com/query/v4/docs/react/reference/useMutation) |
| overtime                                   | `{ elapsedTime?: number }`                                                                                                                      |

================
File: data/hooks/use-form/basic-usage.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BasicUsage() {
  return (
    <Sandpack
      // showNavigator
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/products/create"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "/list.tsx": {
          code: ListTsxCode,
          hidden: true,
        },
        "/show.tsx": {
          code: ShowTsxCode,
          hidden: true,
        },
        "/create.tsx": {
          code: CreateTsxCode,
          active: true,
        },
        "/edit.tsx": {
          code: EditTsxCode,
        },
        "/clone.tsx": {
          code: CloneTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { BrowserRouter, Route, Routes, Navigate, Link, Outlet } from "react-router";
import routerProvider from "@refinedev/react-router";
import "./style.css";
import { List } from "./list.tsx";
import { Show } from "./show.tsx";
import { Clone } from "./clone.tsx";
import { Edit } from "./edit.tsx";
import { Create } from "./create.tsx";
const Layout = ({ children }) => {
    return (
        <div>
            <div style={{ padding: "10px 0", display: "flex", gap: "10px" }}>
                <Link to="/products/create">Create Product</Link>
                <Link to="/products/edit/123">Edit Product #123</Link>
                <Link to="/products/clone/123">Clone Product #123</Link>
            </div>
            <div>
                {children}
            </div>
        </div>
    );
};
export default function App() {
    return (
        <BrowserRouter>
            <Refine
                routerProvider={routerProvider}
                dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
                resources={[
                    {
                        name: "products",
                        list: "/products",
                        show: "/products/:id",
                        create: "/products/create",
                        edit: "/products/edit/:id",
                        clone: "/products/clone/:id",
                    }
                ]}
            >
                <Routes>
                    <Route index element={<Navigate to="/products" />} />
                    <Route path="/products" element={<Layout><Outlet /></Layout>}>
                        <Route index element={<List />} />
                        <Route path="edit/:id" element={<Edit />} />
                        <Route path="clone/:id" element={<Clone />} />
                        <Route path="create" element={<Create />} />
                        <Route path=":id" element={<Show />} />
                    </Route>
                </Routes>
            </Refine>
        </BrowserRouter>
    );
}
`.trim();
const StyleCssCode = `
html {
    margin: 0;
    padding: 0;
}
body {
    margin: 0;
    padding: 12px;
}
* {
    box-sizing: border-box;
}
body {
    font-family: sans-serif;
}
form label, form input, form button {
    display: block;
    width: 100%;
    margin-bottom: 6px;
}
`.trim();
const ListTsxCode = `
import { useList, BaseKey } from "@refinedev/core";
export const List: React.FC = () => {
    const { data, isLoading, isError } = useList<IProduct>({
        resource: "products",
        filters: [
            {
                field: "id",
                operator: "gte",
                value: 120,
            }
        ]
    });
    if (isLoading) {
        return <div>Loading...</div>;
    }
    return (
        <ul>
            {data?.data?.map((product) => (
                <li key={product.id}>
                    {product.name}
                </li>
            ))}
        </ul>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
}
`.trim();
const ShowTsxCode = `
import { useShow, BaseKey } from "@refinedev/core";
export const Show: React.FC = () => {
    const { query: { data, isLoading, isError } } = useShow<IProduct>({
    });
    if (isLoading) {
        return <div>Loading...</div>;
    }
    return (
        <div>
            <h1>{data?.data?.name}</h1>
            <p>Material: {data?.data?.material}</p>
            <small>ID: {data?.data?.id}</small>
        </div>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
}
`.trim();
const CreateTsxCode = `
import React from "react";
import { useForm, HttpError, BaseKey } from "@refinedev/core";
export const Create: React.FC = () => {
    const { onFinish } = useForm<IProduct, HttpError, FormValues>({
        resource: "products",
        action: "create",
        redirect: "show", // redirect to show page after form submission, defaults to "list"
    });
    const [values, setValues] = React.useState<FormValues>({ name: "", material: "" });
    const onSubmit = (e) => {
        e.preventDefault();
        onFinish(values);
    };
    return (
        <form onSubmit={onSubmit}>
            <label htmlFor="name">Name</label>
            <input
                name="name"
                placeholder="Name"
                value={values.name}
                onChange={(e) => setValues({ ...values, name: e.target.value })}
            />
            <label htmlFor="material">Material</label>
            <input
                name="material"
                placeholder="Material"
                value={values.material}
                onChange={(e) => setValues({ ...values, material: e.target.value })}
            />
            <button type="submit">Submit</button>
        </form>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
}
interface FormValues {
    name?: string;
    material?: string;
}
`.trim();
const EditTsxCode = `
import React from "react";
import { useForm, HttpError, BaseKey } from "@refinedev/core";
export const Edit: React.FC = () => {
    const { query, formLoading, onFinish } = useForm<IProduct, HttpError, FormValues>({
        resource: "products",
        action: "edit",
        id: "123",
        redirect: "show", // redirect to show page after form submission, defaults to "list"
    });
    const defaultValues = query?.data?.data;
    const [values, setValues] = React.useState<FormValues>({
        name: defaultValues?.name || "",
        material: defaultValues?.material || "",
    });
    React.useEffect(() => {
        setValues({
            name: defaultValues?.name || "",
            material: defaultValues?.material || "",
        });
    }, [defaultValues]);
    const onSubmit = (e) => {
        e.preventDefault();
        onFinish(values);
    };
    return (
        <form onSubmit={onSubmit}>
            <label htmlFor="name">Name</label>
            <input
                name="name"
                placeholder="Name"
                value={values.name}
                onChange={(e) => setValues({ ...values, name: e.target.value })}
            />
            <label htmlFor="material">Material</label>
            <input
                name="material"
                placeholder="Material"
                value={values.material}
                onChange={(e) => setValues({ ...values, material: e.target.value })}
            />
            <button type="submit">Submit</button>
        </form>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
}
interface FormValues {
    name?: string;
    material?: string;
}
`.trim();
const CloneTsxCode = `
import React from "react";
import { useForm, HttpError, BaseKey } from "@refinedev/core";
export const Clone: React.FC = () => {
    const { query, formLoading, onFinish } = useForm<IProduct, HttpError, FormValues>({
        resource: "products",
        action: "clone",
        id: "123",
        redirect: "show", // redirect to show page after form submission, defaults to "list"
    });
    const defaultValues = query?.data?.data;
    const [values, setValues] = React.useState<FormValues>({
        name: defaultValues?.name || "",
        material: defaultValues?.material || "",
    });
    React.useEffect(() => {
        setValues({
            name: defaultValues?.name || "",
            material: defaultValues?.material || "",
        });
    }, [defaultValues]);
    const onSubmit = (e) => {
        e.preventDefault();
        onFinish(values);
    };
    return (
        <form onSubmit={onSubmit}>
            <label htmlFor="name">Name</label>
            <input
                name="name"
                placeholder="Name"
                value={values.name}
                onChange={(e) => setValues({ ...values, name: e.target.value })}
            />
            <label htmlFor="material">Material</label>
            <input
                name="material"
                placeholder="Material"
                value={values.material}
                onChange={(e) => setValues({ ...values, material: e.target.value })}
            />
            <button type="submit">Submit</button>
        </form>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
}
interface FormValues {
    name?: string;
    material?: string;
}
`.trim();

================
File: data/hooks/use-form/index.md
================
---
title: useForm
source: packages/core/src/hooks/form/useForm.ts
---

import BasicUsage from "./basic-usage";

A hook that orchestrates Refine's data hooks to create, edit, and clone data. It also provides a set of features to make it easier for users to implement their real world needs and handle edge cases such as redirects, invalidation, auto-save and more.

```tsx
import { useForm } from "@refinedev/core";

const { onFinish, ... } = useForm({ ... });
```

:::simple Extended Versions

`@refinedev/antd`, `@refinedev/mantine` and `@refinedev/react-hook-form` packages provide their own extended versions of `useForm` hook with full support for their respective form implementations including validation, error handling, form values, and more.

Refer to their respective documentation for more information and check out the [Forms in Refine](guides-concepts/forms/index.md) guide for detailed information on how to handle forms in Refine.

- [`@refinedev/antd`'s `useForm`](/docs/ui-integrations/ant-design/hooks/use-form)
- [`@refinedev/mantine`'s `useForm`](/docs/ui-integrations/mantine/hooks/use-form)
- [`@refinedev/react-hook-form`'s `useForm`](/docs/packages/list-of-packages)

:::

## Usage

Basic usage of the `useForm` hook demonstrates how to use the hook in all three modes, `create`, `edit`, and `clone`.

<BasicUsage />

## Parameters

### action <RouterBadge />

The action that will be performed with the submission of the form. Can be `create`, `edit`, or `clone`. If not specified, it will be determined by the current route or fallback to `create`.

```tsx
useForm({ action: "create" });
```

#### Create

In `create` action, `useForm` will follow the flow below:

After form is submitted:

1. `useForm` calls `onFinish` function with the form values.
2. `onFinish` function calls [`useCreate`](/docs/data/hooks/use-create) with the form values.
3. `useCreate` calls [`dataProvider`](/docs/data/data-provider)'s `create` function and returns the response.
4. `useForm` calls `onSuccess` or `onError` function with the response, depending on the response status.
5. After a successful mutation, `useForm` will invalidate the queries specified in `invalidates` prop.
6. `onSuccess` or `onError` function then calls the `open` function of the [`notificationProvider`](/docs/notification/notification-provider) to inform the user.
7. `useForm` redirects to the `list` page.

#### Edit

In `edit` action, `useForm` will follow the flow below:

When `useForm` is mounted, it calls [`useOne`](/docs/data/hooks/use-one) hook to retrieve the record to be edited. The `id` for the record is obtained from the props or the current route.

After form is submitted:

1.  `useForm` calls `onFinish` function with the form values.
2.  `onFinish` function calls [`useUpdate`](/docs/data/hooks/use-update) with the form values.
3.  If the mutation mode is `optimistic` or `undoable`, `useForm` will update the query cache with the form values immediately after the mutation is triggered.
4.  If the mutation mode is `undoable`, `useForm` will display a notification with a countdown to undo the mutation.
5.  `useUpdate` calls [`dataProvider`](/docs/data/data-provider)'s `update` function and returns the response.
6.  `useForm` calls `onSuccess` or `onError` function with the response, depending on the response status.
7.  If the mutation fails, `useForm` will revert the query cache to the previous values made in step 3.
8.  After a successful mutation, `useForm` will invalidate the queries specified in `invalidates` prop.
9.  `onSuccess` or `onError` function then calls the `open` function of the [`notificationProvider`](/docs/notification/notification-provider) to inform the user.
10. `useForm` redirects to the `list` page.

#### Clone

When `useForm` is mounted, it calls [`useOne`](/docs/data/hooks/use-one) hook to retrieve the record to be cloned. The `id` for the record is obtained from the props or the current route.

After form is submitted:

1.  `useForm` calls `onFinish` function with the form values.
2.  `onFinish` function calls [`useCreate`](/docs/data/hooks/use-create) with the form values.
3.  `useUpdate` calls [`dataProvider`](/docs/data/data-provider)'s `update` function and returns the response.
4.  `useForm` calls `onSuccess` or `onError` function with the response, depending on the response status.
5.  After a successful mutation, `useForm` will invalidate the queries specified in `invalidates` prop.
6.  `onSuccess` or `onError` function then calls the `open` function of the [`notificationProvider`](/docs/notification/notification-provider) to inform the user.
7.  `useForm` redirects to the `list` page.

### resource <GuideBadge id="guides-concepts/general-concepts" /> <RouterBadge />

The resource name or identifier that will be used for the form. If not specified, it will be determined by the current route.

```tsx
useForm({ resource: "products" });
```

### id <RouterBadge />

The ID of the record that will be used for the action. If not specified, it will be determined by the current route. Required for `edit` and `clone` actions.

```tsx
useForm({
  id: 123,
});
```

:::simple Using with explicit resource

If explicit `resource` is provided, `id` must be provided as well to avoid any unexpected API calls.

:::

### redirect <GuideBadge id="guides-concepts/forms#redirection" /><GlobalConfigBadge />

The redirection behavior after the form submission. It can be `list`, `edit`, `show`, `create`, or `false`. By default it will be `list` or whatever is defined in the Refine's global options.

```tsx
useForm({ redirect: "show" });
```

:::simple Router Integration

This will only work if you have `routerProvider` defined in your `<Refine>` component along with the proper `resource` definition with routes and actions.

:::

### onMutationSuccess

Callback function to be called after a successful mutation. It will be called with the mutation result and variables.

```tsx
useForm({
    onMutationSuccess: (
        data, // Mutation result, depending on the action its the response of `useCreate` or `useUpdate`
        variables, // Variables/form values that were used for the mutation
        context, // React Query's context for the mutation
        isAutoSave, // Boolean value indicating if the mutation was triggered by auto-save or not
    ) => { ... }
});
```

### onMutationError

Callback function to be called after a failed mutation. It will be called with the mutation error and variables.

```tsx
useForm({
    onMutationError: (
        error, // Mutation error, depending on the action its the error response of `useCreate` or `useUpdate`
        variables, // Variables/form values that were used for the mutation
        context, // React Query's context for the mutation
        isAutoSave, // Boolean value indicating if the mutation was triggered by auto-save or not
    ) => { ... }
});
```

### invalidates <GuideBadge id="guides-concepts/forms#invalidation" />

Determines the scope of the invalidation after a successful mutation. Can be array of `list`, `many`, `detail`, `resourceAll`, `all` or `false`. By default, `create` and `clone` actions will invalidate `list` and `many`. `edit` action will invalidate `list`, `many` and `detail` queries.

```tsx
useForm({ invalidates: ["list", "many"] });
```

### dataProviderName <GlobalConfigBadge description="This property can also be included in the `resource` definition." />

Name of the data provider to be used in API interactions. Useful when there are more than one data providers defined.

```tsx
useForm({ dataProviderName: "store" });
```

### mutationMode <GuideBadge id="guides-concepts/forms#mutation-modes" /> <GlobalConfigBadge />

Behavior of the mutation, can either be `pessimistic`, `optimistic` or `undoable`. By default, `pessimistic` or whatever is defined in the Refine's global options.

```tsx
useForm({ mutationMode: "optimistic" });
```

### successNotification <GuideBadge id="guides-concepts/forms#notifications" />

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

Customization options for the notification that will be shown after a successful mutation.

```tsx
useForm({
  // Can also be a static object if you don't need to access the data, values or resource.
  // By setting it to `false`, you can disable the notification.
  successNotification: (data, values, resource) => {
    return {
      message: `Successfully created ${data.title}`,
      description: "good job!",
      type: "success",
    };
  },
});
```

### errorNotification <GuideBadge id="guides-concepts/forms#notifications" />

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

Customization options for the notification that will be shown after a failed mutation.

```tsx
useForm({
  // Can also be a static object if you don't need to access the data, values or resource.
  // By setting it to `false`, you can disable the notification.
  errorNotification: (error, values, resource) => {
    return {
      message: `Failed to create ${values.title}`,
      description: error.message,
      type: "error",
    };
  },
});
```

### meta <GuideBadge id="guides-concepts/general-concepts#meta" description="To learn more about the `meta` and how it works with the data providers, refer to General Concepts guide" />

Additional information that will be passed to the data provider. Can be used to handle special cases in the data provider, generating GraphQL queries or handling additional parameters in the redirection routes.

```tsx
useForm({ meta: { headers: { "x-greetings": "hello world" } } });
```

### queryMeta

Meta data values to be used in the internal `useOne` call for the `edit` and `clone` actions. These values will take precedence over the `meta` values.

```tsx
useForm({ queryMeta: { headers: { "x-greetings": "hello mars" } } });
```

### mutationMeta

Meta data values to be used in the internal `useCreate` and `useUpdate` calls for form submissions. These values will take precedence over the `meta` values.

```tsx
useForm({ mutationMeta: { headers: { "x-greetings": "hello pluto" } } });
```

### queryOptions

Options to be used in the internal `useOne` call for the `edit` and `clone` actions.

```tsx
useForm({
  queryOptions: { retry: 3 },
});
```

### createMutationOptions

Options to be used in the internal `useCreate` call for the `create` and `clone` actions.

```tsx
useForm({
  createMutationOptions: { retry: 3 },
});
```

### updateMutationOptions

Options to be used in the internal `useUpdate` call for the `edit` action.

```tsx
useForm({
  updateMutationOptions: { retry: 3 },
});
```

### liveMode <GuideBadge id="guides-concepts/realtime" />

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Behavior of how to handle received real-time updates, can be `auto`, `manual` or `off`. By default, `auto` or whatever is defined in the Refine's global options.

```tsx
useForm({ liveMode: "auto" });
```

### onLiveEvent <GuideBadge id="guides-concepts/realtime" />

A callback function that will be called when a related real-time event is received.

```tsx
useForm({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

Additional parameters to be used in the `liveProvider`'s `subscribe` method.

```tsx
useForm({
  liveParams: {
    foo: "bar",
  },
});
```

### overtimeOptions

A set of options to be used for the overtime loading state. Useful when the API is slow to respond and a visual feedback is needed to indicate that the request is still in progress. `overtimeOptions` accept `interval` as `number` to determine the ticking intervals and `onInterval` to be called on each tick. `useForm` also returns `overtime` object with `elapsedTime` value that can be used for the feedback.

```tsx
const { overtime } = useForm({
  interval: 1000,
  onInterval(elapsedTime) {
    console.log(elapsedTime);
  },
});
```

### autoSave <GuideBadge id="guides-concepts/forms#auto-save" />

Auto-save behavior of the form. Can have `enabled` to toggle auto-save, `debounce` to set the debounce interval for saving and `invalidateOnUnmount` to invalidate the queries specified in `invalidates` prop on unmount. This feature is only available for the `edit` action. By default, `autoSave` is disabled.

```tsx
const { onFinishAutoSave } = useForm({
  autoSave: {
    enabled: true, // default is false
    debounce: 2000, // debounce interval for auto-save, default is 1000
    invalidateOnUnmount: true, // whether to invalidate the queries on unmount, default is false
  },
});
```

:::simple Auto-save Implementation

Core implementation of the `useForm` hook doesn't provide out of the box auto-save functionality since it doesn't have access to the form values but it provides the necessary props and callbacks to implement it.

Extended versions of `useForm` (such as the one in `@refinedev/react-hook-form`) provides auto-save functionality out of the box.

:::

### optimisticUpdateMap <GuideBadge id="guides-concepts/forms#optimistic-updates" />

In `optimistic` and `undoable` mutation modes, `useForm` will automatically update the query cache with the form values immediately after the mutation is triggered. This behavior can be customized for each query set (`list`, `many` and `detail` queries) using `optimisticUpdateMap`.

```tsx
useForm({
    optimisticUpdateMap: {
        // A boolean value can also be used to enable/disable the optimistic updates for the query set.
        list: (
            previous, // Previous query data
            variables, // Variables used in the query
            id, // Record id
        ) => { ... },
        many: (
            previous, // Previous query data
            variables, // Variables used in the query
            id, // Record id
        ) => { ... },
        detail: (
            previous, // Previous query data
            variables, // Variables used in the query
        ) => { ... },
    }
})
```

## Return Values

### onFinish

A function to call to trigger the mutation. Depending on the action, it will trigger the mutation of `useCreate` or `useUpdate` hooks.

```tsx
const { onFinish } = useForm({ ... });

return (
    <form onSubmit={() => onFinish(values)}>
        { /* ... */ }
    </form>
);
```

### onFinishAutoSave

A function to call to trigger the auto-save mutation. It will trigger the mutation of `useUpdate` hook. This will not trigger the `formLoading` state.

```tsx
const { onFinishAutoSave } = useForm({ ... });

React.useEffect(() => {
    // trigger auto-save on form values change, it will be debounced by the `autoSave.debounce` value
    onFinishAutoSave(values);
}, [values]);
```

### formLoading

A boolean value indicating the loading state of the form. It will reflect the loading status of the mutation or the query in `edit` and `clone` actions.

```tsx
const { formLoading } = useForm({ ... });
```

### mutation

Result of the mutation triggered by calling `onFinish`. Depending on the action, it will be the result of `useCreate` or `useUpdate` hooks.

```tsx
const { mutation: { data, error, isLoading } } = useForm({ ... });
```

### query

In `edit` and `clone` actions, result of the query of a record. It will be the result of `useOne` hook.

```tsx
const { query: { data, error, isLoading } } = useForm({ ... });
```

### setId

A setter function to set the `id` value. Useful when you want to change the `id` value after the form is mounted.

```tsx
const { setId } = useForm({ ... });

const onItemSelect = (id) => {
    setId(id);
};
```

### redirect <GuideBadge id="guides-concepts/forms#redirection" />

A function to handle custom redirections, it accepts `redirect` and `id` parameters. `redirect` can be `list`, `edit`, `show`, `create` or `false`. `id` is the record id if needed in the specified `redirect` route.

```tsx
const { redirect } = useForm({ ... });

redirect("show", 123);
```

### overtime

An object with `elapsedTime` value that can be used for the overtime loading feedback.

```tsx
const { overtime: { elapsedTime } } = useForm({ ... });
```

### autoSaveProps

An object with `data`, `error` and `status` values that can be used for the auto-save feedback. `data` will be the result of the auto-save mutation, `error` will be the error of the auto-save mutation and `status` will be the status of the auto-save mutation.

```tsx
const { autoSaveProps: { data, error, status } } = useForm({ ... });
```

### ~~mutationResult~~ <PropTag deprecated />

This prop is deprecated and will be removed in the future versions. Use [`mutation`](#mutation) instead.

### ~~queryResult~~ <PropTag deprecated />

This prop is deprecated and will be removed in the future versions. Use [`query`](#query) instead.

## API Reference

### Properties

<PropsTable module="@refinedev/core/useForm" />

:::simple Global Configuration

These props have default values in `RefineContext` and can also be set on [`<Refine />`](/docs/core/refine-component) component. `useForm` will use what is passed to `<Refine />` as default but a local value will override it.

:::

### Type Parameters

| Property       | Description                                                                                                                                                         | Type                       | Default                    |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData   | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError         | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TVariables     | Values for params.                                                                                                                                                  | `{}`                       |                            |
| TData          | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |
| TResponse      | Result data returned by the mutation function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TData` will be used as the default value.        | [`BaseRecord`][baserecord] | `TData`                    |
| TResponseError | Custom error object that extends [`HttpError`][httperror]. If not specified, the value of `TError` will be used as the default value.                               | [`HttpError`][httperror]   | `TError`                   |

### Return values

| Property      | Description                                            | Type                                                                                                                                                         |
| ------------- | ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| onFinish      | Triggers the mutation                                  | `(values: TVariables) => Promise<CreateResponse<TData>` \| `UpdateResponse<TData>` \| `void`>                                                                |
| query         | Result of the query of a record                        | [`QueryObserverResult<TData, TError>`](https://react-query.tanstack.com/reference/useQuery)                                                                  |
| mutation      | Result of the mutation triggered by calling `onFinish` | [`UseMutationResult<T>`](https://react-query.tanstack.com/reference/useMutation)                                                                             |
| formLoading   | Loading state of form request                          | `boolean`                                                                                                                                                    |
| id            | Record id for `clone` and `create` action              | [`BaseKey`](/docs/core/interface-references#basekey)                                                                                                         |
| setId         | `id` setter                                            | `Dispatch<SetStateAction<` `string` \| `number` \| `undefined>>`                                                                                             |
| redirect      | Redirect function for custom redirections              | (redirect: `"list"`\|`"edit"`\|`"show"`\|`"create"`\| `false` ,idFromFunction?: [`BaseKey`](/docs/core/interface-references#basekey)\|`undefined`) => `data` |
| overtime      | Overtime loading props                                 | `{ elapsedTime?: number }`                                                                                                                                   |
| autoSaveProps | Auto save props                                        | `{ data: UpdateResponse<TData>` \| `undefined, error: HttpError` \| `null, status: "loading"` \| `"error"` \| `"idle"` \| `"success" }`                      |

================
File: data/hooks/use-infinite-list/_basic-usage-live-preview.md
================
```tsx live url=http://localhost:3000/categories previewHeight=300px
import React from "react";
import { Refine } from "@refinedev/core";

setInitialRoutes(["/posts"]);
// visible-block-start
import React from "react";
import { useInfiniteList } from "@refinedev/core";

const PostList = () => {
  const {
    data,
    isError,
    isLoading,
    hasNextPage,
    fetchNextPage,
    isFetchingNextPage,
  } = useInfiniteList({
    resource: "categories",
    pagination: {
      pageSize: 4,
    },
  });

  if (isLoading) {
    return <p>Loading</p>;
  }
  if (isError) {
    return <p>Something went wrong</p>;
  }

  const allPages = [].concat(...(data?.pages ?? []).map((page) => page.data));

  return (
    <div>
      <ul>
        {allPages.map(({ id, title }) => (
          <li key={id}>
            {id}.{title}
          </li>
        ))}
      </ul>
      {hasNextPage && (
        <button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>
          {isFetchingNextPage ? "Loading more..." : "Load More"}
        </button>
      )}
    </div>
  );
};
// visible-block-end

setRefineProps({
  // Layout: (props: LayoutProps) => <Layout {...props} />,
  resources: [
    {
      name: "posts",
      list: "/posts",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/posts" element={<PostList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-infinite-list/_filtering-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/products previewHeight=300px hideCode
setInitialRoutes(["/products"]);

// visible-block-start
import { useState } from "react";
import { useInfiniteList, HttpError } from "@refinedev/core";

interface IProduct {
  id: number;
  name: string;
  material: string;
}

const ProductList: React.FC = () => {
  //highlight-next-line
  const [value, setValue] = useState("Cotton");

  const {
    data,
    isLoading,
    isError,
    hasNextPage,
    fetchNextPage,
    isFetchingNextPage,
  } = useInfiniteList<IProduct, HttpError>({
    resource: "products",
    //highlight-start
    filters: [
      {
        field: "material",
        operator: "eq",
        value,
      },
    ],
    //highlight-end
  });

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (isError) {
    return <div>Something went wrong!</div>;
  }

  const allPages = [].concat(...(data?.pages ?? []).map((page) => page.data));

  return (
    <div>
      {/* highlight-start */}
      <span> material: </span>
      <select value={value} onChange={(e) => setValue(e.target.value)}>
        {["Cotton", "Bronze", "Plastic"].map((material) => (
          <option key={material} value={material}>
            {material}
          </option>
        ))}
      </select>
      {/* highlight-end */}

      <ul>
        {allPages.map((product) => (
          <li key={product.id}>
            {product.name} - ({product.material})
          </li>
        ))}
      </ul>

      {hasNextPage && (
        <button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>
          {isFetchingNextPage ? "Loading more..." : "Load More"}
        </button>
      )}
    </div>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "products",
      list: "/products",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/products" element={<ProductList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-infinite-list/_sorting-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/products previewHeight=300px hideCode
setInitialRoutes(["/products"]);

// visible-block-start
import { useState } from "react";
import { useInfiniteList, HttpError } from "@refinedev/core";

interface IProduct {
  id: number;
  name: string;
  material: string;
}

const ProductList: React.FC = () => {
  //highlight-next-line
  const [order, setOrder] = useState<"asc" | "desc">("asc");

  const {
    data,
    isLoading,
    isError,
    hasNextPage,
    fetchNextPage,
    isFetchingNextPage,
  } = useInfiniteList<IProduct, HttpError>({
    resource: "products",
    //highlight-start
    sorters: [
      {
        field: "name",
        order,
      },
    ],
    //highlight-end
  });

  if (isLoading) {
    return <p>Loading</p>;
  }
  if (isError) {
    return <p>Something went wrong</p>;
  }

  const allPages = [].concat(...(data?.pages ?? []).map((page) => page.data));

  return (
    <div>
      {/* highlight-start */}
      <button
        onClick={() => setOrder((prev) => (prev === "asc" ? "desc" : "asc"))}
      >
        toggle sort
      </button>
      {/* highlight-end */}

      <ul>
        {allPages.map((product) => (
          <li key={product.id}>
            {product.name} - ({product.material})
          </li>
        ))}
      </ul>

      {hasNextPage && (
        <button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>
          {isFetchingNextPage ? "Loading more..." : "Load More"}
        </button>
      )}
    </div>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "products",
      list: "/products",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/products" element={<ProductList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-infinite-list/index.md
================
---
title: useInfiniteList
siderbar_label: useInfiniteList
source: https://github.com/refinedev/refine/blob/main/packages/core/src/hooks/data/useInfiniteList.ts
description: useInfiniteList data hook from Refine is a modified version of TanStack Query's useInfiniteQuery for retrieving items from a resource with pagination, search, sort, and filter configurations.
---

import BasicUsageLivePreview from "./\_basic-usage-live-preview.md";
import SortingLivePreview from "./\_sorting-live-preview.md";
import FilteringLivePreview from "./\_filtering-live-preview.md";

The `useInfiniteList` hook is an extended version of TanStack Query's [`useInfiniteQuery`](https://tanstack.com/query/v4/docs/react/reference/useInfiniteQuery) used for retrieving items from a `resource` with pagination, sort, and filter configurations. It is ideal for lists where the total number of records is unknown and the user loads the next pages with a button.

- It uses the `getList` method as the query function from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine>`.

- It uses a query key to cache the data. The **query key** is generated from the provided properties. You can see the query key by using the TanStack Query devtools.

## Usage

Here is a basic example of how to use the `useInfiniteList` hook.

<BasicUsageLivePreview />

## Pagination

The `useInfiniteList` hook supports pagination properties just like [`useList`](/docs/data/hooks/use-list). To handle pagination, the `useInfiniteList` hook passes the `pagination` property to the `getList` method from the `dataProvider`.

Dynamically changing the `pagination` properties will trigger a new request. The `fetchNextPage` method will increase the `pagination.current` property by one and trigger a new request as well.

### Retrieving the Total Row Count

When the `getList` method is called via `useInfiniteList`, it should ideally return the total count of rows (`rowCount`). The way this count is obtained depends on the data provider in use:

- **REST Providers:** Commonly obtain the total count from the `x-total-count` header.
- **GraphQL Providers:** Often source the count from specific data fields like `pageInfo.total`.
- **Other Providers:** Follow their own practices for obtaining the total count.

If the data provider doesn't return a specific count, the `getList` method may fall back to using the length of the paginated data array as the `rowCount`.

For more information on how this works, refer to the [`getList` method documentation](https://refine.dev/docs/data/data-provider/#getlist).

```ts
import { useInfiniteList } from "@refinedev/core";

const postListQueryResult = useInfiniteList({
  resource: "posts",
  pagination: { current: 3, pageSize: 8 },
});
```

## Sorting

The `useInfiniteList` hook supports the sorting feature, which you can enable by passing the `sorters` property. `useInfiniteList` will then pass this property to the `getList` method from the `dataProvider`.

Dynamically changing the `sorters` property will trigger a new request.

<SortingLivePreview />

## Filtering

The `useInfiniteList` hook supports the filtering feature, which you can enable by passing the `filters` property. `useInfiniteList` will then pass this property to the `getList` method from the `dataProvider`.

Dynamically changing the `filters` property will trigger a new request.

<FilteringLivePreview />

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useInfiniteList` hook is mounted, it will call the `subscribe` method from the `liveProvider` with some parameters such as `channel`, `resource` etc. This is useful when you want to subscribe to live updates.

## Properties

### resource <PropTag required />

This parameter will be passed to the `getList` method from the `dataProvider` as a parameter. It is usually used as an API endpoint path but it all depends on how you handle the `resource` in the `getList` method.

```tsx
useInfiniteList({
  resource: "categories",
});
```

> For more information, refer to the [creating a data provider tutorial &#8594](/docs/data/data-provider)

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### dataProviderName

This prop allows you to specify which `dataProvider` if you have more than one. Just pass it like in the example:

```tsx
useInfiniteList({
  dataProviderName: "second-data-provider",
});
```

### filters

`filters` will be passed to the `getList` method from the `dataProvider` as a parameter. It is used to send filter query parameters to the API.

```tsx
useInfiniteList({
  filters: [
    {
      field: "title",
      operator: "contains",
      value: "Foo",
    },
  ],
});
```

> For more information, refer to the [`CrudFilters` interface &#8594](/docs/core/interface-references#crudfilters)

### sorters

`sorters` will be passed to the `getList` method from the `dataProvider` as a parameter. It is used to send sort query parameters to the API.

```tsx
useInfiniteList({
  sorters: [
    {
      field: "title",
      order: "asc",
    },
  ],
});
```

> For more information, refer to the [`CrudSorting` interface &#8594](/docs/core/interface-references#crudsorting)

### pagination

`pagination` will be passed to the `getList` method from the `dataProvider` as a parameter. It is used to send pagination query parameters to the API.

#### current

You can pass the `current` page number to the `pagination` property.

```tsx
useInfiniteList({
  pagination: {
    current: 2,
  },
});
```

#### pageSize

You can pass the `pageSize` to the `pagination` property.

```tsx
useInfiniteList({
  pagination: {
    pageSize: 20,
  },
});
```

#### mode

This property can be `"off"`, `"client"` or `"server"`. It is used to determine whether to use server-side pagination or not.

```tsx
useInfiniteList({
  pagination: {
    mode: "off",
  },
});
```

### queryOptions

`queryOptions` is used to pass additional options to the `useQuery` hook. It is useful when you want to pass additional options to the `useQuery` hook.

```tsx
useInfiniteList({
  queryOptions: {
    retry: 3,
  },
});
```

> For more information, refer to the [`useQuery` documentation&#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useInfiniteList({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  getList: async ({
    resource,
    pagination,
    sorters,
    filters,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;
    //...
    // highlight-next-line
    const { data } = await httpClient.get(`${url}`, { headers });

    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useInfiniteList` can call `open` function from `NotificationProvider` to show a success notification. With this prop, you can customize the success notification.

```tsx
useInfiniteList({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useInfiniteList` will call the `open` function from `NotificationProvider` to show an error notification. With this prop, you can customize the error notification.

```tsx
useInfiniteList({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Determines whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.

```tsx
useInfiniteList({
  liveMode: "auto",
});
```

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

The callback function is executed when new events from a subscription have arrived.

```tsx
useInfiniteList({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useInfiniteList({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### ~~config~~ <PropTag deprecated />

Use `pagination`, `hasPagination`, `sorters` and `filters` instead.

### ~~hasPagination~~ <PropTag deprecated />

Use `pagination.mode` instead.

## Return Values

Returns an object with TanStack Query's `useInfiniteQuery` return values.

> For more information, refer to the [`useInfiniteQuery` documentation&#8594](https://tanstack.com/query/latest/docs/react/reference/useInfiniteQuery)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useInfiniteList();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## FAQ

### How to use cursor-based pagination?

Some APIs use the `cursor-pagination` method for its benefits. This method uses a `cursor` object to determine the next set of data. The cursor can be a number or a string and is passed to the API as a query parameter.

**Preparing the data provider:**

Consumes data from data provider `useInfiniteList` with the `getList` method. First of all, we need to make this method in the data provider convenient for this API. The `cursor` data is kept in `pagination` and should be set to `0` by default.

```ts
getList: async ({ resource, pagination }) => {
    const { current } = pagination;
    const { data } = await axios.get(
        `https://api.fake-rest.refine.dev/${resource}?cursor=${current || 0}`,
    );

    return {
        data: data[resource],
        total: 0,
    };
},
```

:::tip

As the `total` data is only needed in the `offset-pagination` method, define it as `0` here.

:::

After this process, we successfully retrieved the first page of data. Let's fill the `cursor` object for the next page.

```ts
getList: async ({ resource, pagination }) => {
    const { current } = pagination;
    const { data } = await axios.get(
        `https://api.fake-rest.refine.dev/${resource}?cursor=${current || 0}`,
    );

    return {
        data: data[resource],
        total: 0,
        // highlight-start
        cursor: {
            next: data.cursor.next,
            prev: data.cursor.prev,
        },
        // highlight-end
    };
},
```

### How to override the `getNextPageParam` method?

By default, `Refine` expects you to return the `cursor` object, but is not required. This is because some APIs don't work that way. To fix this problem you need to override the `getNextPageParam` method and return the next `cursor`.

```tsx
import { useInfiniteList } from "@refinedev/core";

const {
  data,
  error,
  hasNextPage,
  isLoading,
  fetchNextPage,
  isFetchingNextPage,
} = useInfiniteList({
  resource: "posts",
  // highlight-start
  queryOptions: {
    // When you override this method, you can access the `lastPage` and `allPages`.
    getNextPageParam: (lastPage, allPages) => {
      // return the last post's id
      const { data } = lastPage;
      const lastPost = data[data.length - 1];
      return lastPost.id;
    },
  },
  // highlight-end
});
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/useInfiniteList"
successNotification-default='`false`'
errorNotification-default='"Error (status code: `statusCode`)"'
/>

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return Values

| Description                                       | Type                                                                                                                                                |
| ------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| Result of the TanStack Query's `useInfiniteQuery` | [`InfiniteQueryObserverResult<{ data: TData[]; total: number; }, TError>`](https://tanstack.com/query/latest/docs/react/reference/useInfiniteQuery) |
| overtime                                          | `{ elapsedTime?: number }`                                                                                                                          |

## Example

<CodeSandboxExample path="use-infinite-list" />

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: data/hooks/use-invalidate/index.md
================
---
title: useInvalidate
source: /packages/core/src/hooks/invalidate
---

`useInvalidate` is a hook that can be used to invalidate the state of a particular `resource` or [`dataProvider`][data-provider] (with dataProviderName).

This hook will be called when a mutation hook is successful. For example, creating a `Posts` with the [useCreate](/docs/data/hooks/use-create) hook will invalidate the `list` ([useList](/docs/data/hooks/use-list)) and `many` ([useMany](/docs/data/hooks/use-many)) state of the `Posts` resource.

:::simple Good to know

- This hook is used internally by Refine. In most cases, you won't need this hook, but we export it as it may be useful for some use-cases that may require customized invalidation.
- Refine uses [TanStack Query](https://tanstack.com/query/latest) to fetch and manage the state of the data. For more information about invalidation, please read the TanStack Query's [invalidation](https://tanstack.com/query/v4/docs/react/guides/query-invalidation) docs.

:::

## Basic Usage

```ts
import { useInvalidate } from "@refinedev/core";

const invalidate = useInvalidate();

// `invalidate` function is async and returns a promise. If you want to wait for the invalidation process to complete, you can await it.
invalidate({
  resource: "posts",
  invalidates: ["list"],
});
```

## Examples

To invalidate the `"list"` and `"many"` states of the Posts `resource`.

```ts
invalidate({
  resource: "posts",
  invalidates: ["list", "many"],
});
```

To invalidate the state of a Posts with an id of `1`.

```ts
invalidate({
  resource: "posts",
  invalidates: ["detail"],
  id: 1,
});
```

To invalidate the `"list"` and `"many"` states of the Posts `resource` of the [`dataProvider`][data-provider] named `"second-data-provider"`.

```ts
invalidate({
  resource: "posts",
  dataProviderName: "second-data-provider",
  invalidates: ["list"],
});
```

To invalidate all states of the [`dataProvider`][data-provider] named `"second-data-provider"`.

```ts
invalidate({
  dataProviderName: "second-data-provider",
  invalidates: ["all"],
});
```

To invalidate all states of the Posts.

```ts
invalidate({
  resource: "posts",
  invalidates: ["resourceAll"],
});
```

## Invalidation Parameters

### resource

A `resource` represents an entity in an endpoint in the API (e.g. https://api.fake-rest.refine.dev/posts). It is used to invalidate the state of a particular resource.

### id

The `id` to use when invalidating the `"detail"` state.

### dataProviderName

If there is more than one [`dataProvider`][data-provider], you should specify which one to use by passing the `dataProviderName` prop.

### invalidates <PropTag required />

The scope of the invalidation process. These scopes can be provided in an array.

- `"all"`: Invalidates all states of the all resources.
- `"resourceAll"`: Invalidates all states of the given `resource`.
- `"list"`: Invalidates the `"list"` state of the given `resource`.
- `"detail"`: Invalidates the `"detail"` state of the given `resource` and `id`.
- `"many"`: Invalidates the `"many"` state of the given `resource`.

### invalidationFilters and invalidationOptions

The filters and options applied to the invalidation process when picking which queries to invalidate. By default Refine applies some filters and options to fine-tune the invalidation process.

By default settings, all the targeted queries are invalidated and the active ones are triggered for a refetch. If there are any ongoing queries, they are kept as they are.

## API Reference

### Invalidation Parameters

| Property                         | Description                                                       | Type                                                                                                              | Default                                  |
| -------------------------------- | ----------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |
| invalidated <PropTag asterisk /> | The states you want to invalidate.                                | `all`, `resourceAll`, `list`, `many`, `detail`, `false`                                                           |                                          |
| resource                         | Resource name for State invalidation.                             | `string`                                                                                                          |                                          |
| id                               | The `id` to use when invalidating the "detail" state.             | [`BaseKey`](/docs/core/interface-references#basekey)                                                              |                                          |
| dataProviderName                 | The name of the data provider whose state you want to invalidate. | `string`                                                                                                          | `default`                                |
| invalidationFilters              | The filters to use when picking queries to invalidate             | [`InvalidateQueryFilters`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientinvalidatequeries) | `{ type: "all", refetchType: "active" }` |
| invalidationOptions              | The options to use in the invalidation process                    | [`InvalidateOptions`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientinvalidatequeries)      | `{ cancelRefetch: false }`               |

[data-provider]: /docs/data/data-provider

================
File: data/hooks/use-list/_basic-usage-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/products previewHeight=300px
setInitialRoutes(["/products"]);

// visible-block-start
import { useList, HttpError } from "@refinedev/core";

interface IProduct {
  id: number;
  name: string;
  material: string;
}

const ProductList: React.FC = () => {
  const { data, isLoading, isError } = useList<IProduct, HttpError>({
    resource: "products",
  });

  const products = data?.data ?? [];

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (isError) {
    return <div>Something went wrong!</div>;
  }

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          <h4>
            {product.name} - ({product.material})
          </h4>
        </li>
      ))}
    </ul>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "products",
      list: "/products",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/products" element={<ProductList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-list/_filtering-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/products previewHeight=300px hideCode
setInitialRoutes(["/products"]);

// visible-block-start
import { useState } from "react";
import { useList, HttpError } from "@refinedev/core";

interface IProduct {
  id: number;
  name: string;
  material: string;
}

const ProductList: React.FC = () => {
  //highlight-next-line
  const [value, setValue] = useState("Cotton");

  const { data, isLoading, isError } = useList<IProduct, HttpError>({
    resource: "products",
    //highlight-start
    filters: [
      {
        field: "material",
        operator: "eq",
        value,
      },
    ],
    //highlight-end
  });

  const products = data?.data ?? [];

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (isError) {
    return <div>Something went wrong!</div>;
  }

  return (
    <div>
      {/* highlight-start */}
      <span> material: </span>
      <select value={value} onChange={(e) => setValue(e.target.value)}>
        {["Cotton", "Bronze", "Plastic"].map((material) => (
          <option key={material} value={material}>
            {material}
          </option>
        ))}
      </select>
      {/* highlight-end */}

      <ul>
        {products.map((product) => (
          <li key={product.id}>
            <h4>
              {product.name} - ({product.material})
            </h4>
          </li>
        ))}
      </ul>
    </div>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "products",
      list: "/products",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/products" element={<ProductList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-list/_pagination-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/products previewHeight=300px hideCode
setInitialRoutes(["/products"]);

// visible-block-start
import { useState } from "react";
import { useList, HttpError } from "@refinedev/core";

interface IProduct {
  id: number;
  name: string;
  material: string;
}

const ProductList: React.FC = () => {
  //highlight-start
  const [current, setCurrent] = useState(1);
  const [pageSize, setPageSize] = useState(5);
  //highlight-end

  const { data, isLoading, isError } = useList<IProduct, HttpError>({
    resource: "products",
    //highlight-start
    pagination: {
      current,
      pageSize,
    },
    //highlight-end
  });

  const products = data?.data ?? [];

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (isError) {
    return <div>Something went wrong!</div>;
  }

  return (
    <div>
      {/* highlight-start */}
      <button onClick={() => setCurrent((prev) => prev - 1)}>{"<"}</button>
      <span> page: {current} </span>
      <button onClick={() => setCurrent((prev) => prev + 1)}>{">"}</button>
      <span> per page: </span>
      <select
        value={pageSize}
        onChange={(e) => setPageSize(Number(e.target.value))}
      >
        {[5, 10, 20].map((size) => (
          <option key={size} value={size}>
            {size}
          </option>
        ))}
      </select>
      {/* highlight-end */}

      <ul>
        {products.map((product) => (
          <li key={product.id}>
            <h4>
              {product.name} - ({product.material})
            </h4>
          </li>
        ))}
      </ul>
    </div>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "products",
      list: "/products",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/products" element={<ProductList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-list/_sorting-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/products previewHeight=300px hideCode
setInitialRoutes(["/products"]);

// visible-block-start
import { useState } from "react";
import { useList, HttpError } from "@refinedev/core";

interface IProduct {
  id: number;
  name: string;
  material: string;
}

const ProductList: React.FC = () => {
  //highlight-next-line
  const [order, setOrder] = useState<"asc" | "desc">("asc");

  const { data, isLoading, isError } = useList<IProduct, HttpError>({
    resource: "products",
    //highlight-start
    sorters: [
      {
        field: "name",
        order,
      },
    ],
    //highlight-end
  });

  const products = data?.data ?? [];

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (isError) {
    return <div>Something went wrong!</div>;
  }

  return (
    <div>
      {/* highlight-start */}
      <button
        onClick={() => setOrder((prev) => (prev === "asc" ? "desc" : "asc"))}
      >
        toggle sort
      </button>
      {/* highlight-end */}

      <ul>
        {products.map((product) => (
          <li key={product.id}>
            <h4>
              {product.name} - ({product.material})
            </h4>
          </li>
        ))}
      </ul>
    </div>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "products",
      list: "/products",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/products" element={<ProductList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-list/index.md
================
---
title: useList
siderbar_label: useList
source: https://github.com/refinedev/refine/blob/main/packages/core/src/hooks/data/useList.ts
---

import BasicUsageLivePreview from "./\_basic-usage-live-preview.md";
import PaginationLivePreview from "./\_pagination-live-preview.md";
import FilteringLivePreview from "./\_filtering-live-preview.md";
import SortingLivePreview from "./\_sorting-live-preview.md";

`useList` is an extended version of TanStack Query's [`useQuery`](https://tanstack.com/query/v4/docs/react/reference/useQuery) that supports all of its features and also adds some more.

When you need to fetch data according to sort, filter, pagination, etc. from a `resource` , you can use the `useList` hook. It will return the data and some functions to control the query.

- It uses the `getList` method as the **query function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine>`.

- It uses a query key to cache the data. The **query key** is generated from the provided properties. You can see the query key by using the TanStack Query devtools.

## Usage

Here is a basic example of how to use the `useList` hook.

<BasicUsageLivePreview />

## Pagination

The `useList` hook supports the pagination feature. You can pass the `pagination` property to enable pagination. To handle pagination, the `useList` hook passes the `pagination` property to the `getList` method from the `dataProvider`.

Dynamically changing the `pagination` properties will trigger a new request.

### Retrieving the Total Row Count

When the `useList` hook calls the `getList` method, it expects the response to include the total number of rows (`rowCount`). The way this count is retrieved can vary based on the data provider:

- **REST Providers:** Frequently use the `x-total-count` header to determine the total count.
- **GraphQL Providers:** Typically return the count in specific data fields, such as `pageInfo.total`.
- **Other Providers:** Follow their own conventions for obtaining the total count.

If the backend doesn't provide a specific count, the `getList` method may default to using the length of the returned data array as the `rowCount`.

For further details on how the `getList` method retrieves and returns data, refer to the [`getList` documentation](https://refine.dev/docs/data/data-provider/#getlist).

<PaginationLivePreview />

## Sorting

The `useList` hook supports the sorting feature,which you can enable by passing the `sorters` property. `useList` will then pass this property to the `getList` method from the `dataProvider`.

Dynamically changing the `sorters` property will trigger a new request.

<SortingLivePreview />

## Filtering

The `useList` hook supports the filtering feature. You can pass the `filters` property to enable filtering. To handle filtering, the `useList` hook passes the `filters` property to the `getList` method from the `dataProvider`.

Dynamically changing the `filters` property will trigger a new request.

<FilteringLivePreview />

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useList` hook is mounted, it will call the `subscribe` method from the `liveProvider` with some parameters such as `channel`, `resource` etc. It is useful when you want to subscribe to live updates.

## Properties

### resource <PropTag required />

This parameter will be passed to the `getList` method from the `dataProvider` as a parameter. It is usually used as an API endpoint path but it all depends on how you handle the `resource` in the `getList` method.

```tsx
useList({
  resource: "categories",
});
```

> For more information, refer to the [creating a data provider tutorial &#8594](/docs/data/data-provider)

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### dataProviderName

This prop allows you to specify which `dataProvider` if you have more than one. Just pass it like in the example:

```tsx
useList({
  dataProviderName: "second-data-provider",
});
```

### filters

`filters` will be passed to the `getList` method from the `dataProvider` as a parameter. It is used to send filter query parameters to the API.

```tsx
useList({
  filters: [
    {
      field: "title",
      operator: "contains",
      value: "Foo",
    },
  ],
});
```

> For more information, refer to the [`CrudFilters` interface &#8594](/docs/core/interface-references#crudfilters)

### sorters

`sorters` will be passed to the `getList` method from the `dataProvider` as a parameter. It is used to send sort query parameters to the API.

```tsx
useList({
  sorters: [
    {
      field: "title",
      order: "asc",
    },
  ],
});
```

> For more information, refer to the [`CrudSorting` interface &#8594](/docs/core/interface-references#crudsorting)

### pagination

`pagination` will be passed to the `getList` method from the `dataProvider` as a parameter. It is used to send pagination query parameters to the API.

#### current

You can pass the `current` page number to the `pagination` property.

```tsx
useList({
  pagination: {
    current: 2,
  },
});
```

#### pageSize

You can pass the `pageSize` to the `pagination` property.

```tsx
useList({
  pagination: {
    pageSize: 20,
  },
});
```

#### mode

This property can be `"off"`, `"client"` or `"server"`. It is used to determine whether to use server-side pagination or not.

```tsx
useList({
  pagination: {
    mode: "off",
  },
});
```

### queryOptions

`queryOptions` is used to pass additional options to the `useQuery` hook. It is useful when you want to pass additional options to the `useQuery` hook.

```tsx
useList({
  queryOptions: {
    retry: 3,
  },
});
```

> For more information, refer to the [`useQuery` documentation&#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useList({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  getList: async ({
    resource,
    pagination,
    sorters,
    filters,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;

    //...
    //...

    // highlight-next-line
    const { data } = await httpClient.get(`${url}`, { headers });

    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useList` can call `open` function from `NotificationProvider` to show a success notification. With this prop, you can customize the success notification.

```tsx
useList({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useList` will call `open` function from `NotificationProvider` to show an error notification. With this prop, you can customize the error notification.

```tsx
useList({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Determines whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.

```tsx
useList({
  liveMode: "auto",
});
```

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

The callback function is executed when new events from a subscription have arrived.

```tsx
useList({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useList({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### ~~config~~ <PropTag deprecated />

Use `pagination`, `sorters`, and `filters` instead.

### ~~hasPagination~~ <PropTag deprecated />

Use `pagination.mode` instead.

## Return Values

Returns an object with TanStack Query's `useQuery` return values.

> For more information, refer to the [`useQuery` documentation&#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useList();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/useList"
successNotification-default='`false`'
errorNotification-default='"Error (status code: `statusCode`)"'
/>

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return Values

| Description                               | Type                                                                                                                            |
| ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| Result of the TanStack Query's `useQuery` | [`QueryObserverResult<{ data: TData[]; total: number; }, TError>`](https://tanstack.com/query/v4/docs/react/reference/useQuery) |
| overtime                                  | `{ elapsedTime?: number }`                                                                                                      |

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: data/hooks/use-many/_basic-usage-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/products previewHeight=300px
setInitialRoutes(["/products"]);
// visible-block-start
import { useState } from "react";
import { useMany, HttpError } from "@refinedev/core";

interface IProduct {
  id: number;
  name: string;
  material: string;
}

const ProductList: React.FC = () => {
  const [ids, setIds] = useState([1, 2, 3]);

  const { data, isLoading, isError } = useMany<IProduct, HttpError>({
    resource: "products",
    ids,
  });

  const products = data?.data ?? [];

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (isError) {
    return <div>Something went wrong!</div>;
  }

  return (
    <div>
      {products.map((product) => (
        <ul key={product.id}>
          <li key={product.id}>
            {product.id} - {product.name}{" "}
            <button
              onClick={() =>
                setIds((prev) => prev.filter((id) => id !== product.id))
              }
            >
              remove
            </button>
          </li>
        </ul>
      ))}

      <button
        onClick={() => {
          setIds((prev) => [...prev, Math.floor(Math.random() * 150) + 1]);
        }}
      >
        Add new product
      </button>
    </div>
  );
};

// visible-block-end
setRefineProps({
  resources: [
    {
      name: "products",
      list: "/products",
    },
  ],
});
render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/products" element={<ProductList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-many/index.md
================
---
title: useMany
siderbar_label: useMany
source: packages/core/src/hooks/data/useMany.ts
---

import BasicUsageLivePreview from "./\_basic-usage-live-preview.md";

`useMany` is an extended version of TanStack Query's [`useQuery`](https://tanstack.com/query/v4/docs/react/reference/useQuery) that supports all of its features and adds some more.

- It uses the `getMany` method as the **query function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine>`.

- It uses a query key to cache the data. The **query key** is generated from the provided properties. You can see the query key by using the TanStack Query devtools.

It is useful when you want to fetch multiple records from the API. It will return the data and some functions to control the query.

If your data provider does not have a `getMany` method, `useMany` will use the `getOne` method instead. This is not recommended, as it will make requests one by one for each id. It is better to implement the `getMany` method in the data provider.

## Usage

The `useMany` hook expects a `resource` and `ids` property, which will be passed to the `getMany` method from the `dataProvider` as a parameter.

When these properties are changed, the `useMany` hook will trigger a new request.

<BasicUsageLivePreview />

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useMany` hook is mounted, it will call the `subscribe` method from the `liveProvider` with some parameters such as `channel`, `resource` etc. It is useful when you want to subscribe to live updates.

## Properties

### resource <PropTag required />

This parameter will be passed to the `getMany` method from the `dataProvider` as a parameter. t is usually used as an API endpoint path but it all depends on how you handle the `resource` in the `getMany` method.

```tsx
useMany({
  resource: "categories",
});
```

> For more information, refer to the [creating a data provider tutorial &#8594](/docs/data/data-provider)

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### ids <PropTag required />

This prop will be passed to the `getMany` method from the `dataProvider` as a parameter. It is used to determine which records to fetch.

```tsx
useMany({
  ids: [1, 2, 3],
});
```

### dataProviderName

This prop allows you to specify which `dataProvider` if you have more than one. Just pass it like in the example:

```tsx
useMany({
  dataProviderName: "second-data-provider",
});
```

### queryOptions

`queryOptions` is used to pass additional options to the `useQuery` hook. It is useful when you want to pass additional options to the `useQuery` hook.

```tsx
useMany({
  queryOptions: {
    retry: 3,
    enabled: false,
  },
});
```

> For more information, refer to the [`useQuery` documentation&#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
import { stringify } from "query-string";

useMany({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  getMany: async ({
    resource,
    ids,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}?${stringify({ id: ids })}`;

    //...
    //...

    // highlight-next-line
    const { data } = await httpClient.get(`${url}`, { headers });

    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useMany` can call `open` function from `NotificationProvider` to show a success notification. With this prop, you can customize the success notification.

```tsx
useMany({
  successNotification: (data, ids, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useMany` will call the `open` function from `NotificationProvider` to show an error notification. With this prop, you can customize the error notification.

```tsx
useMany({
  errorNotification: (data, ids, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Determines whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.

```tsx
useMany({
  liveMode: "auto",
});
```

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

The callback function is executed when new events from a subscription have arrived.

```tsx
useMany({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useMany({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## Return Values

Returns an object with TanStack Query's `useQuery` return values.

> For more information, refer to the [ `useQuery` documentation &#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useMany();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/useMany"
successNotification-default='`false`'
errorNotification-default='"Error (status code: `statusCode`)"'
/>

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Description                               | Type                                                                                                                   |
| ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| Result of the TanStack Query's `useQuery` | [`QueryObserverResult<{ data: TData[]; error: TError }>`](https://tanstack.com/query/v4/docs/react/reference/useQuery) |
| overtime                                  | `{ elapsedTime?: number }`                                                                                             |

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: data/hooks/use-one/_basic-usage-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/products previewHeight=300px
setInitialRoutes(["/products"]);
// visible-block-start
import { useState } from "react";
import { useOne, HttpError } from "@refinedev/core";

interface IProduct {
  id: number;
  name: string;
  material: string;
}

const ProductList: React.FC = () => {
  const [id, setId] = useState(1);

  const { data, isLoading, isError } = useOne<IProduct, HttpError>({
    resource: "products",
    id,
  });

  const product = data?.data;

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (isError) {
    return <div>Something went wrong!</div>;
  }

  return (
    <div>
      <h3>Product Details</h3>
      <p>id: {product?.id}</p>
      <p>name: {product?.name}</p>
      <p>material: {product?.material}</p>

      <br />

      <button onClick={() => setId((prev) => prev - 1)} disabled={id === 1}>
        {"<"} Prev Product
      </button>
      <button onClick={() => setId((prev) => prev + 1)}>
        Next Product {">"}
      </button>
    </div>
  );
};

// visible-block-end
setRefineProps({
  resources: [
    {
      name: "products",
      list: "/products",
    },
  ],
});
render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/products" element={<ProductList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-one/index.md
================
---
title: useOne
siderbar_label: useOne
source: packages/core/src/hooks/data/useOne.ts
---

import BasicUsageLivePreview from "./\_basic-usage-live-preview.md";

`useOne` is an extended version of TanStack Query's [`useQuery`](https://tanstack.com/query/v4/docs/react/reference/useQuery) that supports all of its features and adds some more.

- It uses the `getOne` method as the **query function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine>`.

- It uses a query key to cache the data. The **query key** is generated from the provided properties. You can see the query key by using the TanStack Query devtools.

It is useful when you want to fetch a single record from the API. It will return the data and some functions to control the query.

## Usage

The `useOne` hook expects a `resource` and `id` property, which will be passed to the `getOne` method from the `dataProvider` as a parameter.

When these properties are changed, the `useOne` hook will trigger a new request.

<BasicUsageLivePreview />

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useOne` hook is mounted, it will call the `subscribe` method from the `liveProvider` with some parameters such as `channel`, `resource` etc. It is useful when you want to subscribe to live updates.

## Properties

### resource <PropTag required />

This parameter will be passed to the `getOne` method from the `dataProvider` as a parameter. It is usually used as an API endpoint path but it all depends on how you handle the `resource` in the `getOne` method.

```tsx
useOne({
  resource: "categories",
});
```

> For more information, refer to the [creating a data provider tutorial &#8594](/docs/data/data-provider)

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### id <PropTag required />

This prop will be passed to the `getMany` method from the `dataProvider` as a parameter. It is used to determine which records to fetch.

```tsx
useOne({
  id: 123,
});
```

### dataProviderName

This prop allows you to specify which `dataProvider` if you have more than one. Just pass it like in the example:

```tsx
useOne({
  dataProviderName: "second-data-provider",
});
```

### queryOptions

`queryOptions` is used to pass additional options to the `useQuery` hook. It is useful when you want to pass additional options to the `useQuery` hook.

```tsx
useOne({
  queryOptions: {
    retry: 3,
    enabled: false,
  },
});
```

> For more information, refer to the [`useQuery` documentation&#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useOne({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  getOne: async ({
    resource,
    id,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}/${id}`;

    //...
    //...

    // highlight-next-line
    const { data } = await httpClient.get(`${url}`, { headers });

    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useOne` can call `open` function from `NotificationProvider` to show a success notification. With this prop, you can customize the success notification.

```tsx
useOne({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useOne` will call the `open` function from `NotificationProvider` to show an error notification. With this prop, you can customize the error notification.

```tsx
useOne({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Determines whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.
For more information about live mode, please check the [Live / Realtime](/docs/realtime/live-provider#livemode) page.

```tsx
useOne({
  liveMode: "auto",
});
```

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

The callback function is executed when new events from a subscription have arrived.

```tsx
useOne({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useOne({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## Return Values

Returns an object with TanStack Query's `useQuery` return values.

> For more information, refer to the [ `useQuery` documentation &#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useOne();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/useOne"
successNotification-default='`false`'
errorNotification-default='"Error (status code: `statusCode`)"'
/>

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Description                               | Type                                                                                                                  |
| ----------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| Result of the TanStack Query's `useQuery` | [`QueryObserverResult<{ data: TData; error: TError; }>`](https://tanstack.com/query/v4/docs/react/reference/useQuery) |
| overtime                                  | `{ elapsedTime?: number }`                                                                                            |

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: data/hooks/use-select/_basic-usage-live-preview.md
================
```tsx live url=http://localhost:3000/categories previewHeight=200px
setInitialRoutes(["/categories"]);
// visible-block-start
import { useSelect } from "@refinedev/core";

interface ICategory {
  id: number;
  title: string;
}

const Categpries: React.FC = () => {
  const { options } = useSelect<ICategory>({
    resource: "categories",
  });

  return (
    <label>
      Select a category:
      <select>
        {options?.map((option) => (
          <option key={option.value} value={option.value}>
            {option.label}
          </option>
        ))}
      </select>
    </label>
  );
};
// visible-block-end
setRefineProps({
  resources: [
    {
      name: "categories",
      list: "/categories",
    },
  ],
});
render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/categories" element={<Categpries />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-select/_default-value-live-preview.md
================
```tsx live url=http://localhost:3000/categories previewHeight=200px hideCode
setInitialRoutes(["/categories"]);
// visible-block-start
import { useSelect } from "@refinedev/core";

interface ICategory {
  id: number;
  title: string;
}

const Categories: React.FC = () => {
  const { options } = useSelect<ICategory>({
    resource: "categories",
    // highlight-next-line
    defaultValue: 3,
  });

  return (
    <label>
      Select a category:
      <select>
        {options?.map((option) => (
          <option key={option.value} value={option.value}>
            {option.value}-{option.label}
          </option>
        ))}
      </select>
    </label>
  );
};
// visible-block-end
setRefineProps({
  resources: [
    {
      name: "categories",
      list: "/categories",
    },
  ],
});
render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/categories" element={<Categories />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-select/_on-search-live-preview.md
================
```tsx live url=http://localhost:3000/categories previewHeight=200px hideCode
setInitialRoutes(["/categories"]);
// visible-block-start
import { useSelect } from "@refinedev/core";

interface ICategory {
  id: number;
  title: string;
}

const Categories: React.FC = () => {
  const { options, onSearch } = useSelect<ICategory>({
    resource: "categories",
    // highlight-start
    onSearch: (value) => [
      {
        field: "title",
        operator: "contains",
        value,
      },
    ],
    // highlight-end
  });

  return (
    <>
      <p>
        Filter:
        <input onChange={(e) => onSearch(e.target.value)} />
      </p>

      <select>
        {options?.map((option) => (
          <option key={option.value} value={option.value}>
            {option.label}
          </option>
        ))}
      </select>
    </>
  );
};
// visible-block-end
setRefineProps({
  resources: [
    {
      name: "categories",
      list: "/categories",
    },
  ],
});
render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/categories" element={<Categories />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-select/_sort-live-preview.md
================
```tsx live url=http://localhost:3000/categories previewHeight=200px hideCode
setInitialRoutes(["/categories"]);
// visible-block-start
import { useSelect } from "@refinedev/core";

interface ICategory {
  id: number;
  title: string;
}

const Categories: React.FC = () => {
  const [order, setOrder] = React.useState<"asc" | "desc">("asc");
  const { options } = useSelect<ICategory>({
    resource: "categories",
    // highlight-start
    sorters: [
      {
        field: "title",
        order,
      },
    ],
    // highlight-end
  });

  return (
    <>
      <label>
        Select a category:
        <select>
          {options?.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
        <button onClick={() => setOrder(order === "asc" ? "desc" : "asc")}>
          Toggle
        </button>
      </label>
    </>
  );
};
// visible-block-end
setRefineProps({
  resources: [
    {
      name: "categories",
      list: "/categories",
    },
  ],
});
render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/categories" element={<Categories />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-select/index.md
================
---
title: useSelect
siderbar_label: useSelect
source: packages/core/src/hooks/useSelect/index.ts
---

import BasicUsageLivePreview from "./\_basic-usage-live-preview.md";
import OnSearchLivePreview from "./\_on-search-live-preview.md";
import SortLivePreview from "./\_sort-live-preview.md";
import DefaultValueLivePreview from "./\_default-value-live-preview.md";

`useSelect` hook allows you to manage any `select` (like a [Html `<select>` tag](https://www.w3schools.com/tags/tag_select.asp), [React Select](https://react-select.com/home), etc...) component. Since it is designed as headless, It expects you to handle the UI.

This hook uses the `useList` hook for fetching data.

:::simple Derivatives and Extended Versions

If you're looking for a complete select library, Refine has out-of-the-box support for the libraries below:

- [Ant Design Select](https://ant.design/components/select) (for Ant Design users) - [Documentation](/docs/ui-integrations/ant-design/hooks/use-select) - [Example](https://github.com/refinedev/refine/tree/main/examples/field-antd-use-select-basic)
- [Material UI Autocomplete](https://mui.com/material-ui/react-autocomplete) (for Material UI users) - [Documentation](/docs/ui-integrations/material-ui/hooks/use-auto-complete)
- [Mantine Select](https://mantine.dev/core/select/) (for Mantine users) - [Documentation](/docs/ui-integrations/mantine/hooks/use-select)

:::

> For more information, refer to the [useList hook→](/docs/data/hooks/use-list)

## Usage

Here is a basic example of how to use `useSelect` hook.

<BasicUsageLivePreview />

## Realtime Updates

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

When `useSelect` hook is mounted, it will call the `subscribe` method from the `liveProvider` with some parameters such as `channel`, `resource` etc. It is useful when you want to subscribe to the live updates.

## Properties

### resource <PropTag required />

It will be passed to the `getList` method from the `dataProvider` as parameter via the `useList` hook. The parameter is usually used as an API endpoint path. It all depends on how to handle the `resource` in the `getList` method.

```tsx
useSelect({
  resource: "categories",
});
```

> For more information, refer to the [creating a data provider&#8594](/docs/data/data-provider)

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### optionLabel and optionValue

Allows you to change the `value` and `label` of your options.
Default values are `optionLabel = "title"` and `optionValue = "id"`

```tsx
useSelect<ICategory>({
    resource: "products",
    optionLabel: "name"
    optionValue: "productId"
});
```

These properties also supports nested property access with [Object path](https://lodash.com/docs/4.17.15#get) syntax.

```tsx
const { options } = useSelect({
  resource: "categories",
  optionLabel: "nested.title",
  optionValue: "nested.id",
});
```

It's also possible to pass function to these props. These functions will receive `item` argument.

```tsx
const { options } = useSelect({
  optionLabel: (item) => `${item.firstName} ${item.lastName}`,
  optionValue: (item) => item.id,
});
```

### searchField

Can be used to specify which field will be searched with value given to `onSearch` function.

```tsx
const { onSearch } = useSelect({ searchField: "name" });

onSearch("John"); // Searches by `name` field with value John.
```

By default, it uses `optionLabel`'s value, if `optionLabel` is a string. Uses `title` field otherwise.

```tsx
// When `optionLabel` is string.
const { onSearch } = useSelect({ optionLabel: "name" });

onSearch("John"); // Searches by `name` field with value John.

// When `optionLabel` is function.
const { onSearch } = useSelect({
  optionLabel: (item) => `${item.id} - ${item.name}`,
});

onSearch("John"); // Searches by `title` field with value John.
```

### sorters

It allows to show the options in the desired order. `sorters` will be passed to the `getList` method from the `dataProvider` as parameter via the `useList` hook. It is used to send sort query parameters to the API.

```tsx
useSelect({
  sorters: [
    {
      field: "title",
      order: "asc",
    },
  ],
});
```

<SortLivePreview />

> For more information, refer to the [`CrudSorting` interface &#8594](/docs/core/interface-references#crudsorting)

### filters

It is used to show options by filtering them. `filters` will be passed to the `getList` method from the `dataProvider` as parameter via the `useList` hook. It is used to send filter query parameters to the API.

```tsx
useSelect({
  filter: [
    {
      field: "isActive",
      operator: "eq",
      value: true,
    },
  ],
});
```

> For more information, refer to the [`CrudFilters` interface &#8594](/docs/core/interface-references#crudfilters)

### defaultValue

Allows to make options selected by default. Adds extra options to `<select>` component. In some cases like there are many entries for the `<select>` and pagination is required, `defaultValue` may not be present in the current visible options and this can break the `<select>` component. To avoid such cases, A separate `useMany` query is sent to the backend with the `defaultValue` and appended to the options of `<select>`, ensuring the default values exist in the current options array. Since it uses `useMany` to query the necessary data, the `defaultValue` can be a single value or an array of values like the following:

```tsx
useSelect({
  defaultValue: 1, // or [1, 2]
});
```

### selectedOptionsOrder

`selectedOptionsOrder` allows us to sort `selectedOptions` on `defaultValue`. It can be:

- `"in-place"`: sort `selectedOptions` at the bottom. It is by default.
- `"selected-first"`: sort `selectedOptions` at the top.

```tsx
useSelect({
  defaultValue: 1, // or [1, 2]
  selectedOptionsOrder: "selected-first", // in-place | selected-first
});
```

> For more information, refer to the [`useMany` documentation&#8594](/docs/data/hooks/use-many)

### debounce

It allows us to `debounce` the `onSearch` function.

```tsx
useSelect({
  resource: "categories",
  debounce: 500,
});
```

### queryOptions

`queryOptions` is used to pass additional options to the `useQuery` hook. It is useful when you want to pass additional options to the `useQuery` hook.

```tsx
useSelect({
  queryOptions: {
    retry: 3,
  },
});
```

> For more information, refer to the [`useQuery` documentation&#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### pagination

`pagination` will be passed to the `getList` method from the `dataProvider` as parameter. It is used to send pagination query parameters to the API.

#### current

You can pass the `current` page number to the `pagination` property.

```tsx
useSelect({
  pagination: {
    current: 2,
  },
});
```

#### pageSize

You can pass the `pageSize` to the `pagination` property.

```tsx
useSelect({
  pagination: {
    pageSize: 20,
  },
});
```

#### mode

Is used to determine whether to use server-side pagination or not. It can be `"off"`, `"client"` or `"server"`

```tsx
useSelect({
  pagination: {
    mode: "off",
  },
});
```

### defaultValueQueryOptions

When the `defaultValue` property is given, the `useMany` data hook is called for the selected records. With this property, you can change the options of this query. If not given, the values given in `queryOptions` will be used.

```tsx
const { options } = useSelect({
  resource: "categories",
  defaultValueQueryOptions: {
    onSuccess: (data) => {
      console.log("triggers when on query return on success");
    },
  },
});
```

### onSearch

It allows us to `AutoComplete` the `options`.

<OnSearchLivePreview />

:::simple Implementation Tips

- The HTML select tag does not natively support AutoComplete. If AutoComplete is desired, it can be used with [React Select](https://react-select.com/async) or [use-select](https://github.com/tannerlinsley/use-select).
- If `onSearch` is used, it will override the existing `filters`.
- For more information, refer to the [`CrudFilters` interface &#8594](/docs/core/interface-references#crudfilters)

:::

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useSelect({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  getList: async ({
    resource,
    pagination,
    sorters,
    filters,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;
    //...
    //...
    // highlight-next-line
    const { data, headers } = await httpClient.get(`${url}`, { headers });
    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation &#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### dataProviderName

If there is more than one `dataProvider`, you can specify which one to use by passing the `dataProviderName` prop. It is useful when you have a different data provider for different resources.

```tsx
useSelect({
  dataProviderName: "second-data-provider",
});
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useSelect` can call `open` function from `NotificationProvider` to show a success notification. With this prop, you can customize the success notification.

```tsx
useSelect({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useSelect` will call `open` function from `NotificationProvider` to show a error notification. With this prop, you can customize the error notification.

```tsx
useSelect({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Determines whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.
For more information about live mode, please check [Live / Realtime](/docs/realtime/live-provider#livemode) page.

```tsx
useSelect({
  liveMode: "auto",
});
```

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

The callback function that is executed when new events from a subscription are arrived.

```tsx
useSelect({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useSelect({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### ~~sort~~ <PropTag deprecated />

Use `sorters` instead.

### ~~hasPagination~~ <PropTag deprecated />

Use `pagination.mode` instead.

## FAQ

### How to get all the data without pagination?

You may want to get all the data without pagination. In this case you should use the [`hasPagination`](/docs/data/hooks/use-select#haspagination) prop. The data provider must have the appropriate implementation in order to use this feature.

### How to add search to options (Autocomplete)?

[`onSearch`](/docs/data/hooks/use-select#onsearch) is a function that is used to set the search value. It is useful when you want to search for a specific value. A simple example of this is shown below.

<OnSearchLivePreview />

### How to ensure `defaultValue` is included in the options?

In some cases we only have `id`, it may be necessary to show it selected in the selection box. This hook sends the request via [`useMany`](/docs/data/hooks/use-many), gets the data and marks it as selected.

<DefaultValueLivePreview />

### How to change the `label` and `value` properties in options?

[`optionLabel` and `optionValue`](/docs/data/hooks/use-select#optionlabel-and-optionvalue) are used to change the value of your options.
The default values are `optionsLabel="title"` and `optionsValue="id"`.

To change to `name` and `categoryId`;

```tsx
useSelect({
  optionLabel: "name",
  optionValue: "categoryId",
});
```

### Can I create the options manually?

Sometimes it may not be enough to create `optionLabel` and `optionValue` options. In this case we create options with `query`.

```tsx
const { query } = useSelect({
  resource: "categories",
});

const options = query.data?.data.map((item) => ({
  label: item.name,
  value: item.id,
}));

return (
  <select>
    {options?.map((option) => (
      <option key={option.value} value={option.value}>
        {option.label}
      </option>
    ))}
  </select>
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/useSelect"  />

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Property          | Description                                    | Type                                                                                                         |
| ----------------- | ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| options           | It returns possible options                    | `{ label: string; value: string }`                                                                           |
| query             | Result of the query of a record                | [`QueryObserverResult<{ data: TData; error: TError }>`](https://react-query.tanstack.com/reference/useQuery) |
| defaultValueQuery | Result of the query of a `defaultValue` record | [`QueryObserverResult<{ data: TData; error: TError }>`](https://react-query.tanstack.com/reference/useQuery) |
| onSearch          | A function to set the search value             | `onSearch: (value: string) => void`                                                                          |
| overtime          | Overtime loading props                         | `{ elapsedTime?: number }`                                                                                   |

## Example

<CodeSandboxExample path="core-use-select" />

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: data/hooks/use-show/_basic-usage-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/products/show/1 previewHeight=300px
setInitialRoutes(["/products/show/123"]);
// visible-block-start
import { useShow } from "@refinedev/core";

interface IProduct {
  id: number;
  name: string;
  material: string;
}

const ProductShow: React.FC = () => {
  const { query } = useShow<IProduct>();

  const { data, isFetching, isError, refetch } = query;
  const product = data?.data;

  if (isFetching) {
    return <div>Loading...</div>;
  }

  if (isError) {
    return <div>Something went wrong!</div>;
  }

  return (
    <div>
      <h3>Product Details</h3>
      <p>id: {product?.id}</p>
      <p>name: {product?.name}</p>
      <p>material: {product?.material}</p>
      <button onClick={refetch}>Refresh</button>
    </div>
  );
};

// visible-block-end
setRefineProps({
  resources: [
    {
      name: "products",
      show: "/products/show/:id",
    },
  ],
});
render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/products/show/:id"
          element={<ProductShow />}
        />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-show/index.md
================
---
title: useShow
---

import BasicUsageLivePreview from "./\_basic-usage-live-preview.md";
import PropResource from "@site/src/partials/prop-resource";

`useShow` is an extended version of [`useOne`](/docs/data/hooks/use-one) that supports all of its features and adds some more.

It is useful when you want to fetch a single record from the API. It will return the data and some functions to control the query.

## Usage

The `useShow` hook does not expect any properties. By default, it will try to read the `resource` and `id` values from the current URL. It will be passed to the `getOne` method from the `dataProvider` as a parameter.

If you define `resource` and `id` on the hook, when these properties are changed, the `useShow` hook will trigger a new request.

<BasicUsageLivePreview />

## Realtime Updates

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

When the `useShow` hook is mounted, it will call the `subscribe` method from the `liveProvider` with some parameters such as `channel`, `resource` etc. It is useful when you want to subscribe to live updates.

## Properties

### resource

<PropResource
hook={{
        name:"useOne",
        URL:"/docs/core/hooks/data/use-one/"
    }}
method={{
        name:"getOne",
        URL:"/docs/core/providers/data-provider/#getone"
    }}
hasDefault={false}
/>

By default, it will try to read the `resource` value from the current URL.

```tsx
useShow({
  resource: "categories",
});
```

If the `resource` is passed, the `id` from the current URL will be ignored because it may belong to a different resource. To retrieve the `id` value from the current URL, use the `useParsed` hook and pass the `id` value to the `useShow` hook.

```tsx
import { useShow, useParsed } from "@refinedev/core";

const { id } = useParsed();

useShow({
  resource: "custom-resource",
  id,
});
```

Or you can use the `setId` function to set the `id` value.

```tsx
import { useShow } from "@refinedev/core";

const { setShowId } = useShow({
  resource: "custom-resource",
});

setShowId("123");
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### id

It will be passed to the `getOne` method from the `dataProvider` as a parameter. It is used to determine which record to fetch. By default, it will try to read the `id` value from the current URL.

```tsx
useShow({
  id: 123,
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useShow({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  getOne: async ({
    resource,
    id,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}/${id}`;

    //...
    //...

    // highlight-next-line
    const { data } = await httpClient.get(`${url}`, { headers });

    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation &#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### dataProviderName

If there is more than one `dataProvider`, you can specify which one to use by passing the `dataProviderName` prop. It is useful when you have a different data provider for different resources.

```tsx
useShow({
  dataProviderName: "second-data-provider",
});
```

### queryOptions

`queryOptions` is used to pass additional options to the `useQuery` hook. It is useful when you want to pass additional options to the `useQuery` hook.

```tsx
useShow({
  queryOptions: {
    retry: 3,
    enabled: false,
  },
});
```

> For more information, refer to the [`useQuery` documentation&#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useShow` can call `open` function from `NotificationProvider` to show a success notification. With this prop, you can customize the success notification.

```tsx
useShow({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useShow` will call the `open` function from `NotificationProvider` to show an error notification. With this prop, you can customize the error notification.

```tsx
useShow({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Determines whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.

```tsx
useShow({
  liveMode: "auto",
});
```

> For more information, refer to the [Live / Realtime page&#8594](/docs/realtime/live-provider#livemode)

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

The callback function is executed when new events from a subscription have arrived.

```tsx
useShow({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useShow({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## Return Values

### query

It is TanStack Query's `useQuery` return values.

> For more information, refer to the [`useQuery` documentation&#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### showId

It is the `id` value that is used on the `useShow` hook.

### setShowId

When you want to change the `showId` value, you can use this setter. It is useful when you want to change the `showId` value based on the user's action.

It will trigger new request to fetch the data when the `showId` value is changed.

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useShow();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

### ~~queryResult~~ <PropTag deprecated />

Use [`query`](#query) instead.

## API Reference

### Props

<PropsTable module="@refinedev/core/useShow" liveMode-default='`"off"`' />

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Property  | Description                     | Type                                                                                                         |
| --------- | ------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| query     | Result of the query of a record | [`QueryObserverResult<{ data: TData; error: TError }>`](https://react-query.tanstack.com/reference/useQuery) |
| showId    | Record id                       | `string`                                                                                                     |
| setShowId | `showId` setter                 | `Dispatch<SetStateAction< string` \| `undefined>>`                                                           |
| overtime  | Overtime loading props          | `{ elapsedTime?: number }`                                                                                   |

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: data/hooks/use-table/_partial-basic-usage-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import React from "react";
import { useTable, HttpError } from "@refinedev/core";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  createdAt: string;
}

const PostList: React.FC = () => {
  const { tableQuery } = useTable<IPost, HttpError>();
  const posts = tableQuery?.data?.data ?? [];

  if (tableQuery?.isLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>Posts</h1>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Status</th>
            <th>Created At</th>
          </tr>
        </thead>
        <tbody>
          {posts.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.title}</td>
              <td>{post.status}</td>
              <td>{new Date(post.createdAt).toDateString()}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: "/posts",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/posts" element={<PostList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-table/_partial-filtering-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px hideCode
setInitialRoutes(["/posts"]);

// visible-block-start
import React, { useMemo } from "react";
import { useMany, useTable, HttpError } from "@refinedev/core";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  createdAt: string;
}

const PostList: React.FC = () => {
  const { tableQuery, filters, setFilters } = useTable<IPost, HttpError>();

  // Fetches the posts for the current page
  const posts = tableQuery?.data?.data ?? [];

  // Gets the current filter values for the fields
  // highlight-start
  const currentFilterValues = useMemo(() => {
    // Filters can be a LogicalFilter or a ConditionalFilter. ConditionalFilter not have field property. So we need to filter them.
    // We use flatMap for better type support.
    const logicalFilters = filters.flatMap((item) =>
      "field" in item ? item : [],
    );

    return {
      title: logicalFilters.find((item) => item.field === "title")?.value || "",
      id: logicalFilters.find((item) => item.field === "id")?.value || "",
      status:
        logicalFilters.find((item) => item.field === "status")?.value || "",
    };
  }, [filters]);
  // highlight-end

  return (
    <div>
      {/* highlight-start */}
      <div
        style={{
          display: "flex",
          gap: "1rem",
          alignItems: "center",
          marginBottom: "4px",
        }}
      >
        <input
          placeholder="Search by title"
          value={currentFilterValues.title}
          onChange={(e) => {
            setFilters([
              {
                field: "title",
                operator: "contains",
                value: !!e.currentTarget.value
                  ? e.currentTarget.value
                  : undefined,
              },
            ]);
          }}
        />
        <input
          placeholder="Search by id"
          value={currentFilterValues.id}
          onChange={(e) => {
            setFilters([
              {
                field: "id",
                operator: "eq",
                value: !!e.currentTarget.value
                  ? e.currentTarget.value
                  : undefined,
              },
            ]);
          }}
        />

        <select
          value={currentFilterValues.status}
          onChange={(e) =>
            setFilters(
              [
                {
                  field: "status",
                  operator: "eq",
                  value: !!e.currentTarget.value
                    ? e.currentTarget.value
                    : undefined,
                },
              ],
              "replace",
            )
          }
        >
          <option value="">All</option>
          <option value="published">Published</option>
          <option value="draft">Draft</option>
          <option value="rejected">Rejected</option>
        </select>
      </div>
      {/* highlight-end */}
      <h1>Posts</h1>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Status</th>
            <th>Created At</th>
          </tr>
        </thead>
        <tbody>
          {tableQuery.data?.data.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.title}</td>
              <td>{post.status}</td>
              <td>{new Date(post.createdAt).toDateString()}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: "/posts",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/posts" element={<PostList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-table/_partial-pagination-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px hideCode
setInitialRoutes(["/posts"]);

// visible-block-start
import React from "react";
import { useMany, useTable, HttpError } from "@refinedev/core";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  createdAt: string;
}

const PostList: React.FC = () => {
  const {
    tableQuery,
    // highlight-start
    current,
    setCurrent,
    pageSize,
    setPageSize,
    pageCount,
    // highlight-end
  } = useTable<IPost, HttpError>();

  // Fetches the posts for the current page
  const posts = tableQuery?.data?.data ?? [];
  // highlight-start
  // Checks if there is a next page available
  const hasNext = current < pageCount;
  // Checks if there is a previous page available
  const hasPrev = current > 1;
  // highlight-end

  return (
    <div>
      <h1>Posts</h1>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Status</th>
            <th>Created At</th>
          </tr>
        </thead>
        <tbody>
          {tableQuery.data?.data.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.title}</td>
              <td>{post.status}</td>
              <td>{new Date(post.createdAt).toDateString()}</td>
            </tr>
          ))}
        </tbody>
      </table>
      {/* highlight-start */}
      <div
        style={{
          display: "flex",
          gap: "1rem",
          alignItems: "center",
        }}
      >
        <div>
          <button onClick={() => setCurrent(1)} disabled={!hasPrev}>
            First
          </button>
          <button
            onClick={() => setCurrent((prev) => prev - 1)}
            disabled={!hasPrev}
          >
            Previous
          </button>
          <button
            onClick={() => setCurrent((prev) => prev + 1)}
            disabled={!hasNext}
          >
            Next
          </button>
          <button onClick={() => setCurrent(pageCount)} disabled={!hasNext}>
            Last
          </button>
        </div>
        <span>
          Page{" "}
          <strong>
            {current} of {pageCount}
          </strong>
        </span>
        <span>
          Go to page:
          <input
            type="number"
            defaultValue={current + 1}
            onChange={(e) => {
              const value = e.target.value ? Number(e.target.value) : 1;
              setCurrent(value);
            }}
          />
        </span>
        <select
          value={pageSize}
          onChange={(e) => {
            const value = e.target.value ? Number(e.target.value) : 10;
            setPageSize(value);
          }}
        >
          {[10, 20, 30, 40, 50].map((size) => (
            <option key={size} value={size}>
              Show {size}
            </option>
          ))}
        </select>
      </div>
      {/* highlight-end */}
    </div>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: "/posts",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/posts" element={<PostList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-table/_partial-relational-data-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import React from "react";
import {
  useTable,
  // highlight-next-line
  useMany,
  HttpError,
} from "@refinedev/core";

// highlight-start
interface ICategory {
  id: number;
  title: string;
}
// highlight-end

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  createdAt: string;
  // highlight-start
  category: {
    id: number;
  };
  // highlight-end
}

const PostList: React.FC = () => {
  const { tableQuery } = useTable<IPost, HttpError>();
  const posts = tableQuery?.data?.data ?? [];

  // highlight-start
  // Fetches the category of each post. It uses the useMany hook to fetch the category data from the API.
  const { data: categoryData, isLoading: categoryIsLoading } = useMany<
    ICategory,
    HttpError
  >({
    resource: "categories",
    // Creates the array of ids. This will filter and fetch the category data for the relevant posts.
    ids: posts.map((item) => item?.category?.id),
    queryOptions: {
      // Set to true only if the posts array is not empty.
      enabled: !!posts.length,
    },
  });
  // highlight-end

  if (tableQuery?.isLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>Posts</h1>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Status</th>
            <th>Created At</th>
            {/* highlight-next-line */}
            <th>Category</th>
          </tr>
        </thead>
        <tbody>
          {posts.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.title}</td>
              <td>{post.status}</td>
              <td>{new Date(post.createdAt).toDateString()}</td>
              {/* highlight-start */}
              <td>
                {categoryIsLoading
                  ? "loading..."
                  : // Gets the title of the category from the categoryData object, which is the result of    the useMany hook.
                    categoryData?.data.find(
                      (item) => item.id === post.category.id,
                    )?.title || "-"}
              </td>
              {/* highlight-end */}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/posts" element={<PostList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-table/_partial-sorting-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px hideCode
setInitialRoutes(["/posts"]);

// visible-block-start
import React, { useMemo } from "react";
import { useMany, useTable, HttpError } from "@refinedev/core";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  createdAt: string;
}

const PostList: React.FC = () => {
  const { tableQuery, sorter, setSorter } = useTable<IPost, HttpError>({
    // highlight-start
    sorters: {
      initial: [
        {
          field: "createdAt",
          order: "desc",
        },
      ],
    },
    // highlight-end
  });

  // Fetches the posts for the current page
  const posts = tableQuery?.data?.data ?? [];

  // Gets the current sort order for the fields
  // highlight-start
  const currentSorterOrders = useMemo(() => {
    return {
      createdAt:
        sorter.find((item) => item.field === "createdAt")?.order || "desc",
      id: sorter.find((item) => item.field === "id")?.order || "desc",
      title: sorter.find((item) => item.field === "title")?.order || "asc",
    };
  }, [sorter]);
  // highlight-end

  // highlight-start
  const toggleSort = (field: string) => {
    setSorter([
      {
        field,
        order: currentSorterOrders[field] === "asc" ? "desc" : "asc",
      },
    ]);
  };
  // highlight-end

  return (
    <div>
      {/* highlight-start */}
      <div
        style={{
          display: "flex",
          gap: "1rem",
          alignItems: "center",
          marginBottom: "1rem",
        }}
      >
        <button onClick={() => toggleSort("createdAt")}>
          Sort date by{" "}
          {currentSorterOrders["createdAt"] === "asc" ? "desc" : "asc"}
        </button>
        <button onClick={() => toggleSort("id")}>
          Sort id by {currentSorterOrders["id"] === "asc" ? "desc" : "asc"}
        </button>
        <button onClick={() => toggleSort("title")}>
          Sort title by{" "}
          {currentSorterOrders["title"] === "asc" ? "desc" : "asc"}
        </button>
      </div>
      {/* highlight-end */}
      <h1>Posts</h1>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Status</th>
            <th>Created At</th>
          </tr>
        </thead>
        <tbody>
          {tableQuery.data?.data.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.title}</td>
              <td>{post.status}</td>
              <td>{new Date(post.createdAt).toDateString()}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: "/posts",
    },
  ],
});

render(
  <ReactRouter.BrowserRouter>
    <RefineHeadlessDemo>
      <ReactRouter.Routes>
        <ReactRouter.Route path="/posts" element={<PostList />} />
      </ReactRouter.Routes>
    </RefineHeadlessDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: data/hooks/use-table/index.md
================
---
title: useTable
source: packages/core/src/hooks/useTable
---

import BasicUsageLivePreview from "./\_partial-basic-usage-live-preview.md";
import PaginationLivePreview from "./\_partial-pagination-live-preview.md";
import SortingLivePreview from "./\_partial-sorting-live-preview.md";
import FilteringLivePreview from "./\_partial-filtering-live-preview.md";
import RelationalDataLivePreview from "./\_partial-relational-data-live-preview.md";
import PropResource from "@site/src/partials/prop-resource";

`useTable` allows us to fetch data according to the sorter, filter, and pagination states. Under the hood, it uses [`useList`](/docs/data/hooks/use-list) for the fetch. Since it is designed to be headless, it expects you to handle the UI.

:::simple Extended Versions

If you're looking for a complete table library, Refine supports two table libraries out of the box.

- [React Table](https://react-table.tanstack.com/) (for Headless, Chakra UI, Mantine) - [Documentation](/docs/packages/list-of-packages) - [Example](/docs/examples/table/tanstack-table/basic-tanstack-table/)
- [Ant Design Table](https://ant.design/components/table/#header) - [Documentation](/docs/ui-integrations/ant-design/hooks/use-table) - [Example](/examples/table/antd/useTable.md)
- [Material UI Table](https://mui.com/x/react-data-grid/) - [Documentation](/docs/ui-integrations/material-ui/hooks/use-data-grid) - [Example](/examples/table/mui/useDataGrid.md)

:::

## Usage

In basic usage, `useTable` returns the data as it comes from the endpoint. By default, it reads [`resource`](#resource) from the URL.

<BasicUsageLivePreview />

## Pagination

`useTable` has a pagination feature. The pagination is done by passing the `current` and `pageSize` keys to `pagination` object. The `current` is the current page, and the `pageSize` is the number of records per page.

It also syncs the pagination state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

By default, the `current` is 1 and the `pageSize` is 10. You can change default values by passing the `pagination.current` and `pagination.pageSize` props to the `useTable` hook.

You can also change the `current` and `pageSize` values by using the `setCurrent` and `setPageSize` functions that are returned by the `useTable` hook. Every change will trigger a new fetch.

By default, pagination happens on the server side. If you want to do pagination handling on the client side, you can pass the pagination.mode property and set it to "client". Also, you can disable the pagination by setting it to "off".

<PaginationLivePreview/>

## Sorting

`useTable` has a sorter feature. The sorter is done by using the `initial` and `permanent` keys to `sorters` object. The `initial` is the initial sorter state, and the `permanent` is the permanent sorter state. These states are a [`CrudSorter`][crudsorting] type that contains the field and the order of the sorter.

You can change the sorters state by using the `setSorters` function. Every change will trigger a new fetch.

It also syncs the sorting state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

<SortingLivePreview/>

## Filtering

`useTable` has a filter feature. The filter is done by using the `initial`, `permanent` and `defaultBehavior` keys to `filters` object. The `initial` is the initial filter state, and the `permanent` is the permanent filter state. These states are a [`CrudFilter`][crudfilters] type that contains the field, the operator, and the value of the filter.

You can change the filters state by using the `setFilters` function. Every change will trigger a new fetch.

It also syncs the filtering state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

`setFilters` function can work in two different behaviors; `merge` (default) and `replace`. You can set the behavior by passing it as the second parameter. You can change the default behavior with the [`filters.defaultBehavior`](#filtersdefaultbehavior) prop.

:::simple Merge behavior

If you are using `merge` behavior and want to remove one of the filters, you should set the `value` to `undefined` or `null`. For `or` filters, you should set the `value` to an empty array `[]` to remove the filter.

:::

:::simple Finding the filter value

Refine provides the [`getDefaultFilter`](https://github.com/refinedev/refine/blob/716656d9ad3deb169c32685cdebbfd46bac44beb/packages/core/src/definitions/table/index.ts#L166) function, You can use this function to find the filter value for the specific field.

```tsx
import { getDefaultFilter, useTable } from "@refinedev/core";

const MyComponent = () => {
  const { filters } = useTable({
    filters: {
      initial: [
        {
          field: "name",
          operator: "contains",
          value: "John Doe",
        },
      ],
    },
  });

  const nameFilterValue = getDefaultFilter("name", filters, "contains");
  console.log(nameFilterValue); // "John Doe"

  return {
    /** ... */
  };
};
```

:::

<FilteringLivePreview/>

## Realtime Updates

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

When the `useTable` hook is mounted, it will call the `subscribe` method from the `liveProvider` with some parameters such as `channel`, `resource` etc. It is useful when you want to subscribe to live updates.

## Properties

### resource

<PropResource
hook={{
    name:"useList",
    URL:"/docs/data/hooks/use-list/"
}}
method={{
    name:"getList",
    URL:"/docs/data/data-provider/#getlist"
}}
hasDefault={false}
/>

By default, it will try to read the `resource` value from the current URL.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  resource: "categories",
});
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### dataProviderName

If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use. It is useful when you want to use a different `dataProvider` for a specific resource.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  dataProviderName: "second-data-provider",
});
```

### pagination.current

Sets the initial value of the page index. Defaults to `1`.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  pagination: {
    current: 2,
  },
});
```

### pagination.pageSize

Sets the initial value of the page size. Defaults to `10`.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  pagination: {
    pageSize: 20,
  },
});
```

### pagination.mode

It can be `"off"`, `"server"` or `"client"`. Defaults to `"server"`.

- **"off":** Pagination is disabled. All records will be fetched.
- **"client":** Pagination is done on the client side. All records will be fetched and then the records will be paginated on the client side.
- **"server":**: Pagination is done on the server side. Records will be fetched by using the `current` and `pageSize` values.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  pagination: {
    mode: "client",
  },
});
```

### sorters.mode

It can be `"off"`, or `"server"`. Defaults to `"server"`.

- **"off":** `sorters` do not get sent to the server. You can use the `sorters` value to sort the records on the client side.
- **"server":**: Sorting is done on the server side. Records will be fetched by using the `sorters` value.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  sorters: {
    mode: "server",
  },
});
```

### sorters.initial

Sets the initial value of the sorter. The `initial` is not permanent. It will be cleared when the user changes the sorter. If you want to set a permanent value, use the `sorters.permanent` prop.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  sorters: {
    initial: [
      {
        field: "name",
        order: "asc",
      },
    ],
  },
});
```

> For more information, refer to the [`CrudSorting` interface&#8594](/docs/core/interface-references#crudsorting)

### sorters.permanent

Sets the permanent value of the sorter. The `permanent` is permanent and unchangeable. It will not be cleared when the user changes the sorter. If you want to set a temporary value, use the `sorters.initial` prop.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  sorters: {
    permanent: [
      {
        field: "name",
        order: "asc",
      },
    ],
  },
});
```

> For more information, refer to the [`CrudSorting` interface &#8594](/docs/core/interface-references#crudsorting)

### filters.mode

It can be `"off"` or `"server"`. Defaults to `"server"`.

- **"off":** `filters` are not sent to the server. You can use the `filters` value to filter the records on the client side.
- **"server":**: Filters are done on the server side. Records will be fetched by using the `filters` value.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  filters: {
    mode: "off",
  },
});
```

### filters.initial

Sets the initial value of the filter. The `initial` is not permanent. It will be cleared when the user changes the filter. If you want to set a permanent value, use the `filters.permanent` prop.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  filters: {
    initial: [
      {
        field: "name",
        operator: "contains",
        value: "Foo",
      },
    ],
  },
});
```

> For more information, refer to the [`CrudFilters` interface &#8594](/docs/core/interface-references#crudfilters)

### filters.permanent

Sets the permanent value of the filter. The `permanent` is permanent and unchangeable. It will not be cleared when the user changes the filter. If you want to set a temporary value, use the `filters.initial` prop.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  filters: {
    permanent: [
      {
        field: "name",
        operator: "contains",
        value: "Foo",
      },
    ],
  },
});
```

> For more information, refer to the [`CrudFilters` interface &#8594](/docs/core/interface-references#crudfilters)

### filters.defaultBehavior

The filtering behavior can be set to either `"merge"` or `"replace"`. Defaults to `"merge"`.

- When the filter behavior is set to `"merge"`, it will merge the new filter with the existing filters. This means that if the new filter has the same column as an existing filter, the new filter will replace the existing filter for that column. If the new filter has a different column than the existing filters, it will be added to the existing filters.

- When the filter behavior is set to `"replace"`, it will replace all existing filters with the new filter. This means that any existing filters will be removed, and only the new filter will be applied to the table.

You can also override the default value by using the second parameter of the [`setFilters`](#setfilters) function.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  filters: {
    defaultBehavior: "replace",
  },
});
```

### syncWithLocation <GlobalConfigBadge id="core/refine-component/#syncwithlocation" />

When you use the `syncWithLocation` feature, the `useTable`'s state (e.g., sort order, filters, pagination) is automatically encoded in the query parameters of the URL, and when the URL changes, the `useTable` state is automatically updated to match. This makes it easy to share table state across different routes or pages, and to allow users to bookmark or share links to specific table views. By default, this feature is disabled.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  syncWithLocation: true,
});
```

### queryOptions

`useTable` uses [`useList`](/docs/data/hooks/use-list) hook to fetch data. You can pass [`queryOptions`](https://tanstack.com/query/v4/docs/react/reference/useQuery).

```tsx
import { useTable } from "@refinedev/core";
useTable({
  queryOptions: {
    retry: 3,
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  getList: async ({
    resource,
    pagination,
    sorters,
    filters,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;

    //...
    //...

    // highlight-next-line
    const { data, headers } = await httpClient.get(`${url}`, { headers });

    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation&#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useTable` can call `open` function from [`NotificationProvider`][notification-provider] to show a success notification. With this prop, you can customize the success notification.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useTable` will call `open` function from [`NotificationProvider`][notification-provider] to show an error notification. With this prop, you can customize the error notification.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Determines whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  liveMode: "auto",
});
```

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

The callback function is executed when new events from a subscription have arrived.

```tsx
import { useTable } from "@refinedev/core";
useTable({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
import { useTable } from "@refinedev/core";
const { overtime } = useTable({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### ~~initialCurrent~~ <PropTag deprecated />

Use `pagination.current` instead.

### ~~initialPageSize~~ <PropTag deprecated />

Use `pagination.pageSize` instead.

### ~~hasPagination~~ <PropTag deprecated />

Use `pagination.mode` instead.

### ~~initialSorter~~ <PropTag deprecated />

Use `sorters.initial` instead.

### ~~permanentSorter~~ <PropTag deprecated />

Use `sorters.permanent` instead.

### ~~initialFilter~~ <PropTag deprecated />

Use `filters.initial` instead.

### ~~permanentFilter~~ <PropTag deprecated />

Use `filters.permanent` instead.

### ~~defaultSetFilterBehavior~~ <PropTag deprecated />

Use `filters.defaultBehavior` instead.

## Return Values

### tableQuery

Returned values from [`useList`](/docs/data/hooks/use-list) hook.

### sorters

Current [sorters state][crudsorting].

### setSorters

A function to set current [sorters state][crudsorting].

```tsx
 (sorters: CrudSorting) => void;
```

### filters

Current [filters state][crudfilters].

### setFilters

```tsx
((filters: CrudFilters, behavior?: SetFilterBehavior) => void) & ((setter: (prevFilters: CrudFilters) => CrudFilters) => void)
```

A function to set current [filters state][crudfilters].

### current

Current page index state. If pagination is disabled, it will be `undefined`.

### setCurrent

```tsx
React.Dispatch<React.SetStateAction<number>> | undefined;
```

A function to set the current page index state. If pagination is disabled, it will be `undefined`.

### pageSize

Current page size state. If pagination is disabled, it will be `undefined`.

### setPageSize

```tsx
React.Dispatch<React.SetStateAction<number>> | undefined;
```

A function to set the current page size state. If pagination is disabled, it will be `undefined`.

### pageCount

Total page count state. If pagination is disabled, it will be `undefined`.

### createLinkForSyncWithLocation

```tsx
(params: SyncWithLocationParams) => string;
```

A function creates accessible links for `syncWithLocation`. It takes [SyncWithLocationParams][syncwithlocationparams] as parameters.

### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
import { useTable } from "@refinedev/core";
const { overtime } = useTable();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

### ~~sorter~~ <PropTag deprecated />

Use `sorters` instead.

### ~~setSorter~~ <PropTag deprecated />

Use `setSorters` instead.

### ~~tableQueryResult~~ <PropTag deprecated />

Use [`tableQuery`](#tablequery) instead.

## FAQ

### How can I handle relational data?

You can use [`useMany`](/docs/data/hooks/use-many) hook to fetch relational data.

<RelationalDataLivePreview/>

### How can I handle client side filtering?

First, you need to set `filters.mode: "off"`

```tsx
import { useTable } from "@refinedev/core";
const { tableQuery, filters, setFilters } = useTable({
  filters: {
    mode: "off",
  },
});
```

Then, you can use the `filters` state to filter your data.

```tsx
// ...

const List = () => {
  const { tableQuery, filters } = useTable();

  // ...

  const filteredData = useMemo(() => {
    if (filters.length === 0) {
      return tableQuery.data;
    }

    // Filters can be a LogicalFilter or a ConditionalFilter. ConditionalFilter not have field property. So we need to filter them.
    // We use flatMap for better type support.
    const logicalFilters = filters.flatMap((item) =>
      "field" in item ? item : [],
    );

    return tableProps.dataSource.filter((item) => {
      return logicalFilters.some((filter) => {
        if (filter.operator === "eq") {
          return item[filter.field] === filter.value;
        }
      });
    });
  }, [tableQuery.data, filters]);
};

return (
  <div>
    {/* ...  */}
    <table>
      <tbody>
        {filteredData.map((item) => (
          <tr key={item.id}>{/* ...  */}</tr>
        ))}
      </tbody>
    </table>
  </div>
);
```

### How can I handle client side sorting?

First, you need to set `sorters.mode: "off"`

```tsx
import { useTable } from "@refinedev/core";
const { tableQuery, sorters, setSorters } = useTable({
  sorters: {
    mode: "off",
  },
});
```

Then, you can use the `sorters` state to sort your data.

```tsx
// ...
import { useTable } from "@refinedev/core";
const List = () => {
  const { tableQuery, sorters } = useTable();

  // ...

  const sortedData = useMemo(() => {
    if (sorters.length === 0) {
      return tableQuery.data;
    }

    return tableQuery.data.sort((a, b) => {
      const sorter = sorters[0];

      if (sorter.order === "asc") {
        return a[sorter.field] > b[sorter.field] ? 1 : -1;
      } else {
        return a[sorter.field] < b[sorter.field] ? 1 : -1;
      }
    });
  }, [tableQuery.data, sorters]);

  return (
    <div>
      {/* ...  */}
      <table>
        <tbody>
          {sortedData.map((item) => (
            <tr key={item.id}>{/* ...  */}</tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
```

## API Reference

### Properties

<PropsTable module="@refinedev/core/useTable"
successNotification-default='"Successfully created `resource`" or "Successfully updated `resource`"'
errorNotification-default='"There was an error creating resource (status code: `statusCode`)" or "Error when updating resource (status code:statusCode)"'      />

### Type Parameters

| Property         | Description                                                                                                                                                         | Type                       | Default                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData     | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError           | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TSearchVariables | Values for search params                                                                                                                                            |                            | `{}`                       |
| TData            | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Property                      | Description                                                                           | Type                                                                                                                                              |
| ----------------------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| tableQuery                    | Result of the `react-query`'s `useQuery`                                              | [` QueryObserverResult<{`` data: TData[];`` total: number; },`` TError> `][usequery]                                                              |
| current                       | Current page index state (returns `undefined` if pagination is disabled)              | `number` \| `undefined`                                                                                                                           |
| pageCount                     | Total page count (returns `undefined` if pagination is disabled)                      | `number` \| `undefined`                                                                                                                           |
| setCurrent                    | A function that changes the current (returns `undefined` if pagination is disabled)   | `React.Dispatch<React.SetStateAction<number>>` \| `undefined`                                                                                     |
| pageSize                      | Current pageSize state (returns `undefined` if pagination is disabled)                | `number` \| `undefined`                                                                                                                           |
| setPageSize                   | A function that changes the pageSize. (returns `undefined` if pagination is disabled) | `React.Dispatch<React.SetStateAction<number>>` \| `undefined`                                                                                     |
| sorters                       | Current sorting states                                                                | [`CrudSorting`][crudsorting]                                                                                                                      |
| setSorters                    | A function that accepts a new sorters state.                                          | `(sorters: CrudSorting) => void`                                                                                                                  |
| ~~sorter~~                    | Current sorting states                                                                | [`CrudSorting`][crudsorting]                                                                                                                      |
| ~~setSorter~~                 | A function that accepts a new sorters state.                                          | `(sorters: CrudSorting) => void`                                                                                                                  |
| filters                       | Current filters state                                                                 | [`CrudFilters`][crudfilters]                                                                                                                      |
| setFilters                    | A function that accepts a new filter state                                            | - `(filters: CrudFilters, behavior?: "merge" \| "replace" = "merge") => void` - `(setter: (previousFilters: CrudFilters) => CrudFilters) => void` |
| createLinkForSyncWithLocation | A function create accessible links for syncWithLocation                               | `(params: `[SyncWithLocationParams][syncwithlocationparams]`) => string;`                                                                         |
| overtime                      | Overtime loading props                                                                | `{ elapsedTime?: number }`                                                                                                                        |

[usequery]: https://react-query.tanstack.com/reference/useQuery
[baserecord]: /docs/core/interface-references#baserecord
[crudsorting]: /docs/core/interface-references#crudsorting
[crudfilters]: /docs/core/interface-references#crudfilters
[httperror]: /docs/core/interface-references#httperror
[Refine swl]: /docs/core/refine-component#syncwithlocation
[syncwithlocationparams]: /docs/core/interface-references#syncwithlocationparams
[notification-provider]: /docs/notification/notification-provider

================
File: data/hooks/use-update-many/index.md
================
---
title: useUpdateMany
siderbar_label: useUpdateMany
source: packages/core/src/hooks/data/useUpdateMany.ts
---

`useUpdateMany` is an extended version of TanStack Query's [`useMutation`](https://tanstack.com/query/v4/docs/react/reference/useMutation). It supports all the features of `useMutation` and adds some extra features.

- It uses the `updateMany` method as the **mutation function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine />`.

It is useful when you want to update many records at once.

If your data provider does not have a `updateMany` method, `useUpdateMany` will use the `update` method instead. It is not recommended, because it will make requests one by one for each id. It is better to implement the `updateMany` method in the data provider.

## Usage

The `useUpdateMany` hook returns many useful properties and methods. One of them is the `mutate` method which is used to trigger a mutation with the given [parameters](#mutation-parameters).

```tsx
import { useUpdateMany } from "@refinedev/core";

const { mutate } = useUpdateMany({
  resource: "products",
});

mutate({
  ids: [1, 2, 3],
  values: {
    name: "New Product",
    material: "Wood",
  },
});
```

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useUpdateMany` mutation runs successfully, it will call the `publish` method from `liveProvider` with some parameters such as `channel`, `type` etc. It is useful when you want to publish the changes to the subscribers on the client side.

## Invalidating Queries

When the `useUpdateMany` mutation runs successfully, by default it will invalidate the following queries from the current `resource`: `"list"`, `"many"`, and `"detail"`. That means, if you use `useList`, `useMany`, or `useOne` hooks on the same page, they will refetch the data after the mutation is completed. You can change this behavior by passing [`invalidates`](#invalidates) prop.

[Refer to the query invalidation documentation for more information &#8594](https://tanstack.com/query/v4/docs/react/guides/query-invalidation)

## Properties

### mutationOptions

`mutationOptions` is used to pass options to the `useMutation` hook. It is useful when you want to pass additional options to the `useMutation` hook.

[Refer to the `useMutation` documentation for more information &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

```tsx
useUpdateMany({
  mutationOptions: {
    retry: 3,
  },
  onSuccess: (data, variables, context) => {
    // Let's celebrate!
  },
  onError: (error, variables, context) => {
    // An error occurred!
  },
});
```

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useUpdateMany({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## Mutation Parameters

Mutation parameters are passed to the `mutate` function and can also be provided as props to the `useUpdateMany` hook. Parameters given to the `mutate` function override those from the hook. Think of the hook's parameters as default values, and the `mutate` function's parameters as specific or dynamic values for each mutation.

```tsx
import { useUpdateMany } from "@refinedev/core";

const { mutate } = useUpdateMany({
  /* parameters */
});

mutate({
  /* this will override the parameters given to the useUpdateMany hook */
});
```

> 🚨 Parameters marked as required can be provided either as props to the `useUpdateMany` hook or as parameters to the `mutate` function.

### resource <PropTag required />

It will be passed to the `updateMany` method from the `dataProvider` as a parameter. The parameter is usually used as an API endpoint path. It all depends on how to handle the `resource` in the `updateMany` method. See the [creating a data provider](/docs/data/data-provider) section for an example of how resources are handled.

```tsx
const { mutate } = useUpdateMany();

mutate({
  resource: "categories",
});
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### ids <PropTag required />

It will be passed to the `updateMany` method from the `dataProvider` as a parameter. It is used to determine which records will be updated.

```tsx
const { mutate } = useUpdateMany();

mutate({
  ids: [1, 2, 3],
});
```

### values <PropTag required />

It will be passed to the `updateMany` method from the `dataProvider` as a parameter. The parameter is usually used as the data to be updated. It contains the new values of the record.

```tsx
const { mutate } = useUpdateMany();

mutate({
  values: {
    name: "New Category",
    description: "New Category Description",
  },
});
```

### mutationMode

Mutation mode determines which mode the mutation runs with. Mutations can run under three different modes: `pessimistic`, `optimistic`, and `undoable`. The default mode is `pessimistic`.
Each mode corresponds to a different type of user experience.

[Refer to the mutation mode documentation for more information &#8594](/docs/advanced-tutorials/mutation-mode)

```tsx
const { mutate } = useUpdateMany();

mutate({
  mutationMode: "undoable",
});
```

### undoableTimeout

When `mutationMode` is set to `undoable`, `undoableTimeout` is used to determine duration to wait before executing the mutation. Default value is `5000` milliseconds.

```tsx
const { mutate } = useUpdateMany();

mutate({
  mutationMode: "undoable",
  undoableTimeout: 10000,
});
```

### onCancel

The `onCancel` property can be utilized when the `mutationMode` is set to `"undoable"`. It provides a function that can be used to cancel the ongoing mutation.

By defining `onCancel`, undoable notification will not be shown automatically. This gives you the flexibility to handle the cancellation process in your own way, such as showing a custom notification or implementing any other desired behavior to allow users to cancel the mutation.

```tsx
import { useRef } from "react";
import { useUpdateMany } from "@refinedev/core";

const MyComponent = () => {
  const { mutate } = useUpdateMany();
  const cancelRef = useRef<(() => void) | null>(null);

  const updateItems = () => {
    mutate({
      //...
      mutationMode: "undoable",
      onCancel: (cancelMutation) => {
        cancelRef.current = cancelMutation;
      },
    });
  };

  const cancelUpdate = () => {
    cancelRef.current?.();
  };

  return (
    <>
      <button onClick={updateItems}>Update</button>
      <button onClick={cancelUpdate}>Cancel</button>
    </>
  );
};
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useUpdateMany` can call the `open` function from `NotificationProvider` to show a success notification. With this prop, you can customize the success notification.

```tsx
const { mutate } = useUpdateMany();

mutate({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useUpdateMany` will call the `open` function from `NotificationProvider` to show an error notification. With this prop, you can customize the error notification.

```tsx
const { mutate } = useUpdateMany();

mutate({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

[Refer to the `meta` section of the General Concepts documentation for more information &#8594](/docs/guides-concepts/general-concepts/#meta-concept)

In the following example, we pass the `headers` property in the `meta` object to the `updateMany` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
const { mutate } = useUpdateMany();

mutate({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  updateMany: async ({
    resource,
    ids,
    variables,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;

    //...
    //...

    // highlight-start
    const { data } = await httpClient.patch(
      url,
      { ids, variables },
      { headers },
    );
    // highlight-end

    return {
      data,
    };
  },
  //...
};
```

### dataProviderName

If there is more than one `dataProvider`, you can specify which one to use by passing the `dataProviderName` prop. It is useful when you have a different data provider for different resources.

```tsx
const { mutate } = useUpdateMany();

mutate({
  dataProviderName: "second-data-provider",
});
```

### invalidates

`invalidates` is used to specify which queries should be invalidated after the mutation is completed.

By default, it invalidates the following queries from the current `resource`: `"list"`, `"many"` and `"detail"`. That means, if you use `useList`, `useMany`, or `useOne` hooks on the same page, they will refetch the data after the mutation is completed.

```tsx
const { mutate } = useUpdateMany();

mutate({
  invalidates: ["list", "many", "detail"],
});
```

### optimisticUpdateMap

If the mutation mode is defined as `optimistic` or `undoable` the `useUpdate` hook will automatically update the cache without waiting for the response from the server. You may want to disable or customize this behavior. You can do this by passing the `optimisticUpdateMap` prop.

When the mutation mode is set to `optimistic` or `undoable`, the `useUpdate` hook will automatically update the cache without waiting for a server response. If you need to customize update logic, you can achieve it by using the `optimisticUpdateMap` prop.

`list`, `many` and `detail` are the keys of the `optimisticUpdateMap` object. To automatically update the cache, you should pass `true`. If you don't want to update the cache, you should pass `false`.

```tsx
const { mutate } = useUpdateMany();

mutate({
  //...
  mutationMode: "optimistic",
  optimisticUpdateMap: {
    list: true,
    many: true,
    detail: false,
  },
});
```

In the scenario mentioned above, the `list` and `many` queries will receive automatic cache updates, whereas the `detail` query cache will remain unaffected.

If you wish to customize the cache update, you have the option to provide functions for the `list`, `many`, and `detail` keys. These functions will be invoked with the `previous` data, `values`, and `id` parameters. Your responsibility is to return the updated data within these functions.

```tsx
const { mutate } = useUpdateMany();

mutate({
  //...
  mutationMode: "optimistic",
  optimisticUpdateMap: {
    // highlight-start
    optimisticUpdateMap: {
      list: (previous, values, ids) => {
        if (!previous) {
          return null;
        }

        const data = previous.data.map((record) => {
          if (
            record.id !== undefined &&
            ids
              .filter((id) => id !== undefined)
              .map(String)
              .includes(record.id.toString())
          ) {
            return {
              foo: "bar",
              ...record,
              ...values,
            };
          }

          return record;
        });

        return {
          ...previous,
          data,
        };
      },
      many: (previous, values, ids) => {
        if (!previous) {
          return null;
        }

        const data = previous.data.map((record) => {
          if (
            record.id !== undefined &&
            ids
              .filter((id) => id !== undefined)
              .map(String)
              .includes(record.id.toString())
          ) {
            return {
              foo: "bar",
              ...record,
              ...values,
            };
          }
          return record;
        });

        return {
          ...previous,
          data,
        };
      },
      detail: (previous, values, id) => {
        if (!previous) {
          return null;
        }

        const data = {
          id,
          ...previous.data,
          ...values,
          foo: `bar`,
        };

        return {
          ...previous,
          data,
        };
      },
    },
  },
  // highlight-end
});
```

## Return Values

Returns an object with TanStack Query's `useMutation` return values.

[Refer to the `useMutation` documentation for more information &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useUpdateMany();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## API Reference

### Mutation Parameters

| Property                      | Description                                                                                        | Type                                                                                   | Default                                                      |
| ----------------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| resource <PropTag asterisk /> | Resource name for API data interactions                                                            | `string`                                                                               |                                                              |
| ids <PropTag asterisk />      | id for mutation function                                                                           | [`BaseKey[]`](/docs/core/interface-references#basekey)                                 |                                                              |
| values <PropTag asterisk />   | Values for mutation function                                                                       | `TVariables`                                                                           | {}                                                           |
| mutationMode                  | [Determines when mutations are executed](/docs/advanced-tutorials/mutation-mode)                   | ` "pessimistic` \| `"optimistic` \| `"undoable"`                                       | `"pessimistic"`\*                                            |
| undoableTimeout               | Duration to wait before executing the mutation when `mutationMode = "undoable"`                    | `number`                                                                               | `5000ms`\*                                                   |
| onCancel                      | Provides a function to cancel the mutation when `mutationMode = "undoable"`                        | `(cancelMutation: () => void) => void`                                                 |                                                              |
| successNotification           | Successful Mutation notification                                                                   | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "Successfully updated `resource`"                            |
| errorNotification             | Unsuccessful Mutation notification                                                                 | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "Error when updating `resource` (status code: `statusCode`)" |
| meta                          | Meta data query for `dataProvider`                                                                 | [`MetaDataQuery`](/docs/core/interface-references#metaquery)                           | {}                                                           |
| dataProviderName              | If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use. | `string`                                                                               | `default`                                                    |
| invalidates                   | You can use it to manage the invalidations that will occur at the end of the mutation.             | `all`, `resourceAll`, `list`, `many`, `detail`, `false`                                | `["list", "many", "detail"]`                                 |

> `*`: These props have default values in `RefineContext` and can also be set on [`<Refine>`](/docs/core/refine-component) component. `useUpdateMany` will use what is passed to `<Refine>` as default but a local value will override it.

### Type Parameters

| Property   | Description                                                                                     | Type                                                       | Default                                                    |
| ---------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| TData      | Result data of the mutation. Extends [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) |
| TError     | Custom error object that extends [`HttpError`](/docs/core/interface-references#httperror)       | [`HttpError`](/docs/core/interface-references#httperror)   | [`HttpError`](/docs/core/interface-references#httperror)   |
| TVariables | Values for mutation function                                                                    | `{}`                                                       | `{}`                                                       |

### Return value

| Description                                | Type                                                                                                                                                                                      |
| ------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Result of the TanStack Query's useMutation | [`UseMutationResult<{ data: TData }, TError, { resource:string; ids: BaseKey[]; values: TVariables; }, UpdateContext>`](https://tanstack.com/query/v4/docs/react/reference/useMutation)\* |
| overtime                                   | `{ elapsedTime?: number }`                                                                                                                                                                |

> `*` `UpdateContext` is an internal type.

================
File: data/hooks/use-update/index.md
================
---
title: useUpdate
siderbar_label: useUpdate
source: packages/core/src/hooks/data/useUpdate.ts
---

`useUpdate` is used when you want to update a record. It is an extended version of TanStack Query's [`useMutation`](https://tanstack.com/query/v4/docs/react/reference/useMutation) that supports all of its features and adds some more.

It uses the `update` method as the **mutation function** from the [`dataProvider`](/docs/data/data-provider) which is passed to `<Refine>`.

## Usage

The `useUpdate` hook returns many useful properties and methods. One of them is the `mutate` method which is used to trigger a mutation with the given [parameters](#mutation-parameters).

```tsx
import { useUpdate } from "@refinedev/core";

const { mutate } = useUpdate({
  resource: "products",
});

mutate({
  id: 1,
  values: {
    name: "New Product",
    material: "Wood",
  },
});
```

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useUpdate` mutation runs successfully, it will call the `publish` method from `liveProvider` with some parameters such as `channel`, `type` etc. It is useful when you want to publish the changes to the subscribers on the client side.

## Invalidating Queries

When the `useUpdate` mutation runs successfully, it will invalidate the following queries from the current `resource`: `"list"`, `"many"`, and `"detail"` by default. Which means that, if you use `useList`, `useMany`, or `useOne` hooks on the same page, they will refetch the data after the mutation is completed. You can change this behavior by passing the [`invalidates`](#invalidates) prop.

> For more information, refer to the [query invalidation documentation&#8594](https://tanstack.com/query/v4/docs/react/guides/query-invalidation)

## Audit Logs

> This feature is only available if you use a [Audit Log Provider](/docs/audit-logs/audit-log-provider).

When the `useUpdate` mutation runs successfully, it will call the `log` method from `auditLogProvider` with some parameters such as `resource`, `action`, `data`, `previousData` etc. It is useful when you want to log the changes to the database.

## Properties

### mutationOptions

`mutationOptions` is used to pass options to the `useMutation` hook. It is useful when you want to pass additional options to the `useMutation` hook.

```tsx
const { mutate } = useUpdate({
  resource: "products",
  id: 1,
  mutationOptions: {
    retry: 3,
    onSuccess: (data, variables, context) => {
      // Let's celebrate!
    },
    onError: (error, variables, context) => {
      // An error occurred!
    },
  },
});

mutate({
  values: {
    name: "New Product",
    material: "Wood",
  },
});
```

[Refer to the `useMutation` documentation for more information &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

## Mutation Parameters

Mutation parameters are passed to the `mutate` function and can also be provided as props to the `useUpdate` hook. Parameters given to the `mutate` function override those from the hook. Think of the hook's parameters as default values, and the `mutate` function's parameters as specific or dynamic values for each mutation.

```tsx
import { useUpdate } from "@refinedev/core";

const { mutate } = useUpdate({
  /* parameters */
});

mutate({
  /* this will override the parameters given to the useUpdate hook */
});
```

> 🚨 Parameters marked as required can be provided either as props to the `useUpdate` hook or as parameters to the `mutate` function.

### resource <PropTag required />

This parameter will be passed to the `update` method from the `dataProvider` as a parameter. It is usually used as an API endpoint path but it all depends on how you handle the `resource` in the `update` method.

```tsx
const { mutate } = useUpdate();

mutate({
  resource: "categories",
});
```

> For more information, refer to the [creating a data provider tutorial &#8594](/docs/data/data-provider)

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### id <PropTag required />

This prop will be passed to the `update` method from the `dataProvider` as a parameter. It is used to determine which record to update.

```tsx
const { mutate } = useUpdate();

mutate({
  id: 123,
});
```

### values <PropTag required />

This prop will be passed to the `update` method from the `dataProvider` as a parameter. It is usually used as the data to be updated and contains the data that will be sent to the server.

```tsx
const { mutate } = useUpdate();

mutate({
  values: {
    name: "New Category",
    description: "New Category Description",
  },
});
```

### mutationMode

Mutation mode determines which mode the mutation runs with. Mutations can run under three different modes: `pessimistic`, `optimistic`, and `undoable`. The default mode is `pessimistic`.
Each mode corresponds to a different type of user experience.

```tsx
const { mutate } = useUpdate();

mutate({
  mutationMode: "undoable",
});
```

> For more information, refer to the [mutation mode documentation &#8594](/docs/advanced-tutorials/mutation-mode)

### undoableTimeout

When `mutationMode` is set to `undoable`, `undoableTimeout` is used to determine the duration to wait before executing the mutation. The default value is `5000` milliseconds.

```tsx
const { mutate } = useUpdate();

mutate({
  mutationMode: "undoable",
  undoableTimeout: 10000,
});
```

### onCancel

The `onCancel` property can be utilized when the `mutationMode` is set to `"undoable"`. It provides a function that can be used to cancel the ongoing mutation.

By defining `onCancel`, undoable notification will not be shown automatically. This gives you the flexibility to handle the cancellation process in your own way, such as showing a custom notification or implementing any other desired behavior to allow users to cancel the mutation.

```tsx
import { useRef } from "react";
import { useUpdate } from "@refinedev/core";

const MyComponent = () => {
  const { mutate } = useUpdate();
  const cancelRef = useRef<(() => void) | null>(null);

  const updateItem = () => {
    mutate({
      //...
      mutationMode: "undoable",
      onCancel: (cancelMutation) => {
        cancelRef.current = cancelMutation;
      },
    });
  };

  const cancelUpdate = () => {
    cancelRef.current?.();
  };

  return (
    <>
      <button onClick={updateItem}>Update</button>
      <button onClick={cancelUpdate}>Cancel</button>
    </>
  );
};
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the success notification that shows up when the data is fetched successfully and `useUpdate` can calls `open` function from `NotificationProvider`:

```tsx
const { mutate } = useUpdate();

mutate({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

This prop allows you to customize the error notification that shows up when the data fetching fails and the `useUpdate` calls the `open` function from `NotificationProvider`:

```tsx
const { mutate } = useUpdate();

mutate({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `update` method. You can pass any properties to specifically handle the data provider methods with similar logic.

```tsx
const { mutate } = useUpdate();

mutate({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  update: async ({
    resource,
    id,
    variables,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}/${id}`;

    //...
    //...

    // highlight-next-line
    const { data } = await httpClient.patch(url, variables, { headers });

    return {
      data,
    };
  },
  //...
};
```

[Refer to the `meta` section of the General Concepts documentation for more information &#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### dataProviderName

This prop allows you to specify which `dataProvider` if you have more than one. Just pass it like in the example:

```tsx
const { mutate } = useUpdate();

mutate({
  dataProviderName: "second-data-provider",
});
```

### invalidates

`invalidates` is used to specify which queries should be invalidated after the mutation is completed.

By default, it invalidates the following queries from the current `resource`: `"list"`, `"many"` and `"detail"`. That means, if you use `useList`, `useMany`, or `useOne` hooks on the same page, they will refetch the data after the mutation is completed.

```tsx
const { mutate } = useUpdate();

mutate({
  invalidates: ["list", "many", "detail"],
});
```

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useUpdate({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### optimisticUpdateMap

If the mutation mode is defined as `optimistic` or `undoable` the `useUpdate` hook will automatically update the cache without waiting for the response from the server. You may want to disable or customize this behavior. You can do this by passing the `optimisticUpdateMap` prop.

When the mutation mode is set to `optimistic` or `undoable`, the `useUpdate` hook will automatically update the cache without waiting for a server response. If you need to customize update logic, you can achieve it by using the `optimisticUpdateMap` prop.

`list`, `many` and `detail` are the keys of the `optimisticUpdateMap` object. To automatically update the cache, you should pass `true`. If you don't want to update the cache, you should pass `false`.

```tsx
const { mutate } = useUpdate();

mutate({
  //...
  mutationMode: "optimistic",
  optimisticUpdateMap: {
    list: true,
    many: true,
    detail: false,
  },
});
```

In the scenario mentioned above, the `list` and `many` queries will receive automatic cache updates, whereas the `detail` query cache will remain unaffected.

If you wish to customize the cache update, you have the option to provide functions for the `list`, `many`, and `detail` keys. These functions will be invoked with the `previous` data, `values`, and `id` parameters. Your responsibility is to return the updated data within these functions.

```tsx
const { mutate } = useUpdate();

mutate({
  //...
  mutationMode: "optimistic",
  // highlight-start
  optimisticUpdateMap: {
    list: (previous, values, id) => {
      if (!previous) {
        return null;
      }

      const data = previous.data.map((record) => {
        if (record.id === id) {
          return {
            foo: "bar",
            ...record,
            ...values,
          };
        }
        return record;
      });

      return {
        ...previous,
        data,
      };
    },
    many: (previous, values, id) => {
      if (!previous) {
        return null;
      }

      const data = previous.data.map((record) => {
        if (record.id === id) {
          return {
            foo: "bar",
            ...record,
            ...values,
          };
        }
        return record;
      });

      return {
        ...previous,
        data,
      };
    },
    detail: (previous, values) => {
      if (!previous) {
        return null;
      }

      return {
        ...previous,
        data: {
          foo: "bar",
          ...previous.data,
          ...values,
        },
      };
    },
  },
  // highlight-end
});
```

## Return Values

Returns an object with TanStack Query's `useMutation` return values.

> For more information, refer to the [`useMutation` documentation &#8594](https://tanstack.com/query/v4/docs/react/reference/useMutation)

### Additional Values

#### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useUpdate();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

## API Reference

### Mutation Parameters

| Property                      | Description                                                                                        | Type                                                                                   | Default                                                      |
| ----------------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| resource <PropTag asterisk /> | Resource name for API data interactions                                                            | `string`                                                                               |                                                              |
| id <PropTag asterisk />       | id for mutation function                                                                           | [`BaseKey`](/docs/core/interface-references#basekey)                                   |                                                              |
| values <PropTag asterisk />   | Values for mutation function                                                                       | `TVariables`                                                                           | {}                                                           |
| mutationMode                  | [Determines when mutations are executed](/docs/advanced-tutorials/mutation-mode)                   | ` "pessimistic` \| `"optimistic` \| `"undoable"`                                       | `"pessimistic"`\*                                            |
| undoableTimeout               | Duration to wait before executing the mutation when `mutationMode = "undoable"`                    | `number`                                                                               | `5000ms`\*                                                   |
| onCancel                      | Provides a function to cancel the mutation when `mutationMode = "undoable"`                        | `(cancelMutation: () => void) => void`                                                 |                                                              |
| successNotification           | Successful Mutation notification                                                                   | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "Successfully updated `resource`"                            |
| errorNotification             | Unsuccessful Mutation notification                                                                 | [`SuccessErrorNotification`](/docs/core/interface-references#successerrornotification) | "Error when updating `resource` (status code: `statusCode`)" |
| meta                          | Meta data query for `dataProvider`                                                                 | [`MetaDataQuery`](/docs/core/interface-references#metaquery)                           | {}                                                           |
| dataProviderName              | If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use. | `string`                                                                               | `default`                                                    |
| invalidates                   | You can use it to manage the invalidations that will occur at the end of the mutation.             | `all`, `resourceAll`, `list`, `many`, `detail`, `false`                                | `["list", "many", "detail"]`                                 |

:::simple Global Configuration

These props have default values in `RefineContext` and can also be set on [`<Refine>`](/docs/core/refine-component) component. `useUpdate` will use what's passed to `<Refine>` as default, but a local value will override it.

:::

<br/>

### Type Parameters

| Property   | Description                                                                                     | Type                                                       | Default                                                    |
| ---------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| TData      | Result data of the mutation. Extends [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) | [`BaseRecord`](/docs/core/interface-references#baserecord) |
| TError     | Custom error object that extends [`HttpError`](/docs/core/interface-references#httperror)       | [`HttpError`](/docs/core/interface-references#httperror)   | [`HttpError`](/docs/core/interface-references#httperror)   |
| TVariables | Values for mutation function                                                                    | `{}`                                                       | `{}`                                                       |

### Return value

| Description                                | Type                                                                                                                                                                                   |
| ------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Result of the TanStack Query's useMutation | [`UseMutationResult<{ data: TData }, TError, { resource:string; id: BaseKey; values: TVariables; }, UpdateContext>`](https://tanstack.com/query/v4/docs/react/reference/useMutation)\* |
| overtime                                   | `{ elapsedTime?: number }`                                                                                                                                                             |

> `*` `UpdateContext` is an internal type.

================
File: data/simple-rest/index.md
================
---
title: Simple REST
source: https://github.com/refinedev/refine/tree/main/packages/simple-rest
swizzle: true
---

The Simple REST data provider is a package that provides an implementation for working with REST APIs that conform to a standard API design. It is built on the foundation of the [json-server](https://github.com/typicode/json-server) package.

You can use this data provider to quickly get started with Refine and then customize it to fit your specific needs.

## Installation

<InstallPackagesCommand args="@refinedev/simple-rest"/>

## Usage

Simple REST package exports a function that accepts `apiUrl` and `httpClient` parameters. While `apiUrl` is required to set the base URL for your API endpoints, `httpClient` is optional and can be used to provide a custom axios instance to handle logics like authentication, error handling, etc.

```tsx title="app.tsx"
import { Refine } from "@refinedev/core";
// highlight-start
import dataProvider from "@refinedev/simple-rest";
import axios from "axios";
// highlight-end

// highlight-start
const httpClient = axios.create();

const App = () => {
  return (
    <Refine
      // highlight-start
      // `httpClient` is optional.
      dataProvider={(dataProvider("<API_URL>"), httpClient)}
      // highlight-end
      /* ... */
    />
  );
};
```

## URL design

The data provider methods are designed to work with REST APIs that follow the standard design. The following table shows the expected URL for each method:

| Method      | URL                          | Query Parameters                   | Body              |
| ----------- | ---------------------------- | ---------------------------------- | ----------------- |
| `getList`   | `apiUrl` / `resource`        | `pagination`, `sorters`, `filters` |                   |
| `getOne`    | `apiUrl` / `resource` / `id` |                                    |                   |
| `getMany`   | `apiUrl` / `resource`        | `id`                               |                   |
| `create`    | `apiUrl` / `resource`        |                                    | `variables`       |
| `update`    | `apiUrl` / `resource` / `id` |                                    | `variables`       |
| `deleteOne` | `apiUrl` / `resource` / `id` |                                    | `data: variables` |

## Default HTTP methods and customizing them

The following table shows the HTTP method used for each data provider method:

| Method      | HTTP Method |
| ----------- | ----------- |
| `getList`   | `GET`       |
| `getOne`    | `GET`       |
| `getMany`   | `GET`       |
| `create`    | `POST`      |
| `update`    | `PATCH`     |
| `deleteOne` | `DELETE`    |

You can customize the HTTP method used for each data provider method by passing a `method` property in the `meta` parameter when calling a hook.

```tsx
import { useUpdate } from "@refinedev/core";

const { mutate } = useUpdate();

mutate({
  resource: "posts",
  id: 1,
  values: {
    title: "New title",
  },
  //highlight-start
  meta: {
    method: "put",
  },
  //highlight-end
});
```

## Passing custom headers

You can pass custom headers to the data provider by passing a `headers` property in the `meta` parameter.

```tsx
import { useOne } from "@refinedev/core";

useOne({
  resource: "posts",
  id: 1,
  //highlight-start
  meta: {
    headers: {
      "X-Custom-Header": "Custom header value",
    },
  },
  //highlight-end
});
```

## Customizing the data provider <GuideBadge id="packages/cli/#swizzle" />

In some cases, you may need to customize the data provider to work with a REST API that doesn't follow the simple-rest design. In this case, you can use the `swizzle` command to customize the data provider.

1. Run the `swizzle` command in the project directory:

   ```bash
   npm run refine swizzle
   ```

2. Select `@refinedev/simple-rest` from the list of available data providers.

3. Edit the `/rest-data-provider/index.ts` file to customize the data provider.

4. Pass the customized data provider to the `dataProvider` prop of the `Refine` component.

   ```tsx
   import { Refine } from "@refinedev/core";

   import { dataProvider } from "./rest-data-provider";

   const App = () => {
     return (
       <Refine
         dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
         /* ... */
       />
     );
   };
   ```

================
File: examples/audit-log/audit-log-antd.md
================
---
id: audit-log-antd
title: Audit Log with Antd
example-tags: [audit-log-provider, antd]
example-title: Audit Log with Antd
---

Refine allows you to track changes and who made them in your data by sending a new log event record whenever a new record is created, updated or deleted. This example demonstrates creating an audit log with [Ant Design](https://ant.design/).

[Refer to the Refine Audit Log Provider documentation for more information. →](/docs/audit-logs/audit-log-provider)

<CodeSandboxExample path="antd-audit-log" />

================
File: examples/audit-log/audit-log-provider.md
================
---
id: audit-log-provider
title: Audit Log Provider
example-tags: [audit-log-provider]
example-title: Audit Log with Headless
---

Refine allows you to track changes and who made them in your data by sending a new log event record whenever a new record is created, updated or deleted. This example demonstrates how to create an audit log provider.

[Refer to the Refine Audit Log Provider documentation for more information. →](/docs/audit-logs/audit-log-provider)

<CodeSandboxExample path="audit-log-provider" />

================
File: examples/auth-provider/auth0.md
================
---
id: auth0
title: Auth0
example-tags: [auth-provider]
---

[Auth0](https://auth0.com/) is a modular, API-first authentication and authorization service that you may use to add authentication and authorization to your apps. In this example, you'll see how to use Auth0 Login with Refine.

[Refer to the Refine Auth0 Login guide for more information. →](/docs/advanced-tutorials/auth/auth0/)

Auth0 example doesn't work in CodeSandbox embed mode. With [this](https://cv8k99.csb.app/) link, you can open the example in the browser and try it.

<CodeSandboxExample path="auth-auth0" />

================
File: examples/auth-provider/google-auth.md
================
---
id: google-auth
title: Google Auth
example-tags: [auth-provider]
---

You can use Google Login to control access and provide identity for your app. This example will guide you through how to connect Google Login into your project using Refine.

:::note

If you are developing your own OAuth application, it's important to add the URLs of both your deployed application and your local development to the list of allowed origins in the OAuth app settings. Failure to do so can cause the app to fail.

For more detailed guidance, you may find this helpful [video tutorial](https://www.youtube.com/watch?v=HtJKUQXmtok).

:::

<CodeSandboxExample path="auth-google-login" />

================
File: examples/auth-provider/keycloak.md
================
---
id: keycloak
title: Keycloak
example-tags: [auth-provider]
---

[Keycloak](https://www.keycloak.org) is a modular, API-first authentication and authorization service that you may use to add authentication and authorization to your apps. In this example, you'll see how to use Keycloak Login with Refine.

:::note Demo Credentials

**Username**: Refine
**Password**: Refine

:::

<CodeSandboxExample path="auth-keycloak" />

================
File: examples/auth-provider/kinde.md
================
---
id: kinde
title: Kinde
example-tags: [auth-provider, community]
---

[Kinde](https://kinde.com/) is a service that makes authentication and authorization easy by providing a range of methods to choose from. In this example, you'll see how to use Kinde Login with Refine.

Kinde example doesn't work in CodeSandbox embed mode as it needs to whitelist callback URLs. With [this](https://xnv6hq-5173.csb.app/) link, you can open the example in the browser and try it.

<CodeSandboxExample path="auth-kinde" />

================
File: examples/auth-provider/otpLogin.md
================
---
id: otpLogin
title: OTP Login
example-tags: [auth-provider]
---

A one-time password(OTP) is a password that has two fundamental properties : it expires quickly, and it can’t be reused. OTPs are usually numeric or alphanumeric strings and are generated for a single login procedure. This example shows how to utilize OTP input logic with Refine. You can use one-time passwords to access your application with Refine [AuthProvider](/docs/authentication/auth-provider).

<CodeSandboxExample path="auth-otp" />

================
File: examples/authentication/antd.md
================
---
id: antd
title: Authentication in Ant Design
sidebar_label: Authentication
example-title: Authentication with Ant Design
example-tags: [antd, auth-provider]
---

You can create your own Authentication approach using Refine. You can customize the [AuthProvider](/docs/authentication/auth-provider) methods according to your needs and control the privileges of your users. This example is a simple example of custom authentication with Refine.

<CodeSandboxExample path="auth-antd" />

================
File: examples/authentication/headless.md
================
---
id: headless
title: Headless
example-title: Authentication Example
example-tags: [headless, auth-provider]
---

You can create your own Authentication approach using Refine. You can customize the [AuthProvider](/docs/authentication/auth-provider) methods according to your needs and control the privileges of your users. This example is a simple example of custom authentication with Refine.

<CodeSandboxExample path="auth-headless" />

================
File: examples/calendar.md
================
---
slug: ant-design-calendar-example
id: antd-calendar-example
title: Calendar
example-tags: [antd]
---

In this example you can see how Ant Design's [Calendar](https://ant.design/components/calendar) component can be used with Refine data hooks.

<CodeSandboxExample path="calendar-app" />

================
File: examples/customization/theme/customThemeAntd.md
================
---
id: customThemeAntd
title: Custom Theme in Ant Design
sidebar_label: Custom Theme
example-title: Custom Theme Ant Design
example-tags: [antd, customization]
---

You can customize design and theme in your project with Refine. In this example, we have created an example application by customizing the default theme of Refine. You can easily customize your theme as you wish in your Refine project.

<CodeSandboxExample path="customization-theme-antd" />

================
File: examples/data-provider/multiple.md
================
---
id: multiple
title: Multiple Providers
example-tags: [data-provider]
---

Refine's Multiple Data Provider feature allows you to connect multiple backends and manage their data with a single interface. This tutorial explains in detail how to use the Multiple Data Provider in your project.

<CodeSandboxExample path="data-provider-multiple" />

================
File: examples/data-provider/supabase.md
================
---
id: supabase
title: Supabase
example-tags: [data-provider, live-provider, auth-provider]
---

Connect your [Supabase](https://supabase.com/) database with Refine Supabase Data Provider and easily manage all the features that the database offers in your interface. This example will show you how Supabase Data Provider works and is used.

:::note

StackBlitz environment does not allow Realtime features to work.

:::

<CodeSandboxExample path="data-provider-supabase" />

================
File: examples/form/antd/custom-form-validation.md
================
---
id: custom-form-validation
title: Custom Form Validation
example-tags: [form, antd]
---

You can make basic validations with Ant Design [Form.Item](https://ant.design/components/form/#Form.Item) rules propertyp to the forms you have created with Refine. In addition, it allows you to make custom validations that you want or need. It is very easy to add your custom rules and validations by using the validator function within the Form.Item rules property. In the example below, a custom form validation process is explained in detail.

[Refer to the Refine Custom Form Validation documentation for more information. →](/docs/ui-integrations/ant-design/hooks/use-steps-form)

<CodeSandboxExample path="form-antd-custom-validation" />

================
File: examples/form/antd/serverSideFormValidation.md
================
---
id: serverSideFormValidation
title: Server-Side Form Validation
example-tags: [form, antd]
---

You can handle server-side form validation errors out-of-the-box with [Ant Design useForm][antd-use-form].

When `dataProvider` returns rejected promise with `errors` field, [`useForm`][react-hook-form-use-form] will automatically update the error state with the rejected `errors` field.

[Refer to the server-side Form Validation documentation for more information. →](/docs/guides-concepts/forms/#server-side-validation-)

<CodeSandboxExample path="server-side-form-validation-antd" />

[antd-use-form]: /docs/ui-integrations/ant-design/hooks/use-form

================
File: examples/form/antd/useDrawerForm.md
================
---
id: useDrawerForm
title: useDrawerForm
example-tags: [form, antd]
---

`useDrawerForm` hook allows you to access and manage the forms you've created in the Drawer Component. The code below may help you understand how to create and manage forms in a Drawer component.

[Refer to the Refine useDrawerForm hook documentation for more information. →](/docs/ui-integrations/ant-design/hooks/use-drawer-form)

<CodeSandboxExample path="form-antd-use-drawer-form" />

================
File: examples/form/antd/useForm.md
================
---
id: useForm
title: useForm
example-tags: [form, antd]
---

Refine `useForm` is a hook that helps you manage methods such as `create`, `edit`, and `clone` within the form. In this example, we constructed forms that you may use to create, edit, and clone posts using the userForm hook. You may look at the example to see how it's used.

[Refer to the Refine useForm hook documentation for more information. →](/docs/ui-integrations/ant-design/hooks/use-form)

<CodeSandboxExample path="form-antd-use-form" />

================
File: examples/form/antd/useModalForm.md
================
---
id: useModalForm
title: useModalForm
example-tags: [form, antd]
---

With the `useModalForm` hook, you can manage a form inside of your modal component. It returns [Ant Design Form](https://ant.design/components/form/) and [Modal](https://ant.design/components/modal/) props. You may examine the code below to learn how to create and manage forms within a modal.

[Refer to the Refine useModalForm hook documentation for more information. →](/docs/ui-integrations/ant-design/hooks/use-modal-form)

<CodeSandboxExample path="form-antd-use-modal-form" />

================
File: examples/form/antd/useStepsForm.md
================
---
id: useStepsForm
title: useStepsForm
example-tags: [form, antd]
---

The `useStepsForm` hook is a method that allows you to split your form into multiple sections using an Ant Design [Steps](https://ant.design/components/steps/) component, which can be used to manage your form. If your form contains multiple steps, as in the example below, it's pretty simple to manage and handle your Steps form using the Refine `useStepsForm` hook.

[Refer to the Refine useStepsForm hook documentation for more information. →](/docs/ui-integrations/ant-design/hooks/use-steps-form)

<CodeSandboxExample path="form-antd-use-steps-form" />

================
File: examples/form/chakra-ui/serverSideFormValidation.md
================
---
id: serverSideFormValidation
title: Server-Side Form Validation
example-tags: [form, chakra-ui, react-hook-form]
---

You can handle server-side form validation errors out-of-the-box with [React Hook Form useForm][react-hook-form-use-form].

When `dataProvider` returns rejected promise with `errors` field, [`useForm`][react-hook-form-use-form] will automatically update the error state with the rejected `errors` field.

[Refer to the server-side Form Validation documentation for more information. →](/docs/guides-concepts/forms/#server-side-validation-)

<CodeSandboxExample path="server-side-form-validation-chakra-ui" />

[react-hook-form-use-form]: /docs/packages/list-of-packages

================
File: examples/form/chakra-ui/useDrawerForm.md
================
---
id: useDrawerForm
title: useDrawerForm
example-tags: [form, chakra-ui, react-hook-form]
---

`useModalForm` hook allows you to manage a form within a modal as well as a drawer. It provides some useful methods to handle the form modal or form drawer. You can view the live example or review the source code to see how it's used with Chakra UI.

<CodeSandboxExample path="form-chakra-ui-use-drawer-form" />

================
File: examples/form/chakra-ui/useForm.md
================
---
id: useForm
title: useForm
example-tags: [form, chakra-ui, react-hook-form]
---

Refine allows you to use all the features of [React Hook Form](https://react-hook-form.com/) library with `@refinedev/react-hook-form` adapter. Using this package, you can create your own **headless** forms and use all the features provided by React Hook Form in your Refine project in a compatible way. You can view the live example or review the source code to see how it's used with Chakra UI.

[Refer to the useForm hook documentation for more information. →](/docs/packages/list-of-packages)

<CodeSandboxExample path="form-chakra-ui-use-form" />

================
File: examples/form/chakra-ui/useModalForm.md
================
---
id: useModalForm
title: useModalForm
example-tags: [form, chakra-ui, react-hook-form]
---

`useModalForm` hook allows you to manage a form within a modal. It provides some useful methods to handle the form modal. You can view the live example or review the source code to see how it's used with Chakra UI.

<CodeSandboxExample path="form-chakra-use-modal-form" />

================
File: examples/form/mantine/serverSideFormValidation.md
================
---
id: serverSideFormValidation
title: Server-Side Form Validation
example-tags: [form, mantine]
---

You can handle server-side form validation errors out-of-the-box with [Mantine useForm][mantine-use-form].

When `dataProvider` returns rejected promise with `errors` field, [`useForm`][react-hook-form-use-form] will automatically update the error state with the rejected `errors` field.

[Refer to the server-side Form Validation documentation for more information. →](/docs/guides-concepts/forms/#server-side-validation-)

<CodeSandboxExample path="server-side-form-validation-mantine" />

[mantine-use-form]: /docs/ui-integrations/mantine/hooks/use-form

================
File: examples/form/mantine/useDrawerForm.md
================
---
id: useDrawerForm
title: useDrawerForm
example-tags: [form, mantine]
---

`useModalForm` hook allows you to manage a form within a modal as well as a drawer. It provides some useful methods to handle the form modal or form drawer. You can view the live example or review the source code to see how it's used with Mantine.

[Refer to the useModalForm hook documentation for more information. →](/docs/ui-integrations/mantine/hooks/use-modal-form)

<CodeSandboxExample path="form-mantine-use-drawer-form" />

================
File: examples/form/mantine/useForm.md
================
---
id: useForm
title: useForm
example-tags: [form, mantine]
---

Refine works integrated with `useForm` of `@mantine/form` library. Using this package, you can use all the features provided by Mantine in your Refine project in a compatible way. You can view the live example or review the source code to see how it's used with Mantine.

[Refer to the useForm hook documentation for more information. →](/docs/ui-integrations/mantine/hooks/use-form)

<CodeSandboxExample path="form-mantine-use-form" />

================
File: examples/form/mantine/useModalForm.md
================
---
id: useModalForm
title: useModalForm
example-tags: [form, mantine]
---

`useModalForm` hook allows you to manage a form within a modal. It provides some useful methods to handle the form modal. You can view the live example or review the source code to see how it's used with Mantine.

[Refer to the useModalForm hook documentation for more information. →](/docs/ui-integrations/mantine/hooks/use-modal-form)

<CodeSandboxExample path="form-mantine-use-modal-form" />

================
File: examples/form/mantine/useStepsForm.md
================
---
id: useStepsForm
title: useStepsForm
example-tags: [form, mantine]
---

`useStepsForm` allows you to manage a form with multiple steps. It provides features such as which step is currently active, the ability to go to a specific step and validation when changing steps etc. You can view the live example or review the source code to see how it's used with Mantine.

[Refer to the useStepsForm hook documentation for more information. →](/docs/ui-integrations/mantine/hooks/use-steps-form)

<CodeSandboxExample path="form-mantine-use-steps-form" />

================
File: examples/form/mui/serverSideFormValidation.md
================
---
id: serverSideFormValidation
title: Server-Side Form Validation
example-tags: [form, material-ui]
---

You can handle server-side form validation errors out-of-the-box with [React Hook Form useForm][react-hook-form-use-form].

When `dataProvider` returns rejected promise with `errors` field, [`useForm`][react-hook-form-use-form] will automatically update the error state with the rejected `errors` field.

[Refer to the server-side Form Validation documentation for more information. →](/docs/guides-concepts/forms/#server-side-validation-)

<CodeSandboxExample path="server-side-form-validation-material-ui" />

[react-hook-form-use-form]: /docs/packages/list-of-packages

================
File: examples/form/mui/useDrawerForm.md
================
---
id: useDrawerForm
title: useDrawerForm
example-tags: [form, mui, react-hook-form]
---

`useModalForm` hook allows you to manage a form within a modal as well as a drawer. It provides some useful methods to handle the form modal or form drawer. You can view the live example or review the source code to see how it's used with Material UI.

[Refer to the useModalForm hook documentation for more information. →](/docs/packages/list-of-packages)

<CodeSandboxExample path="form-material-ui-use-drawer-form" />

================
File: examples/form/mui/useForm.md
================
---
id: useForm
title: useForm
example-tags: [form, mui, react-hook-form]
---

Refine allows you to use all the features of [React Hook Form](https://react-hook-form.com/) library with `@refinedev/react-hook-form` adapter. Using this package, you can create your own **headless** forms and use all the features provided by React Hook Form in your Refine project in a compatible way. You can view the live example or review the source code to see how it's used with Material UI.

[Refer to the useForm hook documentation for more information. →](/docs/packages/list-of-packages)

<CodeSandboxExample path="form-material-ui-use-form" />

================
File: examples/form/mui/useModalForm.md
================
---
id: useModalForm
title: useModalForm
example-tags: [form, mui, react-hook-form]
---

`useModalForm` hook allows you to manage a form within a modal. It provides some useful methods to handle the form modal. You can view the live example or review the source code to see how it's used with Material UI.

[Refer to the useModalForm hook documentation for more information. →](/docs/packages/list-of-packages)

<CodeSandboxExample path="form-material-ui-use-modal-form" />

================
File: examples/form/mui/useStepsForm.md
================
---
id: useStepsForm
title: useStepsForm
example-tags: [form, mui, react-hook-form]
---

`useStepsForm` allows you to manage a form with multiple steps. It provides features such as which step is currently active, the ability to go to a specific step and validation when changing steps etc. You can view the live example or review the source code to see how it's used with Material UI.

[Refer to the useStepsForm hook documentation for more information. →](/docs/packages/list-of-packages)

<CodeSandboxExample path="form-material-ui-use-steps-form" />

================
File: examples/form/react-hook-form/useForm.md
================
---
id: useForm
title: useForm
example-tags: [form, headless, react-hook-form]
---

Refine allows you to use all the features of [React Hook Form](https://react-hook-form.com/) library with `@refinedev/react-hook-form` adapter. Using this package, you can create your own **headless** forms and use all the features provided by React Hook Form in your Refine project in a compatible way. For more information, you can view the live example or review the source code.

[Refer to the useForm documentation for more information. →](/docs/packages/list-of-packages)

<CodeSandboxExample path="form-react-hook-form-use-form" />

================
File: examples/form/react-hook-form/useModalForm.md
================
---
id: useModalForm
title: useModalForm
example-tags: [form, headless, react-hook-form]
---

`useModalForm` hook allows you to manage a form within a modal. It provides some useful methods to handle the form modal. For more information, you can view the live example or review the source code.

[Refer to the useModalForm documentation for more information. →](/docs/packages/list-of-packages)

<CodeSandboxExample path="form-react-hook-form-use-modal-form" />

================
File: examples/form/react-hook-form/useStepsForm.md
================
---
id: useStepsForm
title: useStepsForm
example-tags: [form, headless, react-hook-form]
---

`useStepsForm` allows you to manage a form with multiple steps. It provides features such as which step is currently active, the ability to go to a specific step and validation when changing steps etc. For more information, you can view the live example or review the source code.

[Refer to the useStepsForm documentation for more information. →](/docs/packages/list-of-packages)

<CodeSandboxExample path="form-react-hook-form-use-steps-form" />

================
File: examples/table/antd/advanced-table.md
================
---
id: advancedTable
title: Advanced Tables with Ant Design
sidebar_label: Advanced Table
example-title: Advanced Ant Design Table
example-tags: [table, antd]
---

Multiple record deletion, modification, and other features can be used simultaneously in a table. It's an example of a Advanced Table made with Refine's customization feature.

<CodeSandboxExample path="table-antd-advanced" />

================
File: examples/table/antd/table-filter.md
================
---
id: tableFilter
title: Table Filters in Ant Design
sidebar_label: Table Filters
example-title: Filtering on Ant Design Table
example-tags: [table, antd]
---

The `Table Filter` option allows you to apply filters to the data in your table. The example below demonstrates how you might filter and display data in your table based on certain field parameters.
By filtering your table's data you may only see the fields you want.

<CodeSandboxExample path="table-antd-table-filter" />

================
File: examples/table/antd/useDeleteMany.md
================
---
id: useDeleteMany
title: useDeleteMany
example-title: Ant Design useDeleteMany Hook
example-tags: [table, antd]
---

The `useDeleteMany` is one of Refine's data hooks. It removes more than one data from the database. We used the `useDeleteMany` hook to remove more than one record from our table in this scenario. On your table, you may remove multiple records by selecting them and pressing delete. You can get more information by examining the example.

[Refer to the Refine useDeleteMany data hook documentation for more information. →](/docs/data/hooks/use-delete)

<CodeSandboxExample path="table-antd-use-delete-many" />

================
File: examples/table/antd/useEditableTable.md
================
---
id: useEditableTable
title: useEditableTable
example-title: Ant Design useEditableTable Hook
example-tags: [table, antd]
---

`useEditableTable`, includes all of the capabilities of [`useTable`](/docs/ui-integrations/ant-design/hooks/use-table). It also enables you to edit your Table in addition to these advantages. It returns Ant Design [Table](https://ant.design/components/table/#API) and [Form](https://ant.design/components/form/#API) components props.

[Refer to the Refine useEditableTable hook documentation for more information. →](/docs/ui-integrations/ant-design/hooks/use-editable-table)

<CodeSandboxExample path="table-antd-use-editable-table" />

================
File: examples/table/antd/useTable.md
================
---
id: useTable
title: useTable
example-title: Ant Design useTable Hook
example-tags: [table, antd]
---

You may use the `useTable` hook to process your data with features compatible with the Ant Design [Table](https://ant.design/components/table/) Component. You can be used as an out-of-the-box feature without needing to do extra operations for sorting, filtering, and pagination.

[Refer to the Refine useTable hook documentation for more information. →](/docs/ui-integrations/ant-design/hooks/use-table)

<CodeSandboxExample path="table-antd-use-table" />

================
File: examples/table/antd/useUpdateMany.md
================
---
id: useUpdateMany
title: useUpdateMany
example-title: Ant Design useUpdateMany Hook
example-tags: [table, antd]
---

`useUpdateMany` is one of Refine's data hooks. It performs the process of updating more than one data. In this example, we used the `useUpdateMany` hook to edit multiple data on the table. You can edit more than one data by selecting the rows you want to edit on your table. You can get more information by examining the example.

[Refer to the Refine useUpdateMany data hook documentation for more information. →](/docs/data/hooks/use-update)

<CodeSandboxExample path="table-antd-use-update-many" />

================
File: examples/table/tanstack-table/advanced.md
================
---
id: advanced-tanstack-table
title: Advanced Tables with Tanstack Table
sidebar_label: Advanced Table
example-title: Advanced TanStack Table
example-tags: [table, react-table, tanstack-table]
---

It is an example of Advanced [TanStack Table](https://tanstack.com/table) created with Refine's `@refinedev/react-table` adapter. In addition to the Basic TanStack Table example, deletion editing and filtering features are used together in your table. For more information, you can view the live example or review the source code.

<CodeSandboxExample path="table-react-table-advanced" />

================
File: examples/table/tanstack-table/basic.md
================
---
id: basic-tanstack-table
title: Tables with Tanstack Table
sidebar_label: Basic Table
example-title: Basic TanStack Table
example-tags: [table, react-table, tanstack-table]
---

Refine allows you to use all the features of [TanStack Table](https://tanstack.com/table) with `@refinedev/react-table` adapter. In this way, you can manage your server-side data operations. By using this adapter, you can directly use all the features of TanStack Table in your Refine project.

[Refer to the Refine TanStack Table documentation for more information. →](/docs/packages/list-of-packages)

<CodeSandboxExample path="table-react-table-basic" />

================
File: examples/themes/refine-themes-antd.md
================
---
id: refine-themes-antd
title: Refine Themes in Ant Design
sidebar_label: Refine Themes
example-title: Ant Design
example-tags: [antd, customization]
---

You can use predefined themes provided by Refine. In this example, we have created an example application by using the [`RefineThemes`](/docs/ui-integrations/ant-design/theming#predefined-themes) from `@refinedev/antd`. You can easily [customize your theme](/docs/ui-integrations/ant-design/theming#overriding-the-themes) as you wish in your Refine project.

<CodeSandboxExample path="theme-antd-demo" />

================
File: examples/upload/antd/base64.md
================
---
id: base64
title: Base64 Upload
example-tags: [antd, upload]
---

Refine allows you to upload your files or images in your forms as Base64 Upload. When uploading a file or an image to a source, you can complete your upload by encoding it to Base64. In this example, you'll learn how to use Refine's file2Base64 function to upload a file as Base64.

[Refer to the Refine Base64 Upload documentation for more information. →](/docs/advanced-tutorials/upload/base64-upload/)

<CodeSandboxExample path="upload-antd-base64" />

================
File: examples/upload/antd/multipart.md
================
---
id: multipart
title: Multipart Upload
example-tags: [antd, upload]
---

`Multipart Upload` is supported by the Refine. With Refine, you may upload any file using `Multipart Upload` logic. In this example we showed you how to upload images with Multipart Upload to a resource. Check out the live example for more information.

[Refer to the Refine Multipart Upload documentation for more information. →](/docs/advanced-tutorials/upload/multipart-upload/)

<CodeSandboxExample path="upload-antd-multipart" />

================
File: further-readings/comparison.md
================
---
title: Comparison | Refine vs React-Admin vs AdminBro vs Retool vs Redwood
sidebar_label: Comparison
---

:::note

This comparison table strives to be as accurate and as unbiased as possible. If you use any of these libraries and feel the information could be improved, feel free to suggest changes (with notes or evidence of claims) using the "Edit this page" link at the bottom of this page.

:::

- ✅ &nbsp;1st-class, built-in, and ready to use with no added configuration or code
- 🟡 &nbsp;Supported, but as an unofficial 3rd party or community library/contribution
- 🔶 &nbsp;Supported and documented, but requires extra user-code to implement
- 🛑 &nbsp;Not officially supported or documented.

| Features                             | Refine                                                                                             | React-Admin                                | AdminBro                         | Retool              | Redwood                                               |
| ------------------------------------ | -------------------------------------------------------------------------------------------------- | ------------------------------------------ | -------------------------------- | ------------------- | ----------------------------------------------------- |
| GitHub Stars                         | [![][stars-refine]][gh-refine]                                                                     | [![][stars-react-admin]][gh-react-admin]   | [![][stars-adminjs]][gh-adminjs] | -                   | [![][stars-redwood]][gh-redwood]                      |
| Bundle Size                          | [![][bp-refine]][bpl-refine]                                                                       | [![][bp-react-admin]][bpl-react-admin]     | [![][bp-adminjs]][bpl-adminjs]   | -                   | [![][bp-redwood]][bpl-redwood]                        |
| Pricing                              | Open Source                                                                                        | Open Source / Enterprise Edition           | Open Source                      | SaaS                | Open Source                                           |
| Platform                             | React                                                                                              | React                                      | Node.js - React                  | Cloud / Self-hosted | React - Node                                          |
| Supported UI Frameworks              | **Ant Design, Material UI, Tailwind, Mantine, Chakra UI, anything...**                             | Material UI                                | Own UIs                          | Own UIs             | Tailwind, Chakra, Mantine, WindiCSS and custom styles |
| Headless                             | **Yes**                                                                                            | No                                         | No                               | No                  | No                                                    |
| Access Control                       | **RBAC, ACL, ABAC, etc.**                                                                          | RBAC                                       | RBAC                             | RBAC                | RBAC                                                  |
| SSR Support                          | **Yes** Next.js & Remix                                                                            | No                                         | No                               | No                  | No                                                    |
| Live/Realtime                        | Yes with two mode `auto` and `manual`                                                              | Yes - just Immediately(Enterprise Edition) | No                               | No                  | Yes, with api/webhooks                                |
| Audit Log                            | ✅                                                                                                 | ✅ &nbsp;Enterprise Edition                | No                               | Yes                 | Yes                                                   |
| State Management                     | React Query                                                                                        | React Query                                | Redux                            | -                   | Apollo GraphQL                                        |
| Routing                              | React Router, Next.js, Remix or Any Routing Library                                                | React Router                               | React Router                     | -                   | @redwoodjs/router                                     |
| Devtools                             | Yes - [Refine Devtools](https://github.com/refinedev/refine/blob/main/packages/devtools/README.md) | No                                         | No                               | No                  | Storybook, Pino, Jest                                 |
| Command Palette[\*][command-palette] | ✅                                                                                                 | 🛑                                         | 🛑                               | 🛑                  | 🛑                                                    |
| Own Advanced Tutorial Examples       | Yes - **110+** Examples                                                                            | Yes - Few Examples                         | No                               | No                  | Yes, Divided in Chapters                              |
| Architecture                         | **Hooks Based**                                                                                    | Component Based                            | Hooks Based                      | -                   | Component Based                                       |
| Dynamic Multi-level Menus            | **Yes**                                                                                            | No                                         | No                               | -                   | No                                                    |
| Project Creator CLI                  | ✅                                                                                                 | 🛑                                         | 🛑                               | 🛑                  | ✅                                                    |
| Project CLI                          | ✅                                                                                                 | 🛑                                         | 🛑                               | 🛑                  | ✅                                                    |
| Auth Provider                        | ✅                                                                                                 | ✅                                         | ✅                               | ✅                  | ✅                                                    |
| Data Provider                        | ✅                                                                                                 | ✅                                         | 🔶                               | ✅                  | ✅                                                    |
| i18n                                 | ✅                                                                                                 | ✅                                         | ✅                               | -                   | ✅                                                    |
| Router Provider                      | ✅                                                                                                 | 🛑                                         | 🛑                               | -                   | ✅                                                    |
| Notification Provider                | ✅                                                                                                 | 🛑                                         | 🛑                               | -                   | ✅                                                    |
| GraphQL Support                      | ✅                                                                                                 | 🔶                                         | 🟡                               | ✅                  | ✅                                                    |
| Customization                        | ✅                                                                                                 | 🔶                                         | 🔶                               | 🛑                  | 🔶                                                    |
| Basic Form                           | ✅                                                                                                 | ✅                                         | ✅                               | ✅                  | ✅                                                    |
| Editable Table                       | ✅                                                                                                 | ✅ &nbsp;Enterprise Edition                | 🛑                               | ✅                  | ✅                                                    |
| Tree Select                          | ✅                                                                                                 | ✅ &nbsp;Enterprise Edition                | 🛑                               | 🛑                  | 🛑                                                    |
| Markdown                             | ✅                                                                                                 | ✅ &nbsp;Enterprise Edition                | 🛑                               | ✅                  | 🔶                                                    |
| Calendar                             | ✅                                                                                                 | ✅ &nbsp;Enterprise Edition                | 🛑                               | ✅                  | 🛑                                                    |
| Caching                              | ✅                                                                                                 | ✅                                         | 🛑                               | 🛑                  | ✅                                                    |
| API Caching                          | ✅                                                                                                 | 🛑                                         | 🛑                               | 🛑                  | ✅                                                    |
| Multi Level Menu                     | ✅                                                                                                 | ✅ &nbsp;Enterprise Edition                | 🟡                               | ✅                  | 🛑                                                    |
| Typescript                           | ✅                                                                                                 | ✅                                         | ✅                               | -                   | ✅                                                    |
| Modal Form                           | ✅                                                                                                 | ✅ &nbsp;Enterprise Edition                | 🛑                               | ✅                  | ✅                                                    |
| Drawer Form                          | ✅                                                                                                 | 🔶                                         | 🛑                               | 🛑                  | 🛑                                                    |
| Step Form                            | ✅                                                                                                 | ✅ &nbsp;Enterprise Edition                | 🛑                               | 🛑                  | 🛑                                                    |
| Theming                              | ✅                                                                                                 | ✅                                         | 🔶                               | ✅                  | 🔶                                                    |
| CSV Import/Export                    | ✅                                                                                                 | 🟡                                         | 🟡                               | ✅                  | 🛑                                                    |

<!-- -->

[stars-refine]: https://img.shields.io/github/stars/refinedev/refine?label=%F0%9F%8C%9F
[gh-refine]: https://github.com/refinedev/refine
[bpl-refine]: https://bundlephobia.com/result?p=@refinedev/core
[bp-refine]: https://badgen.net/bundlephobia/minzip/@refinedev/core?label=💾
[command-palette]: https://github.com/refinedev/refine/tree/main/examples/command-palette-kbar

<!-- -->

[stars-react-admin]: https://img.shields.io/github/stars/marmelab/react-admin?label=%F0%9F%8C%9F
[gh-react-admin]: https://github.com/marmelab/react-admin
[bpl-react-admin]: https://bundlephobia.com/result?p=react-admin
[bp-react-admin]: https://badgen.net/bundlephobia/minzip/react-admin?label=💾

<!-- -->

[adminjs]: https://adminbro.com/index.html
[stars-adminjs]: https://img.shields.io/github/stars/SoftwareBrothers/adminjs?label=%F0%9F%8C%9F
[gh-adminjs]: https://github.com/SoftwareBrothers/adminjs
[bpl-adminjs]: https://bundlephobia.com/result?p=admin-bro
[bp-adminjs]: https://badgen.net/bundlephobia/minzip/admin-bro?label=💾

<!-- -->

[stars-redwood]: https://img.shields.io/github/stars/redwoodjs/redwood?label=%F0%9F%8C%9F
[gh-redwood]: https://github.com/redwoodjs/redwood
[bpl-redwood]: https://bundlephobia.com/result?p=@redwoodjs/core
[bp-redwood]: https://badgen.net/bundlephobia/minzip/@redwoodjs/core?label=💾

================
File: further-readings/license.md
================
---
title: License
---

# Overview

**Refine** is licensed under the MIT License. It only requires the preservation of copyright and license notices. Licensed works, modifications, and larger works may be distributed under different terms and without source code.

## Permissions

- ✅ Commercial use
- ✅ Modification
- ✅ Distribution
- ✅ Private use

## Limitations

- ❌ Liability
- ❌ Warranty

# License

MIT License

Copyright (c) 2021 Refine Development Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: further-readings/telemetry.md
================
---
title: Telemetry
sidebar_label: Telemetry
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Telemetry

## Summary

**Refine** implements a **simple** and **transparent** telemetry module for collecting usage statistics defined in a **very limited scope**.

Tracking is totally **secure** and users can choose to remain **anonymous** without providing any personally identifiable information.

When setting up a new project, there is an extra, non-mandatory step where we ask for the developer’s **email address**.

Upon entry, this contact information will be collected and linked to the project. It’s used occasionally to reach out to community members, and we never share it with third parties or engage in spamming.

The telemetry system **does not use cookies**. Participation is optional and users may easily **opt-out**.

## Why do we need this?

We try to answer the question **how many users are actively using the Refine framework**. This information is critical for open-source projects like Refine to better understand their communities and measure their growth metrics.

## How do we collect data?

<Tabs>
    <TabItem value="refine-core" label="Refine core" default>

The tracking happens when a Refine application is loaded on the user's browser. On application init, a single HTTP request is sent to "https://telemetry.refine.dev". The request body is encoded with Base64 to be decoded on Refine servers.

There are no consequent requests for that session, as we do NOT collect any behavioral information such as _page views_, _button clicks_, etc.

<h2>What is collected?</h2>

The HTTP call has a JSON payload having the following application-specific attributes:

| Value         | Type        | Description                                                                                                     |
| ------------- | ----------- | --------------------------------------------------------------------------------------------------------------- |
| providers     | `boolean[]` | List of providers used in the project (auth, data, router, live, notification, auditLog, i18n or accessControl) |
| version       | `string`    | Version of the Refine package.                                                                                  |
| resourceCount | `number`    | Number of total resources.                                                                                      |

Additionally, the following information is extracted and collected from the HTTP header:

| Value      | Description                                           |
| ---------- | ----------------------------------------------------- |
| IP Address | IP Address of the machine the request is coming from. |
| Hostname   | Hostname of the machine the request is coming from.   |
| Browser    | Browser and browser version.                          |
| OS         | OS and OS version.                                    |

Lastly, we collect the contact information, **if provided** upon project creation.

| Value         | Description                               |
| ------------- | ----------------------------------------- |
| Email Address | Developer's Email Address. [**OPTIONAL**] |

:::note

refine.new is the cloud-based alternative to CLI for creating Refine projects.
It requires users signing in with an GitHub account and a limited set of public profile information is collected for analytics purposes. The collected data can also be automatically linked to the created project.

Projects created with refine.new still can opt-out from telemetry by simply adding `disableTelemetry` prop to the `<Refine>` component's `options` prop.

:::

<h2>How to opt-out?</h2>

You can opt out of telemetry by simply adding `disableTelemetry` prop to the `<Refine>` component's `options` prop.

  </TabItem>

<TabItem value="refine-cli" label="Refine CLI">

After running a command with the `Refine` CLI, a single HTTP request is sent to "https://telemetry.refine.dev/cli".

<h2>What is collected?</h2>

| Value            | Type                                          | Description                                                   |
| ---------------- | --------------------------------------------- | ------------------------------------------------------------- |
| nodeEnv          | `string`                                      | Specifies the environment in which an application is running. |
| nodeVersion      | `string`                                      | Installed Node.js version.                                    |
| os               | `string`                                      | Operating system name.                                        |
| osVersion        | `string`                                      | Operating system version.                                     |
| command          | `string`                                      | Running script name.                                          |
| packages         | `{ "name": "string", "version": "string" }[]` | Installed `Refine` packages.                                  |
| projectFramework | `string`                                      | Installed `react` framework.                                  |

Additionally, the following information is extracted and collected from the HTTP header:

| Value      | Description                                           |
| ---------- | ----------------------------------------------------- |
| IP Address | IP Address of the machine the request is coming from. |

:::note

refine.new is the cloud-based alternative to CLI for creating Refine projects.
It requires users signing in with an GitHub account and a limited set of public profile information is collected for analytics purposes. The collected data can also be automatically linked to the created project.

Projects created with refine.new still can opt-out from telemetry by simply adding `disableTelemetry` prop to the `<Refine>` component's `options` prop.

:::

<h2>How to opt-out?</h2>

You can opt out of telemetry by simply adding `REFINE_NO_TELEMETRY=true` to environment variables.

</TabItem>
</Tabs>

================
File: further-readings/testing.md
================
---
title: Testing
---

**Refine**'s components and hooks are made from small pieces of code. Each component or hook is designed to be testable and work independently of each other.

So, you don't need unit testing, because **Refine** is already tested by its maintainers. However, you can write unit tests in your own code (helper, definitions, etc.).

We strongly recommend that you write end-to-end tests of your application. **Refine** used the [cypress](https://www.cypress.io/) framework as an example. You are free to write tests with any framework you want.

## Example

<CodeSandboxExample path="with-cypress" />

================
File: getting-started/example/mui.tsx
================
import React from "react";
import clsx from "clsx";
import { PREVIEW_URL } from "./preview-url";
export const MUIExample = () => (
  <div className={clsx("pb-6")}>
    <div
      className={clsx(
        "h-[600px]",
        "mx-auto",
        "max-w-screen-xl",
        "w-full",
        "px-2",
        "md:px-4",
        "xl:px-6",
        "absolute",
        "left-0",
        "right-0",
      )}
    >
      <div
        className={clsx(
          "border border-gray-200 dark:border-gray-600",
          "relative",
          "overflow-hidden",
          "rounded-xl",
          "landing-xl:rounded-2xl",
          "overflow-hidden",
          "w-full",
          "h-full",
        )}
      >
        <iframe
          title="MUI Example"
          className={clsx("h-full", "w-full")}
          src={PREVIEW_URL}
        />
      </div>
    </div>
    <div className={clsx("h-[600px]")} />
  </div>
);

================
File: getting-started/example/preview-url.ts
================
const PREVIEW_STRING =
  "JYWwDg9gTgLgBAJQKYEMDGMAkBGANHAbzjSlRiQGEIA7cgDxnwFcBnJAZRhXObYFEAZgKQZelGvXgBfOAKgQQcAOSl0MJQG4AUKEixCxVeQQQI02fMUrUGALQATBQHo0AG2BJamneGjwirEgA4kgwAJL2njDAMACeYgCyKNTxcIHsABYQAO5iAPLUSPhBMQASTABGAELJhVD4yALAhXAycgrKAAKkTYWRAG4u0Ejeun4GACJI-TCmriwACvL9wJH1cFMzc4vJSK6tFh1K3Ui9SANOA7MQ86O++kSNzUgA0hUoUEsQK2sNp89vD4HdpWE5nC4Aa3eUDuen8iH+hQAKhkkCAkCx8KUUCAKkwoABzJBQBKeJhiACCTFmaAUYFcoSKcAoRiZfHsMTEE24KCCUFW+G55AAYh5XPZ8OyYlVqbNqPhMjkZTA5YK9ozlaq4AAZYAsRhwRW5OBIpAMUV7exUXyFWj4JJQCGObLUC3iv5ndjUdBQj5fH7EsQAOTMwCaaG4wBo-tWgZNqPR9m1KFiEGpADUAEySqDyKDWyC28wgro9Z4XEBMYCw8YUFgsGpsdwtEvHSvAJwgbjE4AoVxOOsNlBN541-RBVwQd6uTixBksQ6g9ud7v8vtOCdTvuz+dj+DyanEqrNDnUAmYgxBlArAndpEQZAsNNQNBMgCq1BY1-OFAyySJLAhtETRxhMEBoEw6K0EiMQMti1D2AyUDApYpaIuc0xOKodgHuQMLaGM+j2DyMZrIuaHgphLC6AytikPqe4GFU8jZGwUAmIe6wceQF7cUyeTUgyxaodYah0WmeGMdyjoJBAkQCTAzbnORbZVk4wC0p+thdnhvb9tJEKyfJgnloxuoEhkMBGUgClKfYKmdMuGk0Cw2mrnpTjmZZ1m2aZBH3PAFJgGANTIa2jlqTpPbrkFIUfIxFL9DyYUiRFHZRWu-aJcljFhJpmo0A5y4ZR5eU0AV1CMZwPpFZF7nrtVaAQox943NCtXpfV-ata40ItbEkAElAKBgBksQdSuunrkiA0QENI1jYxRAomiSCkcSKFHGlk3Rf2+pzhiS1wFUEB0PgprmmKEpwFSNJ0kJTLsOqohwKS1BMGE5AgOds3zaN43Diav3Df9OAKlwTVwIDjUQjgm1LnVU2uEdgTCtAihtKlZZ9Jh2EwLYWQQBCtgCOjR1ULQ8iuEh8PKHjBOmMTpNQCAjFvR9X1w+FxVdU47OfWiR1Cry-L2ZjW3LnQDg8rYQ2rN4WiafqcAAPoAFYsHQooMle6KYGgcAALxwAARE4I1gE4MDgE4FQQMASH0t2LBOAArNg2AAAzYGgACcABstjYAA7NggcACwCJHtgABwAMzh5mDhoEIFSZmgKcoBUntYehthgPIasiDATgsC+Qw2lELsW7YznUOpCFmgAdDAmsm9oSuBcFZXUEbcAABQAJRGwAfIQWhwHApAwPivf9xPk8ImoOBNyQZBIHwDJQTA-dKCw-QEko+AEAvi9wHQICuJ+ABcpuWTAYDX04TjZK-TfZHHTfQASTiZp7-+lwPibXAp9F7ZFWDADIt8TaZnDsA0Bk9UTAAsjAaBsD4Fn0nisJA2QTp0GgZ7OAhDYFwHQYvEBmDZAO1cNA6gNAkDANVirJsAhb5MEbuCfAKtmHPlfLfAgTQdY4iQLfdWmttZIF1kgfW+AlJBkghUYkt9XZSCkFoBBcA-jL2wKvVkm9Vq0F3mAbgGQj7j0oZPQRNDTYQVzFEKgk4oAYIsUoKxdEmAMiUNA6Yng5L2GcZQ+w0CEjYE-sHGOvsm6J0zCgcOcA4mEMSbYT+rtwlENcLHeJFI4kJKIXkwhMd+gx1ifE-JeTMxN0zB7OAKTwmuBjvEkpuTEk1Kbqkhpnt6m2HDtk0pLTiFxLDumYpOSyme1sBUqp2BkltLqbHbpAAtBIDSRl9LgNgdZcAOlFKaWU6ZHThkLJNhYk5pyznnMnhQlxbhgBgHcZ47x-RfH2H8Vw5hexWFpA4eWN5T58R8MIIIyRwjREay1g7YFes0CyOePI3ESj1mZlURoweGitEYBXmvbs+jt5GJMWYogVjoG2NILQBx0BGFBNNiEuJxTMykLyRs6ZuT6X0paRshJRyLmaKYSwth3y+i-N4SIwFEKpGgvEWK4RMi4ByIUQi7AMdVFwFRWfVVKrtBSG0IrFy8AxHgqEXrCofczYWytjbO2EKoBOx4m7D23s-aBxDmHbpUcBCxwTknewKcBBpwzgILOOdsZIHzoXYupdy6aUkC7WkjjtJySQA3SIdAW5tw0LIdhGAoy9xVhAMA0QaB9l-CgZomAY79zzSwYeRAhKyuHDACkGcMQsG1KUdgfd2GRHBOm2tSVXBMCQH3StABtT2ABdHtoQ4DAD7tgdN2QMgQoHjOgAPHAStTcGRnkgdW4gur11gCHWAFgw7gATr3Z+eAAhe7GxHTOgA1Os89D7jaZnTWGAeFbD2Gx-coPNBbvSuEba+esSg4AAB9wMHqNr+pQ-7s1Fr7MjYeAAyFDcA+0Dpg3Ad61Nd3T1nl8rt5Z00yA-V+mDxslDoBAywMDkHoM-qo-BwtQGm2gd3a4etwHm2tvbcbTDSB02Cb7te-ugnB6kbgHsNg06BADzzZR5QEZqb0ag4ppjf780IdcBQJDShd0ieNmJ-uTczMfHPMPQ2Y9BOryQ-3Lj+oeP1j4-gMzTcLNVsk3Wpz7GW1to7QK84UmZAEagL3QTpH1HRZ1Ze5kNxoDWQppIPuWLyDJbNDvBeBAZBaEk+ozu8XHFJYkJl9ayFjb9xPpPNAi7xSkpAVIKzY9qsXuVrGxLCbhSWG1OBbcsxhpEj7pOFTnBoAoCJE3Ik4Qvr9xNh1kkCaTb5Zq-uvU7BYj6jREsU4xJPCvgMn3XN2nWPFtLeW4d4CEI5HwHBk7gHnN0a4aPVWTcdK1dJByFAt2VPIy4fS6zqtMzzzPibfuBddtQFcgt2wLBaurVvsRR0g8TYL0HrdmjzazEqzji9nHb3uDw5YGO-LC9CssE219HbwhSWvj7utyn22eh7eoAdj4EI4AAH5TZI4hMc6B7gUHtzJ-u4dIAE34DYFZBNY6O1sGquQEHi8FvWW6woXro2BsTcHQxinW2QDU5Z6+NH2rJ6BEEMIDA-ch4vda5PK7zpN19ZnFrybUuBYgDmyrpb+BxeRBW60fAYuZek9W3FqX5LFuRD7jbwHdu5MDz94OzTJtBeWWW+YzBUvrJzd58t7QZ8ZAycHfHye2eE1zbTzAfPoC1GTy1eoyeYW56gOQNo3R68cVRH7pHkrtBMtN3K8fDRgn+EaLL6Eayt8I8Jaj0UcfcAk9XML78j5-LiOCt5cK-hQLxWqzBRIqRmAKgwsKHCxRUBb7hxUWotFS8MU6LSxvLe3eVroiH5nyhz84CpiYMQZIxAf4Z4g6kCIBCYg6C2C4qIpATc0mdAOI9IIqSeSmqeyC6eXOCIZwb+GITcSQRItAKAcAt8TwyI4BLAuB2uBBBkC+oB6It8yBKeVexy3OJBSA2B5BVQ-ag6xB6E7BTcnBA6Bkq+rgnyna6E103CfyL4IqAiUqdB++kqhq0iJ+sqsK8ql+cA7syKC++AtWDs9gpKKKoC6q+WDesWys+qh+0qhBxspqwU5qlslqjsXGtq7sXsPsAcQcocEcbqHqicycqc6cmc2cucZwoaEARcGAEaaAFchYVcTgqIKAawSazcrcdA7cGarOAGqsLGgGZ21AmAwcX6VaBgtajmDafmfGgWG+wWsqU6RmB6J646k68AM6xsc6cAC6S6-cq6jRm6ngBIO6BghWGmjRp656hW16R6J6D6T676cA96r6768m1uGmsGuRfYj2amjG6x92iGqmqG6GRmxsuGrg+GoQhGYh3aBw5GaxVGmOoGEG6m36uxAGmxfmBmpR3GlRAWAmfYA6wm-xyesg1A4mQJ3mRe8wg6txLxVGv22xdxWmbxum+mhmQJomoJpm5mhIJRgOtmv2Dm3xtGrmcA7mnmg83m5Rj2VRxsVxJGBwoWFx4WGGQJUWMWBW+6pQqAZElWrW+oGkEI40xsMAUAA6jWzWmehWRAS+cA5e0eMgtJbAGWDAPes+fekgoebW8IxEXAbCbEBwipwQoQEQUQMQsQQ8puU8TJLeZ8beD+He2KL+hisUoUx8cAkA1EAG0+0QTU403OJs-Jvp-OpspALhwATyjCkha+RG4hQq-yMhu+IKChBqkK0i32qhZ+6ht8mYSqdemC6KWAj+eiTpO8PU0Ix8UZIh6+sZW+8ZO+chIqlhDZmA6Zcq8KGhmYvsyKJyBZmKxZBiO8MMw+ZyHIpAWaNA0CLEASFi4C9gkC0CXsnsAApNOZQmrKwMBLEBlrQNAgIAyFLJ4K8gvpPH2MgtQB7iwMSlEMSJGe8lWTGZwrWdIfWUoRKimUfq2Woe2bfHHJ7NoWcr2UWZ3iWf3NiLiPiESCSGSBWXeaIUFhITwnWaKq+cmVYXrJ+Zmd+TUv7Mquqj2ffoWQ6eQF3oYkOZ-qcqOcXNmpOTkKuTORAlAqbIuSucvqcuufyQIFuaVjuabHuWaLYIeXRZQqeQSOeV9JeTYteU4sIXBTUQhVIQCrIShU2UoS2afpIlmTUsHP+ecoBURc-gOf3D3BVMOdygttAs0NATEEJRYjQBQO4E1LfLHi1seRYnKUgBaa5SvrytGXSZvpIdvshamW+WhWmepefgiuHHHDpRcr7gmigXnhgXaYRU-iRTvF5NLsZIpD8oQJWbJTWQFUhUpcFahc2RhRpVheHF2TIMPDwe3qlSBQZD5CZJvgQHldWY+YVc+UFXvipamWpRmRVRflftVSql5WNeNfgP3MdsifkYUf3MOoEOsHdsiVsc9oDirB5klFwFACTk8TkXsbpn+KWkUYtWxLdhsWxrRtjgDmPCrBUt6OiCTocQPONZPMlX2cBYZWRaXucpReOdQDRdkDZScreI-Exf7GAOkaxRciJWJWiBJfNlJSDRYuxZuduagpJf3tJT5feX5ecHGd1cVb1QfmVeFZpa7NFbftyuQgdbNcdQUadUtRdYdWtarLjhtZ-I9UgHtWhq9TTbaTYClf2bijNINCDGNKZQLYvJrGPtLYEnqE7LEHLfLZQnQIjXQoUCjTTSwCABZdQEpLYBUCNnzjDfLVIGbTTRbW9RYklGuDxQGZUNEIpEgJmLeXyg+TlV1YpYmfIX1R+eTVhf7H+dTarTyjNTpnNUzedUiTpmzSrHEhteHE3NzSTjbWqunWNdLXpQ1YZdlDtW6WXGgKIpdVHQtczbHaxvHa7Hjq7FtclCTvgH2JjRHadgzfNWdXGCtXHR8Vwv7Hjv7CncIo3bjflZ1YhUTb7Y2aTapeVRFRocHEijVTbXhacqvZQuvYvJvavSYZqtqoVv7dKr7CaubPYdbI4fbM4c7Hau4Y6l4S6pHNHPHP4d6oEf6oGqEc8OEZESXEXU4MYgBLbJOASPnBAPqDGqyKmukemgIJmtkSrKcXqBkFQH2BiK+JgMDq4BkBeFANg8KNQLuuRlgwuAAIQnEeJnEGDN6yrYNSbF5UPWlTx4OgkQnAhwPZp02R3t3+zFGcZTpUk-H8ae19AtEslcHTGjrnq1ptHrLzp1aDo9FwBrobpbqDEZC7ojHfpjFnrpqTE3raMLFzHToLFLEJ6rGwmV0PYfH7WInd2naolwB83HE4YUPnEzzMn432BSYwlKbUbWMMa2OXVbGcZEm8a-FiMAkRPAliYSZ0NQlmO2Pwk2MWN2N5EONEANEmZkk4kSn4n2YCPEltpubYmWaUmhMubhOeMhZWnuMRasmtDmHwCcFzQLBgMwAsjrwx4SmtZSmgJfhPIVRfDHqsXBpUCkD8KyDoy9ZJHNAEiB6gKkAEh6h4SsVRpUysXMwgAK4yHSa5jQALjW315y5IBowsxVZNaWlSlQzUjgT3SMhDMSURjkAEjQCxC3S3PgAPQPMGlpBsDvO0ifOMhVYLMYiBXzbdgvP8gYjOIXON41OEZK7vVC36VpU96shul6jTOngEi3ybNYuzOS7fiDPyDHrT5EuyjRgksXjtXCME1Pk+0NkhXNm+yB3DWkIh137JUosgV4JS2YIAtxEO2bM2Wy0GAcgsBK27n7mMJ8V0ATDABjlek2I3CQTUDHKHMWIoA3MFgPTQIQBCDu2+XwWE0MvKUz39UsuDXz3ZnYAxX5kEXcuGUXQwBujXS-VnzuaLPLPEhzbO0MiMLuuYKkAACOVYpAVKJsKIeoVClo06C4IbYb5wKNTWlti8xIeYt8JDJDrdeR3DC1-c6b+zKqLNq1vdQOeOFSfrPN6OrlqIrgYAxIzrJdh1c1PDw6BbezUOxblj7x11XCHNd1n8VbJbPdfbqsidd1yd6I9Y2ujdrlXYhIzQtC6MfYKNsD1MAA6gxbfCKWKa5WENQGANSMmIoq4A8xMywBkPyNQBCDu6KYOhqycnEA29ApICjVxqe9AjBC7Sjdza+7BAwjJR1V7RPaayVYfXrJa22Wy5mDhXmRvToQ67naLZlq63y5Qp60gEs1tlAF7txdXuhxYgmwq+cF+4uguCBOKHG1aaGyR0eWcim65YWxoVmzm0Wnm+28xwuOjj21dVjlwjXRtXXVGlEHO2cnWw21AE25w23SWgUW2x23mNxyO1XWWyrP3RtYPSJ3aLx-HcHHjsHG9s2rOzW2cgu0s4DabHQizKu6m5YhQ1u3OYxbu-Pmcge0ezACe3sOewYJe9e7e3AC5-M2Zx4tEEpHe3u2ch+3sNAhjb+0mfNvh4a3jca-SwmYy6VapVB1+Wy3HNVQvpvZckhyLd3sllTEhIR2fGszcLfNV64HZzhgl081h6803KsCjaKfOBM8R+G2R9G5R-ZNGz10m8F6ct-hiM2PjOK1nLRIUAwLYEpK5V2lq64DAOmECbfKcZoq5aSmsE5YSldK0BKYi6cly8h93v83czwORWcu5s15C28zcwK181Sw1x62ZgN294vHZUAUSE5SrPgBJrbpnQN1-NQMWsAWCVwW1-YAHhco++ctNnkPdl59Yj0V9N05ndQydzTQgxQ0gyg-OOg8Dmx0dXJ5gG2-d685d4C+QA8yp1Y2OyrA0htTHF-PdheKk72-x6rMfRtZEr0NdEoPCVwl7Hjl7NbmAJj2HVqdOl9BEEbJnZQs+0gPq3L2iCgVOD-ajjL2fNzqT62wtTEGiAz9z6BqLxshtR7DD6b3x+b6rNgLdQ75WxAJwNewSD9vpqLwOw73HEPGnbr4vM2-TeT228b99Lp2p9gBOw78nbMG7wS8pl7w74J3ddgK7P73D-LYVmAAr8bAbxx2ALb-HWHOL4PQKJH0zyHOL4Z-HyKYn8L8nyrIquL+WoPCTgXmHdQ+H3n7+rn140r0d8X1H3z2n5ElWyPc5QPKbMtoV2vZ3-D195PHqMjwBnwKG32PeOt1wU5bkYD+CcD9LZowBnnzJ7m6HwtXv5Xzz-dYQhtX-Db9f-b-dZb3dVUi3K7-X2eJ76pv9k7-dcDnb5Z8LkhWQTHn0H4q81exxWwlr2Lg68w6+vUuhx0EzD8memYH3vdU-gV8uedvJ7EDhj73U4+n-d3j-z+xA5U+5AzPoP0njB8uGF-YdCgKf54D7qGnN-oPTr4kCk+v-IHPp3v5FEgBC-blNQ2gG0t7IATe7L3z+JcEIggghjkvytKNwoA7nakE5WMTDQQAuJMeDj3ORncSuhiZ1mhxu7cp3MagnEJiEH7RdrEJsPTM81eba0LE5nJdlZxXauB7BlCO2r2AdoSQ7IbgzBMx0zbZskB9AxTkWx444D46OZCtmzyp5QBUg4QtTp2QraRJVgYneWhJ0baZZaBsnUtApy47dt4hTPX8njl-J2ZbBsQ1ATfzjiv92aOibAUEzU5xx-+jQozjOyJCpDpaw3KlC5yA6iCTW6XM1ooQtassEUMcODpnTn4b0ehnjPoS+XA7msj82XTCmy1dj5cLkEw7tjS2mFpdZhJNQYQsOGEaFXYS9Aroh10FfVcUZXG4BVyMFnw-2psfUNwFYAo06utXCQOsx26HkEUVWGNlRyayH9zk2PG2mcMdLfVnoBoQNicncyfdM6o+M-ux3oGfcmB2OOOBgJRFNxBMe1BjCbAMIoABABHTOpYOgQK4nhUw1Lt7X6FzC9hR9A4bfC9jhw7WsVYrucO7z8wvobpWEdiOGh4jkuY9EDgpQpG7D3y1Iq1ppS9jVV8AJsCYFyOrzrDKEBZR1rilZEm8DAHIo9sbSQZJtSRclGYT1STIQdpEiwoagqi9iqIJRCwSoO4EvZJtZR9rYEcRRApKiI+GTDbiGSQA-1NRo9YDv5VA4Ci9R8w4UdB2NG2sLapsZAO6P8Q2jJ4No4AZghDGbCyRPonYX6KpGQcaRcAX2KsIsTb1jCJuLQGYQPr+i9YLPU2KfUtjn1bYl9YkDagxA30HUnhZ1D4SfqeoAivqIIgGhCLBpv64aP+gAxrHG05ooDcBk4HOAxAoGGRWBlkQ4Z49qYBPCAKgzhzSJsADmbBvgFwYsB8GhDFYsQzgBkMXGeGBhrUxoYsA4msmIgNQzXH4MLSDJTIgDThFk9S0GfStHw3gAFMwmQjKpnUXgANER0zRT8cY3aJyNuivRFRgMSGJEBNGEjHRrLymK3pj0p6QxtgGfQmNSEyxT9IE1Zr+NnivjUug4ycbolf0pxNxpcXgreMVitjB4nRmSbYSMJ11EJr5kKZCNIsUTDElDwHSsN6GPjTTI31UxUSuJOEg4iqPwkglrc2TSzC9jybUxCS9Et8cUw8w5Mym0kipu+JInXjhB9TNRIVmaYEhWm+oKUPAEqzS9Ze8efpkgGJaVoRm6EMZjs1DbEhYgj4ULvgDxZzjsWo3JvFh29b1BQEdXDZujG2YTM8hGrBUr8xOboxzmmpQrP2O0ltMWAwsI7EEIfELUbJsQ+yatwqHP9-+FSHUumQKGVDihTcLKR3zhZXMtWd0WnmtCpa1cIW1PJ7ld3KmVofmgQGnogUVzx56IYLGIR4BYDTlluoXbfgOiyHn8Epw6SKTpNbjCw0pzAggcnRiFxD6hTPCgSrDropDTOR3S0oCMFpqAFR3ePSRixbTOTZmuLKZvtO-6ylyWKoSlpWjJYDMKW1Aenp6N6HbDdRftQsdIhjhpjYE3ZW0ci3O6GJeWNwvdJXCFbowRW+CMVorS4zK1eK0rRyfuXlaKtqKyrftCADVauTMEJUiADq0ZB6sDWWogqomKenT0Uxr096TfjhZyimRIIlDpdEtCVdF4mHbDnhF9YAcA241ToX1wo6HchuSAWjuG2TYrSTk-gncYEJbbt0M+nHTtspyRF90B6LcADu0IsTpCpOmQu8XNTFkhCu2YQuaTf14F3Va+AHCadjhZ53U2e07L8G0P5kOCLMTgk2NZy7CuCGu67VwI53nKBd72DXZQZ5yzjecKpvnK9s0AC5BcEeyvAaCKhNhvsGuhI02N+39YNc7hYc5mbjPHr8ikxz0omWWjTG-lPpCHfCnaIMpUyXWV0WmZPHpkeS8O-eWgCzIuRsyo55HH4YN3jbczE29HU5IxzOSCzWO8UgomrLyGayaJN-Ufrz1Xj4d5ZlCRWdJwL7k9u5Es-IVrOf5i8rensIeeXINA5S551Q5vjolNkmcGujgyzjbJcFrsHO27V2ZF1OQezUePnIgH539kRcH2O80Lg7GeC3yI5XsqwXF1jlNckuDXFiBJXDiJy+RgVYmsmKFFFi0xUVLOZgjn7yifpO8S4dTDjAQiL0IpGrkgveFnI45M0mHh1w8QYhuujcujuzLrnUdOh6rBruNxYCTcHAeoGbiGjm74xFuI5U4CtzW4uitu38z4RoW+EDcjuL2bQZQlzmosmpD0IuZgju5VTYhQi+5q9xtpQjC5NtH7v+BFTTV9+XBQyTTVB4KLIetmVYDGJORBzTkSPFHq-Kcrh81FQgxhnwvOTTjLRyDOcUT0XHTVO5mAMWTNMkV09XuUs53uLwqS5FOes85gaEnF6fxBepA7HNH3F7hxJeZio-mtnl72RDY1AxeJAPkzh9NeFQbXokr14qzRZRvNkZ4ub4LT0+j-VeQEtYEO92BxAhviLwd46yalVAwPjQOyWTzclyokpWEqNkO82eHAqpU32wADzm+vsTPrIIFo59T+E8oaUX3yV-wK2i8uoX3PSnrz3+3Sk6dxLIEACK2gAwqTL275xKlM-fYZfD17mls0BGA9AbLJdqT9juM-CkuMIOUWJ9FJyFfvdnX5MBN+EAPqUoqv5A848mdY-tmjGVOKxZV-Npf9gIGwJil-im6gtMzB11llHvLgWstg4VseGAg35fujAHxKIBIcqAfhN-QmxYBGAeAarUQEizmlDAoEgbP+y1L7qhnOZccpv6RD7+XSypSsuqX3V+lnZepWHQGnwihpjAkFezTv6DtF5cK0Jf23XlVChlWPRhiIM8bJMT+8S39BiruWUIHlRHDhR7NUEfAzBx3TOgIpAoGDC5-027mZlMEaD5BZ8SOdYPEWxBfBZ8Xecuxs72zB+Hg5IJjXxUtVNRg-ducLJD5DT1ZksgVTjiaEVIZplK9mqiKwH2AR53KMecrPGVdz82Pc8NTjgIEJxShLXcofkrjgLSc1EK+ZcwLjhlKccg9LeebItWLxq53Q+6VsPJEpzCZIC4mSKKwq+xgx4wlev-O9HJyCZTLVSm9ObVst-Y9I+DmvVco8d4x2ox6UAtTmNr05A6hFKkggUZ0c530vQbAreFXCEFrlOOQ8JnhdSGuLw1BTcHYWKD9uRCv4T8qrkWKgRq65kaRTBEiKMOH3ORdLVhEJrnFC1REUGrjjUqf16IoEpiKgycjcR+I6WlauJH7qa1CY7tdOobWhU51gYjQmKIZG6UKZ9owyo6LBiCSd+POaUTyK9F0s61PazLv1X7WIbaR0fU0abClEgblsmdaBWuv7iYa8A2G-qabDVE2KPRE6vGTBqnq9rSNaYj2DfjNEWiNREY+jWhrzksiyQHuLDc6Jw0mxSA4Y-DQ9KI2wb+NR+MjTl2NFwcJRYY4uNaJXrjVdFi8OMbBQI3yVAFfGkjZpsE2exh1Jw7OVvVzH5j90+owoifTNTlinCVYlwjWLcJ1inU3hV1E2Jfo+o-UwRINHnALgRFux5cXsS7EimDjW4TgS0TADHEwN2GhUaxbOPnGvhlxODZhpuIHjbjdxhEg8YRmIYniS88LZkheJYbVMJxt499ZEqfGlF+G5TfzMpLkqiNvxcE38dI1nSASGQy6JRn0VUZgTZeoxO9BMX3QwSDGj6RCfMUWIoSzGFGPiQWoRIpN+JyGRxkcVxV7jKGZ4xhh+LIxkSUmFErbdRPpUcYviikrrX3CYmZNQSsTA4BxPO2+Mkm4g67ZHXSbMTjMmJUSZoKiZ2ZJJr4pSbJPJIKSKiDE6ouIWqZqSuCUWTScA1Gm6hlYBk-4Vcyyl8hVg3zIKYEGFi477AYUy5vuiIBZTKpZQ2IONLjb4szwVOzNbEDCB7SZmZ4BqWwCSApBgWZ8NqUhXBZlDOp05VYJeQ0Q5bL2hPNBh5Ra0LUcdosO6UGoylNwf5WgFNaiIJyTLVl2OKadblMV44nFkS09HkqDULThONqlNcWvL7RqblGONTtSsM6CIVmCKw2XjnLQnQbgqAAhpct4VwBh0z1ViklNiCr9s0ElX6p4BoVUoO5pK0tIbrl146PFQa-pZEh-nyzAp4U-dLGlVYLhjYH1HRIEFJDi4TuU-YdBokDYDcLKzc0edyWJB74TYYQCYDZRV60J1CNlEAM0GdmMVXYnsVNuK0lZQyzQNlOGgLlOCgaFZ1eqABSEFx7yGQ3Is2vorL1XR-2P7VNokTWC17o5gHBfG3uoAd7sy-8HveDJTBSsB9c+s2gvstDEov5C+WVrSJX3j7a978rfe3uPkwru9C+XvRDOP3Q0F8u3YkBQD2DWImt2RX-bh3k1YY-hiC8jCQyB7UMTYtgYXGcnWk6Chan1Sma-mBgLRYgcmm2gK3oQO0wAvgrouQHYDGIAUJsCHL4O+DEg9yOQaBIuheSeBfBkgPIE8igA0Hsg3iGccej1AqbIEeoHUepps3Spg4aY12A5ptoqKB0xmsdXcv0Xz7r9i+mxDapsqr6a9CXGwUztb3P6nOtI4Ogfolaf7+93+k5IJhCAqgvhAPKeDkGiX8t0VQkmXcOhYgpr55afReTNK2WnJEdAJBfGqpAP-7qYuLLLb3BAPfCRMEBj4YeJmks76dczbnJYo2n2kYF-cXPU3G6wTZt4+AU4hKJiPuY6NZyWqvzSsUG6FqM02nUGuqRW8dEWU5w--0d5NwQlzu73kEt10Y8Xs4fGHkpgcP8rIVovAgdHxh7+78l6fcXrCrlnrCTNchs-QoYv33CuAe6lQ-foS4QatDO+4+THDf0nIP9R+ow3RXkMnJy9NiVkPYApCj6q9SRNQ-IWsFHGoYpxzBNvt32IoNjFiLY5DJNiysbKfhgA4EcnGFQQjYBh9tWgiOEYUjSRoUCcyNX-Hb4jAmlnwepb4zBD7mkQ-Oo0K+xh1GqHw6ftL3THxQ0CNQCHoWPnGoAtextABn3UL4h9IZNArcbPiqGJ9U+yclSZWMPHHeTxyhE+FgA0LcWfYNgPob71vHoZP+jhf4cANBGFBawb4SxB4WIKkDZyEE4xpSNpGCQGRw7RIYIqoH0NuKPSSZQMD0G2Cys6tWOWgD2APcEQW+CxEf4wnyOAh6zYibs25ks63KHOoxqNDamiAup6TgaZEBGmTTVKc0xX0tP8Gp1Npl6YUTs2jVIxPKOU3ep3hTAHorpuAO6f1NuyrStIKAMabiVmmcgFp8zYFytNBmMutp5ExRpDoOn8jMhjExogR5jpWKw6UozyF0I2rojx0gkGOlzELwZTapoCmgcMTo7wR3GpOVZoLMhmkT5Gx40usjMoGuzGp7vETtFhul3Mce+wHdMz3IzHmKrVc52sI3wngzackc9pqQ1VJcKOYqMXvQ5JxZ3NGnEsV5otSVjrUfml2AFo8JBaH6vhZ+l6nC1tiP6nYmLT-WiL-1tciW4BslpdiXsszaRccaKffV+82tNaDrfdppKiDetQkn8VIynQyMOiXREbYo2UbHp+i26dRsMX3TTa4JUEvRpBIQlISVtb6NbehJu2UTvtG22arhP23iMCJrjCrR4xUlnaFMF2zCTsWYyba6JMOt8Y9vqbPbWJSAdifE04mwYvtWExi79oEn-GWJWJOSWJLxJAlQdrgKScJYh2kkSmXmHtJ1oQunaDgXhoTA0xR0tM2mRoLpljvJ1wBA9HOjgFkGyCk6ipDl6o3TubM-NA9ZOuLIabTNxTo9BRP3sOi8tBq8c+UnkIVJFxxYKdPIRnQ91p2YtmzSV15k2bZ1zMCdbAAoB5Vamgt+dHU6FqxVWA8r7xoVhaoFaF49Hy29-DNQ9zV15Tlp+1E2NOUD3B6XIKtM+OHuNqkchZ1V1imnrWnXqEj6WpI0aF2kxHb4qVrK5ucs1FUdzs6-2O9LGHkz9V31CGLDBY1EAwat+qDZOrU1LX4NK1os6Qm0ojqz4DG6M-3DFpzQJaWBnayyXtruq7Y9gWINgBlYSAN2SAKk9AjtjigVNta7c0ObTmnXRzOZcc1ddNj16iVkC04beu7OllUOV0AsHgfBFRNyrc1MK4NfyVTSBj46nM8Dd42g3lrGc4MRNRXWbSkjd1v6GNDk3PXPBr1uSB9a+u0Afrf102ADdeQHWeNg5gYWTbOsoiobtNSNszMc0WJrrSN26yjctBo2iw7Il0VBaqtem0zKa03ecoZAj1+zACxa6TZOsZy4OlNyW5JtRa02HrDN11Q7Teus3HJ3136ygn+s3AebOtrtfzcpGC3RzccXMq5QlFxcJb61xG9OcMQOgnQOQV0BCcxtNLS0ON1WzVc23SzNOS88gLQG1tE3oN7twUQbbOvhwKbqKBG9TcY3m3MDltj4EzadvvXPrdt9mw7cshO3Ab8160-rebLg39zV+Kmr7dNgaGHucN5dSbaiOs6XJLBIO1JsMRctFTyprI6bByNmYM8dVDAFtLHvIsJ7UQTIxQy4ROKwrdZrgCmvt3RWd7+Sjpcz01vVsoFptg1RgdBhPWrbzNyu2zZgAc3HbXN520DYzt62Bb2d0c+HAuud2TYyxgO19MLs3XDVctukOjcVs4blbjhuOymqT1Nxd1rANOx7WJuZ3gFn9tu5oRLNn2NrotS+-Tevtl23VFd225Mxruc2TY3N1+4dZBsf2W7ohttQBS7tHGTjvd5zVTYXugnuwhgyE9HcqvQPUz8dui2EqFUO83DzDmAEg6NbUOSbtD1Sq3aWELq0T2Yvu6YX3puaQzgnK82fRvNWpqxD5+1E+fvqNj3Ub5lsRFvbFRawiP5uLTEQS0uBxFnUlwJA3AuZafjOaJxcDhgt-jwdD22kipN7TIX+tqF1okNs6LyNRtOF8ghNoIvgSiLWjGbbozm36M70FF5baY3IzrbXio7LHLxKyf2MBJeE1i+Q33HHbDxplmS-cT4u0Xsnt2mtMZfCZPahJMTcEtVoSYpM5L-F3jnpiUv-bhJql8kuJM0sEkfHJJIHRSSMvwXKmXFsyzKvUmNNmQNqjpt2DsuXqjJfTM6XKHp4gszgVkiZk5KyuoyvWOHHySzD8kGAApVyHKyFLOY5ZNSHZnB6V3RYGBZr2LQ6SzBiOEtrp5026T7JMlmThmvNgc+-Y9vwbXYgmhzYHaAfS2-pgbXA0WF3LAzU2orCnYftePvGYZZoOGVRQnKIzVWpC8k9q1qnYyBAVDvm8C6zvNkwXZ19PihqK4PP9Bst90Mav0vK73JOHJmcvuZduSeZ-VyNrXO4VcyeXle+5RbMoQ+r31wOcWUpxnkJ3VYUVifqK8wRxqGAWN9upK4DUyuhH-2Ctifaauc0WhZs6tjvKtl7zbZtnVyo7IePdD92h7Y9q-Mvmyk-ZN7W+ajODkvtTY4c1ylao33xdLjVbUl0C8nrN3VKVLiGxyxOTKO2H6J1zeeZDOJ0tHZYnR1fVcIGO76DYkLSY+bGv1Wx79DsdFrDRREexAF+x4LprEjj0tLjm8fAycVLivHZRep91vh1-i+tTRYJ-+NkZhOgJY2kCfhY0ZxPIJs2uLPNpSeLbKL6TlYpk4EtCPcnU7xS7tsKdYY2LJT2rb3HKcfauJl2md0iKEvUkGnYlppy9padvbpL672S-pi3c4Dunu25SwDpEkGXcmQz-Jg28h3ySJnul3x4hdUmzOkdll-dN3deZ6SVnLlMPMrGMkbOLpwzEFgzMDCgJNmZzogBc4XhXPTmnuW5yNcPEnd6XO8Hab53A8-PLpp0r55s48Wu2tzMjkF82T-nUuO7kLjh4xphcL44XUQBFyzBBkTMXjX+mVrDJI4A1L9SMlGWqvRmYzyAxLgN7raDeyP+qVH0c5RtDq0fxrRdxl261colz2X8czl4gu5dNzCFArhuUK75kNdxXNbpNdPKOU1PmB8rsYw12Vct1jPUr0ISmqV3Dts1eUstUa-nYmvHVdsw+Zu2PnWu3Otrz2aewdfXznXJ8u+a5Sb0evMs77YxVHITnbqEu-rxu-mck9H5pPGDvpSLcjdRiXNaj2N2nI5oJuHCFY3R-edrGGP03j9TN2FrfqRbP6hQLsYW-i3FvirLsNLRlvmf-vYhvZoD5KU8s8hid+O45rOdWDuW4r7Wdc5+D7gpH89aICAEXolIl7KE5+nE6bHa537CTte2G6myi82yW9qbe48fK728nDD-Jk-eSfpOmwZ91JxeLScn1nlh9s+ys1Mf2OKH1PMc6-fuVv0L5aT6+hLyciO86H2WrJzBBx52OYmVv2JiNniZcgEm19CXEk-idTYUnFNjJzb2sAe+iUGTQuQ79oZdksmkXfgTk7IG5OudnjqLzj6m0+MBGq3HDP41YeyBSmgTzJeI4vCjPS2FTg2SexQ1VMc-g72HjkDAHjOJmVX4X1cXHZ9OZnsg2Zj2rCabtpfpUccMBVTVLOob+fo9wcq5ZF+xgPTyZ6q1L8Z+y-oy8v1LxR9UrK+c7Sjvn5OcXsxn1Q5AHX5ED19ikUz3pjM0b-9M5nTfR14N-1Ut9f2b8aviN+Wb0WQ-F41Z0BH7rbNuSMPreW30kd7MwVkHb9iT+b-9+iHSZ8n9U5r-7ije3WLLxc8uam9rn+PcJlP9I9Qczr4NAfjB67CNs708vZ5iwiGYBzFfvNt5vRxV7TfBbqvfhd83V4scNeQ01j5r7Y9a8OOaxoFmX5W6ANTjO5vDdrS+Ibdw7riAT1i2MQG1oXQnmFhRsBNwvRO+3cWYizMUHfKxh3JF1J8YyouoTzGP21TtdQvc7bPiC75PMU6O0rvP33Fyd8oE3cMW8njPFjg7ugjKJY-u4lq9qQksmBU7O6T-i2x-a4lv045MgztDzDOz7iy5Q6b7ru6Nu1xDICMkh4kxIaSf7jaq2WmOqs5XMTllc5Gg7liB7ak9Zt5YHOQUn5YeWAVnHbBWfqqCThWdAZFYbU+9igCxWsfgizx+ULgL79wk1s86D2B0vQHYsKXr76K+esNmDUuxwvJ52+ogVtYM2e1usgyBNDun5H4CgTJ40eJtlh63WeDo9aK2L1sQ5V2pDg-a12zNg3aAu4nmBwUuqlHoGZeELqcgSisNgA7Q2RgSA7ig8tqvasajZAv78ORpo546uy0loHkeTgf1QuBCjkhoXWwfrTQ+BJgaXbmBz9nfbV21geQ6UOkQVX5wazZLEFGiSGj7aMOYtj+xeBSQSPZm2Snv4E6cPDgmoq2Ajnq6DsJ9pI4pclfuS5oOBQe9J52RhCo6nm8zu5qW87fkm6+a19I+Y9+L5qFoD+ObvV7fmBbr-TlwsUJ15z+hULFA24rWPc5VBPLD-LEgfEOsBtU3vnmayBOgdKgsaXtpmLeB2wYZQlAMAOUDVAtQAgoBm5fnkEaaZwWApYOnLNcG4orBICCfAywLGAHBzwQr6nBesOcEYOudiLZS2Igb3gJoypDAAf4hwXL7HB2gdEFH44IXEFX4Sge4Hn2hlIOCNgewM8DJ+JviiFRBXQapQYhRQe3ZHmjDkYGbg04DuAYghdHEBdcOptbDWIRAD9YVAEIDEBowtAOwDi4ZgIugM6psOjLqsgePdI++qIeSH9UlIdazxI1vrSHfB3eKwRegPoNCCIhwIWb5oh7wTnZZ+6vsqGGImwNcDzAmoUcGBmJwTqFghYCmtaOmuIT8HoQj6mD4kQAIXtxwAWUuVhzY98KSzPwI0MAD1GKABCAho9EOlrBo+UtMDLYFanQjAQGkJGAXSAYBoSBAQEGGCxhAGEPhY8EkMSDlYmZpxDHgCELMzmCHQoVbSEElMt7y0mnqchxykUirAekrcHaqYIaWtAhAMA4rWFkmMvE-hNhSWq2FOO68PWE9WQvp2FAW3YeW5OA18Bt6JK0-oOEth0UqXCuWo4eOEy86ILqRcu5yBGDUAsZljLi+iSmqpyCg-BWEnIGCpP5thYdI2ElibXn2HK4rIE2FtePYd2AXhk8OW7XhR4cOJC+84cK7S0k4WeHPh0-m+H3hi+KEAoA3VmHRrhG4SJ5bhMvDuEtyFapH7S0vikBE60sQKzhbskCBrhxhlnP57y02QB8A76qINQAfgJklaC-cuCuBHy0SYTggAAigOixCLwEgCbYz8oPyj+4QBGwJACyJ5yuASILYAIACyMkDYA6YLYBVAQYHwBoAwADHAXhVbBMySA0CKwRwAXwNrz4AdcPPYKeN1rFA9wxIfeRShZIdX7NkcoZpThIuFK67nIZmsiEWh0oVpEUhYCj-YSaRgXxAXgSISSEmRmkfkHmRZ1jHAMO8tNCG5+fEE6ECyJZLfCZK9oa-jgESYCmASQWYG6RckhJk5QSkRgRFG-AvnD6SCkz8pKGkhrwUIbWhLkUo49CGkalFDBaYjHBuBgfB5GostkKEBqRnyNlGdBZkbKF5RQfhGYh+MvFlEpRlUU5HVRLkccKJKRUSBReRK4WcgngZoPRGB86oNvCKRKgVeA3gd4A+DFhr4G6R863VBQ7AMNYdFK8GTUWn5Whi4mmKtquFI1EOROUSGY6RWFBEgi2awh1EBRY9pmFukxiC7JmwXYUtHbRLwc1FvB6UaOa+wBgQ1GnRO8N1FEAfUaDLVqQ0cx7vR-cFpJo6yzGVE7sK0Y4Eyh6IRtGZRyUTtEPRaUetFnWqJjSG68nUYZSfR7pCYjEorIIwh-RPFEYFAxbTEs7XcdkepHgxvolVFQxSMbVF3RIIWtFYaz0bVH+RaMT8HnRBgJdGMUJsCOFjhPNnjGY0BMajptMOHqTHlR5MfWqPRiMc9EN+tMdqGQxuoVLEoxb0dZFsxRABzHQIP4TzG4xvkQDGEx+oGIEixYMXDGrRcsU9EYOvsAkGE2xkfdHGxlMfLFmxFsYkp1RgDnR43WGMWrFfhpbpBpahloSbGSxZsZcFh0LMSqEqx06I3A-RyZnzEjRSRt16xASfrlTmh1sRDG2xpsZiHrI-8FtGwxicRTEtRVMTJ7pxy9IVEAxbsVjGHGvYfgCRxAMTHHExTIAbG5mRsUnE5xdsanHuEGcd7GmRjcSnFUhacb0GFxysYeAXRJcVzGvhmseXHaxRgTHHCxbcY5ESxDMZl6ewS9BsIJxdMb7GzxzcfPGKxgcUXEhx7sQGRzhI8dJhjxhobArEBrlqDF1xWceLEIxq8V3FewqvpbH2RF8cRq5R1Lp7B3xjsSdF9xJMZjFXRAAFRaxA5FHGMafAJ2y1BfZkvGyxycX7FrxNMZnHLxkCdfHyhXsEzGq0TsfnbZ0RcehB-BZ8RVE2xHcVAk3xnsOGZWRR8f3D4R34IRGKKgEKGAgQQIeAk+x8CftFss9qBvGMiRgWBAQQ28BvrwQiEE8F0J7cTPGMJQYiwmjqNNEHFGh0wCaE7AhQPVzxxVsXAl4JCCaKKhIwiU5r1RWYn0FRuphM356oL0p5raOF9GV7jBqbvWK9+r5lm4fmubpY5f0jEX+bfRnXoVhRocnBtDGwjgBwlRAU2KEBpUVQMzok6imqYAyicAB3D7o8gGYCpYrICYBmA-cI4nPAUAKTghJoYRwpK4GvqiwpGCfBgDWQZ8Sg7wx+onZoQKTpspHBQmSan4NxEsYJo9xY1HEmJJK6LFBwATgCPCDwQAA";
export const PREVIEW_URL = `https://cloud2.refine.dev/.refine/preview/${PREVIEW_STRING}`;

================
File: getting-started/example/sandpack.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function MUISandpack() {
  return (
    <Sandpack
      hidePreview
      showFiles
      files={{
        "/App.tsx": { code: AppTsxCode.trim() },
        "/authProvider.ts": {
          code: AuthProviderCode.trim(),
        },
        "/i18n.ts": {
          code: I18nCode.trim(),
        },
        "/context/color-mode.tsx": {
          code: ColorModeCode.trim(),
        },
        "/components/header.tsx": {
          code: HeaderCode.trim(),
        },
        "/pages/categories/create.tsx": {
          code: CategoryCreateCode.trim(),
        },
        "/pages/categories/edit.tsx": {
          code: CategoryEditCode.trim(),
        },
        "/pages/categories/list.tsx": {
          code: CategoryListCode.trim(),
        },
        "/pages/categories/show.tsx": {
          code: CategoryShowCode.trim(),
        },
        "/pages/categories/types.ts": {
          code: CategoryTypesCode.trim(),
        },
        "/pages/products/create.tsx": {
          code: ProductCreateCode.trim(),
        },
        "/pages/products/edit.tsx": {
          code: ProductEditCode.trim(),
        },
        "/pages/products/list.tsx": {
          code: ProductListCode.trim(),
        },
        "/pages/products/show.tsx": {
          code: ProductShowCode.trim(),
        },
        "/pages/products/types.ts": {
          code: ProductTypesCode.trim(),
        },
      }}
    />
  );
}
const AppTsxCode = `
import { Authenticated, type I18nProvider, Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, {
  CatchAllNavigate,
  NavigateToResource,
} from "@refinedev/react-router";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import CssBaseline from "@mui/material/CssBaseline";
import GlobalStyles from "@mui/material/GlobalStyles";
import {
  AuthPage,
  ErrorComponent,
  RefineSnackbarProvider,
  ThemedLayoutV2,
  useNotificationProvider,
} from "@refinedev/mui";
import { useTranslation } from "react-i18next";
import { authProvider } from "./authProvider";
import { Header } from "./components/header";
import { ColorModeContextProvider } from "./contexts/color-mode";
import {
  CategoryCreate,
  CategoryEdit,
  CategoryList,
  CategoryShow,
} from "@/pages/categories";
import {
  ProductCreate,
  ProductEdit,
  ProductList,
  ProductShow,
} from "@/pages/products";
function App() {
  const { t, i18n } = useTranslation();
  const i18nProvider: I18nProvider = {
    translate: (key, params) => t(key, params).toString(),
    changeLocale: (lang: string | undefined) => i18n.changeLanguage(lang),
    getLocale: () => i18n.language,
  };
  return (
    <BrowserRouter>
      <ColorModeContextProvider>
        <CssBaseline />
        <GlobalStyles styles={{ html: { WebkitFontSmoothing: "auto" } }} />
        <RefineSnackbarProvider>
          <Refine
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            notificationProvider={useNotificationProvider}
            routerProvider={routerProvider}
            authProvider={authProvider}
            i18nProvider={i18nProvider}
            resources={[
              {
                name: "products",
                list: "/products",
                create: "/products/new",
                edit: "/products/:id/edit",
                show: "/products/:id",
              },
              {
                name: "categories",
                list: "/categories",
                create: "/categories/new",
                edit: "/categories/:id/edit",
                show: "/categories/:id",
                meta: {
                  canDelete: true,
                },
              },
            ]}
          >
            <Routes>
              <Route
                element={
                  <Authenticated
                    key="authenticated-inner"
                    fallback={<CatchAllNavigate to="/login" />}
                  >
                    <ThemedLayoutV2 Header={() => <Header sticky />}>
                      <Outlet />
                    </ThemedLayoutV2>
                  </Authenticated>
                }
              >
                <Route
                  index
                  element={<NavigateToResource resource="products" />}
                />
                <Route path="/products">
                  <Route index element={<ProductList />} />
                  <Route path="new" element={<ProductCreate />} />
                  <Route path=":id" element={<ProductShow />} />
                  <Route path=":id/edit" element={<ProductEdit />} />
                </Route>
                <Route path="/categories">
                  <Route index element={<CategoryList />} />
                  <Route path="new" element={<CategoryCreate />} />
                  <Route path=":id" element={<CategoryShow />} />
                  <Route path=":id/edit" element={<CategoryEdit />} />
                </Route>
                <Route path="*" element={<ErrorComponent />} />
              </Route>
              <Route
                element={
                  <Authenticated
                    key="authenticated-outer"
                    fallback={<Outlet />}
                  >
                    <NavigateToResource />
                  </Authenticated>
                }
              >
                <Route
                  path="/login"
                  element={
                    <AuthPage
                      type="login"
                      formProps={{
                        defaultValues: {
                          email: "demo@refine.dev",
                          password: "demodemo",
                        },
                      }}
                    />
                  }
                />
                <Route
                  path="/register"
                  element={<AuthPage type="register" />}
                />
                <Route
                  path="/forgot-password"
                  element={<AuthPage type="forgotPassword" />}
                />
                <Route
                  path="/update-password"
                  element={<AuthPage type="updatePassword" />}
                />
              </Route>
            </Routes>
          </Refine>
        </RefineSnackbarProvider>
      </ColorModeContextProvider>
    </BrowserRouter>
  );
}
export default App;
`;
const AuthProviderCode = `
import type { AuthBindings } from "@refinedev/core";
export const TOKEN_KEY = "refine-auth";
export const authProvider: AuthBindings = {
  login: async ({ username, email, password }) => {
    if ((username || email) && password) {
      localStorage.setItem(TOKEN_KEY, username);
      return {
        success: true,
        redirectTo: "/",
      };
    }
    return {
      success: false,
      error: {
        name: "LoginError",
        message: "Invalid username or password",
      },
    };
  },
  logout: async () => {
    localStorage.removeItem(TOKEN_KEY);
    return {
      success: true,
      redirectTo: "/login",
    };
  },
  check: async () => {
    const token = localStorage.getItem(TOKEN_KEY);
    if (token) {
      return {
        authenticated: true,
      };
    }
    return {
      authenticated: false,
      redirectTo: "/login",
    };
  },
  getPermissions: async () => null,
  getIdentity: async () => {
    const token = localStorage.getItem(TOKEN_KEY);
    if (token) {
      return {
        id: 1,
        name: "John Doe",
        avatar: "https://i.pravatar.cc/300",
      };
    }
    return null;
  },
  onError: async (error) => {
    console.error(error);
    return { error };
  },
  forgotPassword: async (params) => {
    return {
      success: true,
      redirectTo: "/update-password",
      successNotification: {
        message: "Email has been sent.",
      },
    };
  },
  updatePassword: async (params) => {
    return {
      success: true,
      redirectTo: "/login",
      successNotification: {
        message: "Successfully updated password.",
      },
    };
  },
};
`;
const I18nCode = `
import i18n from "i18next";
import detector from "i18next-browser-languagedetector";
import Backend from "i18next-xhr-backend";
import { initReactI18next } from "react-i18next";
i18n
  .use(Backend)
  .use(detector)
  .use(initReactI18next)
  .init({
    supportedLngs: ["en", "de"],
    backend: {
      loadPath: "/locales/{{lng}}/{{ns}}.json",
    },
    ns: ["common"],
    defaultNS: "common",
    fallbackLng: ["en", "de"],
  });
export default i18n;
`;
const ColorModeCode = `
import { ThemeProvider } from "@mui/material/styles";
import { RefineThemes } from "@refinedev/mui";
import type React from "react";
import {
  type PropsWithChildren,
  createContext,
  useEffect,
  useState,
} from "react";
type ColorModeContextType = {
  mode: string;
  setMode: () => void;
};
export const ColorModeContext = createContext<ColorModeContextType>(
  {} as ColorModeContextType,
);
export const ColorModeContextProvider: React.FC<PropsWithChildren> = ({
  children,
}) => {
  const colorModeFromLocalStorage = localStorage.getItem("colorMode");
  const isSystemPreferenceDark = window?.matchMedia(
    "(prefers-color-scheme: dark)",
  ).matches;
  const systemPreference = isSystemPreferenceDark ? "dark" : "light";
  const [mode, setMode] = useState(
    colorModeFromLocalStorage || systemPreference,
  );
  useEffect(() => {
    window.localStorage.setItem("colorMode", mode);
  }, [mode]);
  const setColorMode = () => {
    if (mode === "light") {
      setMode("dark");
    } else {
      setMode("light");
    }
  };
  return (
    <ColorModeContext.Provider
      value={{
        setMode: setColorMode,
        mode,
      }}
    >
      <ThemeProvider
        // you can change the theme colors here. example: mode === "light" ? RefineThemes.Magenta : RefineThemes.MagentaDark
        theme={mode === "light" ? RefineThemes.Blue : RefineThemes.BlueDark}
      >
        {children}
      </ThemeProvider>
    </ColorModeContext.Provider>
  );
};
`.trim();
const HeaderCode = `
import DarkModeOutlined from "@mui/icons-material/DarkModeOutlined";
import LightModeOutlined from "@mui/icons-material/LightModeOutlined";
import { FormControl, MenuItem, Select } from "@mui/material";
import AppBar from "@mui/material/AppBar";
import Avatar from "@mui/material/Avatar";
import IconButton from "@mui/material/IconButton";
import Stack from "@mui/material/Stack";
import Toolbar from "@mui/material/Toolbar";
import Typography from "@mui/material/Typography";
import { useGetIdentity, useGetLocale, useSetLocale } from "@refinedev/core";
import {
  HamburgerMenu,
  type RefineThemedLayoutV2HeaderProps,
} from "@refinedev/mui";
import i18n from "i18next";
import type React from "react";
import { useContext } from "react";
import { ColorModeContext } from "../../contexts/color-mode";
type IUser = {
  id: number;
  name: string;
  avatar: string;
};
export const Header: React.FC<RefineThemedLayoutV2HeaderProps> = ({
  sticky = true,
}) => {
  const { mode, setMode } = useContext(ColorModeContext);
  const { data: user } = useGetIdentity<IUser>();
  const changeLanguage = useSetLocale();
  const locale = useGetLocale();
  const currentLocale = locale();
  return (
    <AppBar position={sticky ? "sticky" : "relative"}>
      <Toolbar>
        <Stack
          direction="row"
          width="100%"
          justifyContent="flex-end"
          alignItems="center"
        >
          <HamburgerMenu />
          <Stack
            direction="row"
            width="100%"
            justifyContent="flex-end"
            alignItems="center"
          >
            <FormControl sx={{ minWidth: 64 }}>
              <Select
                disableUnderline
                defaultValue={currentLocale}
                slotProps={{
                  input: {
                    "aria-label": "Without label",
                  },
                }}
                variant="standard"
                sx={{
                  color: "inherit",
                  "& .MuiSvgIcon-root": {
                    color: "inherit",
                  },
                  "& .MuiStack-root > .MuiTypography-root": {
                    display: {
                      xs: "none",
                      sm: "block",
                    },
                  },
                }}
              >
                {[...(i18n.languages ?? [])].sort().map((lang: string) => (
                  <MenuItem
                    selected={currentLocale === lang}
                    key={lang}
                    defaultValue={lang}
                    onClick={() => {
                      changeLanguage(lang);
                    }}
                    value={lang}
                  >
                    <Stack
                      direction="row"
                      alignItems="center"
                      justifyContent="center"
                    >
                      <Avatar
                        sx={{
                          width: "24px",
                          height: "24px",
                          marginRight: "5px",
                        }}
                        src={\`/images/flags/\${lang}.svg\`}
                      />
                    </Stack>
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
            <IconButton
              color="inherit"
              onClick={() => {
                setMode();
              }}
            >
              {mode === "dark" ? <LightModeOutlined /> : <DarkModeOutlined />}
            </IconButton>
            {(user?.avatar || user?.name) && (
              <Stack
                direction="row"
                gap="16px"
                alignItems="center"
                justifyContent="center"
              >
                {user?.name && (
                  <Typography
                    sx={{
                      display: {
                        xs: "none",
                        sm: "inline-block",
                      },
                    }}
                    variant="subtitle2"
                  >
                    {user?.name}
                  </Typography>
                )}
                <Avatar src={user?.avatar} alt={user?.name} />
              </Stack>
            )}
          </Stack>
        </Stack>
      </Toolbar>
    </AppBar>
  );
};
`;
const ProductCreateCode = `
import { type HttpError, useTranslate } from "@refinedev/core";
import { useForm } from "@refinedev/react-hook-form";
import { Controller } from "react-hook-form";
import { Autocomplete, Box, TextField } from "@mui/material";
import { Create, useAutocomplete } from "@refinedev/mui";
import type { Product } from "./types";
export const ProductCreate: React.FC = () => {
  const translate = useTranslate();
  const {
    saveButtonProps,
    refineCore: { formLoading },
    register,
    control,
    formState: { errors },
  } = useForm<Product, HttpError, Product>();
  const { autocompleteProps: categoryAutocompleteProps } = useAutocomplete({
    resource: "categories",
  });
  return (
    <Create isLoading={formLoading} saveButtonProps={saveButtonProps}>
      <Box
        component="form"
        sx={{ display: "flex", flexDirection: "column" }}
        autoComplete="off"
      >
        <TextField
          {...register("name", {
            required: translate("form.required"),
          })}
          error={!!errors?.name}
          helperText={<>{errors?.name?.message}</>}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          type="text"
          label={translate("products.fields.name")}
          name="name"
        />
        <TextField
          {...register("description", {
            required: translate("form.required"),
          })}
          error={!!errors?.description}
          helperText={<>{errors?.description?.message}</>}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          multiline
          label={translate("products.fields.description")}
          name="description"
        />
        <TextField
          {...register("price", {
            required: translate("form.required"),
            min: 0.1,
            valueAsNumber: true,
          })}
          error={!!errors?.price}
          helperText={<>{errors?.price?.message}</>}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          type="number"
          label={translate("products.fields.price")}
          name="price"
        />
        <TextField
          {...register("material", {
            required: translate("form.required"),
          })}
          error={!!errors?.material}
          helperText={<>{errors?.material?.message}</>}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          type="text"
          label={translate("products.fields.material")}
          name="material"
        />
        <Controller
          control={control}
          name="category"
          rules={{ required: translate("form.required") }}
          render={({ field }) => (
            <Autocomplete
              {...categoryAutocompleteProps}
              {...field}
              onChange={(_, value) => {
                field.onChange(value);
              }}
              getOptionLabel={(item) => {
                return (
                  categoryAutocompleteProps?.options?.find(
                    (p) => p?.id?.toString() === item?.id?.toString(),
                  )?.title ?? ""
                );
              }}
              isOptionEqualToValue={(option, value) => option?.id === value?.id}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label={translate("products.fields.category")}
                  margin="normal"
                  variant="outlined"
                  error={!!errors?.category}
                  helperText={<>{errors?.category?.message}</>}
                  required
                />
              )}
            />
          )}
        />
      </Box>
    </Create>
  );
};
`;
const ProductEditCode = `
import {
  type HttpError,
  useTranslate,
} from "@refinedev/core";
import { useForm } from "@refinedev/react-hook-form";
import { Controller } from "react-hook-form";
import { Autocomplete, Box, TextField } from "@mui/material";
import { Edit, useAutocomplete } from "@refinedev/mui";
import type { Product } from "./types";
export const ProductEdit = () => {
  const translate = useTranslate();
  const {
    saveButtonProps,
    refineCore: { query, formLoading },
    register,
    control,
    formState: { errors },
  } = useForm<Product, HttpError, Product>();
  const productsData = query?.data?.data;
  const { autocompleteProps: categoryAutocompleteProps } = useAutocomplete({
    resource: "categories",
    defaultValue: productsData?.category?.id,
  });
  return (
    <Edit isLoading={formLoading} saveButtonProps={saveButtonProps}>
      <Box
        component="form"
        sx={{ display: "flex", flexDirection: "column" }}
        autoComplete="off"
      >
        <TextField
          {...register("id", { valueAsNumber: true })}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          type="number"
          label={translate("products.fields.id")}
          name="id"
          disabled
        />
        <TextField
          {...register("name", {
            required: translate("form.required"),
          })}
          error={!!errors?.name}
          helperText={<>{errors?.name?.message}</>}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          type="text"
          label={translate("products.fields.name")}
          name="name"
        />
        <TextField
          {...register("description", {
            required: translate("form.required"),
          })}
          error={!!errors?.description}
          helperText={<>{errors?.description?.message}</>}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          multiline
          label={translate("products.fields.description")}
          name="description"
        />
        <TextField
          {...register("price", {
            required: translate("form.required"),
            valueAsNumber: true,
          })}
          error={!!errors?.price}
          helperText={<>{errors?.price?.message}</>}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          type="number"
          label={translate("products.fields.price")}
          name="price"
        />
        <TextField
          {...register("material", {
            required: translate("form.required"),
          })}
          error={!!errors?.material}
          helperText={<>{errors?.material?.message}</>}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          type="text"
          label={translate("products.fields.material")}
          name="material"
        />
        <Controller
          control={control}
          name="category"
          rules={{ required: translate("form.required") }}
          defaultValue={productsData?.category ?? null}
          render={({ field }) => (
            <Autocomplete
              {...categoryAutocompleteProps}
              {...field}
              onChange={(_, value) => {
                field.onChange(value);
              }}
              getOptionLabel={(item) => {
                return (
                  categoryAutocompleteProps?.options?.find(
                    (p) => p?.id?.toString() === item?.id?.toString(),
                  )?.title ?? ""
                );
              }}
              isOptionEqualToValue={(option, value) => option?.id === value?.id}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label={translate("products.fields.category")}
                  margin="normal"
                  variant="outlined"
                  error={!!errors?.category?.id}
                  helperText={errors?.category?.id?.message}
                  required
                />
              )}
            />
          )}
        />
      </Box>
    </Edit>
  );
};
`;
const ProductListCode = `
import { useMemo } from "react";
import {
  useGetLocale,
  useList,
  useTranslate,
} from "@refinedev/core";
import { DataGrid, type GridColDef } from "@mui/x-data-grid";
import {
  DeleteButton,
  EditButton,
  List,
  NumberField,
  ShowButton,
  useDataGrid,
} from "@refinedev/mui";
export const ProductList = () => {
  const { dataGridProps } = useDataGrid();
  const locale = useGetLocale()();
  const translate = useTranslate();
  const { data: categoryData, isLoading: categoryLoading } = useList({
    resource: "categories",
    pagination: {
      mode: "off",
    },
  });
  const columns = useMemo<GridColDef[]>(
    () => [
      {
        field: "name",
        flex: 1,
        headerName: translate("products.fields.name"),
        minWidth: 300,
      },
      {
        field: "category",
        flex: 1,
        headerName: translate("products.fields.category"),
        minWidth: 200,
        valueGetter: ({ row }) => {
          const value = row?.category;
          return value;
        },
        display: "flex",
        renderCell: function render({ value }) {
          return categoryLoading ? (
            <>{translate("loading")}</>
          ) : (
            categoryData?.data?.find((item) => item.id === value?.id)?.title ??
              null
          );
        },
      },
      {
        field: "price",
        flex: 1,
        headerName: translate("products.fields.price"),
        minWidth: 100,
        maxWidth: 150,
        display: "flex",
        renderCell: ({ value }) => {
          return (
            <NumberField
              value={value}
              locale={locale}
              options={{ style: "currency", currency: "USD" }}
            />
          );
        },
      },
      {
        field: "actions",
        headerName: translate("table.actions"),
        sortable: false,
        display: "flex",
        renderCell: function render({ row }) {
          return (
            <>
              <ShowButton hideText recordItemId={row.id} />
              <EditButton hideText recordItemId={row.id} />
              <DeleteButton hideText recordItemId={row.id} />
            </>
          );
        },
        align: "center",
        headerAlign: "center",
        minWidth: 80,
      },
    ],
    [categoryLoading, categoryData, locale, translate],
  );
  return (
    <List>
      <DataGrid {...dataGridProps} columns={columns} />
    </List>
  );
};
`;
const ProductShowCode = `
import { useOne, useShow, useTranslate } from "@refinedev/core";
import Skeleton from "@mui/material/Skeleton";
import Stack from "@mui/material/Stack";
import Typography from "@mui/material/Typography";
import {
  NumberField,
  Show,
  TextFieldComponent as TextField,
} from "@refinedev/mui";
import type { Product } from "./types";
export const ProductShow: React.FC = () => {
  const translate = useTranslate();
  const {
    query: { data: productResult, isLoading },
  } = useShow<Product>();
  const product = productResult?.data;
  const {
    data: categoryData,
    isLoading: categoryLoading,
    isError: categoryError,
  } = useOne({
    resource: "categories",
    id: product?.category?.id,
    queryOptions: {
      enabled: !!product?.category?.id,
    },
  });
  return (
    <Show isLoading={isLoading}>
      <Stack gap={1}>
        <Typography variant="body1" fontWeight="bold">
          {translate("products.fields.id")}
        </Typography>
        {product ? (
          <NumberField value={product.id} />
        ) : (
          <Skeleton height="20px" width="200px" />
        )}
        <Typography variant="body1" fontWeight="bold">
          {translate("products.fields.name")}
        </Typography>
        {product ? (
          <TextField value={product.name} />
        ) : (
          <Skeleton height="20px" width="200px" />
        )}
        <Typography variant="body1" fontWeight="bold">
          {translate("products.fields.description")}
        </Typography>
        {product ? (
          <TextField value={product.description} />
        ) : (
          <Skeleton height="20px" width="200px" />
        )}
        <Typography variant="body1" fontWeight="bold">
          {translate("products.fields.price")}
        </Typography>
        {product ? (
          <NumberField value={product.price} />
        ) : (
          <Skeleton height="20px" width="200px" />
        )}
        <Typography variant="body1" fontWeight="bold">
          {translate("products.fields.material")}
        </Typography>
        {product ? (
          <TextField value={product.material} />
        ) : (
          <Skeleton height="20px" width="200px" />
        )}
        <Typography variant="body1" fontWeight="bold">
          {translate("products.fields.category")}
        </Typography>
        {categoryError ? null : categoryLoading ? (
          <Skeleton height="20px" width="200px" />
        ) : (
          <TextField value={categoryData?.data?.title} />
        )}
      </Stack>
    </Show>
  );
};
`;
const ProductTypesCode = `
export interface Product {
  id: string;
  name: string;
  description: string;
  price: number;
  material: string;
  category?: {
    id: string;
  } | null;
}
`;
const CategoryCreateCode = `
import { type HttpError, useTranslate } from "@refinedev/core";
import { useForm } from "@refinedev/react-hook-form";
import { Box, TextField } from "@mui/material";
import { Create } from "@refinedev/mui";
import type { Category } from "./types";
export const CategoryCreate: React.FC = () => {
  const translate = useTranslate();
  const {
    saveButtonProps,
    refineCore: { formLoading },
    register,
    formState: { errors },
  } = useForm<Category, HttpError, Category>();
  return (
    <Create isLoading={formLoading} saveButtonProps={saveButtonProps}>
      <Box
        component="form"
        sx={{ display: "flex", flexDirection: "column" }}
        autoComplete="off"
      >
        <TextField
          {...register("title", {
            required: translate("form.required"),
          })}
          error={!!errors?.title}
          helperText={<>{errors?.title?.message}</>}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          type="text"
          label={translate("categories.fields.title")}
          name="title"
        />
      </Box>
    </Create>
  );
};
`;
const CategoryEditCode = `
import { type HttpError, useTranslate } from "@refinedev/core";
import { useForm } from "@refinedev/react-hook-form";
import { Box, TextField } from "@mui/material";
import { Edit } from "@refinedev/mui";
import type { Category } from "./types";
export const CategoryEdit: React.FC = () => {
  const translate = useTranslate();
  const {
    saveButtonProps,
    register,
    formState: { errors },
  } = useForm<Category, HttpError, Category>();
  return (
    <Edit saveButtonProps={saveButtonProps}>
      <Box
        component="form"
        sx={{ display: "flex", flexDirection: "column" }}
        autoComplete="off"
      >
        <TextField
          {...register("id", { valueAsNumber: true })}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          type="number"
          label={translate("categories.fields.id")}
          name="id"
          disabled
        />
        <TextField
          {...register("title", {
            required: translate("form.required"),
          })}
          error={!!errors?.title}
          helperText={<>{errors?.title?.message}</>}
          margin="normal"
          fullWidth
          slotProps={{
            inputLabel: {
              shrink: true,
            },
          }}
          type="text"
          label={translate("categories.fields.title")}
          name="title"
        />
      </Box>
    </Edit>
  );
};
`;
const CategoryListCode = `
import { useMemo } from "react";
import { useTranslate } from "@refinedev/core";
import { DataGrid, type GridColDef } from "@mui/x-data-grid";
import {
  DeleteButton,
  EditButton,
  List,
  ShowButton,
  useDataGrid,
} from "@refinedev/mui";
export const CategoryList: React.FC = () => {
  const translate = useTranslate();
  const { dataGridProps } = useDataGrid();
  const columns = useMemo<GridColDef[]>(
    () => [
      {
        field: "title",
        flex: 1,
        headerName: translate("categories.fields.title"),
        minWidth: 200,
      },
      {
        field: "actions",
        headerName: translate("table.actions"),
        sortable: false,
        display: "flex",
        renderCell: function render({ row }) {
          return (
            <>
              <ShowButton hideText recordItemId={row.id} />
              <EditButton hideText recordItemId={row.id} />
              <DeleteButton hideText recordItemId={row.id} />
            </>
          );
        },
        align: "center",
        headerAlign: "center",
        minWidth: 80,
      },
    ],
    [translate],
  );
  return (
    <List>
      <DataGrid {...dataGridProps} columns={columns} />
    </List>
  );
};
`;
const CategoryShowCode = `
import {
  useShow,
  useTranslate,
} from "@refinedev/core";
import Skeleton from "@mui/material/Skeleton";
import Stack from "@mui/material/Stack";
import Typography from "@mui/material/Typography";
import {
  NumberField,
  Show,
  TextFieldComponent as TextField,
} from "@refinedev/mui";
import type { Category } from "./types";
export const CategoryShow = () => {
  const translate = useTranslate();
  const {
    query: { data: categoryResult, isLoading },
  } = useShow<Category>();
  const category = categoryResult?.data;
  return (
    <Show isLoading={isLoading}>
      <Stack gap={1}>
        <Typography variant="body1" fontWeight="bold">
          {translate("categories.fields.id")}
        </Typography>
        {category ? (
          <NumberField value={category?.id ?? ""} />
        ) : (
          <Skeleton height="20px" width="200px" />
        )}
        <Typography variant="body1" fontWeight="bold">
          {translate("categories.fields.title")}
        </Typography>
        {category ? (
          <TextField value={category?.title} />
        ) : (
          <Skeleton height="20px" width="200px" />
        )}
      </Stack>
    </Show>
  );
};
`;
const CategoryTypesCode = `
export interface Category {
  id: string;
  title: string;
}
`;

================
File: getting-started/overview.md
================
---
title: Overview
slug: /
displayed_sidebar: mainSidebar
---

## What is Refine?

**Refine** is a React meta-framework for CRUD-heavy web applications. It addresses a wide range of enterprise use cases including internal tools, admin panels, dashboards and B2B apps.

Refine's core hooks and components streamline the development process by offering industry-standard solutions for crucial aspects of a project, including **authentication**, **access control**, **routing**, **networking**, **state management**, and **i18n**.

Refine's headless architecture enables the building of highly customizable applications by decoupling business logic from UI and routing. This allows integration with:

- Any custom designs or UI frameworks like [TailwindCSS](https://tailwindcss.com/), along with built-in support for [Ant Design](https://ant.design/), [Material UI](https://mui.com/material-ui/getting-started/overview/), [Mantine](https://mantine.dev/), and [Chakra UI](https://chakra-ui.com/).

- Various platforms, including Next.js, Remix, React Native, Electron, etc., by a simple routing interface without the need for additional setup steps.

## Why Refine?

Within the broad spectrum of development approaches, Refine occupies a unique sweet spot between “starting from scratch” with traditional development method and low-code/no-code solutions. With their respective initial pros at the beginning of development, both of the two extreme approaches may present long-term risks:

Despite offering the ultimate level flexibility, “Starting from scratch” method is likely to cause

- Project delays
- Technical debt
- Maintenance problems
- Lack of development and security best practices
- A polluted codebase
- And lack of standardization across teams

Low/no-code solutions address this shortcoming but create a new set of challenges such as

- Vendor lock-in
- Lack of customization & styling options
- Poor developer experience
- And limited support for complex use-cases

Offering the best from both worlds, Refine mitigates all risks of “from scratch” development without compromising from flexibility, agility and open technologies.

## Overview of the Refine structure

import { MUIExample } from './example/mui';

<MUIExample />

<br/>

import { MUISandpack } from './example/sandpack';

<MUISandpack />

## Use cases

**Refine** shines when it comes to _data-intensive_ applications like _admin panels_, _dashboards_ and _internal tools_.

<a href="https://refine.dev/templates/">
<img src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/diagram-3.png" alt="Refine diagram" />
</a>

## Key Features

- Refine Devtools - dive deeper into your app and provide useful insights
- Connectors for **15+ backend services** including [REST API](https://github.com/refinedev/refine/tree/main/packages/simple-rest), [GraphQL](https://github.com/refinedev/refine/tree/main/packages/graphql), [NestJs CRUD](https://github.com/refinedev/refine/tree/main/packages/nestjsx-crud), [Airtable](https://github.com/refinedev/refine/tree/main/packages/airtable), [Strapi](https://github.com/refinedev/refine/tree/main/packages/strapi), [Strapi v4](https://github.com/refinedev/refine/tree/main/packages/strapi-v4), [Supabase](https://github.com/refinedev/refine/tree/main/packages/supabase), [Hasura](https://github.com/refinedev/refine/tree/main/packages/hasura), [Appwrite](https://github.com/refinedev/refine/tree/main/packages/appwrite), [Firebase](https://firebase.google.com/), [Nestjs-Query](https://github.com/refinedev/refine/tree/main/packages/nestjs-query) and [Directus](https://directus.io/).
- SSR support with Next.js & Remix and Advanced routing with any router library of your choice
- Auto-generation of CRUD UIs based on your API data structure
- Perfect state management & mutations with React Query
- Providers for seamless authentication and access control flows
- Out-of-the-box support for live / real-time applications
- Easy audit logs & document versioning

## Community

**Refine** has a very friendly community and we are always happy to help you get started:

- [🌟 Apply for the Priority support program!](https://s.refine.dev/enterprise) You can apply to priority support program and receive assistance from the Refine **core** team in your **private** channel.
- [Join the Discord community!](https://discord.gg/refine) It is the easiest way to get help and ask questions to the community.
- [Join the GitHub Discussions](https://github.com/refinedev/refine/discussions) to ask anything about the Refine project or give feedback; we would love to hear your thoughts!
- [Learn how to contribute to the Refine!](/docs/guides-concepts/contributing/)

## Next Steps

👉 Continue with the [Quickstart guide](/docs/getting-started/quickstart/) to setup and run your first **Refine** project.

👉 Jump directly to the [Tutorial](/tutorial) to learn Refine by building a full-blown CRUD application.

================
File: getting-started/quickstart.md
================
---
title: Quick Start Guide
displayed_sidebar: mainSidebar
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Playground } from "@site/src/components/playground";

**Refine** works on any environment that can run **React** (incl. _Vite, Next.js, Remix, and CRA(Legacy)_ etc.)

Although you could take the time to manually set up your environment and install the **Refine** packages afterwards, the optimal way to get started with **Refine** is using the [Browser-based Scaffolder](https://refine.dev/?playground=true) and **CLI-based Scaffolder**.

## Using CLI

Use `create-refine-app` to quickly bootstrap a new **Refine** project with lots of options to fit your needs.

```sh
npm create refine-app@latest
```

<figure>
   <img className="w-full rounded-lg border border-solid border-gray-200 dark:border-gray-700" src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/assets/refine-vite-mui-rest-auth-screenshot.webp" alt="Example result" />
    <figcaption className="text-center">A Refine app created with CLI using Vite + Material UI + REST API + Custom Auth Provider</figcaption>
</figure>

## Using Browser

Refine's browser-based scaffolder has the same set of options as the CLI-based scaffolder. It is a great way to set up a new project and have a preview of how it looks before you download it.

<Playground />

## Next Steps

👉 Jump to [Tutorials](/tutorial) and continue your work to turn your example project into a full-blown CRUD application! 🚀

👉 See [real-life examples](/templates) built using **Refine**

👉 Check out the [General Concepts](/docs/guides-concepts/general-concepts) and [Data Fetching](/docs/guides-concepts/data-fetching) guides to start learning Refine.

================
File: guides-concepts/audit-logs/index.md
================
---
title: Audit Logs
---

Audit logs are useful tool for web applications, providing a reliable record of user actions and system changes. Capturing and storing these logs ensures transparency and accountability which can be crucial for **security**, **compliance**, and debugging purposes.

## Audit Log Provider

Refine offers [Audit Log Provider](/docs/audit-logs/audit-log-provider) to centralize retrieving audit logs easily across your application.

CRUD operations are automatically logged when **Audit Log Provider** is provided, along with the current user information coming from [useGetIdentity](/docs/authentication/hooks/use-get-identity) hook.

**Audit Log Provider** is an object that contains `get`, `create` and `update` methods.

```tsx title="audit-log-provider.ts"
import { AuditLogProvider } from "@refinedev/core";

export const auditLogProvider: AuditLogProvider = {
  get: async (params) => {
    const { resource, meta, action, author, metaData } = params;

    const response = await fetch(
      `https://example.com/api/audit-logs/${resource}/${meta.id}`,
      {
        method: "GET",
      },
    );

    const data = await response.json();

    return data;
  },
  // Ideally, audit logs should be created in the backend.
  // It's not reliable source of truth as it can be manipulated by the user.
  create: async (params) => {
    const { resource, meta, action, author, data, previousData } = params;

    console.log(resource); // "produts", "posts", etc.
    console.log(meta); // { id: "1" }, { id: "2" }, etc.
    console.log(action); // "create", "update", "delete"
    // author object is `useGetIdentity` hook's return value.
    console.log(author); // { id: "1", name: "John Doe" }
    console.log(data); // { name: "Product 1", price: 100 }
    console.log(previousData); // { name: "Product 1", price: 50 }

    await fetch("https://example.com/api/audit-logs", {
      method: "POST",
      body: JSON.stringify(params),
    });

    return { success: true };
  },
  update: async (params) => {
    const { id, name, ...rest } = params;
    console.log(id); // "1"
    console.log(name); // "Created Product 1"
    console.log(rest); // { foo: "bar" }

    await fetch(`https://example.com/api/audit-logs/${id}`, {
      method: "PATCH",
      body: JSON.stringify(params),
    });

    return { success: true };
  },
};
```

And can be passed to `<Refine />` component's `auditLogProvider` prop:

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";

import { auditLogProvider } from "./audit-log-provider";

export const App = () => {
  return <Refine auditLogProvider={auditLogProvider}>{/* ... */}</Refine>;
};
```

### Hook Integrations

Refine's mutation hooks such as `useCreate`, `useCreateMany`, `useUpdate`, `useUpdateMany`, `useDelete`, `useDeleteMany` are already integrated with **Audit Log Provider**.

See the [Supported Hooks](/docs/audit-logs/audit-log-provider#supported-hooks) section for more information.

### Hooks

#### useLogList

You can use [useLogList](/docs/audit-logs/hooks/use-log) hook to retrieve audit logs. It uses **Audit Log Provider**'s `get` method under the hood.

```tsx
import { useLogList } from "@refinedev/core";

const productsAuditLogResults = useLogList({
  resource: "products",
});
```

#### useLog

You can use [useLog](/docs/audit-logs/hooks/use-log) hook for your custom logging needs. It uses **Audit Log Provider**'s `create` method under the hood.

```tsx
import { useLog } from "@refinedev/core";

const { log } = useLog();
const { mutate } = log;

mutate({
  resource: "products",
  action: "create",
  author: {
    username: "admin",
  },
  data: {
    title: "New Product",
  },
  meta: {
    id: 1,
  },
});
```

================
File: guides-concepts/authentication/auth-pages/antd.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function AntdAuth() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import "@refinedev/antd/dist/reset.css";
import { App as AntdApp, ConfigProvider } from "antd";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import {
    AuthPage,
    ErrorComponent,
    RefineThemes,
    ThemedLayoutV2,
} from "@refinedev/antd";
import { Authenticated, Refine } from "@refinedev/core";
import routerProvider, {
    CatchAllNavigate,
    NavigateToResource,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
    return (
        <BrowserRouter>
            <ConfigProvider theme={RefineThemes.Blue}>
                <AntdApp>
                    <Refine
                        routerProvider={routerProvider}
                        dataProvider={dataProvider(
                            "https://api.fake-rest.refine.dev",
                        )}
                        authProvider={{
                            check: async () => ({
                                authenticated: false,
                                redirectTo: "/login",
                            }),
                            login: async () => {
                                return {
                                    success: false,
                                };
                            },
                            logout: async () => {
                                return {
                                    success: false,
                                };
                            },
                            onError: async () => ({}),
                            getIdentity: async () => ({
                                id: 1,
                                name: "John Doe",
                                avatar: "https://i.pravatar.cc/300",
                            }),
                        }}
                        resources={[
                            {
                                name: "dashboard",
                                list: "/",
                            },
                        ]}
                        options={{ syncWithLocation: true }}
                    >
                        <Routes>
                            <Route
                                element={
                                    <Authenticated
                                        fallback={
                                            <CatchAllNavigate to="/login" />
                                        }
                                    >
                                        <ThemedLayoutV2>
                                            <Outlet />
                                        </ThemedLayoutV2>
                                    </Authenticated>
                                }
                            >
                                <Route index element={<div>Welcome!</div>} />
                            </Route>
                            <Route
                                element={
                                    <Authenticated fallback={<Outlet />}>
                                        <NavigateToResource resource="dashboard" />
                                    </Authenticated>
                                }
                            >
                                <Route
                                    path="/login"
                                    element={
                                        <AuthPage
                                            type="login"
                                            wrapperProps={{
                                                style: {
                                                    paddingTop: 24,
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/register"
                                    element={
                                        <AuthPage
                                            type="register"
                                            wrapperProps={{
                                                style: {
                                                    paddingTop: 24,
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/forgot-password"
                                    element={
                                        <AuthPage
                                            type="forgotPassword"
                                            wrapperProps={{
                                                style: {
                                                    paddingTop: 24,
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/update-password"
                                    element={
                                        <AuthPage
                                            type="updatePassword"
                                            wrapperProps={{
                                                style: {
                                                    paddingTop: 24,
                                                },
                                            }}
                                        />
                                    }
                                />
                            </Route>
                            <Route
                                element={
                                    <Authenticated>
                                        <ThemedLayoutV2>
                                            <Outlet />
                                        </ThemedLayoutV2>
                                    </Authenticated>
                                }
                            >
                                <Route path="*" element={<ErrorComponent />} />
                            </Route>
                        </Routes>
                    </Refine>
                </AntdApp>
            </ConfigProvider>
        </BrowserRouter>
    );
}
`.trim();

================
File: guides-concepts/authentication/auth-pages/chakra.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function ChakraUIAuth() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/chakra-ui": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/react-table": "latest",
        "react-router": "^7.0.2",
        "@tabler/icons-react": "^3.1.0",
        "@chakra-ui/react": "^2.5.1",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `import React from "react";
import { ChakraProvider } from "@chakra-ui/react";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import {
    AuthPage,
    ErrorComponent,
    RefineThemes,
    ThemedLayoutV2,
} from "@refinedev/chakra-ui";
import { Authenticated, Refine } from "@refinedev/core";
import routerProvider, {
    CatchAllNavigate,
    NavigateToResource,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
    return (
        <BrowserRouter>
            <ChakraProvider theme={RefineThemes.Blue}>
                <Refine
                    routerProvider={routerProvider}
                    dataProvider={dataProvider(
                        "https://api.fake-rest.refine.dev",
                    )}
                    authProvider={{
                        check: async () => ({
                            authenticated: false,
                            redirectTo: "/login",
                        }),
                        login: async () => {
                            return {
                                success: false,
                            };
                        },
                        logout: async () => {
                            return {
                                success: false,
                            };
                        },
                        onError: async () => ({}),
                        getIdentity: async () => ({
                            id: 1,
                            name: "John Doe",
                            avatar: "https://i.pravatar.cc/300",
                        }),
                    }}
                    resources={[
                        {
                            name: "dashboard",
                            list: "/",
                        },
                    ]}
                    options={{ syncWithLocation: true }}
                >
                    <Routes>
                        <Route
                            element={
                                <Authenticated
                                    fallback={<CatchAllNavigate to="/login" />}
                                >
                                    <ThemedLayoutV2>
                                        <Outlet />
                                    </ThemedLayoutV2>
                                </Authenticated>
                            }
                        >
                            <Route index element={<div>Welcome!</div>} />
                        </Route>
                        <Route
                            element={
                                <Authenticated fallback={<Outlet />}>
                                    <NavigateToResource resource="dashboard" />
                                </Authenticated>
                            }
                        >
                            <Route
                                path="/login"
                                element={
                                    <AuthPage
                                        type="login"
                                        wrapperProps={{
                                            style: {
                                                margin: "24px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/register"
                                element={
                                    <AuthPage
                                        type="register"
                                        wrapperProps={{
                                            style: {
                                                margin: "24px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/forgot-password"
                                element={
                                    <AuthPage
                                        type="forgotPassword"
                                        wrapperProps={{
                                            style: {
                                                margin: "24px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/update-password"
                                element={
                                    <AuthPage
                                        type="updatePassword"
                                        wrapperProps={{
                                            style: {
                                                margin: "24px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                        </Route>
                        <Route
                            element={
                                <Authenticated>
                                    <ThemedLayoutV2>
                                        <Outlet />
                                    </ThemedLayoutV2>
                                </Authenticated>
                            }
                        >
                            <Route path="*" element={<ErrorComponent />} />
                        </Route>
                    </Routes>
                </Refine>
            </ChakraProvider>
        </BrowserRouter>
    );
}
`.trim();

================
File: guides-concepts/authentication/auth-pages/headless.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function HeadlessAuth() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import { Refine, AuthPage, Authenticated, ErrorComponent } from "@refinedev/core";
import routerProvider, {
  CatchAllNavigate,
  NavigateToResource,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
  return (
      <BrowserRouter>
          <Refine
              routerProvider={routerProvider}
              dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
              authProvider={{
                  check: async () => ({
                      authenticated: false,
                      redirectTo: "/login",
                  }),
                  login: async () => {
                      return {
                          success: false,
                      };
                  },
                  logout: async () => {
                      return {
                          success: false,
                      };
                  },
                  onError: async () => ({}),
                  getIdentity: async () => ({
                      id: 1,
                      name: "John Doe",
                      avatar: "https://i.pravatar.cc/300",
                  }),
              }}
              resources={[
                  {
                      name: "dashboard",
                      list: "/",
                  },
              ]}
          >
              <Routes>
                  <Route
                      element={
                          <Authenticated
                              fallback={<CatchAllNavigate to="/login" />}
                          >
                              <Outlet />
                          </Authenticated>
                      }
                  >
                      <Route index element={<div>Welcome!</div>} />
                  </Route>
                  <Route
                      element={
                          <Authenticated
                              fallback={
                                  <div
                                      style={{
                                          margin: "24px auto",
                                          maxWidth: "400px",
                                      }}
                                  >
                                      <Outlet />
                                  </div>
                              }
                          >
                              <NavigateToResource resource="dashboard" />
                          </Authenticated>
                      }
                  >
                      <Route
                          path="/login"
                          element={<AuthPage type="login" />}
                      />
                      <Route
                          path="/register"
                          element={<AuthPage type="register" />}
                      />
                      <Route
                          path="/forgot-password"
                          element={<AuthPage type="forgotPassword" />}
                      />
                      <Route
                          path="/update-password"
                          element={<AuthPage type="updatePassword" />}
                      />
                  </Route>
                  <Route
                      element={
                          <Authenticated>
                              <Outlet />
                          </Authenticated>
                      }
                  >
                      <Route path="*" element={<ErrorComponent />} />
                  </Route>
              </Routes>
          </Refine>
      </BrowserRouter>
  );
}
`.trim();

================
File: guides-concepts/authentication/auth-pages/mantine.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function MantineAuth() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/mantine": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/react-table": "latest",
        "react-router": "^7.0.2",
        "@tabler/icons-react": "^3.1.0",
        "@emotion/react": "^11.8.2",
        "@mantine/core": "^5.10.4",
        "@mantine/hooks": "^5.10.4",
        "@mantine/notifications": "^5.10.4",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Global, MantineProvider } from "@mantine/core";
import { NotificationsProvider } from "@mantine/notifications";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import { Authenticated, Refine } from "@refinedev/core";
import {
    AuthPage,
    ErrorComponent,
    RefineThemes,
    ThemedLayoutV2,
} from "@refinedev/mantine";
import routerProvider, {
    CatchAllNavigate,
    NavigateToResource,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
    return (
        <BrowserRouter>
            <MantineProvider
                theme={RefineThemes.Blue}
                withNormalizeCSS
                withGlobalStyles
            >
                <Global styles={{ body: { WebkitFontSmoothing: "auto" } }} />
                <NotificationsProvider position="top-right">
                    <Refine
                        routerProvider={routerProvider}
                        dataProvider={dataProvider(
                            "https://api.fake-rest.refine.dev",
                        )}
                        authProvider={{
                            check: async () => ({
                                authenticated: false,
                                redirectTo: "/login",
                            }),
                            login: async () => {
                                return {
                                    success: false,
                                };
                            },
                            logout: async () => {
                                return {
                                    success: false,
                                };
                            },
                            onError: async () => ({}),
                            getIdentity: async () => ({
                                id: 1,
                                name: "John Doe",
                                avatar: "https://i.pravatar.cc/300",
                            }),
                        }}
                        resources={[
                            {
                                name: "dashboard",
                                list: "/",
                            },
                        ]}
                        options={{ syncWithLocation: true }}
                    >
                        <Routes>
                            <Route
                                element={
                                    <Authenticated
                                        fallback={
                                            <CatchAllNavigate to="/login" />
                                        }
                                    >
                                        <ThemedLayoutV2>
                                            <Outlet />
                                        </ThemedLayoutV2>
                                    </Authenticated>
                                }
                            >
                                <Route index element={<div>Welcome</div>} />
                            </Route>
                            <Route
                                element={
                                    <Authenticated fallback={<Outlet />}>
                                        <NavigateToResource resource="dashboard" />
                                    </Authenticated>
                                }
                            >
                                <Route
                                    path="/login"
                                    element={
                                        <AuthPage
                                            type="login"
                                            wrapperProps={{
                                                style: {
                                                    display: "flex",
                                                    flexDirection: "column",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    minHeight: "100vh",
                                                    margin: "24px auto",
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/register"
                                    element={
                                        <AuthPage
                                            type="register"
                                            wrapperProps={{
                                                style: {
                                                    display: "flex",
                                                    flexDirection: "column",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    minHeight: "100vh",
                                                    margin: "24px auto",
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/forgot-password"
                                    element={
                                        <AuthPage
                                            type="forgotPassword"
                                            wrapperProps={{
                                                style: {
                                                    display: "flex",
                                                    flexDirection: "column",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    minHeight: "100vh",
                                                    margin: "24px auto",
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/update-password"
                                    element={
                                        <AuthPage
                                            type="updatePassword"
                                            wrapperProps={{
                                                style: {
                                                    display: "flex",
                                                    flexDirection: "column",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    minHeight: "100vh",
                                                    margin: "24px auto",
                                                },
                                            }}
                                        />
                                    }
                                />
                            </Route>
                            <Route
                                element={
                                    <Authenticated>
                                        <ThemedLayoutV2>
                                            <Outlet />
                                        </ThemedLayoutV2>
                                    </Authenticated>
                                }
                            >
                                <Route path="*" element={<ErrorComponent />} />
                            </Route>
                        </Routes>
                    </Refine>
                </NotificationsProvider>
            </MantineProvider>
        </BrowserRouter>
    );
}
`.trim();

================
File: guides-concepts/authentication/auth-pages/mui.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function MaterialUIAuth() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/mui": "latest",
        "react-router": "^7.0.2",
        "@emotion/react": "^11.8.2",
        "@emotion/styled": "^11.8.1",
        "@mui/lab": "^6.0.0-beta.14",
        "@mui/material": "^6.1.7",
        "@mui/system": "latest",
        "@mui/x-data-grid": "7.23.5",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import CssBaseline from "@mui/material/CssBaseline";
import GlobalStyles from "@mui/material/GlobalStyles";
import { ThemeProvider } from "@mui/material/styles";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import { Authenticated, Refine } from "@refinedev/core";
import {
    AuthPage,
    ErrorComponent,
    RefineThemes,
    ThemedLayoutV2,
} from "@refinedev/mui";
import routerProvider, {
    CatchAllNavigate,
    NavigateToResource,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
    return (
        <BrowserRouter>
            <ThemeProvider theme={RefineThemes.Blue}>
                <CssBaseline />
                <GlobalStyles
                    styles={{ html: { WebkitFontSmoothing: "auto" } }}
                />
                <Refine
                    routerProvider={routerProvider}
                    dataProvider={dataProvider(
                        "https://api.fake-rest.refine.dev",
                    )}
                    authProvider={{
                        check: async () => ({
                            authenticated: false,
                            redirectTo: "/login",
                        }),
                        login: async () => {
                            return {
                                success: false,
                            };
                        },
                        logout: async () => {
                            return {
                                success: false,
                            };
                        },
                        onError: async () => ({}),
                        getIdentity: async () => ({
                            id: 1,
                            name: "John Doe",
                            avatar: "https://i.pravatar.cc/300",
                        }),
                    }}
                    resources={[
                        {
                            name: "dashboard",
                            list: "/",
                        },
                    ]}
                    options={{ syncWithLocation: true }}
                >
                    <Routes>
                        <Route
                            element={
                                <Authenticated
                                    fallback={<CatchAllNavigate to="/login" />}
                                >
                                    <ThemedLayoutV2>
                                        <Outlet />
                                    </ThemedLayoutV2>
                                </Authenticated>
                            }
                        >
                            <Route
                                path="/dashboard"
                                element={<div>Welcome</div>}
                            />
                        </Route>
                        <Route
                            element={
                                <Authenticated fallback={<Outlet />}>
                                    <NavigateToResource resource="dashboard" />
                                </Authenticated>
                            }
                        >
                            <Route
                                path="/login"
                                element={
                                    <AuthPage
                                        type="login"
                                        wrapperProps={{
                                            style: {
                                                margin: "72px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/register"
                                element={
                                    <AuthPage
                                        type="register"
                                        wrapperProps={{
                                            style: {
                                                margin: "72px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/forgot-password"
                                element={
                                    <AuthPage
                                        type="forgotPassword"
                                        wrapperProps={{
                                            style: {
                                                margin: "72px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/update-password"
                                element={
                                    <AuthPage
                                        type="updatePassword"
                                        wrapperProps={{
                                            style: {
                                                margin: "72px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                        </Route>
                        <Route
                            element={
                                <Authenticated>
                                    <ThemedLayoutV2>
                                        <Outlet />
                                    </ThemedLayoutV2>
                                </Authenticated>
                            }
                        >
                            <Route path="*" element={<ErrorComponent />} />
                        </Route>
                    </Routes>
                </Refine>
            </ThemeProvider>
        </BrowserRouter>
    );
}
`.trim();

================
File: guides-concepts/authentication/auth-provider-interface.md
================
```ts
import { Refine, AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  register: async (params) => {
    if (params.email === authCredentials.email && params.password) {
      localStorage.setItem("email", params.email);
      return {
        success: true,
        redirectTo: "/",
      };
    }
    return {
      success: false,
      error: {
        message: "Register failed",
        name: "Invalid email or password",
      },
    };
  },
  login: async ({ providerName, email }) => {
    if (providerName === "google") {
      window.location.href = "https://accounts.google.com/o/oauth2/v2/auth";
      return {
        success: true,
      };
    }

    if (providerName === "github") {
      window.location.href = "https://github.com/login/oauth/authorize";
      return {
        success: true,
      };
    }

    if (email === authCredentials.email) {
      localStorage.setItem("email", email);
      return {
        success: true,
        redirectTo: "/",
      };
    }

    return {
      success: false,
      error: {
        message: "Login failed",
        name: "Invalid email or password",
      },
    };
  },
  check: async () => {
    return localStorage.getItem("email")
      ? {
          authenticated: true,
        }
      : {
          authenticated: false,
          error: {
            message: "Check failed",
            name: "Not authenticated",
          },
          logout: true,
          redirectTo: "/login",
        };
  },
  logout: async () => {
    localStorage.removeItem("email");
    return {
      success: true,
      redirectTo: "/login",
    };
  },
  onError: async (error) => {
    console.error(error);
    return { error };
  },
  getIdentity: async () => ({
    id: 1,
    name: "Jane Doe",
    avatar: "https://unsplash.com/photos/IWLOvomUmWU/download?force=true&w=640",
  }),
  updatePassword: async (params) => {
    if (params.password === authCredentials.password) {
      //we can update password here
      return {
        success: true,
      };
    }
    return {
      success: false,
      error: {
        message: "Update password failed",
        name: "Invalid password",
      },
    };
  },
  forgotPassword: async (params) => {
    if (params.email === authCredentials.email) {
      //we can send email with reset password link here
      return {
        success: true,
      };
    }
    return {
      success: false,
      error: {
        message: "Forgot password failed",
        name: "Invalid email",
      },
    };
  },
  getPermissions: async (params) => {
    if (params) {
      // do some logic like for example you can get roles for specific tenant
      return ["admin"];
    }

    return ["admin"];
  },
};
```

================
File: guides-concepts/authentication/index.md
================
---
title: Authentication
---

import Register from "./register";
import Login from "./login";
import IsAuthenticated from "./is-authenticated";
import OnError from "./on-error";
import AuthProviderInterface from "./auth-provider-interface.md";
import AuthHooks from "@site/src/partials/auth-provider/auth-hooks.md";
import AuthProviderExamplesLinks from "@site/src/partials/auth-provider/auth-provider-examples-links.md";

Authentication is the process of verifying the identity of a user or client. It's a critical component of security, ensuring that only authorized users can access certain features or data within the application. Whether you are building a complex **enterprise-level** application or a simple CRUD interface, Refine's authentication system provides the necessary infrastructure to protect your pages and ensure that users interact with your application in a secure and controlled manner.

Refine's **flexible architecture** allows you to easily implement various authentication strategies:

- [Google](https://developers.google.com/identity/protocols/oauth2)
- [Amazon Cognito](https://aws.amazon.com/cognito/)
- [Okta](https://www.okta.com/) (Included in [Refine's Enterprise Edition](/docs/enterprise-edition/okta))
- [Auth0](https://auth0.com/)

You can implement your own authentication system or use one of the [supported auth providers](#supported-auth-providers).

> [To learn more about how to create auth provider, check out the tutorial page.][create-auth-provider-tutorial]

## Auth Provider

Refine handles authentication by [Auth Provider](#auth-provider) and consumes the auth provider methods by [auth hooks](#auth-hooks).

Auth provider is an object that contains methods to handles authentication in your app, designed to return promises for use with async methods. By offering a structured architecture it simplifies authentication implementation and management through your app.

To activate authentication in your app, you need to pass an `authProvider` to the `<Refine />` as a prop. Once you provide auth provider, you can utilize our auth hooks (useLogin, useRegister, useIsAuthenticated etc.) to easily manage your authentication.

```tsx title="App.tsx"
import { Refine, AuthProvider } from "@refinedev/core";

export const authProvider: AuthProvider = {
  login: async ({ email, password }) => {
    const { status } = handleLogin(email, password);

    if (status === 200) {
      return { success: true, redirectTo: "/dashboard" };
    } else {
      return {
        success: false,
        error: { name: "Login Error", message: "Invalid credentials" },
      };
    }
  },
  check: async (params) => ({}),
  logout: async (params) => ({}),
  onError: async (params) => ({}),
  register: async (params) => ({}),
  forgotPassword: async (params) => ({}),
  updatePassword: async (params) => ({}),
  getPermissions: async (params) => ({}),
  getIdentity: async (params) => ({}),
};

const App = () => {
  // highlight-next-line
  return <Refine authProvider={authProvider}>...</Refine>;
};
```

## Handling Authentication

Refine provides a set of hooks to handle authentication. You can use these hooks to manage your authentication process. You can find the [list of hooks](#auth-hooks) below.

### Register

Let's start with registering a new user. To register a new user, we will implement `authProvider.register` method. We will call this method with `useRegister` hook when the user submits the registration form.

<Register />

### Login

After registering a new user, we will implement `authProvider.login` method to login the user. We will call this method with `useLogin` hook when the user submits the login form. This implementation is very similar to the registration process.

<Login />

### Checking Authentication

In the previous examples, the registration and login process were set up. Next, we need to check if the user is authenticated or not. This will be done by using the `authProvider.check` method together with the `useIsAuthenticated` hook.

By using `useIsAuthenticated` hook, we can easily check if the user is authenticated or not. If they are, the user's profile will be shown. If not, the `<Login />` component will appear.

Additionally, in this example, we will implement `authProvider.logout` and `authProvider.getIdentity` methods. We will call these methods with `useLogout` and `useGetIdentity` hooks. These hooks make it easy to log out users and get their identity information.

<IsAuthenticated />

Refine also provides `<Authenticated />` component to easily handle authentication state. You can use this component to protect your routes and conditionally render your components.

[To learn more about the `<Authenticated />` component, check out the reference page.](/docs/authentication/components/authenticated)

```tsx
import { Authenticated } from "@refinedev/core";

const Page = () => {
  return (
    <Authenticated
      loading={<div>loading...</div>}
      fallback={<div>You cannot access this section</div>}
    >
      <h1>Welcome to your dashboard</h1>
    </Authenticated>
  );
};
```

### Usage with data provider <GuideBadge id="guides-concepts/data-fetching/" />

After implementing the authentication process, we need to inform data provider about the authentication credentials. We can do this by sending the authentication credentials with the request. For example after obtaining the authentication token we can store it in cookies and sent it with on every request.

[To learn more about the how to use authentication with data provider and working example, check out data fetching guide.](/docs/guides-concepts/data-fetching/#authentication-)

## Error Handling

`authProvider.onError` method is used to handle errors that occur during the http request.

Under the hood, Refine utilizes the [`useOnError`][use-on-error] hook for all data hooks. This means that when a promise is rejected from the `dataProvider` or when you get an error response from the API, Refine automatically calls `authProvider.onError` by using the `useOnError` hook.

Let's say wan't to get product from the API with [`useOne`][use-one] hook. If the user is not authenticated, the API will return an error response. You can handle this error by implementing `authProvider.onError` method and Refine will automatically call this method when the error occurs.

<OnError />

Once you implement `authProvider.onError` method, you can call this method with [`useOnError`][use-on-error] hook. This will help you to handle errors in single place.

## UI Integrations

### `<AuthPage />`

While Refine itself is headless, it offers `<AuthPage />` Integrations for popular UI libraries for:

- [Headless](/docs/authentication/components/auth-page)
- [Ant Design](/docs/ui-integrations/ant-design/components/auth-page)
- [Material UI](/docs/ui-integrations/material-ui/components/auth-page)
- [Chakra UI](/docs/ui-integrations/chakra-ui/components/auth-page)
- [Mantine](/docs/ui-integrations/mantine/components/auth-page)

With `<AuthPage />` component you can easily handle authentication pages (login, register, update password, forgot password) and speed up your development process.

<Tabs wrapContent={false}>

<TabItem value="Headless">

import { HeadlessAuth } from './auth-pages/headless';

<HeadlessAuth/>

</TabItem>

<TabItem value="Ant Design">

import { AntdAuth } from './auth-pages/antd';

<AntdAuth/>

</TabItem>

<TabItem value="Material UI">

import { MaterialUIAuth } from './auth-pages/mui';

<MaterialUIAuth/>

</TabItem>

<TabItem value="Chakra UI">

import { ChakraUIAuth } from './auth-pages/chakra';

<ChakraUIAuth/>

</TabItem>

<TabItem value="Mantine">

import { MantineAuth } from './auth-pages/mantine';

<MantineAuth/>

</TabItem>

</Tabs>

### Notification <GuideBadge id="notification/notification-provider" />

Refine provides a automatic notification system to notify users about the authentication errors. To use this feature, you need to pass [`notificationProvider`](/docs/notification/notification-provider) to the `<Refine />` component.

Once you provide `notificationProvider`, Refine will automatically notify users about the authentication errors on following auth provider methods:

- register
- login
- logout
- forgotPassword
- updatePassword

For example, when you return `error` object from the `authProvider.login` method, Refine will automatically notify users about the error.

```tsx
import { Refine, AuthProvider } from "@refinedev/core";
import { handleLogin } from "./utils";

export const authProvider: AuthProvider = {
  login: async ({ email, password }) => {
    const { status } = handleLogin(email, password);
    if (status === 418) {
      return {
        success: false,
        error: { name: "Login Error", message: "Invalid credentials" },
      };
    }
  },
  ...
};
```

## Router Integrations <GuideBadge id="guides-concepts/routing/" />

Refine provides a automatic routing system to redirect users to the desired page after the authentication process. To use this feature, you need to pass [`routerProvider`](/docs/routing/router-provider) to the `<Refine />` component.

Once you provide `routerProvider`, Refine will automatically redirect users to the desired page on following auth provider methods:

- register
- login
- logout
- onError
- forgotPassword
- updatePassword

For example, when you return `redirectTo` object from the `authProvider.register` method, Refine will automatically redirect users to the desired page.

```tsx
import { Refine, AuthProvider } from "@refinedev/core";
import { handleLogin } from "./utils";

export const authProvider: AuthProvider = {
  register: async ({ email, password }) => {
    const { status } = handleLogin(email, password);
    if (status === 418) {
      return {
        success: false,
        redirectTo: "/forgot-password",
        error: { name: "Register Error", message: "User already exists" },
      };
    }
  },
  ...
};
```

## Auth hooks

<AuthHooks />

## OAuth Integrations

Flexible architecture of auth provider allows you to integrate your **own** or [third-party authentication systems](#supported-auth-provider) into Refine.

You can use the following oAuth provider implementations as a starting point for your own auth provider or you can use them as it is.

- [Google](https://github.com/refinedev/refine/tree/main/examples/auth-google-login)
- [Auth0](https://github.com/refinedev/refine/tree/main/examples/auth-auth0)
- [Kinde](https://github.com/refinedev/refine/tree/main/examples/auth-kinde)
- [Keycloak](https://github.com/refinedev/refine/tree/main/examples/auth-keycloak)
- [supabase](https://github.com/refinedev/refine/tree/main/examples/data-provider-supabase)
- [Strapi](https://github.com/refinedev/refine/tree/main/examples/data-provider-strapi-v4)
- [Auth.js](https://github.com/refinedev/refine/tree/main/examples/with-nextjs-next-auth)

[To learn more about the `authProvider` interface, check out the reference page.](/docs/authentication/auth-provider)

## Supported Auth Providers

<AuthProviderExamplesLinks />

> For more information on how you can create your own auth providers, refer to the [Create a Auth Provider tutorial &#8594][create-auth-provider-tutorial]

## `authProvider` Interface

To better understand the auth provider interface, we have created an example that demonstrates how the required methods are implemented. For more comprehensive and diverse examples, you can refer to the [supported auth providers](#supported-auth-providers) section.

[To learn more about the `authProvider` interface, check out the reference page.](/docs/authentication/auth-provider)

<AuthProviderInterface />

[use-login]: /docs/authentication/hooks/use-login
[use-logout]: /docs/authentication/hooks/use-logout
[use-is-authenticated]: /docs/authentication/hooks/use-is-authenticated
[use-on-error]: /docs/authentication/hooks/use-on-error
[use-get-identity]: /docs/authentication/hooks/use-get-identity
[use-permissions]: /docs/authentication/hooks/use-permissions
[use-register]: /docs/authentication/hooks/use-register
[use-forgot-password]: /docs/authentication/hooks/use-forgot-password
[use-update-password]: /docs/authentication/hooks/use-update-password
[create-auth-provider-tutorial]: /docs/authentication/auth-provider
[use-one]: /docs/data/hooks/use-one

================
File: guides-concepts/authentication/is-authenticated.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function IsAuthentcated() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        axios: "^1.6.2",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          hidden: false,
          active: true,
        },
        "/login-page.tsx": {
          code: LoginPageTsxCode,
          hidden: false,
          active: true,
        },
        "/auth-provider.ts": {
          code: AuthProviderCode,
          hidden: false,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { HomePage } from "./home-page.tsx";
import { dataProvider } from "./data-provider.ts";
import { authProvider } from "./auth-provider.ts";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            authProvider={authProvider}
        >
            <HomePage />
        </Refine>
    );
}
`.trim();
const AuthProviderCode = `
import React from "react";
import { AuthProvider } from "@refinedev/core";
// to keep the example short and simple, we didn't send a request, and we save the token in localStorage.
// in real world, you should send a request and token should be saved in more secure place.
export const authProvider: AuthProvider = {
    login: async ({ email }) => {
        localStorage.setItem("email", email);
        return {
            success: true,
        };
    },
    check: async () => {
        const email = localStorage.getItem("email");
        if (!email) {
            return {
                authenticated: false,
            };
        }
        return {
            authenticated: true,
        };
    },
    logout: async () => {
        localStorage.removeItem("email");
        return {
            success: true,
        };
    },
    getIdentity: async () => {
        const email = localStorage.getItem("email");
        return {
            email,
        };
    },
    register: async () => {
        throw new Error("Not implemented");
    },
    onError: async () => {
        throw new Error("Not implemented");
    },
};
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
    getList: async () => {
        throw new Error("Not implemented");
    },
    getOne: async () => {
        throw new Error("Not implemented");
    },
    create: async () => {
        throw new Error("Not implemented");
    },
    update: async () => {
        throw new Error("Not implemented");
    },
    deleteOne: async () => {
        throw new Error("Not implemented");
    },
    getApiUrl: () => url,
});
`.trim();
const LoginPageTsxCode = `
import React from "react";
import { useLogin } from "@refinedev/core";
export const LoginPage = () => {
    const { mutate: login } = useLogin();
    const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        // get form data
        const formData = Object.fromEntries(
            new FormData(e.currentTarget).entries(),
        );
        // call login mutation
        login(formData);
        // reset form data
        e.currentTarget.reset();
    };
    return (
        <div>
            <h1>Login</h1>
            <form onSubmit={(e) => onSubmit(e)}>
                <input type="email" placeholder="email" />
                <button type="submit">Submit</button>
            </form>
        </div>
    );
};
`.trim();
const HomePageTsxCode = `
import React from "react";
import { useIsAuthenticated, useGetIdentity, useLogout } from "@refinedev/core";
import { LoginPage } from "./login-page.tsx";
export const HomePage = () => {
    const { data: authenticated } = useIsAuthenticated();
    const { data: identity } = useGetIdentity<{ email: string }>();
    const { mutate: logout } = useLogout();
    if (authenticated?.authenticated) {
        return (
            <div>
                <h1>Hello,  {identity?.email}</h1>
                <button onClick={() => logout()}>Logout</button>
            </div>
        );
    }
    return <LoginPage />;
};
`.trim();

================
File: guides-concepts/authentication/login.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function Login() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        axios: "^1.6.2",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/login-page.tsx": {
          code: LoginPageTsxCode,
          hidden: false,
          active: true,
        },
        "/auth-provider.ts": {
          code: AuthProviderCode,
          hidden: false,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { LoginPage } from "./login-page.tsx";
import { dataProvider } from "./data-provider.ts";
import { authProvider } from "./auth-provider.ts";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            authProvider={authProvider}
        >
            <LoginPage />
        </Refine>
    );
}
`.trim();
const AuthProviderCode = `
import React from "react";
import { AuthProvider } from "@refinedev/core";
export const authProvider: AuthProvider = {
    login: async ({ email }) => {
        // to keep the example short and simple, we didn't send a request, and we save the token in localStorage.
        // in real world, you should send a request and token should be saved in more secure place.
        localStorage.setItem("token", email);
        alert("You are logged in!");
        return {
            success: true,
        };
        throw new Error("Not implemented");
    },
    register: async () => {
        throw new Error("Not implemented");
    },
    logout: async () => {
        throw new Error("Not implemented");
    },
    check: async () => {
        throw new Error("Not implemented");
    },
    onError: async () => {
        throw new Error("Not implemented");
    },
};
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
    getList: async () => {
        throw new Error("Not implemented");
    },
    getOne: async () => {
        throw new Error("Not implemented");
    },
    create: async () => {
        throw new Error("Not implemented");
    },
    update: async () => {
        throw new Error("Not implemented");
    },
    deleteOne: async () => {
        throw new Error("Not implemented");
    },
    getApiUrl: () => url,
});
`.trim();
const LoginPageTsxCode = `
import React from "react";
import { useLogin } from "@refinedev/core";
export const LoginPage = () => {
    const { mutate: login } = useLogin();
    const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        // get form data
        const formData = Object.fromEntries(
            new FormData(e.currentTarget).entries(),
        );
        // call login mutation
        login(formData);
        // reset form data
        e.currentTarget.reset();
    };
    return (
        <div>
            <h1>Login</h1>
            <form onSubmit={(e) => onSubmit(e)}>
                <input type="email" placeholder="email" />
                <button type="submit">Submit</button>
            </form>
        </div>
    );
};
`.trim();

================
File: guides-concepts/authentication/on-error.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function OnError() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        axios: "^1.6.2",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-page.tsx": {
          code: ProductPageTsxCode,
          hidden: false,
          active: true,
        },
        "/auth-provider.ts": {
          code: AuthProviderCode,
          hidden: false,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { ProductPage } from "./product-page.tsx";
import { dataProvider } from "./data-provider.ts";
import { authProvider } from "./auth-provider.ts";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            authProvider={authProvider}
        >
            <ProductPage />
        </Refine>
    );
}
`.trim();
const AuthProviderCode = `
import React from "react";
import { AuthProvider } from "@refinedev/core";
export const authProvider: AuthProvider = {
    onError: async (error: HttpError) => {
        // simulating a HTTP error
        if (error.statusCode === 401) {
            alert(error.message);
        }
        return {};
    },
    login: async () => {
        throw new Error("Not implemented");
    },
    logout: async () => {
        throw new Error("Not implemented");
    },
    check: async () => {
        throw new Error("Not implemented");
    },
};
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
    getOne: async () => {
        // simulating a HTTP error
        const error: HttpError = {
            message: "User is not authenticated",
            statusCode: 401,
        };
        return Promise.reject(error);
    },
    getList: async () => {
        throw new Error("Not implemented");
    },
    create: async () => {
        throw new Error("Not implemented");
    },
    update: async () => {
        throw new Error("Not implemented");
    },
    deleteOne: async () => {
        throw new Error("Not implemented");
    },
    getApiUrl: () => url,
});
`.trim();
const ProductPageTsxCode = `
import React from "react";
import { useOne } from "@refinedev/core";
export const ProductPage = () => {
    const { data, refetch } = useOne<Product>({
        resource: "products",
        id: "1",
        queryOptions: {
            retry: false,
            enabled: false,
        },
    });
    const product = data?.data;
    return (
        <div>
            <h2>Product</h2>
            <p>name: {product?.name}</p>
            <button onClick={() => refetch()}>Get Product</button>
        </div>
    );
};
type Product = {
    id: string;
    name: string;
};
`.trim();

================
File: guides-concepts/authentication/register.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function Login() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        axios: "^1.6.2",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/register-page.tsx": {
          code: RegisterPageTsxCode,
          hidden: false,
          active: true,
        },
        "/auth-provider.ts": {
          code: AuthProviderCode,
          hidden: false,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { RegisterPage } from "./register-page.tsx";
import { dataProvider } from "./data-provider.ts";
import { authProvider } from "./auth-provider.ts";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            authProvider={authProvider}
        >
            <RegisterPage />
        </Refine>
    );
}
`.trim();
const AuthProviderCode = `
import React from "react";
import { AuthProvider } from "@refinedev/core";
export const authProvider: AuthProvider = {
    register: async ({ email }) => {
        // to keep the example short and simple, we didn't send a request, and we save the token in localStorage.
        // in real world, you should send a request and token should be saved in more secure place.
        localStorage.setItem("token", email);
        alert("You have successfully registered!");
        return {
            success: true,
        };
    },
    login: async () => {
        throw new Error("Not implemented");
    },
    logout: async () => {
        throw new Error("Not implemented");
    },
    check: async () => {
        throw new Error("Not implemented");
    },
    onError: async () => {
        throw new Error("Not implemented");
    },
};
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
    getList: async () => {
        throw new Error("Not implemented");
    },
    getOne: async () => {
        throw new Error("Not implemented");
    },
    create: async () => {
        throw new Error("Not implemented");
    },
    update: async () => {
        throw new Error("Not implemented");
    },
    deleteOne: async () => {
        throw new Error("Not implemented");
    },
    getApiUrl: () => url,
});
`.trim();
const RegisterPageTsxCode = `
import React from "react";
import { useRegister } from "@refinedev/core";
export const RegisterPage = () => {
    const { mutate: register } = useRegister();
    const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        // get form data
        const formData = Object.fromEntries(
            new FormData(e.currentTarget).entries(),
        );
        // call register mutation
        register(formData);
        // reset form data
        e.currentTarget.reset();
    };
    return (
        <div>
            <h1>Register</h1>
            <form onSubmit={(e) => onSubmit(e)}>
                <input
                    type="email"
                    placeholder="email"
                />
                <button type="submit">Submit</button>
            </form>
        </div>
    );
};
`.trim();

================
File: guides-concepts/authorization/example.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function AccessControlExample() {
  return (
    <Sandpack
      showNavigator
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/payments/1"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "/access-control.ts": {
          code: AccessControlCode,
          active: true,
        },
        "/show.tsx": {
          code: ShowTsxCode,
        },
      }}
    />
  );
}
const AccessControlCode = /* ts */ `
import { AccessControlProvider } from "@refinedev/core";
const role = "editor";
// Uncomment this line and refresh to see difference.
// const role = "admin";
export const accessControlProvider: AccessControlProvider = {
  can: async ({ action, resource, params }) => {
    console.log(action, resource, params);
    if (
      role === "admin" &&
      ["field", "refund", "approve"].includes(action)
    ) {
      return {
        can: true,
      };
    }
    return {
      can: false,
      reason: "Unauthorized",
    };
  },
};
`.trim();
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
import { BrowserRouter, Route, Routes } from "react-router";
import "./style.css";
import { accessControlProvider } from "./access-control.ts";
import { PaymentShow } from "./show.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <Refine
      accessControlProvider={accessControlProvider}
        routerProvider={routerProvider}
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        resources={[
          {
            name: "payments",
            show: "/payments/:id",
          },
        ]}
      >
        <Routes>
          <Route path="/payments/:id" element={<PaymentShow />} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
}
`.trim();
const StyleCssCode = `
html {
    margin: 0;
    padding: 0;
}
body {
    margin: 0;
    padding: 12px;
}
* {
    box-sizing: border-box;
}
body {
    font-family: sans-serif;
}
form label, form input, form button {
    display: block;
    width: 100%;
    margin-bottom: 6px;
}
span + button {
    margin-left: 6px;
}
ul > li {
    margin-bottom: 6px;
}
`.trim();
const ShowTsxCode = `
import { CanAccess, useCan } from "@refinedev/core";
export const PaymentShow: React.FC = () => {
  const { data } = useCan({
    resource: "payments",
    action: "refund",
    params: { id: 1 },
  });
  return (
    <>
      <h1>Payment Details</h1>
      <p>
        <b>ID</b>: <span>1</span>
      </p>
      <p>
        <b>Amount</b>: <span>$100</span>
      </p>
      <p>
        <b>Transaction ID</b>:
        <span>
          <CanAccess
            resource="payments"
            action="field"
            params={{ field: "transactionId" }}
            fallback={<>This field is only visible to admin users.</>}
          >
            <span>123456789</span>
          </CanAccess>
        </span>
      </p>
      <button disabled={!data?.can}>
        {data?.can ? "Refund" : data?.reason}
      </button>
    </>
  );
};
`.trim();

================
File: guides-concepts/authorization/index.md
================
---
title: Authorization
---

Authorization is a key aspect of security and user experience in web applications. Whether you are building a complex **enterprise-level** application or a simple CRUD interface, Refine's authorization system provides the necessary infrastructure to protect your resources and ensure that users interact with your application in a secure and controlled manner.

Refine's **flexible architecture** allows you to easily implement various authorization strategies:

- Role-Based Access Control (**RBAC**)
- Attribute-Based Access Control (**ABAC**)
- Access Control List (**ACL**)

With **any** authorization solution. (i.e. [Okta](https://help.okta.com/wf/en-us/content/topics/workflows/connector-reference/okta/overviews/authorization.htm), [Casbin](https://casbin.org/), [Cerbos](https://cerbos.dev), or more)

Refine offers several features to help you implement authorization in your application:

- `<CanAccess />` component: Conditionally renders child components based on the user's access to a resource.
- `useCan` hook: Returns a value indicating whether the user has access to a resource based on the given parameters.
- **UI Integrations**: Conditionally renders UI elements such as **buttons**, **menu items**, etc. based on the user's access to a resource.

In order to enable these features, Refine uses the **Access Control Provider** as an interface to connect your application with your authorization solution and provides necessary parameters to make access control decisions.

## Access Control Provider

The [Access Control Provider](/docs/authorization/access-control-provider) is an object that contains a `can` method. This method is called by Refine to understand if the user can see a certain resource or perform an action.

A basic **Access Control Provider** looks like this:

```tsx title="access-control-provider.ts"
import { AccessControlProvider } from "@refinedev/core";

export const accessControlProvider: AccessControlProvider = {
  can: async ({ resource, action, params }) => {
    console.log(resource); // products, orders, etc.
    console.log(action); // list, edit, delete, etc.
    console.log(params); // { id: 1 }, { id: 2 }, etc.

    if (meetSomeCondition) {
      return { can: true };
    }

    return {
      can: false,
      reason: "Unauthorized",
    };
  },
};
```

And can be passed to `<Refine />` component's `accessControlProvider` prop:

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";

import { accessControlProvider } from "./access-control-provider";

export const App = () => {
  return (
    <Refine
      // highlight-next-line
      accessControlProvider={accessControlProvider}
    >
      {/* ... */}
    </Refine>
  );
};
```

[To learn more about the `Access Control Provider`, check out the reference page.](/docs/authorization/access-control-provider)

## CanAccess Component

The `CanAccess` component can be used to wrap your **pages** or **components** to hide them from unauthorized users.

It calls **Access Control Provider**'s `can` method and conditionally renders its children based on the result.

Here's a basic example of how to use the `CanAccess` component:

```tsx title="list-page.tsx"
import { CanAccess } from "@refinedev/core";

export const ListPage = () => {
  return (
    <CanAccess
      resource="products"
      action="list"
      fallback={<h1>You are not authorized to see this page.</h1>}
    >
      <>
        <h1>Products</h1>
        <CanAccess resource="products" action="show" params={{ id: 1 }}>
          <Button>See Details</Button>
        </CanAccess>
      </>
    </CanAccess>
  );
};
```

[To learn more about the `CanAccess` component, check out the reference page.](/docs/authorization/components/can-access)

### Router Integrations

Refine's router integrations can infer `resource`, `action`, and `params.id` props from the current route and pass them to the `<CanAccess />` component.

This means you can wrap all of your routes with a single `<CanAccess />` component, instead of wrapping each page individually.

See [React Router](/docs/packages/list-of-packages), [Next.js](/docs/packages/list-of-packages), [Remix](/docs/packages/list-of-packages) integration pages for more information.

## useCan Hook

The `useCan` hook can be used to check if the user has access to a resource or action.

It calls **Access Control Provider**'s `can` method and returns a value indicating whether the user has access to the resource or action.

Here's a basic example of how to use the `useCan` hook:

```tsx title="list-page.tsx"
import { useCan } from "@refinedev/core";

export const ListPage = () => {
  const { data } = useCan({
    resource: "products",
    action: "show",
    params: { id: 1 },
  });

  return (
    <>
      <h1>Products</h1>
      {data?.can && <Button>See Details</Button>}
    </>
  );
};
```

[To learn more about the `useCan` hook, check out the reference page.](/docs/authorization/hooks/use-can)

## Handling Authorization

import { AccessControlExample } from "./example";

<AccessControlExample />

## UI Integrations

When Access Control Provider is provided, Refine's UI Integrations automatically manages the **visibility** of their components like **buttons** and **menu items**, simplifying the management of UI.

These UI Integrations uses the Access Control Provider to check if a user has the necessary permissions. This check is performed without requiring manual implementation for each component, streamlining the development process.

### Sider

Sider component's **menu items** will **automatically hidden** if user don't have access.

Let's assume we have **products** resource.

Menu item of this resource will call `can` method with following parameters:

```
{ resource: "products", action: "list" }
```

And if user isn't allowed to `list` products, menu item will be hidden.

### Buttons

If you are using one of our buttons from our UI Integrations in your application, you don't need to wrap it with `<CanAccess />` or use `useCan` every time. These buttons will automatically be shown or hidden.

```tsx title=button-example.ts
// Following buttons call `can` method with commented parameters.
import {
  CreateButton, //  { resource: "products", action: "create", params: { resource }}
  ListButton, //    { resource: "products", action: "list" , params: { resource }}
  EditButton, //    { resource: "products", action: "edit", params: { id: 1, resource } }
  ShowButton, //    { resource: "products", action: "show", params: { id: 1, resource } }
  DeleteButton, //  { resource: "products", action: "delete", params: { id: 1, resource } }
  CloneButton, //   { resource: "products", action: "clone", params: { id: 1, resource } }
} from "@refinedev/antd"; // or @refinedev/chakra-ui, @refinedev/mui, @refinedev/mantine
```

================
File: guides-concepts/contributing/index.md
================
---
title: Contributing
---

We follow a [code of conduct](https://github.com/refinedev/refine/blob/main/CODE_OF_CONDUCT.md) when participating in the community. Please read it before you make any contributions.

- If you plan to work on an issue, mention so in the issue page before you start working on it.
- If you plan to work on a new feature, create an issue and discuss it with other community members/maintainers.
- Ask for help in our [community room](https://discord.gg/refine).

## Ways to contribute

- **Stars on GitHub**: If you're a Refine user and enjoy using our platform, don't forget to star it on [GitHub](https://github.com/refinedev/refine)! 🌟
- **Improve documentation**: Good documentation is imperative to the success of any project. You can make our documents the best they need to be by improving their quality or adding new ones.
- **Give feedback**: We're always looking for ways to make Refine better, please share how you use Refine, what features are missing and what is done good via [GitHub Discussions](https://github.com/refinedev/refine/discussions) or [Discord](http://discord.gg/refine).
- **Share Refine**: Help us reach people. Share [Refine repository](https://github.com/refinedev/refine) with everyone who can be interested.
- **Contribute to codebase**: your help is needed to make this project the best it can be! You could develop new features or fix [existing issues](https://github.com/refinedev/refine/issues) - every contribution will be welcomed with great pleasure!
- **Share your own integrations**: If you've created an integration for Refine, this can be a data provider, an auth provider, a UI integration or a routing integration, please share it with us! Refine's community has been growing rapidly and we're sure that your integration will be useful for many people. We'll be happy to add your integration to our [integrations page](https://refine.dev/integrations) along with the other community made integrations and share it with our community.

## Setting Up Your Environment for Development

:::simple Requirements

- [Node.js](https://nodejs.org/en/) version 18 or higher
- [Git](https://git-scm.com/) and [GitHub](https://github.com) account
- [pnpm](https://pnpm.io/) version 9 or higher
- [Latest Microsoft Visual C++ Redistributable Version](https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170)

:::

If your environment is ready, you can [fork the Refine repository](https://github.com/refinedev/refine/fork) and clone it to your local machine.

### Cloning the Repository

After you fork the Refine repository, you need to clone it to your local machine. Instead of using the `refinedev/refine` repository, it's recommended to use your fork. This way, you can push your changes to your fork and create a pull request from there.

```sh
git clone https://github.com/refinedev/refine.git
```

### Installing dependencies

After you clone the repository, you need to install the dependencies. We use pnpm as package manager with workspaces feature. You can run the following command to install, link dependencies and build packages:

```sh title="Terminal"
pnpm install
```

If you don't want to wait for building packages, you can use

```sh title="Terminal"
pnpm install --ignore-scripts
```

### Building packages

You can use `pnpm build` command with `--scope` flag to build packages & examples.

```sh title="Terminal"
pnpm build --scope @refinedev/antd --scope base-antd
```

### Working with packages

```sh title="Terminal"
pnpm dev --scope @refinedev/antd --scope base-antd
```

After running this command, you should see the packages and examples you've started in watch mode. You can now make changes in any of them and see the results in the browser.

If you make a change in the `@refinedev/antd` package, you will see that right after the compilation, the `base-antd` example will re-compile and you will see the changes in the browser.

<details>

<summary>How to add a dependency to a package?</summary>

Navigate to the folder and run the following command:

```sh title="Terminal"
cd packages/core
pnpm add my-new-dep
```

</details>

### Running Tests

Just like the `dev` command, we can use the `test` command to run tests for the packages and examples we're working on.

```sh title="Terminal"
pnpm test -- --scope @refinedev/antd
```

:::simple Good to know

- Refine uses [Jest](https://jestjs.io/) as the test runner and [@testing-library/react](https://testing-library.com/docs/react-testing-library/intro/) for testing React components. For E2E tests, we're using [Cypress](https://www.cypress.io).
- We're expecting to see proper tests for each feature/bugfix you make. If you're not sure how to write tests for your feature/bugfix, please ask for help in our [community room](https://discord.gg/refine).

:::

## Working on Documentation

Refine documentation is built with [Docusaurus](https://docusaurus.io/). Documentation is handled separately from Lerna, so you need to install the dependencies and start the documentation separately.

```sh title="Terminal"
cd documentation
pnpm install
pnpm dev:docs
```

:::simple Documentation Scripts

- You can also use `pnpm dev:blog` to start the blog section of the documentation.

- `dev:docs` and `dev:blog` scripts start a portion of the documentation and skips the unnecessary parts to speed up the development process such as type and props table generation, checklist generation, etc. If you want to start the documentation with all the features, you can use `pnpm dev` command.

- To create a production build of the documentation, you can use `pnpm build` command. Then, you can use `pnpm serve` command to serve the production build in your local machine.

:::

### Creating Previews and Code Samples

We're using [Codesandbox's Sandpack](https://sandpack.codesandbox.io) to provide live previews and code editors in our documentation. We've created a custom `<Sandpack />` component to make it easier to use with Refine and provided some predefined configurations for the most common use cases.

Check out the example usage of `<Sandpack />` in Core API's `useForm` hook documentation:

- [useForm Documentation](/docs/data/hooks/use-form/#usage)
- [Source Code for Sandpack](https://github.com/refinedev/refine/blob/main/documentation/docs/data/hooks/use-form/basic-usage.tsx)
- [Source Code for Markdown](https://github.com/refinedev/refine/blob/main/documentation/docs/data/hooks/use-form/index.md)

## Committing Your Work and Preparing a Pull Request

Refine is a monorepo with multiple packages and examples. To make sure we're keeping things clean and in order, we're using couple of tools to enforce a good development experience.

### Linting & Formatting

We are using [biome](https://biomejs.dev) for linting & formatting across the repository.

We suggest using [biome VSCode extension](https://biomejs.dev/reference/vscode/) to handle linting & formatting on your local environment to avoid unexpected failures on CI.

Since biome doesn't have markdown support yet, we are using prettier to format markdown files.

### Commit Convention

Commit messages are essential to keep everything clear in our development process. We use [conventional commits](https://www.conventionalcommits.org/en/v1.0.0/) to keep our commit messages consistent and easy to understand.

We're expecting to see proper commit messages with the following format:

```
<type>(optional scope): <description>
```

An example commit message:

```
feat(core): add useAwesome hook
```

:::simple Good to know

We're using [commitlint](https://commitlint.js.org/) to enforce conventional commits. If you don't follow the conventional commit format, you will see an error message when you try to commit your changes or a Github action will fail when you create a pull request.

:::

### Creating a Changeset

To manage our releases, changelogs and versioning, we're using [Changesets](https://github.com/changesets/changesets) and [Changesets GitHub Action](https://github.com/changesets/action) to automate the process. Changesets are designed to make your workflows easier, by allowing the person making contributions to make key decisions when they are making their contribution. Changesets hold two key bits of information: a version type (following semver), and change information to be added to a changelog.

Follow the steps below to create a changeset:

```sh
pnpm changeset
```

After you run this command, you will be asked couple of questions:

- Select the package(s) you are modifying
- Choose one of `major/patch/minor` according to your change
- Add explanation about the changes

After you answer these questions, a changeset file will be created under `.changeset` directory. You can commit this file with your changes.

:::simple Good to know

- We're expecting a changeset to include a description about the changes you've made and how it affects the users. Please make sure you provide a good description for your changeset.
- It's required for a changeset to provide a link to the issue that is related with. If you don't have an issue for your changes, please create one and link it to your changeset.
- You'll be able to edit your changeset after you create it. If you need to make changes to your changeset, you can edit it under `.changeset` directory.

:::

Check out the following examples to see how changesets should be formatted:

```md title=".changeset/some-changeset.md"
---
"@refinedev/core": minor
---

feat: added x feature #ISSUE_ID

Now with x feature, you can do y.

Resolves #1234
```

or

```md title=".changeset/some-other-changeset.md"
---
"@refinedev/mantine": patch
---

fix: issue with x. #ISSUE_ID

We had an edge where it causes x issue to happen, now it's fixed.

Fixes #5678
```

### Creating a Pull Request

After you commit your changes and create a changeset, you can push your changes to your fork and [create a pull request](https://github.com/refinedev/refine/compare). When you create a pull request, you will see a Github action that will run the tests and check if your changeset is valid. Our maintainers will review your changes in short time and merge your pull request if everything is good.

Our Pull Request template is designed to make sure you provide all the necessary information about your changes. Please make sure you fill the template with the required information.

We're looking forward to see your contributions! 🎉

## Release Cycle

Refine follows a monthly release cycle. We're releasing a new version every month with the changes we've made in that month. Unless there's a critical bugfix, we're not releasing a new version in the middle of the month. If your PR is approved and ready to be merged, it will be labeled as `pr-ready` and will be merged to the `main` branch with the next release.

Each approved PR will be included to a milestone, these milestones are used to track the progress of the monthly release.

================
File: guides-concepts/data-fetching/authentication.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function Authentication() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        axios: "^1.6.2",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          hidden: false,
          active: true,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: false,
        },
        "/auth-provider.ts": {
          code: AuthProviderCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { HomePage } from "./home-page.tsx";
import { dataProvider } from "./data-provider.ts";
import { authProvider } from "./auth-provider.ts";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine
            dataProvider={dataProvider(API_URL)}
            authProvider={authProvider(API_URL)}
        >
            <HomePage />
        </Refine>
    );
}
`.trim();
const AuthProviderCode = `
import React from "react";
import { AuthProvider } from "@refinedev/core";
export const authProvider = (url: string): AuthProvider => ({
    login: async ({ email, password }) => {
        // To keep the example short and simple,
        // we didn't send a request, and we save the token in localStorage.
        localStorage.setItem("token", JSON.stringify({ email, password }));
        return {
            success: true,
        };
    },
    check: async () => {
        const token = localStorage.getItem("token");
        return {
            authenticated: !!token,
            error: new Error("Unauthorized"),
        };
    },
    logout: async () => {
        localStorage.removeItem("token");
        return {
            success: true,
        };
    },
    onError: async () => {
        throw new Error("Not implemented");
    },
});
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
import axios from "axios";
const axiosInstance = axios.create();
// add token to every request
axiosInstance.interceptors.request.use(
    async (config) => {
        const token = localStorage.getItem("token");
        if (token && config?.headers) {
            config.headers.Authorization = \`Bearer \${token}\`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    },
);
export const dataProvider = (url: string): DataProvider => ({
    getList: async ({ resource }) => {
        const response = await axiosInstance.get(\`\${url}/$\{resource}\`);
        const data = response.data;
        return {
            data,
            total: data.length,
        };
    },
    getOne: async () => {
        throw new Error("Not implemented");
    },
    create: async () => {
        throw new Error("Not implemented");
    },
    update: async () => {
        throw new Error("Not implemented");
    },
    deleteOne: async () => {
        throw new Error("Not implemented");
    },
    getApiUrl: () => url,
});
`.trim();
const HomePageTsxCode = `
import React from "react";
import {
    BaseKey,
    Authenticated,
    useList,
    useLogin,
    useLogout,
} from "@refinedev/core";
export const HomePage = () => {
    const { data: animalsData, isLoading: isLoadingAnimals } =
        useList<IAnimals>({
            resource: "animals",
        });
    const animals = animalsData?.data;
    const { mutate: login, isLoading: isLoadingLogin } = useLogin();
    const { mutate: logout } = useLogout();
    const loading = isLoadingAnimals || isLoadingLogin;
    return (
        <Authenticated
            loading={loading}
            fallback={
                <div>
                    <h4>You are not authenticated</h4>
                    <button
                        disabled={isLoadingLogin}
                        onClick={() =>
                            login({
                                email: "refine@demo.com",
                                password: "refine",
                            })
                        }
                    >
                        Login
                    </button>
                </div>
            }
        >
            <div>
                <button onClick={() => logout()}>Logout</button>
                <h4>Animals</h4>
                <ul>
                    {animals?.map((animal) => (
                        <li key={animal.id}>
                            <p>Name: {animal.name}</p>
                        </li>
                    ))}
                </ul>
            </div>
        </Authenticated>
    );
};
interface IAnimals {
    id: BaseKey;
    name: string;
    type: string;
}
`.trim();

================
File: guides-concepts/data-fetching/data-provider-interface.md
================
```ts
import {
  DataProvider,
  HttpError,
  Pagination,
  CrudSorting,
  CrudFilters,
  CrudOperators,
} from "@refinedev/core";
import { stringify } from "query-string";
import axios, { AxiosInstance } from "axios";

type MethodTypes = "get" | "delete" | "head" | "options";
type MethodTypesWithBody = "post" | "put" | "patch";

const axiosInstance = axios.create();

export const dataProvider = (
  apiUrl: string,
  // get axios instance from user or use default one.
  httpClient: AxiosInstance = axiosInstance,
): DataProvider => ({
  getOne: async ({ resource, id, meta }) => {
    const url = `${apiUrl}/${resource}/${id}`;

    const { headers, method } = meta ?? {};
    const requestMethod = (method as MethodTypes) ?? "get";

    const { data } = await httpClient[requestMethod](url, { headers });

    return {
      data,
    };
  },

  update: async ({ resource, id, variables, meta }) => {
    const url = `${apiUrl}/${resource}/${id}`;

    const { headers, method } = meta ?? {};
    const requestMethod = (method as MethodTypesWithBody) ?? "patch";

    const { data } = await httpClient[requestMethod](url, variables, {
      headers,
    });

    return {
      data,
    };
  },

  create: async ({ resource, variables, meta }) => {
    const url = `${apiUrl}/${resource}`;

    const { headers, method } = meta ?? {};
    const requestMethod = (method as MethodTypesWithBody) ?? "post";

    const { data } = await httpClient[requestMethod](url, variables, {
      headers,
    });

    return {
      data,
    };
  },

  deleteOne: async ({ resource, id, variables, meta }) => {
    const url = `${apiUrl}/${resource}/${id}`;

    const { headers, method } = meta ?? {};
    const requestMethod = (method as MethodTypesWithBody) ?? "delete";

    const { data } = await httpClient[requestMethod](url, {
      data: variables,
      headers,
    });

    return {
      data,
    };
  },

  getList: async ({ resource, pagination, sorters, filters, meta }) => {
    const url = `${apiUrl}/${resource}`;

    const { headers: headersFromMeta, method } = meta ?? {};
    const requestMethod = (method as MethodTypes) ?? "get";

    // init query object for pagination and sorting
    const query: {
      _start?: number;
      _end?: number;
      _sort?: string;
      _order?: string;
    } = {};

    const generatedPagination = generatePagination(pagination);
    if (generatedPagination) {
      const { _start, _end } = generatedPagination;
      query._start = _start;
      query._end = _end;
    }

    const generatedSort = generateSort(sorters);
    if (generatedSort) {
      const { _sort, _order } = generatedSort;
      query._sort = _sort.join(",");
      query._order = _order.join(",");
    }

    const queryFilters = generateFilter(filters);

    const { data, headers } = await httpClient[requestMethod](
      `${url}?${stringify(query)}&${stringify(queryFilters)}`,
      {
        headers: headersFromMeta,
      },
    );

    const total = +headers["x-total-count"];

    return {
      data,
      total: total || data.length,
    };
  },

  getApiUrl: () => apiUrl,
});

// Convert axios errors to HttpError on every response.
axiosInstance.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    const customError: HttpError = {
      ...error,
      message: error.response?.data?.message,
      statusCode: error.response?.status,
    };

    return Promise.reject(customError);
  },
);

// convert Refine CrudOperators to the format that API accepts.
const mapOperator = (operator: CrudOperators): string => {
  switch (operator) {
    case "ne":
    case "gte":
    case "lte":
      return `_${operator}`;
    case "contains":
      return "_like";
    case "eq":
    default:
      return "";
  }
};

// generate query string from Refine CrudFilters to the format that API accepts.
const generateFilter = (filters?: CrudFilters) => {
  const queryFilters: { [key: string]: string } = {};

  if (filters) {
    filters.map((filter) => {
      if (filter.operator === "or" || filter.operator === "and") {
        throw new Error(
          `[@refinedev/simple-rest]: /docs/data/data-provider#creating-a-data-provider`,
        );
      }

      if ("field" in filter) {
        const { field, operator, value } = filter;

        if (field === "q") {
          queryFilters[field] = value;
          return;
        }

        const mappedOperator = mapOperator(operator);
        queryFilters[`${field}${mappedOperator}`] = value;
      }
    });
  }

  return queryFilters;
};

// generate query string from Refine CrudSorting to the format that API accepts.
const generateSort = (sorters?: CrudSorting) => {
  if (sorters && sorters.length > 0) {
    const _sort: string[] = [];
    const _order: string[] = [];

    sorters.map((item) => {
      _sort.push(item.field);
      _order.push(item.order);
    });

    return {
      _sort,
      _order,
    };
  }

  return;
};

// generate query string from Refine Pagination to the format that API accepts.
const generatePagination = (pagination?: Pagination) => {
  // pagination is optional on data hooks, so we need to set default values.
  const { current = 1, pageSize = 10, mode = "server" } = pagination ?? {};

  const query: {
    _start?: number;
    _end?: number;
  } = {};

  if (mode === "server") {
    query._start = (current - 1) * pageSize;
    query._end = current * pageSize;
  }

  return query;
};
```

================
File: guides-concepts/data-fetching/error-handling.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function ErrorHandling() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product.tsx": {
          code: ProductTsxCode,
          hidden: false,
          active: true,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { Product } from "./product.tsx";
import { dataProvider } from "./data-provider.ts";
export default function App() {
    return (
            <Refine
                dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            >
                <Product />
            </Refine>
    );
}
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
  getOne: async ({ id, resource }) => {
    const response = await fetch(\`\${url}/\${resource}/\${id}\`);
      const data = await response.json();
      if (!response.ok || !data) {
        const error: HttpError = {
            message: "Something went wrong while fetching data",
            statusCode: 404,
        };
        return Promise.reject(error);
      }
      return {
          data,
      };
  },
  create: async () => {
      throw new Error("Not implemented");
  },
  update: async () => {
      throw new Error("Not implemented");
  },
  deleteOne: async () => {
      throw new Error("Not implemented");
  },
  getList: async () => {
      throw new Error("Not implemented");
  },
  getApiUrl: () => url,
});
`.trim();
const ProductTsxCode = `
import React from "react";
import { useOne, BaseKey } from "@refinedev/core";
export const Product: React.FC = () => {
    const { data, error, isError, isLoading } = useOne<IProduct>({
        resource: "products",
        id: "non-existing-id", 
        queryOptions: {
            retry: 0,
        },
    });
    if (isError) {
        return (
            <div>
                <h1>Error</h1>
                <p>{error.message}</p>
            </div>
        );
    }
    if (isLoading) {
        return <div>Loading...</div>;
    }
    const product = data?.data;
    return (
        <div>
            <h4>{product?.name}</h4>
            <p>Material: {product?.material}</p>
            <p>Price {product?.price}</p>
        </div>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
    price: string;
}
`.trim();

================
File: guides-concepts/data-fetching/index.md
================
---
title: Data Fetching
---

import UseOne from "./use-one";
import UseUpdate from "./use-update";
import UseList from "./use-list";
import UseListWithFilters from "./use-list-with-filters";
import MultipleDataProvider from "./multiple-data-provider";
import Authentication from "./authentication";
import OneToOne from "./one-to-one";
import OneToMany from "./one-to-many";
import ErrorHandling from "./error-handling";
import SupportedDataProviders from "@site/src/partials/data-provider/supported-data-providers.md";
import DataHooks from "@site/src/partials/data-provider/data-hooks.md";
import DataProviderInterface from "./data-provider-interface.md";

Data is essential for any UI Application and these applications are a bridge between users and the underlying data source(s), making it possible for users to interact with data in a meaningful way.

To manage data, Refine needs a `data provider`, which is a function that implements the [`DataProvider`](/docs/core/interface-references#dataprovider) interface. It is responsible for communicating with your API and making data available to Refine applications. While you can use one of our built-in data providers, you can also easily create your own data provider matching your API.

Refine passes relevant parameters like `resource` name, or the `id` of the record to your data provider, so data provider can make API calls to appropriate endpoints.

Once you provide `data provider` to Refine, you can utilize our data hooks (`useOne`, `useList`, `useUpdate`) to easily manage your data from various sources, including REST, GraphQL, RPC, and SOAP.

Moreover, Refine offers support for multiple data providers, allowing you to use different data providers for different resources. For instance, you can use **REST** for the `posts` endpoint and **GraphQL** for the `users` query.

<Image src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/providers/data-provider/api-consuming-flow.png" />

## Fetching Data

Imagine we want to fetch a record with the ID `123` from the `products` endpoint. For this, we will use the `useOne` hook. Under the hood, it calls the `dataProvider.getOne` method from your data provider.

<UseOne />

## Updating Data

Now, let's update the record with the ID `124` from `products` endpoint. To do this, we can use `useUpdate` hook, which calls `dataProvider.update` method under the hood.

In this example, we are updating product's price with a random value.

<UseUpdate />

Refine offers various data hooks for CRUD operations, you can see the list of these hooks below:

<DataHooks />

## How Refine treats data and state?

Data hooks uses [TanStack Query](https://tanstack.com/query) under the hood. It takes care of managing the state for you. It provides `data`, `isLoading`, and `error` states to help you handle loading, success, and error scenarios gracefully.

Refine treats data and state in a structured and efficient manner, providing developers with powerful tools to manage data seamlessly within their applications. Here are some key aspects of how Refine treats data and state:

1. **Resource-Based Approach:** Organizes data around resources, which are essentially models representing different data entities or API endpoints. These resources help structure your application's data management.

2. **Invalidation:** Automatically invalidates data after a successful mutation (e.g., creating, updating, or deleting a resource), ensuring that the UI is updated with the latest data.

3. **Caching:** Caches data to improve performance and deduplicates API calls.

4. **Optimistic Updates:** Supports optimistic updates, which means it will update the UI optimistically before the actual API call is complete. This enhances the user experience by reducing perceived latency.

5. **Hooks for CRUD Operations:** Offers a collection of hooks that align with common data operations like listing, creating, updating, and deleting data (`useList`, `useCreate`, `useUpdate`, `useDelete`). In addition to these basic hooks, Refine provides advanced hooks that are a composition of these fundamental ones for handling more complex tasks (`useForm`, `useTable`, `useSelect`).

6. **Integration with UI Libraries:** Works seamlessly with popular UI libraries. It provides a structured approach to represent data within these libraries.

7. **Realtime Updates**: Allowing your application to reflect changes in data as they occur.

## Meta usage <GuideBadge id="guides-concepts/general-concepts#meta" />

[`meta`][meta] is a special property that can be used to pass additional information to your data provider methods through data hooks like `useOne`, `useList`, `useForm` from anywhere across your application.

The capabilities of `meta` properties depend on your data provider's implementation. While some may use additional features through `meta`, others may not use them or follow a different approach.

Here are some examples of `meta` usage:

- Passing additional headers or parameters to the request.
- Generate GraphQL queries.
- Multi-tenancy support (passing the tenant id to the request).

In the example below, we are passing `meta.foo` property to the `useOne` hook. Then, we are using this property to pass additional headers to the request.

```tsx
import { DataProvider, useOne } from "@refinedev/core";

useOne({
    resource: "products",
    id: 1,
    meta: {
        foo: "bar",
    },
});

export const dataProvider = (apiUrl: string): DataProvider => ({
    getOne: async ({ resource, id, meta }) => {
        const response = await fetch(`${apiUrl}/${resource}/${id}`, {
            headers: {
                "x-foo": meta.foo,
            },
        });

        const data = await response.json();

        return {
            data,
        };
    },
    ...
});
```

## GraphQL

Refine's `meta` property has `gqlQuery` and `gqlMutation` fields, which accepts **GraphQL** operation as `graphql`'s [`DocumentNode`](https://graphql.org/graphql-js/type/#documentnode) type.

You can use these fields to pass **GraphQL** queries or mutations to your data provider methods through data hooks like `useOne`, `useList`, `useForm` from anywhere across your application.

Easiest way to generate GraphQL queries is to use [graphql-tag](https://www.npmjs.com/package/graphql-tag) package.

```tsx
import gql from "graphql-tag";
import { useOne, useUpdate } from "@refinedev/core";

const GET_PRODUCT_QUERY = gql`
  query GetProduct($id: ID!) {
    product(id: $id) {
      id
      title
      category {
        title
      }
    }
  }
`;

useOne({
  resource: "products",
  id: 1,
  meta: {
    gqlQuery: GET_PRODUCT_QUERY,
  },
});

const UPDATE_PRODUCT_MUTATION = gql`
  mutation UpdateOneProduct($id: ID!, $input: UpdateOneProductInput!) {
    updateOneProduct(id: $id, input: $input) {
      id
      title
      category {
        title
      }
    }
  }
`;

const { mutate } = useUpdate();

mutate({
  resource: "products",
  id: 1,
  values: {
    title: "New Title",
  },
  meta: {
    gqlMutation: UPDATE_PRODUCT_MUTATION,
  },
});
```

:::simple

**Nest.js Query** data provider implements full support for `gqlQuery` and `gqlMutation` fields.

See [Nest.js Query Docs](/docs/data/packages/nestjs-query) for more information.

:::

Also, you can check Refine's built-in [GraphQL data providers](#supported-data-providers) to handle communication with your GraphQL APIs or use them as a starting point.

## Multiple Data Providers

Using multiple data providers in Refine allows you to work with various APIs or data sources in a single application. You might use different data providers for different parts of your app.

Each data provider can have its own configuration, making it easier to manage complex data scenarios within a single application.
This flexibility is handy when dealing with various data structures and APIs.

For example, we want to fetch:

- `products` from `https://api.finefoods.refine.dev`
- `user` from `https://api.fake-rest.refine.dev`.

As you can see the example below:

- We are defining multiple data providers in `App.tsx`.
- Using `dataProviderName` field to specify which data provider to use in data hooks in `home-page.tsx`.

<MultipleDataProvider />

## Handling errors

Refine expects errors to be extended from [HttpError](/docs/core/interface-references#httperror). We believe that having consistent error interface makes it easier to handle errors coming from your API.

When implemented correctly, Refine offers several advantages in error handling:

- **Notification**: If you have [`notificationProvider` ](/docs/notification/notification-provider), Refine will automatically show a notification when an error occurs.
- **Server-Side Validation**: Shows [errors coming from the API](/docs/advanced-tutorials/forms/server-side-form-validation/) on the corresponding form fields.
- **Optimistic Updates**: Instantly update UI when you send a mutation and automatically revert the changes if an error occurs during the mutation.

<ErrorHandling />

## Listing Data

Imagine we need to fetch a list of records from the `products` endpoint. For this, we can use [`useList`][use-list] or [`useInfiniteList`][use-infinite-list] hooks. It calls `dataProvider.getList` method from your data provider, returns `data` and `total` fields from the response.

<UseList />

### Filters, Sorters and Pagination

We fetched all the products from the `products` endpoint in the previous example. But in real world, we usually need to fetch a subset of the data.

Refine provides a unified [`filters`][crud-filters], [`sorters`][crud-sorting], and [`pagination`][pagination] parameters in data hooks to pass your `data provider` methods, making it possible to fetch the data you need with any complexity. It's data provider's responsibility to handle these parameters and modify the request sent to your API.

Now let's make it more realistic example by adding filters, sorters, and pagination.

We want to:

- Fetch 5 products
- With `material` field equals to `wooden`
- Sorted by `ID` field in `descending` order

For this purpose, we can pass additional parameters to `useList` hook like [`filters`][crud-filters], [`sorters`][crud-sorting], and [`pagination`][pagination].

`useList` calls the `dataProvider.getList` method under the hood with the given parameters. We will use these parameters modify our request sent to our API.

<UseListWithFilters />

While the example above is simple, it's also possible to build more complex queries with [`filters`][crud-filters] and [`sorters`][crud-sorting].

For instance, we can fetch products:

- With wooden material
- Belongs to category ID 45
- **OR** have a price between 1000 and 2000.

```tsx
import { DataProvider, useList } from "@refinedev/core";

useList({
  resource: "products",
  pagination: {
    current: 1,
    pageSize: 10,
  },
  filters: [
    {
      operator: "and",
      value: [
        { field: "material", operator: "eq", value: "wooden" },
        { field: "category.id", operator: "eq", value: 45 },
      ],
    },
    {
      operator: "or",
      value: [
        { field: "price", operator: "gte", value: 1000 },
        { field: "price", operator: "lte", value: 2000 },
      ],
    },
  ],
});
```

## Relationships

Refine handles data relations with data hooks(eg: `useOne`, `useMany`, etc.). This compositional design allows you to flexibly and efficiently manage data relationships to suit your specific requirements.

### One-to-One

In a one-to-one relationship, each thing matches with just one other thing. It's like a unique partnership.

For instance, a product can have only one product detail.

<!-- prettier-ignore-start -->
```md
┌──────────────┐       ┌────────────────┐
│ Products     │       │ ProductDetail  │
│--------------│       │----------------│
│ id           │───────│ id             │
│ name         │       │ weight         │
│ price        │       │ dimensions     │
│ description  │       │ productId      │
│ detail       │       │                │
│              │       │                │
└──────────────┘       └────────────────┘
```
<!-- prettier-ignore-end -->

We can use the `useOne` hook to fetch the detail of a product.

<OneToOne />

### One-to-Many

In a one-to-many relationship, each resource matches with many other resource. It's like a parent with many children.

For instance, a products can have many reviews.

<!-- prettier-ignore-start -->

```md
┌──────────────┐       ┌────────────────┐
│ Products     │       │ Reviews        │
│--------------│       │----------------│
│ id           │───┐   │ id             │
│ name         │   │   │ rating         │
│ price        │   │   │ comment        │
│ description  │   │   │ user           │
│ detail       │   └───│ product        │
│              │       │                │
└──────────────┘       └────────────────┘
```
<!-- prettier-ignore-end -->

We can use the `useList` hook and filter by the product ID to fetch the reviews of a product.

<OneToMany />

### Many-to-Many

In a many-to-many relationship, each resource matches with many other resources, and each of those resources matches with many other resources.

For instance, products can have many categories, and categories can have many products.

<!-- prettier-ignore-start -->
```md
┌──────────────┐       ┌───────────────────┐       ┌──────────────┐
│ Products     │       │ ProductCategories │       │ Categories   │
│--------------│       │----------------───│       │--------------│
│ id           │───┐   │ id                │   ┌───│ id           │
│ name         │   └───│ productId         │   │   │ name         │
│ price        │       │ categoryId        │───┘   │ description  │
│ description  │       │                   │       │              │
│ detail       │       │                   │       │              │
│              │       │                   │       │              │
└──────────────┘       └───────────────────┘       └──────────────┘

```
<!-- prettier-ignore-end -->

In this case, we can use the `useMany` hook to fetch the categories of a product and the `useMany` hook to fetch the products of a category.

```tsx
import { DataProvider, useMany } from "@refinedev/core";

const { data: productCategories } = useList({
  resource: "productCategories",
});

const { data: products } = useMany({
  resource: "products",
  ids: productCategories.map((productCategory) => productCategory.productId),
  queryOptions: {
    enabled: productCategories.length > 0,
  },
});

const { data: categories } = useMany({
  resource: "categories",
  ids: productCategories.map((productCategory) => productCategory.categoryId),
  queryOptions: {
    enabled: productCategories.length > 0,
  },
});
```

## Authentication <GuideBadge id="guides-concepts/authentication/" />

Imagine you want to fetch a data from a protected API. To do this, you will first need to obtain your authentication token and you will need to send this token with every request.

In Refine we handle [authentication](/docs/guides-concepts/authentication/) with [Auth Provider](/docs/authentication/auth-provider/). To get token from the API, we will use the `authProvider.login` method. Then, we will use [`<Authenticated />`](/docs/authentication/components/authenticated) component to to render the appropriate components.

After obtaining the token, we'll use Axios interceptors to include the token in the headers of all requests.

<Authentication />

## TanStack Query `QueryClient`

To modify the [`QueryClient`](https://tanstack.com/query/v4/docs/reference/QueryClient) instance, you can use the `reactQuery` prop of the [`<Refine />`](/docs/core/refine-component) component.

## `dataProvider` interface

To better understand the data provider interface, we have created an example that demonstrates how the required methods are implemented. For more comprehensive and diverse examples, you can refer to the [supported data providers](#supported-data-providers) section.

> In this example, we implemented data provider to support [JSON placeholder API](https://jsonplaceholder.typicode.com/).

<DataProviderInterface />

[To learn more about the `dataProvider` interface, check out the reference page.](/docs/data/data-provider)

## Supported data providers

<SupportedDataProviders/>

## Data hooks

<DataHooks />

[basekey]: /docs/core/interface-references#basekey
[create-a-data-provider]: /docs/data/data-provider
[swizzle-a-data-provider]: /docs/packages/cli#swizzle
[data-provider-tutorial]: /docs/data/data-provider
[use-api-url]: /docs/data/hooks/use-api-url
[use-create]: /docs/data/hooks/use-create
[use-create-many]: /docs/data/hooks/use-create
[use-custom]: /docs/data/hooks/use-custom
[use-delete]: /docs/data/hooks/use-delete
[use-delete-many]: /docs/data/hooks/use-delete
[use-list]: /docs/data/hooks/use-list
[use-infinite-list]: /docs/data/hooks/use-infinite-list
[use-many]: /docs/data/hooks/use-many
[use-one]: /docs/data/hooks/use-one
[use-update]: /docs/data/hooks/use-update
[use-update-many]: /docs/data/hooks/use-update
[crud-sorting]: /docs/core/interface-references#crudsorting
[crud-filters]: /docs/core/interface-references#crudfilters
[pagination]: /docs/core/interface-references#pagination
[http-error]: /docs/core/interface-references#httperror
[meta-data]: /docs/core/interface-references#metaquery
[meta]: /docs/core/interface-references#metaquery
[use-login]: /docs/authentication/hooks/use-login
[use-register]: /docs/authentication/hooks/use-register

================
File: guides-concepts/data-fetching/multiple-data-provider.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function MultipleDataProvider() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          hidden: false,
          active: true,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { HomePage } from "./home-page.tsx";
import { dataProvider } from "./data-provider.ts";
const API_URL = "https://api.fake-rest.refine.dev";
const FINE_FOODS_API_URL = "https://api.finefoods.refine.dev";
export default function App() {
    return (
        <Refine
            dataProvider={{
                default: dataProvider(API_URL),
                fineFoods: dataProvider(FINE_FOODS_API_URL),
            }}
        >
            <HomePage />
        </Refine>
    );
}
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
  getOne: async ({ id, resource }) => {
    const response = await fetch(\`\${url}/\${resource}/\${id}\`);
      const data = await response.json();
      return {
          data,
      };
  },
  create: async () => {
      throw new Error("Not implemented");
  },
  update: async () => {
      throw new Error("Not implemented");
  },
  deleteOne: async () => {
      throw new Error("Not implemented");
  },
  getList: async () => {
      throw new Error("Not implemented");
  },
  getApiUrl: () => url,
});
`.trim();
const HomePageTsxCode = `
import { useOne } from "@refinedev/core";
export const HomePage = () => {
    const { data: product, isLoading: isLoadingProduct } = useOne<IProduct>({
        resource: "products",
        id: 123,
        dataProviderName: "default",
    });
    const { data: user, isLoading: isLoadingUser } = useOne<IUser>({
        resource: "users",
        id: 123,
        dataProviderName: "fineFoods",
    });
    if (isLoadingProduct || isLoadingUser) return <div>Loading...</div>;
    return (
        <div>
            <h2>Product</h2>
            <h4>{product?.data?.name}</h4>
            <p>Material: {product?.data?.material}</p>
            <p>Price {product?.data?.price}</p>
            <br />
            <h2>User</h2>
            <h4>
                {user?.data?.firstName} {user?.data?.lastName}
            </h4>
            <p>Phone: {user?.data?.gsm}</p>
        </div>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
    price: string;
}
interface IUser {
    id: BaseKey;
    firstName: string;
    lastName: string;
    gsm: string;
}
`.trim();

================
File: guides-concepts/data-fetching/one-to-many.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function OneToMany() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product.tsx": {
          code: ProductTsxCode,
          hidden: false,
          active: true,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { Product } from "./product.tsx";
import { dataProvider } from "./data-provider.ts";
export default function App() {
    return (
            <Refine
                   dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            >
                <Product />
            </Refine>
    );
}
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
  getOne: async ({ id, resource }) => {
    const response = await fetch(\`\${url}/\${resource}/\${id}\`);
      const data = await response.json();
      return {
          data,
      };
  },
  getList: async ({ resource, filters }) => {
    // We simplified query string generation to keep the example application short and straightforward.
    // For more detailed and complex implementation examples, you can refer to the source code of the data provider packages.
    // https://github.com/refinedev/refine/blob/main/packages/simple-rest/src/provider.ts
    // we know that we only have one filter in this example.
    const filter = filters?.[0];
    const params = [];
    if (filter && "field" in filter) {
        params.push(\`\${filter.field}=\${filter.value}\`);
    }
    // combine all params with "&" character to create query string.
    const query = params.join("&");
    const response = await fetch(\`\${url}/\${resource}?\${query}\`);
    const data = await response.json();
    return {
        data,
        total: data.length,
    };
  },
  getMany: async ({ ids, resource }) => {
    throw new Error("Not implemented");
  },
  create: async () => {
      throw new Error("Not implemented");
  },
  update: async () => {
      throw new Error("Not implemented");
  },
  deleteOne: async () => {
      throw new Error("Not implemented");
  },
  getApiUrl: () => url,
});
`.trim();
const ProductTsxCode = `
import React from "react";
import { useOne, useList, BaseKey } from "@refinedev/core";
export const Product: React.FC = () => {
    const { data: productData, isLoading: productLoading } = useOne<IProduct>({
        resource: "products",
        id: 123,
    });
    const product = productData?.data;
    const { data: reviewsData, isLoading: reviewsLoading } =
        useList<IProductReview>({
            resource: "product-reviews",
            filters: [{ field: "product.id", operator: "eq", value: product?.id }],
            queryOptions: {
                enabled: !!product,
            },
        });
    const rewiews = reviewsData?.data;
    const loading = productLoading || reviewsLoading;
    if (loading) {
        return <div>Loading...</div>;
    }
    return (
        <div>
            <h4>{product?.name}</h4>
            <p>Material: {product?.material}</p>
            <p>Price {product?.price}</p>
            <h5>Reviews</h5>
            <ul>
                {rewiews?.map((review) => (
                    <li key={review.id}>
                        <p>Rating: {review.rating}</p>
                        <p>{review.comment}</p>
                    </li>
                ))}
            </ul>
        </div>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
    price: string;
    description: string;
}
interface IProductReview {
    id: BaseKey;
    rating: number;
    comment: string;
    product: {
        id: BaseKey;
    }
    user: {
        id: BaseKey;
    }
}
`.trim();

================
File: guides-concepts/data-fetching/one-to-one.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function OneToOne() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product.tsx": {
          code: ProductTsxCode,
          hidden: false,
          active: true,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { Product } from "./product.tsx";
import { dataProvider } from "./data-provider.ts";
export default function App() {
    return (
            <Refine
                dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            >
                <Product />
            </Refine>
    );
}
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
  getOne: async ({ id, resource }) => {
    const response = await fetch(\`\${url}/\${resource}/\${id}\`);
      const data = await response.json();
      return {
          data,
      };
  },
  create: async () => {
      throw new Error("Not implemented");
  },
  update: async () => {
      throw new Error("Not implemented");
  },
  deleteOne: async () => {
      throw new Error("Not implemented");
  },
  getList: async () => {
      throw new Error("Not implemented");
  },
  getApiUrl: () => url,
});
`.trim();
const ProductTsxCode = `
import React from "react";
import { useOne, BaseKey } from "@refinedev/core";
export const Product: React.FC = () => {
    const { data: productData, isLoading: productLoading } = useOne<IProduct>({
        resource: "products",
        id: 123,
    });
    const product = productData?.data;
    const { data: productDetailData, isLoading: productDetailLoading }  = useOne<IProductDetail>({
        resource: "product-detail",
        id: product?.id,
        queryOptions: {
            enabled: !!product,
        },
    });
    const productDetail = productDetailData?.data;
    loading = productLoading || productDetailLoading;
    if (loading) {
        return <div>Loading...</div>;
    }
    return (
        <div>
            <h4>{product?.name}</h4>
            <p>Material: {product?.material}</p>
            <p>Price {product?.price}</p>
            <p>Weight: {productDetail?.weight}</p>
            <p>Dimensions: {productDetail?.dimensions?.width} x {productDetail?.dimensions?.height} x {productDetail?.dimensions?.depth}</p>
        </div>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
    price: string;
    description: string;
}
interface IProductDetail {
    id: BaseKey;
    weight: number;
    dimensions: {
        width: number;
        height: number;
        depth: number;
    };
}
`.trim();

================
File: guides-concepts/data-fetching/use-list-with-filters.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function UseListWithFilters() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          hidden: false,
          active: true,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { HomePage } from "./home-page.tsx";
import { dataProvider } from "./data-provider.ts";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine dataProvider={dataProvider(API_URL)}>
            <HomePage />
        </Refine>
    );
}
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
    getList: async ({ resource, filters, pagination, sorters }) => {
        // We simplified query string generation to keep the example application short and straightforward.
        // For more detailed and complex implementation examples, you can refer to the source code of the data provider packages.
        // https://github.com/refinedev/refine/blob/main/packages/simple-rest/src/provider.ts
        // we know that we only have one filter and one sorter in this example.
        const filter = filters?.[0];
        const sorter = sorters?.[0];
        const params = [];
        if (filter && "field" in filter) {
            params.push(\`\${filter.field}=\${filter.value}\`);
        }
        if (sorter && "field" in sorter) {
            params.push(\`_sort=\${sorter.field}\`);
            params.push(\`_order=\${sorter.order}\`);
        }
        // pagination is optional, so we need give default values if it is undefined.
        const { current = 1, pageSize = 10 } = pagination ?? {};
        params.push(\`_start=\${(current - 1) * pageSize}\`);
        params.push(\`_end=\${current * pageSize}\`);
        // combine all params with "&" character to create query string.
        const query = params.join("&");
        const response = await fetch(\`\${url}/\${resource}?\${query}\`);
        const data = await response.json();
        return {
            data,
            total: data.length,
        };
    },
    getOne: async () => {
        throw new Error("Not implemented");
    },
    getMany: async () => {
        throw new Error("Not implemented");
    },
    create: async () => {
        throw new Error("Not implemented");
    },
    update: async () => {
        throw new Error("Not implemented");
    },
    deleteOne: async () => {
        throw new Error("Not implemented");
    },
    getApiUrl: () => url,
});
`.trim();
const HomePageTsxCode = `
import { useList } from "@refinedev/core";
export const HomePage = () => {
    const { data: products } = useList({
        resource: "products",
        pagination: { current: 1, pageSize: 5 },
        sorters: [{ field: "id", order: "DESC" }],
        filters: [{ field: "material", operator: "eq", value: "Wooden" }],
    });
    return (
        <div>
            <h2>Wooden Products</h2>
            <ul>
                {products?.data?.map((product) => (
                    <li key={product.id}>
                       <p>
                            {product.id}
                            <br />
                            {product.name}
                            <br />
                            Price: {product.price}
                            <br />
                            Material: {product.material}
                       </p>
                    </li>
                ))}
            </ul>
        </div>
    );
};
interface IProducts {
    id: BaseKey;
    name: string;
    material: string;
    price: string;
}
`.trim();

================
File: guides-concepts/data-fetching/use-list.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function UseList() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          hidden: false,
          active: true,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { HomePage } from "./home-page.tsx";
import { dataProvider } from "./data-provider.ts";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine dataProvider={dataProvider(API_URL)}>
            <HomePage />
        </Refine>
    );
}
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
    getList: async ({ resource }) => {
        const response = await fetch(\`\${url}/\${resource}\`);
        const data = await response.json();
        return {
            data,
            total: data.length,
        };
    },
    getOne: async () => {
        throw new Error("Not implemented");
    },
    getMany: async () => {
        throw new Error("Not implemented");
    },
    create: async () => {
        throw new Error("Not implemented");
    },
    update: async () => {
        throw new Error("Not implemented");
    },
    deleteOne: async () => {
        throw new Error("Not implemented");
    },
    getApiUrl: () => url,
});
`.trim();
const HomePageTsxCode = `
import { useList } from "@refinedev/core";
export const HomePage = () => {
    const { data: products } = useList({
        resource: "products",
    });
    return (
        <div>
            <h2>Products</h2>
            <p> Showing {products?.total} records in total. </p>
            <ul>
                {products?.data?.map((product) => (
                    <li key={product.id}>
                        <p>
                            {product.name}
                            <br />
                            Price: {product.price}
                            <br />
                            Material: {product.material}
                        </p>
                    </li>
                ))}
            </ul>
        </div>
    );
};
interface IProducts {
    id: BaseKey;
    name: string;
    material: string;
    price: string;
}
`.trim();

================
File: guides-concepts/data-fetching/use-one.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function UseOne() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product.tsx": {
          code: ProductTsxCode,
          hidden: false,
          active: true,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { Product } from "./product.tsx";
import { dataProvider } from "./data-provider.ts";
export default function App() {
    return (
            <Refine
                dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            >
                <Product />
            </Refine>
    );
}
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
  getOne: async ({ id, resource }) => {
    const response = await fetch(\`\${url}/\${resource}/\${id}\`);
      const data = await response.json();
      return {
          data,
      };
  },
  create: async () => {
      throw new Error("Not implemented");
  },
  update: async () => {
      throw new Error("Not implemented");
  },
  deleteOne: async () => {
      throw new Error("Not implemented");
  },
  getList: async () => {
      throw new Error("Not implemented");
  },
  getApiUrl: () => url,
});
`.trim();
const ProductTsxCode = `
import React from "react";
import { useOne, BaseKey } from "@refinedev/core";
export const Product: React.FC = () => {
    const { data, error, isError, isLoading } = useOne<IProduct>({
        resource: "products",
        id: 123,
    });
    if (isError) <div>{error?.message}</div>;
    if (isLoading) <div>Loading...</div>;
    const product = data?.data;
    return (
        <div>
            <h4>{product?.name}</h4>
            <p>Material: {product?.material}</p>
            <p>Price {product?.price}</p>
        </div>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
    price: string;
}
`.trim();

================
File: guides-concepts/data-fetching/use-update.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function UseUpdate() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product.tsx": {
          code: ProductTsxCode,
          hidden: false,
          active: true,
        },
        "/data-provider.ts": {
          code: DataProviderCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import { Product } from "./product.tsx";
import { dataProvider } from "./data-provider.ts";
export default function App() {
    return (
            <Refine
                dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            >
                <Product />
            </Refine>
    );
}
`.trim();
const DataProviderCode = `
import React from "react";
import { DataProvider } from "@refinedev/core";
export const dataProvider = (url: string): DataProvider => ({
    getOne: async ({ id, resource }) => {
        const response = await fetch(\`\${url}/\${resource}/\${id}\`);
        const data = await response.json();
        return {
            data,
        };
    },
    update: async ({ resource, id, variables }) => {      
        console.log(variables, JSON.stringify(variables))
        const response = await fetch(\`\${url}/\${resource}/\${id}\`, {
            method: "PATCH",
            body: JSON.stringify(variables),
            headers: {
                "Content-Type": "application/json",
            },
        });
        const data = await response.json();
        return {
            data,
        };
    },
    create: async () => {
        throw new Error("Not implemented");
    },
    deleteOne: async () => {
        throw new Error("Not implemented");
    },
    getList: async () => {
        throw new Error("Not implemented");
    },
    getApiUrl: () => url,
});
`.trim();
const ProductTsxCode = `
import React from "react";
import { useOne, BaseKey, useUpdate } from "@refinedev/core";
export const Product: React.FC = () => {
    const { data, error, isError, isLoading, isFetching } = useOne<IProduct>({
        resource: "products",
        id: 124,
    });
    const { mutate, isLoading: isUpdating } = useUpdate();
    if (isError) {
        return (
            <div>
                <h1>Error</h1>
                <pre>{JSON.stringify(error)}</pre>
            </div>
        );
    }
    if (isLoading)  return <div>Loading...</div>;
    const incrementPrice = async () => {
        await mutate({
            resource: "products",
            id: 124,
            values: {
                price: Math.random() * 100,
            },
        });
    };
    const product = data?.data;
    return (
        <div>
            <h4>{product?.name}</h4>
            <p>Material: {product?.material}</p>
            <p>Price {product?.price}</p>
            <button onClick={incrementPrice} disabled={isUpdating || isFetching}>Update Price</button>
        </div>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
    price: string;
}
`.trim();

================
File: guides-concepts/deployment/index.md
================
---
title: Deployment
---

Refine being a meta-framework, it does not have a specific deployment configuration on its own.

Refine applications are usually built on top of the following frameworks, and you can follow their deployment guides to deploy your application.

- [Vite deployment guide](https://vitejs.dev/guide/static-deploy.html)
- [Next.js deployment guide](https://nextjs.org/docs/deployment)
- [Remix deployment guide](https://remix.run/docs/en/main/guides/deployment)

For convenience, we've created a [refinedev/Dockerfiles](https://github.com/refinedev/dockerfiles) GitHub repository that contains Dockerfiles for each of the frameworks above.

These Dockerfiles are derived from their respective official Dockerfile examples, using [refinedev/node](https://hub.docker.com/r/refinedev/node) as base image, which has a `non-root` `refine:nodejs` user.

The final stage is running the application as `non-root` `refine:nodejs` user for better **security** and only includes necessary production dependencies for smaller image size.

================
File: guides-concepts/development/index.md
================
---
title: Development
---

Refine offers improved developer experience by providing a set of tools to help you develop your application. These tools will help you from creating a new project to developing, customizing and debugging your application. This guide will introduce you to these tools and how to use them.

## Creating a New Project

Refine provides an app scaffolding tool which is available both as [browser-based](https://refine.dev/?playground=true) and as command-line interface. Both of the tools will provide you set of options to choose from to create your project.

:::simple Options

- The platform you want to use (Vite, Next.js or Remix)
- The UI library of your choice (Ant Design, Material UI, Chakra UI, Mantine or none)
- The data provider you want to use (REST, Supabase, Strapi, NestJS, Appwrite, Airtable and Hasura)
- The authentication provider you want to use (Google Auth, Keycloak, Auth0, Supabase, Appwrite, Strapi, Custom or none)

:::

To use the browser-based scaffolding tool, you can visit [refine.dev](https://refine.dev/?playground=true) and select the options you want to use for your project. After you are done with the options, you can click on the **Create Project** button to download your project.

To use the command-line interface, you can simply run the following command in your terminal:

<CreateRefineAppCommand args="my-refine-app" />

After running the command, you will be prompted to select the options you want to use for your project. After you are done with the options, the CLI will create your project in the `my-refine-app` directory.

<Image src="https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-07-25-refine-primereact/create-refine-project.gif" />

## Using CLI

Refine offers a command-line interface to help you with your app's development. The CLI provides a set of commands to help you with running your app, creating new resources and taking care of the boilerplate code for you, creating providers with templates to get you started to implement your own providers with ease, updating your app's dependencies easily, exporting components and providers from Refine packages to your app to let you customize them just like you would do with your own components and providers, and and get you notified about the announcements from the Refine team.

To learn more about the `@refinedev/cli` package, check out the [CLI documentation](/docs/packages/cli/).

### Installation

CLI will be included in the apps created with the scaffolders by default. If you want to use the CLI in your existing project, you can install it by running the following command in your terminal:

<Tabs>

<TabItem value="npm">

```bash
npm i @refinedev/cli
```

</TabItem>

<TabItem value="yarn">

```bash
yarn add @refinedev/cli
```

</TabItem>

<TabItem value="pnpm">

```bash
pnpm add @refinedev/cli
```

</TabItem>

</Tabs>

### Usage

After installing the CLI, its recommended to update your scripts and add `refine` command to your `package.json` file:

```json
{
  "scripts": {
    "refine": "refine"
  }
}
```

This command will help you use CLI command easily. You can run the following command to see the available commands:

```bash
npm run refine -- --help
```

It's recommended to use Refine's runners to run your development server. They will use the appropriate commands for your app's platform and also provide you with some additional features such as running the devtools (if installed) along with your app, checking for updates and notifying you about them, and notifying you about the announcements from the Refine team.

<Tabs>

<TabItem value="Vite">

```diff
{
    "scripts": {
-        "dev": "vite",
-        "build": "vite build",
-        "start": "vite preview"
    }
+        "dev": "refine dev",
+        "build": "refine build",
+        "start": "refine start"
    }
}
```

</TabItem>

<TabItem value="Next.js">

```diff
{
    "scripts": {
-        "dev": "next dev",
-        "build": "next build",
-        "start": "next start"
    }
+        "dev": "refine dev",
+        "build": "refine build",
+        "start": "refine start"
    }
}
```

</TabItem>

<TabItem value="Remix">

```diff
{
    "scripts": {
-        "dev": "remix dev",
-        "build": "remix build",
-        "start": "remix-serve build"
    }
+        "dev": "refine dev",
+        "build": "refine build",
+        "start": "refine start"
    }
}
```

</TabItem>

</Tabs>

### Using `swizzle`

This command allows you to export components and providers from Refine packages to your app to let you customize them just like you would do with your own components and providers.

<details>

<summary>Why is it called swizzling?</summary>

The term comes from Objective-C and Swift-UI: [method swizzling](https://pspdfkit.com/blog/2019/swizzling-in-swift/) is the process of changing the implementation of an existing selector (method).

For Refine, component swizzling means providing an alternative component that will be used instead of the default one.

You can think of it as [Monkey Patching](https://en.wikipedia.org/wiki/Monkey_patch) for React components, which allows you to change the default implementation. Gatsby has a similar feature called [theme shadowing](https://www.gatsbyjs.com/docs/how-to/plugins-and-themes/shadowing/).

**Thanks to the [Docusaurus](https://docusaurus.io) team for inspiring us for this feature.**

</details>

#### Do I need to use swizzle?

Refine packages provide data providers, UI frameworks, and components that make it easy to build a project. Most these are customizable and can be used as is. However, sometimes you may want to customize it as if you created it yourself. This is where swizzling comes in. Most of Refine packages provide a swizzle command that ejects the files to your project. You can then customize them as you wish.

:::simple Caution

- `swizzle` is a one-way operation. Once you swizzle a component or provider, you'll be responsible for keeping it up to date and fixing any issues that arise from the changes you've made.

- Exports of the packages will not be updated automatically. You will need to replace the default elements with the elements you have swizzled manually.

- You can always switch back to the default implementations by updating your imports.

:::

### Using `add`

This command will help you add new resources and providers to your app. It will take care of the boilerplate code for you and provide a good starting point for you to implement your own pages and providers.

```bash
npm run refine add <auth, live, data, access-control, notification, i18n, audit-log, resource>
```

:::simple Options

- `resource`: To create a new resource and its CRUD pages.
- `auth`: To create a new authentication provider.
- `live`: To create a new live provider.
- `data`: To create a new data provider.
- `access-control`: To create a new access control provider.
- `notification`: To create a new notification provider.
- `i18n`: To create a new i18n provider.
- `audit-log`: To create a new audit log provider.

:::

## Using Devtools

Refine provides a devtools package to help you with your app's development. Devtools will help you monitor your app's queries and mutations, inspect queries made by your components and update your dependencies with a single click.

:::simple Good to know

Devtools will only work in development mode. In production it will not be included in your app's bundle and will not have any effect on your app's performance.

:::

### Installation

To install devtools, you can use the following commands:

<Tabs>

<TabItem value="auto" label="Using CLI">

CLI has a command to install devtools and set it up for you:

```bash
npm run refine devtools init
```

</TabItem>

<TabItem value="manual" label="Manual">

```bash
npm i @refinedev/devtools
```

</TabItem>

</Tabs>

### Usage

The following steps is handled by the CLI command automatically. If you've used the CLI command to install devtools, you can skip this section.

To use devtools, you'll need to wrap your component with the `DevtoolsProvider` component and if you're going to show it in the UI, you can add `DevtoolsPanel` component inside your app.

```tsx
import { Refine } from "@refinedev/core";
import { DevtoolsPanel, DevtoolsProvider } from "@refinedev/devtools";

const App = () => {
  return (
    {/* highlight-start */}
    <DevtoolsProvider
      // If you're running devtools server on a different port or a domain, you can set the URL manually.
      // Note that, custom domains and ports are only available in the Enterprise Edition.
      // url="http://localhost:5001"
    >
    {/* highlight-end */}
      <Refine
      // ...
      >
        {/* ... */}
        {/* highlight-next-line */}
        <DevtoolsPanel />
      </Refine>
      {/* highlight-next-line */}
    </DevtoolsProvider>
  );
};
```

<Image src="https://refine.ams3.cdn.digitaloceanspaces.com/assets/devtools-demo.gif" />

**Running Devtools Server**

Devtools will boot up a server to operate both on your app and have control over your project's source code to provide you with the best experience. If you're using `@refinedev/cli`'s `refine dev` command, it will automatically start the devtools server for you if you have `@refinedev/devtools` installed.

If you want to start devtools server manually, you can use the following command:

```bash
refine devtools start
```

If you're running the devtools manually, you can disable the automatic start of the devtools server by passing `--devtools=false` flag to the `refine dev` command.

As an alternative, you can also install the `@refinedev/devtools-server` package and use `refine-devtools` command to start the server.

**Required Ports**

Devtools server will run on port `5001` by default. Devtools will serve HTTP and WebSocket connections on this port. If you want to change the port, you can set the `REFINE_DEVTOOLS_PORT` environment variable to the desired port number.

:::simple Enterprise Edition

Refine Devtools running on ports other than "5001" is only available in the Enterprise Edition. If you're using the Community Edition, Refine Devtools will not work if the port is changed. Checkout [Refine Devtools in Enterprise Edition](/docs/enterprise-edition/devtools) for more information.

:::

## Using Inferencer

`@refinedev/inferencer` is a package that provides a way to automatically generate views for resources based on the data structure. The aim is to reduce the amount of time spent on creating views for resources by generating the code automatically that can be customized easily.

:::simple Available UI Options

- Ant Design
- Material UI
- Chakra UI
- Mantine
- Headless

:::

### Installation

To install inferencer, you can use the following commands:

<Tabs>

<TabItem value="npm">

```bash
npm i @refinedev/inferencer
```

</TabItem>

<TabItem value="yarn">

```bash
yarn add @refinedev/inferencer
```

</TabItem>

<TabItem value="pnpm">

```bash
pnpm add @refinedev/inferencer
```

</TabItem>

</Tabs>

### Usage

Inferencer package provides components for each UI implementation with subpaths (eg: `@refinedev/inferencer/antd`) that is used to generate views dynamically by using the response of your data provider. You can use these components to generate views for your resources.

```tsx
import { AntdInferencer } from "@refinedev/inferencer/antd";

const PostList = () => {
  return <AntdInferencer resource="posts" action="list" />;
};
```

The generated views will be previewed in your app and a modal will be shown to you to copy the code.

:::simple Good to know

The code generated by the Inferencer may not cover all the cases for your app but it will provide you with a good starting point and reduce the amount of time you spend on development.

:::

## Documentation and Community

All the features of Refine and its packages are well documented and you can find the appropriate documentation for your needs. If you have any questions or need help with your app's development, you can join our [Discord](https://discord.gg/refine) server and ask your questions there. You can also join our [Discussions](https://github.com/refinedev/refine/discussions) page to discuss your ideas and questions with the community.

================
File: guides-concepts/faq/index.md
================
---
title: Frequently Asked Questions
sidebar_label: FAQ
---

## How can I change the form data before submitting it to the API?

You may need to modify the form data before it is sent to the API for various reasons. For example, you may want to add a field to the form data or change the value of a field before submitting it to the API. This can be achieved easily by Refine's `useForm` implementations.

Check out the [Modifying Data Before Submission section in Forms guide](/docs/guides-concepts/forms/#modifying-data-before-submission) to learn how to achieve this.

## How can I refetch data?

Refine automatically invalidates the affected resources after mutations. However, in some cases you may want to refetch manually.

<Tabs
defaultValue="refetch"
values={[
{label: 'React Query Refetch', value: 'refetch'},
{label: 'useInvalidate Hook', value: 'useinvalidate'},
]}>
<TabItem value="refetch">

```tsx
import { useTable, useForm, useShow } from "@refinedev/core";

// All "data" related hooks provided by Refine can use query' refetch function
const { tableQuery: { refetch } } = useTable();
const { tableQueryResult: { refetch } } = useTable();
const { query: { refetch } } = useForm();
...
...
const { query: { refetch } } = useShow();
...
...
```

</TabItem>
<TabItem value="useinvalidate">

```tsx
import { useInvalidate } from "@refinedev/core";

const invalidate = useInvalidate();

// To invalidate the list and many states of the Posts resource
invalidate({
  resource: "posts",
  invalidates: ["list", "many"],
});

// To invalidate the state of a Posts with an id of 1
invalidate({
  resource: "posts",
  invalidates: ["detail"],
  id: 1,
});

// To invalidate the list and many states of the Posts resource of the dataProvider named "second-data-provider"
invalidate({
  resource: "posts",
  dataProviderName: "second-data-provider",
  invalidates: ["list"],
});

// To invalidate all states of dataprovider named "second-data-provider"
invalidate({
  dataProviderName: "second-data-provider",
  invalidates: ["all"],
});
```

[Refer to the Refine useInvalidate hook documentation for more information. →](/docs/core/hooks/data/use-invalidate)

</TabItem>
</Tabs>

## How can I request an API with nested route?

Refine's way of doing this is with the `resource` property on all data hooks. You can think of the `resource` property as the URL.

For example, If you want to make a request of the URL `/user/1/posts`.

```tsx
import { useTable, useOne } from "@refinedev/core";

useTable({
  resource: "/users/1/posts",
});
```

## How can I ensure a query is only run after a certain variable is available and not on load?

Note that `data` related hooks (`useMany`, `useOne`, etc.) can also accept all `useQuery` options, which allows you to implement dependent queries whereby a query is only run after a certain data is available. This is particularly useful if you want `useMany` to only run after a certain data is available and not on load.

[Refer to react-query docs on **dependent queries** for more information → ](https://react-query.tanstack.com/guides/dependent-queries)

- Suppose you want this query to run after `categoryIds` is fetched by a preceding query, you can set `enabled` to `categoryIds.length > 0`. This will ensure that `useMany` is only run after `categoryIds` is fetched.

```tsx
useMany({
  resource: "categories",
  ids: categoryIds,
  // highlight-next-line
  queryOptions: { enabled: categoryIds.length > 0 },
});
```

## Can I work with JavaScript?

Although Refine is written in TypeScript and it is recommended to use TypeScript, you can also work with Javascript without any problems. Check out the [Refine with Javascript example →](https://github.com/refinedev/refine/tree/main/examples/with-javascript)

## How I can override specific function of Data Providers?

In some cases, you may need to override functions of Refine data providers. The simplest way to do this is to use the [Spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

Below code sample, overrides the `update` function of the [`@refinedev/simple-rest`](https://github.com/refinedev/refine/tree/main/packages/simple-rest). You can apply custom logic to the data provider methods or handle a custom `meta` property for your needs.

```tsx
import dataProvider from "@refinedev/simple-rest";

const simpleRestProvider = dataProvider("API_URL");
const myDataProvider = {
  ...simpleRestProvider,
  update: async ({ resource, id, variables, meta }) => {
    console.log("Overriding the update function");

    // You can either send a request from scratch or use the original function
    return await simpleRestProvider.update({ resource, id, variables, meta });
  },
};

<Refine dataProvider={myDataProvider} />;
```

## Why are API calls triggering twice?

This is the expected behavior if you use [`<React.StrictMode>`][https://react.dev/reference/react/StrictMode]. In this mode, React will render the components twice in **development mode** to identify unsafe life cycles, unexpected side effects, and legacy or deprecated APIs. It's used for highlighting possible problems. You can also check out the related issue on the [TanStack Query repository](https://github.com/TanStack/query/issues/3633).

## How can I add an item to the Sider component?

`<Sider />` components use the `resources` property of the `<Refine>` component to render the navigation links. If a resource has a `list` property, it will be rendered as a navigation link in the sider. To add a custom item to the sider, you can use three different approaches:

#### Using Resource Definitions

The first and simplest way is to use the `resources` property on the `<Refine>` component. The `<Sider>` component shows the resources whose `list` property is set. So, you can have an extra navigation link by adding a resource with the `list` attribute.

```tsx
import { Refine } from "@refinedev/core";

<Refine
    ...
    resources={[
        {
            name: "dashboard",
            list: "/",
            meta: {
                label: "Dashboard",
                icon: "🏠",
            },
        },
    ]}
/>;
```

#### Using `render` property of `<Sider>` component

The second way is to use the `render` property of the `<Sider>` component. The `render` property is a function that receives an object with the `items` and `logout` properties. The `items` property is the list of navigation items and the `logout` property is the logout button.

<Tabs
defaultValue="antd"
values={[
{label: 'Ant Design', value: 'antd'},
{label: 'Material UI', value: 'mui'},
{label: 'Mantine', value: 'mantine'},
{label: 'Chakra UI', value: 'chakra-ui'},
]}>
<TabItem value="antd">

```tsx
import { Layout, Sider } from "@refinedev/antd";

const CustomSider = () => {
  return (
    <Sider
      render={({ items, logout }) => {
        return (
          <>
            <a href="https://refine.dev/">👋 Navigation Link</a>
            {items}
            {logout}
          </>
        );
      }}
    />
  );
};

const CustomLayout = () => {
  return <Layout Sider={CustomSider}>...</Layout>;
};
```

</TabItem>
<TabItem value="mui">

```tsx
import { Layout, Sider } from "@refinedev/mui";

const CustomSider = () => {
  return (
    <Sider
      render={({ items, logout }) => {
        return (
          <>
            <a href="https://refine.dev/">👋 Navigation Link</a>
            {items}
            {logout}
          </>
        );
      }}
    />
  );
};

const CustomLayout = () => {
  return <Layout Sider={CustomSider}>...</Layout>;
};
```

</TabItem>
<TabItem value="mantine">

```tsx
import { Layout, Sider } from "@refinedev/mantine";

const CustomSider = () => {
  return (
    <Sider
      render={({ items, logout }) => {
        return (
          <>
            <a href="https://refine.dev/">👋 Navigation Link</a>
            {items}
            {logout}
          </>
        );
      }}
    />
  );
};

const CustomLayout = () => {
  return <Layout Sider={CustomSider}>...</Layout>;
};
```

</TabItem>
<TabItem value="chakra-ui">

```tsx
import { Layout, Sider } from "@refinedev/chakra-ui";

const CustomSider = () => {
  return (
    <Sider
      render={({ items, logout }) => {
        return (
          <>
            <a href="https://refine.dev/">👋 Navigation Link</a>
            {items}
            {logout}
          </>
        );
      }}
    />
  );
};

const CustomLayout = () => {
  return <Layout Sider={CustomSider}>...</Layout>;
};
```

</TabItem>
</Tabs>

#### Using `swizzle` command

The third way is to use the `swizzle` command.

You can use the command to copy the default `Sider` component to your project. This will allow you to customize the sider as you want.

[Refer to the swizzle section of Development guide. &#8594](/docs/guides-concepts/development/#using-swizzle)

## How to hide items from the Sider component?

Refine's [`useMenu`](/docs/core/hooks/utilities/use-menu/) hook and `<Sider />` components use the `resources` property of the `<Refine>` component to render the navigation links. If a resource has a `list` property, it will be rendered as a navigation link in the sider. To hide a resource from the menu, you can use the `meta.hide` property of the resource.

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";

const App = () => (
  <Refine
    ...
    resources={[
      {
        name: "posts",
        list: "/posts",
        meta: {
          label: "Posts",
          icon: "📝",
        },
      },
      {
        name: "users",
        list: "/users",
        meta: {
          // Users resource will be hidden from the menu but will be accessible via the URL
          hide: true,
        },
      },
    ]}
  />
);
```

## How can I remove GitHub Banner?

To remove the GitHub Banner, you need to find and remove the `<GitHubBanner />` component from your React application. The specific location of this component may vary depending on the React platform you are using.

Here are the locations where you can find and remove the `<GitHubBanner />` component based on different React platforms:

- Vite: `src/App.tsx` - [See an example](https://github.com/refinedev/refine/blob/main/examples/auth-antd/src/App.tsx#L161)
- Next.js: `src/app/layout.tsx` - [See an example](https://github.com/refinedev/refine/blob/main/examples/with-nextjs/src/app/layout.tsx#L37)
- Remix: `app/root.tsx` - [See an example](https://github.com/refinedev/refine/blob/main/examples/with-remix-antd/app/root.tsx#L37)

## How to solve "Module 'X' has no exported member 'Y'" error?

The error message "Module 'X' has no exported member 'Y'" typically occurs when using `pnpm` due to its cache system. We are aware of this issue and are actively working on resolving it by updating our peer dependencies with each version release. However, this is still a work in progress. In the meantime, you can resolve this error by using the `npm i <module-name>@latest` command.

Here are a couple of examples of reported errors and their corresponding fix:

1. Error: "Module '@refinedev/mantine' has no exported member 'HamburgerMenu'"

   - Solution: Run `npm i @refinedev/mantine@latest` to install the latest version of the `@refinedev/mantine` module.

2. Error: "Module '@refinedev/antd' has no exported member 'ThemedLayoutV2'"
   - Solution: Execute `npm i @refinedev/antd@latest` to install the latest version of the `@refinedev/antd` module.

By following these steps and updating to the latest module versions, you should be able to resolve the "not exported" error.

## How to use React Query DevTools with Refine?

Until `@refinedev/core`'s version `4.28.2`, Refine had the `@tanstack/react-query-devtools` package available by default. However, this package has been removed from the core package and is no longer available by default.

We're recommending [`@refinedev/devtools`](/docs/guides-concepts/development/#using-devtools) as an alternative to `@tanstack/react-query-devtools`. `@refinedev/devtools` is tailored for Refine and provides more detailed information about the queries and mutations with its monitoring panel and much more.

## How do invalidation works in queries?

Refine invalidates and refetches the related queries after a successful mutation. To have a better understanding of how invalidation works in Refine, check out the [State Management section of General Concepts guide.](/docs/guides-concepts/general-concepts/#state-management)

## How to handle filters and sorters when using client side pagination?

When you're implementing client side pagination with the `pagination.mode` set to "client," you might run into issues when applying client side filtering and sorting. This is due to the fact that client side filtering and sorting are applied to the sliced data, not the whole data. To ensure that the client side filtering and sorting are applied to the whole data, you need to use the `pagination.mode: "off"` prop.

## How to handle server side validation errors?

When working with forms and mutations, using only client side validation might not be enough. You may also need to validate the data on the server side. Refine provides an interface [`HttpError`](/docs/core/interface-references/#httperror) to propagate the server side validation errors to the form values. You can use this interface to handle server side validation errors.

To learn more about server side validation and see an example, check out the [Server Side Validation section of the Forms guide.](/docs/guides-concepts/forms/#server-side-validation-)

## How to work offline in local environment?

When working without a network connection, `@tanstack/query` prevents requests from being made until a successful connection is established. You might feel frustrated and wonder,

> Why can't I work with my own data? Must I use an internet connection to run this library?

Don't worry; according to the `@tanstack/query` [documentation](https://tanstack.com/query/latest/docs/react/guides/network-mode), you can simply add the `networkMode: "always"` option to the `reactQuery` props on the `<Refine/>` component.

```javascript
<Refine
  // ...
  options: {
    // ...
    reactQuery: {
      clientConfig: {
        defaultOptions: {
          queries: { // For fetching data
            networkMode: "always", // Apply this to mutations as well, as shown below
          },
          mutations: { // For posting data
            networkMode: "always" // It defaults to "online," preventing requests when there is no connection
          },
        },
      },
    },
  }
/>
```

## Why are there network errors showing in the console?

When working with Refine in development environment you may receive network errors in the console. Browsers will log network errors regardless of the status of the Promise. This is a common behavior in development environments and does not affect the functionality of the application.

Still, there two common errors that you may encounter when working with Refine in development environment but you can safely ignore them:

- `401 (Unauthorized) from :5001/api/.auth/sessions/whoami` - This error is related with the Refine's Devtools and logged if there are no active authentication sessions in Devtools. You can get rid of this error by logging in to the Devtools.

- Numerous `404 (Not Found)` errors when using Refine's Inferencer - These errors are related with the Inferencer component since the main logic behind Inferencer components are to infer the data structure from the API. When trying to infer the data structure, Inferencer may send requests to the API to determine relationships between resources. You can safely ignore these errors as they are not affecting the functionality of the application. To learn more about the functionality of Inferencer, check out the [How the fields are inferred? section in Inferencer docs](/docs/packages/inferencer/#how-the-fields-are-inferred).

If you have any other network errors thrown by Refine and have no relation with the above mentioned errors or not caused by your project's logic, please reach out to us via [GitHub Issues](https://github.com/refinedev/refine/issues) or our [Discord Community](https://discord.gg/refine).

[use-form-core]: /docs/core/hooks/use-form/
[use-form-react-hook-form]: /docs/packages/list-of-packages
[use-form-antd]: /docs/ui-integrations/ant-design/hooks/use-form
[edit-mui]: /docs/packages/list-of-packages

================
File: guides-concepts/forms/index.md
================
---
title: Forms
---

In almost every user facing application, forms are a necessity. They are the primary way for users to interact with your application and provide data to your backend. They are also one of the most complex parts of an application to build and maintain with many cases and features to consider. Refine's form integration aims to make this process as simple as possible while providing as many real world features as possible out of the box. This guide will cover the basics of forms in Refine and how to use them.

## Handling Data

`useForm` hook orchestrates Refine's [`useOne`](/docs/data/hooks/use-one), [`useUpdate`](/docs/data/hooks/use-update) and [`useCreate`](/docs/data/hooks/use-create) hooks internally to provide a single interface for form handling.

While editing or cloning a record, `useOne` will be used to fetch the record to provide values for the form. When creating a new record, `useCreate` will be used for the mutation. When updating a record, `useUpdate` will be used for the mutation.

This means that the `useForm` hook will handle all of the data fetching and mutation logic for you. All you need to do is provide the form with the correct props and it will handle the rest.

## Basic Usage

The usage of the `useForm` hooks may slightly differ between libraries, the core functionality is provided by the `@refinedev/core`'s `useForm` hook and is the same across all implementations. Refine's core has the `useForm` hook which is the foundation of all the other extensions and `useForm` implementations in the other helper libraries.

To learn more about the usage and see `useForm` in action, check out the reference pages for each library:

<Tabs smallTabs>
<TabItem value="core" label="Refine's Core">

```tsx title="edit.tsx"
import { useForm } from "@refinedev/core";

const EditPage = () => {
  const { query, formLoading, onFinish } = useForm<
    IProduct,
    HttpError,
    FormValues
  >({
    resource: "products",
    action: "edit",
    id: 123,
  });

  const record = query.data?.data;

  const onSubmit = (event) => {
    const data = Object.fromEntries(new FormData(event.target).entries());

    onFinish(data);
  };

  return (
    <form onSubmit={onSubmit}>
      <label>
        Name:
        <input defaultValue={record?.name} />
      </label>
      <label>
        Material:
        <input defaultValue={record?.material} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
};
```

[Check out Core's `useForm` reference page to learn more about the usage and see it in action.](/docs/data/hooks/use-form/)

</TabItem>
<TabItem value="hook-form" label="React Hook Form" default>

```tsx title="edit.tsx"
import { useForm } from "@refinedev/react-hook-form";

const EditPage = () => {
  const {
    refineCore: { onFinish, formLoading, query },
    register,
    handleSubmit,
    formState: { errors },
    saveButtonProps,
  } = useForm<IProduct, HttpError, FormValues>({
    refineCoreProps: {
      resource: "products",
      action: "edit",
      id: 123,
    },
  });

  return (
    <form onSubmit={handleSubmit(onFinish)}>
      <label>
        Name:
        <input {...register("name")} />
      </label>
      <label>
        Material:
        <input {...register("material")} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
};
```

[Check out React Hook Form's `useForm` reference page to learn more about the usage and see it in action.](/docs/packages/list-of-packages)

</TabItem>
<TabItem value="antd" label="Ant Design">

```tsx title="edit.tsx"
import { useForm, Edit } from "@refinedev/antd";
import { Form, Input } from "antd";

const EditPage = () => {
  const { formProps, saveButtonProps, query } = useForm<
    IProduct,
    HttpError,
    FormValues
  >({
    refineCoreProps: {
      resource: "products",
      action: "edit",
      id: 123,
    },
  });

  return (
    <Edit saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item label="Name" name="name">
          <Input />
        </Form.Item>
        <Form.Item label="Material" name="material">
          <Input />
        </Form.Item>
      </Form>
    </Edit>
  );
};
```

[Check out Ant Design Form's `useForm` reference page to learn more about the usage and see it in action.](/docs/ui-integrations/ant-design/hooks/use-form)

</TabItem>
<TabItem value="mantine" label="Mantine">

```tsx title="edit.tsx"
import { useForm, Edit } from "@refinedev/mantine";
import { TextInput } from "@mantine/core";

const EditPage = () => {
  const {
    refineCore: { onFinish, formLoading, query },
    register,
    handleSubmit,
    formState: { errors },
    saveButtonProps,
  } = useForm<IProduct, HttpError, FormValues>({
    refineCoreProps: {
      resource: "products",
      action: "edit",
      id: 123,
    },
    initialValues: {
      name: "",
      material: "",
    },
  });

  return (
    <Edit saveButtonProps={saveButtonProps}>
      <form>
        <TextInput
          mt={8}
          label="Name"
          placeholder="Name"
          {...getInputProps("name")}
        />
        <TextInput
          mt={8}
          label="Material"
          placeholder="Material"
          {...getInputProps("material")}
        />
      </form>
    </Edit>
  );
};
```

[Check out Mantine Form's `useForm` reference page to learn more about the usage and see it in action.](/docs/ui-integrations/mantine/hooks/use-form)

</TabItem>
<TabItem value="material-ui" label={(<span><span className="block">Material UI</span><small className="block">React Hook Form</small></span>)}>

```tsx title="edit.tsx"
import { HttpError } from "@refinedev/core";
import { Edit } from "@refinedev/mui";
import { useForm } from "@refinedev/react-hook-form";
import { Button, Box, TextField } from "@mui/material";

const EditPage = () => {
  const {
    refineCore: { onFinish, formLoading, query },
    register,
    handleSubmit,
    saveButtonProps,
  } = useForm<IProduct, HttpError, FormValues>({
    refineCoreProps: {
      resource: "products",
      action: "edit",
      id: 123,
    },
  });

  return (
    <Edit saveButtonProps={saveButtonProps}>
      <Box component="form">
        <TextField
          {...register("name", {
            required: "This field is required",
          })}
          name="name"
          label="Name"
        />
        <TextField
          {...register("material", {
            required: "This field is required",
          })}
          name="material"
          label="Material"
        />
      </Box>
    </Edit>
  );
};
```

[Check out React Hook Form's `useForm` reference page to learn more about the usage and see it in action.](/docs/packages/list-of-packages)

</TabItem>
<TabItem value="chakra-ui" label={(<span><span className="block">Chakra UI</span><small className="block">React Hook Form</small></span>)}>

```tsx title="edit.tsx"
import { HttpError } from "@refinedev/core";
import { Edit } from "@refinedev/chakra-ui";
import { useForm } from "@refinedev/react-hook-form";
import { FormControl, FormLabel, Input, Button } from "@chakra-ui/react";

const EditPage = () => {
  const {
    refineCore: { onFinish, formLoading, query },
    register,
    handleSubmit,
    saveButtonProps,
  } = useForm<IProduct, HttpError, FormValues>({
    refineCoreProps: {
      resource: "products",
      action: "edit",
      id: 123,
    },
  });

  return (
    <Edit saveButtonProps={saveButtonProps}>
      <form>
        <FormControl mb="3">
          <FormLabel>Name</FormLabel>
          <Input
            id="name"
            type="text"
            {...register("name", { required: "Name is required" })}
          />
        </FormControl>
        <FormControl mb="3">
          <FormLabel>Material</FormLabel>
          <Input
            id="material"
            type="text"
            {...register("material", {
              required: "Material is required",
            })}
          />
        </FormControl>
      </form>
    </Edit>
  );
};
```

[Check out React Hook Form's `useForm` reference page to learn more about the usage and see it in action.](/docs/packages/list-of-packages)

</TabItem>
</Tabs>

## Integration with Routers

If a router integration is made, in most of the cases this enables Refine to infer the `resource`, `action` and `id` from the current route and provide them to `useForm` hook. In most of the cases, this will prevent the need of passing explicit `resource`, `action` and `id` props to the hooks including `useForm`.

```tsx
import { useForm } from "@refinedev/core";

useForm({
  // These properties will be inferred from the current route
  // removed-start
  resource: "posts",
  action: "edit",
  id: 1,
  // removed-end
});
```

To learn more about the routing, check out the [Routing](/guides-concepts/routing/index.md#router-integrations) guide and the [General Concepts](/guides-concepts/general-concepts/index.md#router-provider) guide to learn more about how it benefits the development experience.

### Redirection

`useForm` also uses the router integration to redirect the user to the desired page after a successful mutation. By default, it's the list page of the resource but this can be customized by passing a `redirect` prop to the `useForm` hook. If you want to change the redirection behavior for all forms, you can use the `options.redirect` prop of the [`<Refine>` component](/docs/core/refine-component).

```tsx
import { useForm } from "@refinedev/core";

useForm({
  redirect: "show", // Can also be "list", "edit" or false
});
```

### Unsaved Changes <GuideBadge id="guides-concepts/routing/#useform" /> <GlobalConfigBadge id="core/refine-component/#warnwhenunsavedchanges" />

Refine's `useForm` hooks have a built-in feature to prevent the user from losing the unsaved changes via a confirmation dialog when changing the route/leaving the page. To enable this feature, you need to use the [`<UnsavedChangesNotifier />`](/docs/guides-concepts/routing/#useform) components from the router package of the library you are using and set the `warnWhenUnsavedChanges` prop to `true`.

```tsx
import { Refine, useForm } from "@refinedev/core";

useForm({
  warnWhenUnsavedChanges: true,
});
```

#### **Usage of `<UnsavedChangesNotifier />`**

<Tabs wrapContent={false}>
<TabItem value="react-router" label="React Router">

```tsx title="app.tsx"
import { Refine } from "@refinedev/core";
import {
  routerProvider,
  UnsavedChangesNotifier,
} from "@refinedev/react-router";
import { BrowserRouter, Routes } from "react-router";

const App = () => (
  <BrowserRouter>
    <Refine
      // ...
      routerProvider={routerProvider}
      options={{
        // highlight-next-line
        warnWhenUnsavedChanges: true,
      }}
    >
      <Routes>{/* ... */}</Routes>
      {/* highlight-start */}
      {/* The `UnsavedChangesNotifier` component should be placed under <Refine /> component. */}
      <UnsavedChangesNotifier />
      {/* highlight-end */}
    </Refine>
  </BrowserRouter>
);
```

Check out the [`UnsavedChangesNotifier` section of the React Router integration documentation](/docs/packages/list-of-packages#unsavedchangesnotifier) for more information.

</TabItem>
<TabItem value="next-js" label="Next.js">

```tsx title="_app.tsx"
import type { AppProps } from "next/app";
import { Refine } from "@refinedev/core";
import {
  routerProvider,
  UnsavedChangesNotifier,
} from "@refinedev/nextjs-router/pages";

export default function App({ Component, pageProps }) {
  return (
    <Refine
      // ...
      routerProvider={routerProvider}
      options={{
        // highlight-next-line
        warnWhenUnsavedChanges: true,
      }}
    >
      <Component {...pageProps} />
      {/* highlight-start */}
      {/* The `UnsavedChangesNotifier` component should be placed under <Refine /> component. */}
      <UnsavedChangesNotifier />
      {/* highlight-end */}
    </Refine>
  );
}
```

Check out the [`UnsavedChangesNotifier` section of the React Router integration documentation](/docs/packages/list-of-packages#unsavedchangesnotifier) for more information.

</TabItem>
<TabItem value="remix" label="Remix">

```tsx title="app/root.tsx"
import type { MetaFunction } from "@remix-run/node";

import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

import { Refine } from "@refinedev/core";

// highlight-next-line
import routerProvider, {
  UnsavedChangesNotifier,
} from "@refinedev/remix-router";

export default function App() {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Refine
          // ...
          routerProvider={routerProvider}
          options={{
            // highlight-next-line
            warnWhenUnsavedChanges: true,
          }}
        >
          <Outlet />
          {/* highlight-next-line */}
          <UnsavedChangesNotifier />
        </Refine>
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}
```

Check out the [`UnsavedChangesNotifier` section of the React Router integration documentation](/docs/packages/list-of-packages#unsavedchangesnotifier) for more information.

</TabItem>
</Tabs>

## Actions <RouterBadge />

In `useForm`, you'll have 3 action modes to choose from:

### Create

This is the default action mode and is used for creating a new record for the resource.

### Edit

Used for editing an existing record. This action mode requires an `id` prop to be passed to the form.

### Clone

Used for cloning an existing record. This action mode requires an `id` prop to be passed to the form. The record with the given `id` will be fetched and the values will be used as the initial values for the form fields and the mutation will be performed to create a new record.

## Relationships <GuideBadge id="guides-concepts/data-fetching/#relationships" />

Refine handles [data relations](/docs/guides-concepts/data-fetching/#relationships) with data hooks(eg: `useOne`, `useMany`, etc.). This compositional design allows you to easily display other resources' data in your components.

However, when it comes to forms, we may want to add fields that are related to other resources. For instance, you may want to add a `category` field to the `products` resource. This field will be a select input that will display the categories fetched from the `categories` resource. Refine offers [`useSelect`](/docs/core/hooks/use-select) hook to easily manage select (like a [Html `<select>` tag](https://www.w3schools.com/tags/tag_select.asp), [React Select](https://react-select.com/home), etc.) components.

You can find more information and usage examples on following `useSelect` documentation pages:

- [Headless](/docs/core/hooks/use-select)
- [Ant Design Select](/docs/ui-integrations/ant-design/hooks/use-select/)
- [Material UI Autocomplete](/docs/ui-integrations/material-ui/hooks/use-auto-complete/)
- [Mantine Select](/docs/ui-integrations/mantine/hooks/use-select/)

In the following example, we will add a `category` field to the `products` resource. This field will be a select input populated with categories using the `useSelect` hook.

<Tabs wrapContent={false}>
<TabItem value="headless" label="Headless">

import UseSelectHeadless from "./use-select-headless";

<UseSelectHeadless />

</TabItem>

<TabItem  value="antd" label="Ant Design">

import UseSelectAntd from "./use-select-antd";

<UseSelectAntd />

</TabItem>

<TabItem value="material-ui" label="Material UI">

import UseSelectMaterialUI from "./use-select-material-ui";

<UseSelectMaterialUI />

</TabItem>

<TabItem value="mantine" label="Mantine">

import UseSelectMantine from "./use-select-mantine";

<UseSelectMantine />

</TabItem>

</Tabs>

## Mutation Modes <GlobalConfigBadge id="core/refine-component/#mutationmode" />

`useForm` provides 3 mutation modes to choose from, you may need each of them in different scenarios throughout your application.

```tsx
useForm({
  mutationMode: "optimistic", // Can be "pessimistic", "optimistic" and "undoable". Default is "pessimistic"
});
```

### Pessimistic

This is the default mode and is the most common mode. In this mode, the mutation will be performed immediately and the form will be toggle the loading state until the mutation is completed.

If the mutation fails, the error will be displayed to the user with no further action such as invalidating the cache and redirection after the mutation.

### Optimistic

In this mode, the mutation will be performed immediately and simultaneously it will be treated as if it has succeeded. The user will be shown a success notification and the existing query cache will be optimistically updated with the provided form values for the list, many and detail queries.

If not specified the opposite, it will do the redirection to the desired page. If the mutation succeeds, the query cache will be invalidated and the active queries will trigger a refetch.

If the mutation fails, the optimistic updates will be reverted and the error will be displayed to the user.

### Undoable

In this mode, the mutation will be delayed for the specified amount of time but simultaneously will be treated as if it has succeeded. Identical to the `optimistic` mode, the existing query cache will be updated accordingly and the user will be shown a notification with a countdown.

Unless it is ordered to "undo" the action by the user, the mutation will be performed after the countdown. If the mutation succeeds, the query cache will be invalidated and the active queries will trigger a refetch.

If the mutation fails, the optimistic updates will be reverted and the error will be displayed to the user.

## Invalidation <GuideBadge id="guides-concepts/general-concepts#caching" description="To learn more about caching, refer to General Concepts guide" />

All the queries made by Refine's data hooks and their derivatives are cached for a certain amount of time. This means that if you perform a query for a resource, the result will be cached and the next time you perform the same query, the results will be returned immediately from the cache and then if the data is considered stale, the query will be refetched in the background.

When you perform a mutation, the query cache will be invalidated by default after a successful mutation. This means that if you perform a mutation that affects the data of a query, the query will be refetched in the background and the UI will be updated accordingly.

### Default Behavior

By default, `useForm` will invalidate the following queries after a successful mutation:

For `create` and `clone` actions; `list` and `many` queries for the resource. This means all the related queries made by `useList`, `useSelect`, `useMany`, `useTable` etc. will be invalidated.

For `edit` action; in addition to the queries invalidated in `create` and `clone` modes, `detail` query for the resource will be invalidated. This means all the related queries made by `useOne`, `useShow` etc. will be invalidated.

### Custom Invalidation

In some cases, you may want to change the default invalidation behavior such as to invalidate all the resource or skipping the `list` queries etc. To do that, you can use the `invalidates` prop of the `useForm` to determine which query sets should be invalidated after a successful mutation.

```tsx
const { formProps } = useForm({
  resource: "posts",
  action: "edit",
  id: 1,
  // highlight-next-line
  invalidates: ["many", "detail"], // default is ["list", "many", "detail"]
});
```

If you want to disable the invalidation completely and handle it manually, you can pass `false` to the `invalidates` prop. Then, you can use the [`useInvalidate`](/docs/data/hooks/use-invalidate) hook to invalidate the queries manually based on your conditions.

```tsx
import { useInvalidate } from "@refinedev/core";

const invalidate = useInvalidate();

useForm({
  resource: "categories",
  action: "edit",
  id: 1,
  // highlight-start
  invalidates: false,
  onMutationSuccess() {
    invalidate({
      resource: "posts",
      invalidates: ["resourceAll"],
    });
  },
  // highlight-end
});
```

## Optimistic Updates

In many cases, you may want to update the query cache optimistically after a mutation before the mutation is completed. This is especially comes in handy when managing the waiting experience of the user. For example, if you are updating a record, you may want to update the query cache with the new values to show the user that the record is updated immediately and then revert the changes if the mutation fails.

:::note

Optimistic updates are only available in `optimistic` and `undoable` mutation modes.

:::

### Default Behavior

By default, Refine's mutations will use the provided form data/values to update the existing records in the query cache. This update process includes the `list`, `many` and `detail` queries related to the record and the resource.

### Custom Optimistic Updates

In some cases such as the data being submitted is slightly different from the data being fetched in the structural level, you may want to customize the optimistic updates. To do that, you can use the `optimisticUpdateMap` prop of the `useForm` to determine how the query cache will be updated for each query set.

`optimisticUpdateMap` prop also lets you disable the optimistic updates for a specific query set by passing `false` to the corresponding key.

```tsx
useForm({
  resource: "posts",
  id: 1,
  mutationMode: "optimistic",
  optimisticUpdateMap: {
    list: (
      previous, // Previous query data
      variables, // Variables used in the query
      id, // Record id
    ) => {
      // update the `previous` data using the `variables` and `id`, then return it
    },
    many: (
      previous, // Previous query data
      variables, // Variables used in the query
      id, // Record id
    ) => {
      // update the `previous` data using the `variables` and `id`, then return it
    },
    detail: (
      previous, // Previous query data
      variables, // Variables used in the query
    ) => {
      // update the `previous` data using the `variables`, then return it
    },
  },
});
```

## Server Side Validation <GlobalConfigBadge id="core/refine-component/#disableserversidevalidation" />

Server-side form validation is a technique used to validate form data on the server before processing it. Unlike client-side validation, which is performed in the user's browser using JavaScript, server-side validation occurs on the server-side code, typically in the backend of the application.

Refine supports server-side validation out-of-the-box in all `useForm` derivatives. To handle server-side validation, the data providers needs to be correctly set up to return the errors in form submissions with a specific format. After this, Refine's `useForm` will propagate the errors to the respective form fields.

```ts
import { HttpError } from "@refinedev/core";

const error: HttpError = {
  message: "An error occurred while updating the record.",
  statusCode: 400,
  // the errors field is required for server-side validation.
  // when the errors field is set, useForm will automatically display the error messages in the form with the corresponding fields.
  errors: {
    title: ["Title is required"],
    content: {
      key: "form.error.content",
      message: "Content is required.",
    },
    tags: true,
  },
};
```

[Check out `HttpError` interface for more information about the error format.](/docs/core/interface-references#httperror)

Examples below demonstrates the server-side validation and error propagation:

<Tabs smallTabs wrapContent={false}>
<TabItem value="core" label="Refine's Core">

import ServerSideValidationCore from "./server-side-validation-core.tsx";

<ServerSideValidationCore />

</TabItem>
<TabItem value="hook-form" label="React Hook Form">

import ServerSideValidationReactHookForm from "./server-side-validation-react-hook-form.tsx";

<ServerSideValidationReactHookForm />

</TabItem>
<TabItem default value="antd" label="Ant Design">

import ServerSideValidationAntd from "./server-side-validation-antd.tsx";

<ServerSideValidationAntd />

</TabItem>
<TabItem value="mantine" label="Mantine">

import ServerSideValidationMantine from "./server-side-validation-mantine.tsx";

<ServerSideValidationMantine />

</TabItem>
<TabItem value="material-ui" label={(<span><span className="block">Material UI</span><small className="block">React Hook Form</small></span>)}>

import ServerSideValidationMui from "./server-side-validation-mui.tsx";

<ServerSideValidationMui />

</TabItem>
<TabItem value="chakra-ui" label={(<span><span className="block">Chakra UI</span><small className="block">React Hook Form</small></span>)}>

import ServerSideValidationChakraUi from "./server-side-validation-chakra-ui.tsx";

<ServerSideValidationChakraUi />

</TabItem>
</Tabs>

## Notifications <GuideBadge id="notification/notification-provider" />

When forms are submitted, it is a good practice to notify the user about the result of the submission. `useForm` handles this for you, when the mutation succeeds or fails it will show a notification to the user with a proper message. This behavior can be customized or disabled using the `successNotification` and `errorNotification` props.

These props accepts both a function that returns the configuration or a static configuration, this means you'll be able to use the response of the mutation to customize the notification message.

```tsx title="Default Notification Values"
useForm({
  // If not passed explicitly, these default values will be used. Default values can also be customized via i18n.
  successNotification: (data, values, resource) => {
    return {
      description: translate("notifications.success", "Successful"),
      message: translate(
        "notifications.(edit|create)Success",
        "Successfully (updated|created) {resource}",
      ),
      type: "success",
    };
  },
  // If not passed explicitly, these default values will be used. Default values can also be customized via i18n.
  errorNotification: (error, values, resource) => {
    return {
      description: error.message,
      message: translate(
        "notifications.(edit|create)Error",
        "Error when (updating|creating) {resource} (status code: {error.statusCode})",
      ),
      type: "error",
    };
  },
});
```

## Auto Save

In many forms, it is a good practice to save the form data automatically as the user types to avoid losing the data in case of an unexpected event. This is especially useful in long forms where the user may spend a lot of time filling the form. `useForm` is packed with this feature out-of-the-box.

While `@refinedev/core`'s `useForm` packs this feature, the auto save is not triggered automatically. In the extensions of the `useForm` hook in the other libraries, the auto save is handled internally and is triggered automatically.

```tsx title="edit.tsx"
import { useForm } from "@refinedev/core";

const { autoSaveProps } = useForm({
  autoSave: {
    enabled: true, // Enables the auto save feature, defaults to false
    debounce: 2000, // Debounce interval to trigger the auto save, defaults to 1000
    invalidateOnUnmount: true, // Invalidates the queries when the form is unmounted, defaults to false
  },
});
```

### `<AutoSaveIndicator />`

Refine's core and ui integrations are shipped with an [`<AutoSaveIndicator />`](/docs/core/components/auto-save-indicator) component that can be used to show a visual indicator to the user when the auto save is triggered. The `autoSaveProps` value from the `useForm`'s return value can be passed to the `<AutoSaveIndicator />` to show the auto save status to the user. It will automatically show the loading, success and error states to the user.

```tsx title="edit.tsx"
import { AutoSaveIndicator } from "@refinedev/core";

const { autoSaveProps } = useForm({
  resource: "posts",
  action: "edit",
  id: 1,
  autoSave: {
    enabled: true,
  },
});

return (
  <form>
    {/* ... */}
    <AutoSaveIndicator {...autoSaveProps} />
  </form>
);
```

## Modifying Data Before Submission

In some cases, you might want to change the data before submitting it to the backend. For example, you might want to add a `full_name` field to the form data of a user resource by combining the `first_name` and `last_name` fields. While the `useForm` from the `@refinedev/core` has the natural support for this, the `useForm` derivatives from the other libraries of Refine has a different approach.

Each of these form implementations have a way to modify the data before submission with a slightly different approach. To learn more about how to modify the data before submission, check out the usage examples of each library:

<Tabs>
<TabItem value="react-hook-form" label="React Hook Form" default>

To learn more about how to modify the data before submission, check out the [Using `useForm` of `@refinedev/react-hook-form`](/docs/packages/list-of-packages##how-can-i-change-the-form-data-before-submitting-it-to-the-api) reference page.

<Tabs>
<TabItem value="headless" label="Headless">

```tsx title="edit.tsx"
import { useForm } from "@refinedev/react-hook-form";
import { FieldValues } from "react-hook-form";

const EditPage = () => {
  const {
    refineCore: { onFinish },
    register,
    handleSubmit,
  } = useForm();

  // highlight-start
  const onFinishHandler = (data: FieldValues) => {
    onFinish({
      fullName: `${data.name} ${data.surname}`,
    });
  };
  // highlight-end

  return (
    // highlight-next-line
    <form onSubmit={handleSubmit(onFinishHandler)}>
      <label>
        Name:
        <input {...register("name")} />
      </label>
      <label>
        Surname:
        <input {...register("surname")} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
};
```

</TabItem>
<TabItem value="material-ui" label="With Material UI">

```tsx title="edit.tsx"
import { HttpError } from "@refinedev/core";
import { Create } from "@refinedev/mui";
import { useForm } from "@refinedev/react-hook-form";
import { Button, Box, TextField } from "@mui/material";

type FormValues = {
  name: string;
  surname: string;
};

export const UserCreate: React.FC = () => {
  const {
    saveButtonProps,
    refineCore: { onFinish },
    handleSubmit,
  } = useForm<FormValues, HttpError, FormValues>();

  const handleSubmitPostCreate = (values: FormValues) => {
    const { name, surname } = values;
    const fullName = `${name} ${surname}`;
    onFinish({
      ...value,
      fullName,
    });
  };

  return (
    <Create
      saveButtonProps={{
        ...saveButtonProps,
        onClick: handleSubmit(handleSubmitForm),
      }}
    >
      <Box component="form">
        <TextField
          {...register("name", {
            required: "This field is required",
          })}
          name="name"
          label="Name"
          error={!!errors.name}
          helperText={errors.name?.message}
        />
        <TextField
          {...register("surname", {
            required: "This field is required",
          })}
          name="surname"
          label="Surname"
          error={!!errors.surname}
          helperText={errors.surname?.message}
        />
      </Box>
    </Create>
  );
};
```

Check out the [`<Create />`](/docs/ui-integrations/material-ui/components/basic-views/create#savebuttonprops) component and [`saveButtonProps`](/docs/packages/list-of-packages#savebuttonprops) prop to learn more about their usage.

</TabItem>
<TabItem value="chakra-ui" label="With Chakra UI">

```tsx title="edit.tsx"
import { HttpError } from "@refinedev/core";
import { Create } from "@refinedev/chakra-ui";
import { useForm } from "@refinedev/react-hook-form";
import { FormControl, FormLabel, Input, Button } from "@chakra-ui/react";

type FormValues = {
  name: string;
  surname: string;
};

export const UserCreate: React.FC = () => {
  const {
    saveButtonProps,
    refineCore: { onFinish },
    handleSubmit,
  } = useForm<FormValues, HttpError, FormValues>();

  const handleSubmitPostCreate = (values: FormValues) => {
    const { name, surname } = values;
    const fullName = `${name} ${surname}`;
    onFinish({
      ...value,
      fullName,
    });
  };

  return (
    <Create
      saveButtonProps={{
        ...saveButtonProps,
        onClick: handleSubmit(handleSubmitForm),
      }}
    >
      <form>
        <FormControl mb="3">
          <FormLabel>Name</FormLabel>
          <Input
            id="name"
            type="text"
            {...register("name", { required: "Name is required" })}
          />
        </FormControl>
        <FormControl mb="3">
          <FormLabel>Surname</FormLabel>
          <Input
            id="surname"
            type="text"
            {...register("surname", {
              required: "Surname is required",
            })}
          />
        </FormControl>
      </form>
    </Create>
  );
};
```

Check out the [`<Create />`](/docs/ui-integrations/chakra-ui/components/basic-views/create#savebuttonprops) component and [`saveButtonProps`](/docs/packages/list-of-packages#savebuttonprops) prop to learn more about their usage.

</TabItem>
</Tabs>

</TabItem>
<TabItem value="antd" label="Ant Design">

To learn more about how to modify the data before submission, check out the [Using `useForm` of `@refinedev/antd`](/docs/ui-integrations/ant-design/hooks/use-form#how-can-i-change-the-form-data-before-submitting-it-to-the-api) reference page.

```tsx title="edit.tsx"
import { useForm, Create } from "@refinedev/antd";
import { Form, Input } from "antd";

const EditPage = () => {
  const { formProps, saveButtonProps, onFinish } = useForm();

  // highlight-start
  const handleOnFinish = (values) => {
    onFinish({
      fullName: `${values.name} ${values.surname}`,
    });
  };
  // highlight-end

  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form {...formProps} onFinish={handleOnFinish} layout="vertical">
        <Form.Item label="Name" name="name">
          <Input />
        </Form.Item>
        <Form.Item label="Surname" name="surname">
          <Input />
        </Form.Item>
      </Form>
    </Create>
  );
};
```

</TabItem>
<TabItem value="mantine" label="Mantine">

To learn more about how to modify the data before submission, check out the [Using `useForm` of `@refinedev/mantine`](/docs/ui-integrations/mantine/hooks/use-form#how-can-i-change-the-form-data-before-submitting-it-to-the-api) reference page.

```tsx title="edit.tsx"
import { useForm, Create } from "@refinedev/mantine";
import { TextInput } from "@mantine/core";

const CreatePage = () => {
  const { saveButtonProps, getInputProps } = useForm({
    initialValues: {
      name: "",
      surname: "",
    },
    // highlight-start
    transformValues: (values) => ({
      fullName: `${values.name} ${values.surname}`,
    }),
    // highlight-end
  });

  return (
    <Create saveButtonProps={saveButtonProps}>
      <form>
        <TextInput
          mt={8}
          label="Name"
          placeholder="Name"
          {...getInputProps("name")}
        />
        <TextInput
          mt={8}
          label="Surname"
          placeholder="Surname"
          {...getInputProps("surname")}
        />
      </form>
    </Create>
  );
};
```

</TabItem>
</Tabs>

## Save and Continue

In many cases, you may want to redirect the user to the edit page of the record after creating it. This is especially useful in cases where the user needs to fill a long form and you don't want to lose the data in case of an unexpected event.

In the example below, we'll create multiple options for the user to choose from after creating a record. The user will be able to choose between redirecting to the list page, edit page or staying in the create page in order to continue creating records.

import SaveAndContinue from "./save-and-continue";

<SaveAndContinue />

================
File: guides-concepts/forms/save-and-continue.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BasicUsage() {
  return (
    <Sandpack
      // showNavigator
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/react-hook-form": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/products/create"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "/list.tsx": {
          code: ListTsxCode,
        },
        "/create.tsx": {
          code: CreateTsxCode,
          active: true,
        },
        "/edit.tsx": {
          code: EditTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { BrowserRouter, Route, Routes, Navigate, Outlet } from "react-router";
import routerProvider from "@refinedev/react-router";
import "./style.css";
import { List } from "./list.tsx";
import { Edit } from "./edit.tsx";
import { Create } from "./create.tsx";
export default function App() {
    return (
        <BrowserRouter>
            <Refine
                routerProvider={routerProvider}
                dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
                resources={[
                    {
                        name: "products",
                        list: "/products",
                        create: "/products/create",
                        edit: "/products/edit/:id",
                    }
                ]}
            >
                <Routes>
                    <Route path="/products" element={<Outlet />}>
                        <Route index element={<List />} />
                        <Route path="create" element={<Create />} />
                        <Route path="edit/:id" element={<Edit />} />
                    </Route>
                </Routes>
            </Refine>
        </BrowserRouter>
    );
}
`.trim();
const StyleCssCode = `
html {
    margin: 0;
    padding: 0;
}
body {
    margin: 0;
    padding: 12px;
}
* {
    box-sizing: border-box;
}
body {
    font-family: sans-serif;
}
form label, form input, form button {
    display: block;
    width: 100%;
    margin-bottom: 6px;
}
`.trim();
const ListTsxCode = `
import { useList, BaseKey } from "@refinedev/core";
import { Link } from "react-router";
export const List: React.FC = () => {
    const { data, isLoading, isError } = useList<IProduct>({
        resource: "products",
        filters: [
            {
                field: "id",
                operator: "gte",
                value: 120,
            }
        ]
    });
    if (isLoading) {
        return <div>Loading...</div>;
    }
    return (
        <div>
                <h1>Products</h1>
                <Link to="/products/create">Create Product</Link>
            <ul>
                {data?.data?.map((product) => (
                    <li key={product.id}>
                        {product.name}
                    </li>
                ))}
            </ul>
        </div>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
}
`.trim();
const CreateTsxCode = `
import React from "react";
import { useForm } from "@refinedev/react-hook-form";
import type { HttpError, BaseKey } from "@refinedev/core";
export const Create: React.FC = () => {
    const {
        refineCore: { onFinish, formLoading, redirect },
        register,
        handleSubmit,
        reset,
    } = useForm<IProduct, HttpError, FormValues>({
        refineCoreProps: {
            redirect: false,
        }
    });
    const saveAndList = (variables: FormValues) => {
        onFinish(variables).then(() => {
            // The default behavior is (unless changed in <Refine /> component) redirecting to the list page.
            // Since we've stated as \`redirect: false\` in the useForm hook, we need to redirect manually.
            redirect("list");
        });
    };
    const saveAndContinue = (variables: FormValues) => {
        onFinish(variables).then(({ data }) => {
            // We'll wait for the mutation to finish and grab the id of the created product from the response.
            // This will only work on \`pesimistic\` mutation mode.
            redirect("edit", data.id);
        });
    };
    const saveAndAddAnother = (variables: FormValues) => {
        onFinish(variables).then(() => {
            // We'll wait for the mutation to finish and reset the form.
            reset();
        });
    };
    return (
        <div>
            <h1>Create Product</h1>
            <form onSubmit={handleSubmit(saveAndList)}>
                <label htmlFor="name">Name</label>
                <input
                    name="name"
                    placeholder="Name"
                    {...register("name", { required: true })}
                />
                <label htmlFor="material">Material</label>
                <input
                    name="material"
                    placeholder="Material"
                    {...register("material", { required: true })}
                />
                <div style={{ display: "flex", gap: "12px" }}>
                    <button type="submit">Save</button>
                    <button type="button" onClick={handleSubmit(saveAndContinue)}>Save and Continue Editing</button>
                    <button type="button" onClick={handleSubmit(saveAndAddAnother)}>Save and Add Another</button>
                </div>
            </form>
        </div>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
}
interface FormValues {
    name?: string;
    material?: string;
}
`.trim();
const EditTsxCode = `
import React from "react";
import { useSelect } from "@refinedev/core";
import { useForm } from "@refinedev/react-hook-form";
import type { HttpError, BaseKey } from "@refinedev/core";
export const Edit: React.FC = () => {
    const {
        refineCore: { onFinish, formLoading },
        register,
        handleSubmit,
        reset
    } = useForm<IProduct, HttpError, FormValues>();
    return (
        <div>
            <h1>Edit Product</h1>
            <form onSubmit={handleSubmit(onFinish)}>
                <label htmlFor="name">Name</label>
                <input
                    name="name"
                    placeholder="Name"
                    {...register("name", { required: true })}
                />
                <label htmlFor="material">Material</label>
                <input
                    name="material"
                    placeholder="Material"
                    {...register("material", { required: true })}
                />
                <button type="submit">Save</button>
            </form>
        </div>
    );
};
interface IProduct {
    id: BaseKey;
    name: string;
    material: string;
}
interface FormValues {
    name?: string;
    material?: string;
}
`.trim();

================
File: guides-concepts/forms/server-side-validation-antd.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function ServerSideValidationAntd() {
  return (
    <Sandpack
      height={460}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/products/create"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/data-provider.tsx": {
          code: DataProviderTsxCode,
          active: true,
        },
        "/create.tsx": {
          code: CreateTsxCode,
        },
      }}
    />
  );
}
const DataProviderTsxCode = /* jsx */ `
import type { HttpError } from "@refinedev/core";
import baseDataProvider from "@refinedev/simple-rest";
const dataProvider = {
    ...baseDataProvider("https://api.fake-rest.refine.dev"),
    create: async () => {
        // For demo purposes, we're hardcoding the error response.
        // In a real-world application, the error of the server should match the \`HttpError\` interface
        // or should be transformed to match it.
        return Promise.reject({
            message: "This is an error from the server",
            statusCode: 400,
            errors: {
                name: "Name should be at least 3 characters long",
                material: "Material should start with a capital letter",
                description: "Description should be at least 10 characters long",
            },
        } as HttpError);
    }
};
export default dataProvider;
`.trim();
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine, Authenticated } from "@refinedev/core";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import { BrowserRouter, Route, Routes, Outlet, Navigate } from "react-router";
import { ErrorComponent, RefineThemes, ThemedLayoutV2, useNotificationProvider, AuthPage } from "@refinedev/antd";
import { App as AntdApp, ConfigProvider } from "antd";
import dataProvider from "./data-provider";
import "@refinedev/antd/dist/reset.css";
import { ProductShow } from "./show";
import { ProductCreate } from "./create";
export default function App() {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <AntdApp>
          <Refine
            routerProvider={routerProvider}
            dataProvider={dataProvider}
            notificationProvider={useNotificationProvider}
            resources={[
              {
                name: "products",
                create: "/products/create"
              }
            ]}
            options={{ mutationMode: "pessimistic", syncWithLocation: true, redirect: { afterCreate: false } }}
          >
            <Routes>
                <Route
                    element={
                    <ThemedLayoutV2>
                        <Outlet />
                    </ThemedLayoutV2>
                    }
                >
                    <Route path="/products" element={<Outlet />}>
                        <Route path="create" element={<ProductCreate />} />
                    </Route>
                    <Route path="*" element={<ErrorComponent />} />
                </Route>
            </Routes>
          </Refine>
        </AntdApp>
      </ConfigProvider>
    </BrowserRouter>
  );
};
`.trim();
const CreateTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Create, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export const ProductCreate = () => {
  const { formProps, saveButtonProps } = useForm({ refineCoreProps: { redirect: "show" }});
  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
            label="Name"
            name="name"
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Material"
            name="material"
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Description"
            name="description"
        >
            <TextArea rows={2} />
        </Form.Item>
      </Form>
    </Create>
  );
};
`.trim();

================
File: guides-concepts/forms/server-side-validation-chakra-ui.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function ServerSideValidationChakraUi() {
  return (
    <Sandpack
      height={460}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/chakra-ui": "^2.26.17",
        "@tabler/icons-react": "^3.1.0",
        "@refinedev/core": "^4.45.1",
        "@refinedev/react-router": "latest",
        "@refinedev/simple-rest": "^4.5.4",
        "@refinedev/react-table": "^5.6.4",
        "@tanstack/react-table": "^8.2.6",
        "@refinedev/react-hook-form": "^4.8.12",
        "@chakra-ui/react": "^2.5.1",
        "react-dom": "^18.0.0",
        "react-router": "^7.0.2",
        "react-hook-form": "^7.43.5",
      }}
      startRoute="/products/create"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/data-provider.tsx": {
          code: DataProviderTsxCode,
          active: true,
        },
        "/create.tsx": {
          code: CreateTsxCode,
        },
      }}
    />
  );
}
const DataProviderTsxCode = /* jsx */ `
import type { HttpError } from "@refinedev/core";
import baseDataProvider from "@refinedev/simple-rest";
const dataProvider = {
    ...baseDataProvider("https://api.fake-rest.refine.dev"),
    create: async () => {
        // For demo purposes, we're hardcoding the error response.
        // In a real-world application, the error of the server should match the \`HttpError\` interface
        // or should be transformed to match it.
        return Promise.reject({
            message: "This is an error from the server",
            statusCode: 400,
            errors: {
                name: "Name should be at least 3 characters long",
                material: "Material should start with a capital letter",
                description: "Description should be at least 10 characters long",
            },
        } as HttpError);
    }
};
export default dataProvider;
`.trim();
const AppTsxCode = /* jsx */ `
import { Refine } from "@refinedev/core";
import {
    ErrorComponent,
    ThemedLayoutV2,
    RefineThemes,
    useNotificationProvider,
    AuthPage
} from "@refinedev/chakra-ui";
import { ChakraProvider } from "@chakra-ui/react";
import routerProvider, {
    NavigateToResource,
} from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet, Navigate } from "react-router";
import dataProvider from "./data-provider";
import { ProductCreate } from "./create";
const App: React.FC = () => {
    return (
        <BrowserRouter>
            <ChakraProvider theme={RefineThemes.Blue}>
                <Refine
                    notificationProvider={useNotificationProvider}
                    routerProvider={routerProvider}
                    dataProvider={dataProvider}
                    resources={[
                        {
                            name: "products",
                            create: "/products/create",
                        },
                    ]}
                    options={{ mutationMode: "pessimistic", syncWithLocation: true, redirect: { afterCreate: false } }}
                >
                    <Routes>
                        <Route
                            element={
                                <ThemedLayoutV2>
                                    <Outlet />
                                </ThemedLayoutV2>
                            }
                        >
                            <Route path="/products" element={<Outlet />}>
                                <Route path="create" element={<ProductCreate />} />
                            </Route>
                            <Route path="*" element={<ErrorComponent />} />
                        </Route>
                    </Routes>
                </Refine>
            </ChakraProvider>
        </BrowserRouter>
    );
};
export default App;
`.trim();
const CreateTsxCode = /* jsx */ `
import { Create } from "@refinedev/chakra-ui";
import {
    FormControl,
    FormErrorMessage,
    FormLabel,
    Input,
    Textarea,
} from "@chakra-ui/react";
import { useForm } from "@refinedev/react-hook-form";
export const ProductCreate = () => {
    const {
        refineCore: { formLoading },
        saveButtonProps,
        register,
        formState: { errors },
    } = useForm();
    return (
        <Create isLoading={formLoading} saveButtonProps={saveButtonProps}>
            <FormControl mb="3" isInvalid={!!errors?.name}>
                <FormLabel>Name</FormLabel>
                <Input
                    id="name"
                    type="text"
                    {...register("name")}
                />
                <FormErrorMessage>
                    {\`$\{errors.name?.message}\`}
                </FormErrorMessage>
            </FormControl>
            <FormControl mb="3" isInvalid={!!errors?.material}>
                <FormLabel>Material</FormLabel>
                <Input
                    id="material"
                    type="text"
                    {...register("material")}
                />
                <FormErrorMessage>
                    {\`$\{errors.material?.message}\`}
                </FormErrorMessage>
            </FormControl>
            <FormControl mb="3" isInvalid={!!errors?.description}>
                <FormLabel>Description</FormLabel>
                <Textarea
                    id="description"
                    {...register("description")}
                />
                <FormErrorMessage>
                    {\`$\{errors.description?.message}\`}
                </FormErrorMessage>
            </FormControl>
        </Create>
    );
};
`.trim();

================
File: guides-concepts/forms/server-side-validation-core.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function ServerSideValidationReactHookForm() {
  return (
    <Sandpack
      height={460}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/core": "^4.45.1",
        "@refinedev/react-router": "latest",
        "@refinedev/simple-rest": "^4.5.4",
        "react-dom": "^18.0.0",
        "react-router": "^7.0.2",
      }}
      startRoute="/products/create"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "/data-provider.tsx": {
          code: DataProviderTsxCode,
          active: true,
        },
        "/create.tsx": {
          code: CreateTsxCode,
        },
      }}
    />
  );
}
const DataProviderTsxCode = /* jsx */ `
import type { HttpError } from "@refinedev/core";
import baseDataProvider from "@refinedev/simple-rest";
const dataProvider = {
    ...baseDataProvider("https://api.fake-rest.refine.dev"),
    create: async () => {
        // For demo purposes, we're hardcoding the error response.
        // In a real-world application, the error of the server should match the \`HttpError\` interface
        // or should be transformed to match it.
        return Promise.reject({
            message: "This is an error from the server",
            statusCode: 400,
            errors: {
                name: "Name should be at least 3 characters long",
                material: "Material should start with a capital letter",
                description: "Description should be at least 10 characters long",
            },
        } as HttpError);
    }
};
export default dataProvider;
`.trim();
const StyleCssCode = /* css */ `
body {
    margin: 0;
    padding: 0;
    font-family: sans-serif;
}
form {
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}
label {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
}
label span {
  display: inline-flex;
  min-width: 120px;
}
form button[type="button"] {
  margin-top: 12px;
  align-self: flex-end;
}
`.trim();
const AppTsxCode = /* jsx */ `
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";
import "./style.css";
import dataProvider from "./data-provider";
import { ProductCreate } from "./create";
const App: React.FC = () => {
    return (
        <BrowserRouter>
                <Refine
                    routerProvider={routerProvider}
                    dataProvider={dataProvider}
                    resources={[
                        {
                            name: "products",
                            create: "/products/create",
                        },
                    ]}
                    options={{ mutationMode: "pessimistic", syncWithLocation: true, redirect: { afterCreate: false } }}
                >
                    <Routes>
                      <Route path="/products" element={<Outlet />}>
                          <Route path="create" element={<ProductCreate />} />
                      </Route>
                    </Routes>
                </Refine>
        </BrowserRouter>
    );
};
export default App;
`.trim();
const CreateTsxCode = /* jsx */ `
import { useForm } from "@refinedev/core";
export const ProductCreate = () => {
    const {
        mutation: { error },
        formLoading,
        onFinish,
    } = useForm();
    const { errors } = error ?? {};
    return (
      <div style={{ position: "relative" }}>
        <form onSubmit={(event) => {
          event.preventDefault();
          const formData = new FormData(event.currentTarget);
          const variables = Object.fromEntries(formData.entries());
          onFinish(variables).catch(() => {})
        }} style={{ display: "flex", flexDirection: "column", gap: "12px" }}>
          <label>
            <span>Name</span>
            <input type="text" id="name" name="name" />
            </label>
            <span style={{ color: "red" }}>{errors?.name ?? ""}</span>
          <label>
            <span>Material</span>
            <input type="text" id="material" name="material" />
            </label>
            <span style={{ color: "red" }}>{errors?.material ?? ""}</span>
          <label>
            <span>Description</span>
            <textarea id="description" name="description" />
            </label>
            <span style={{ color: "red" }}>{errors?.description ?? ""}</span>
          <button type="submit">Save</button>
        </form>
        {formLoading && (<div style={{
          position: "absolute",
          inset: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          backgroundColor: "rgba(255, 255, 255, 0.5)",
          color: "#000",
        }}>loading...</div>)}
      </div>
    );
};
`.trim();

================
File: guides-concepts/forms/server-side-validation-mantine.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function ServerSideValidationMantine() {
  return (
    <Sandpack
      height={460}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/mantine": "^2.28.21",
        "@refinedev/core": "^4.45.1",
        "@refinedev/react-router": "^latest",
        "@refinedev/simple-rest": "^4.5.4",
        "@refinedev/react-table": "^5.6.4",
        "@tanstack/react-table": "^8.2.6",
        "@tabler/icons-react": "^3.1.0",
        "@emotion/react": "^11.8.2",
        "@mantine/core": "^5.10.4",
        "@mantine/hooks": "^5.10.4",
        "@mantine/form": "^5.10.4",
        "@mantine/notifications": "^5.10.4",
        "react-router": "^7.0.2",
      }}
      startRoute="/products/create"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/data-provider.tsx": {
          code: DataProviderTsxCode,
          active: true,
        },
        "/create.tsx": {
          code: CreateTsxCode,
        },
      }}
    />
  );
}
const DataProviderTsxCode = /* jsx */ `
import type { HttpError } from "@refinedev/core";
import baseDataProvider from "@refinedev/simple-rest";
const dataProvider = {
    ...baseDataProvider("https://api.fake-rest.refine.dev"),
    create: async () => {
        // For demo purposes, we're hardcoding the error response.
        // In a real-world application, the error of the server should match the \`HttpError\` interface
        // or should be transformed to match it.
        return Promise.reject({
            message: "This is an error from the server",
            statusCode: 400,
            errors: {
                name: "Name should be at least 3 characters long",
                material: "Material should start with a capital letter",
                description: "Description should be at least 10 characters long",
            },
        } as HttpError);
    }
};
export default dataProvider;
`.trim();
const AppTsxCode = /* jsx */ `
import { Refine, Authenticated } from "@refinedev/core";
import {
    ErrorComponent,
    ThemedLayoutV2,
    RefineThemes,
    useNotificationProvider,
    AuthPage
} from "@refinedev/mantine";
import { NotificationsProvider } from "@mantine/notifications";
import { MantineProvider, Global } from "@mantine/core";
import routerProvider, {
    NavigateToResource,
} from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet, Navigate } from "react-router";
import dataProvider from "./data-provider";
import { ProductCreate } from "./create";
const App: React.FC = () => {
    return (
        <BrowserRouter>
            <MantineProvider
                theme={RefineThemes.Blue}
                withNormalizeCSS
                withGlobalStyles
            >
                <Global styles={{ body: { WebkitFontSmoothing: "auto" } }} />
                <NotificationsProvider position="top-right">
                    <Refine
                        notificationProvider={useNotificationProvider}
                        routerProvider={routerProvider}
                        dataProvider={dataProvider}
                        resources={[
                            {
                                name: "products",
                                create: "/products/create",
                            },
                        ]}
                        options={{ mutationMode: "pessimistic", syncWithLocation: true, redirect: { afterCreate: false } }}
                    >
                        <Routes>
                            <Route
                                element={
                                    <ThemedLayoutV2>
                                        <Outlet />
                                    </ThemedLayoutV2>
                                }
                            >
                                <Route path="/products" element={<Outlet />}>
                                    <Route path="create" element={<ProductCreate />} />
                                </Route>
                                <Route path="*" element={<ErrorComponent />} />
                            </Route>
                        </Routes>
                    </Refine>
                </NotificationsProvider>
            </MantineProvider>
        </BrowserRouter>
    );
};
export default App;
`.trim();
const CreateTsxCode = /* jsx */ `
import { Create, useForm } from "@refinedev/mantine";
import { TextInput, Textarea, NumberInput } from "@mantine/core";
export const ProductCreate = () => {
  const {
      saveButtonProps,
      getInputProps,
      errors,
  } = useForm({
        initialValues: {
          name: "",
          material: "",
        },
  });
  return (
    <Create saveButtonProps={saveButtonProps}>
      <form>
        <TextInput
          mt={8}
          id="name"
          label="Name"
          placeholder="Name"
          {...getInputProps("name")}
        />
        <TextInput
          mt={8}
          id="material"
          label="Material"
          placeholder="Material"
          {...getInputProps("material")}
        />
        <Textarea
          mt={8}
          id="description"
          label="Description"
          placeholder="Description"
          {...getInputProps("description")}
        />
      </form>
    </Create>
  );
};
`.trim();

================
File: guides-concepts/forms/server-side-validation-mui.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function ServerSideValidationMui() {
  return (
    <Sandpack
      height={460}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/mui": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/react-hook-form": "^4.8.12",
        "@emotion/react": "^11.8.2",
        "@emotion/styled": "^11.8.1",
        "@mui/lab": "^6.0.0-beta.14",
        "@mui/material": "^6.1.7",
        "@mui/system": "latest",
        "@mui/x-data-grid": "7.23.5",
        "react-router": "^7.0.2",
        "react-hook-form": "^7.43.5",
      }}
      startRoute="/products/create"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/data-provider.tsx": {
          code: DataProviderTsxCode,
          active: true,
        },
        "/create.tsx": {
          code: CreateTsxCode,
        },
      }}
    />
  );
}
const DataProviderTsxCode = /* jsx */ `
import type { HttpError } from "@refinedev/core";
import baseDataProvider from "@refinedev/simple-rest";
const dataProvider = {
    ...baseDataProvider("https://api.fake-rest.refine.dev"),
    create: async () => {
        // For demo purposes, we're hardcoding the error response.
        // In a real-world application, the error of the server should match the \`HttpError\` interface
        // or should be transformed to match it.
        return Promise.reject({
            message: "This is an error from the server",
            statusCode: 400,
            errors: {
                name: "Name should be at least 3 characters long",
                material: "Material should start with a capital letter",
                description: "Description should be at least 10 characters long",
            },
        } as HttpError);
    }
};
export default dataProvider;
`.trim();
const AppTsxCode = /* jsx */ `
import { Refine, Authenticated } from "@refinedev/core";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import { BrowserRouter, Route, Routes, Outlet, Navigate } from "react-router";
import {
  ThemedLayoutV2,
  ErrorComponent,
  RefineThemes,
  useNotificationProvider,
  RefineSnackbarProvider,
  AuthPage,
} from "@refinedev/mui";
import CssBaseline from "@mui/material/CssBaseline";
import GlobalStyles from "@mui/material/GlobalStyles";
import { ThemeProvider } from "@mui/material/styles";
import dataProvider from "./data-provider";
import { ProductCreate } from "./create";
export default function App() {
  return (
    <BrowserRouter>
      <ThemeProvider theme={RefineThemes.Blue}>
        <CssBaseline />
        <GlobalStyles
            styles={{ html: { WebkitFontSmoothing: "auto" } }}
        />
        <RefineSnackbarProvider>
            <Refine
                routerProvider={routerProvider}
                dataProvider={dataProvider}
                notificationProvider={useNotificationProvider}
                resources={[
                    {
                        name: "products",
                        create: "/products/create",
                    },
                ]}
                options={{ mutationMode: "pessimistic", syncWithLocation: true, redirect: { afterCreate: false } }}
            >
                <Routes>
                    <Route
                        element={
                            <ThemedLayoutV2>
                                <Outlet />
                            </ThemedLayoutV2>
                        }
                    >
                        <Route path="/products" element={<Outlet />}>
                          <Route path="create" element={<ProductCreate />} />
                        </Route>
                        <Route path="*" element={<ErrorComponent />} />
                    </Route>
                </Routes>
            </Refine>
        </RefineSnackbarProvider>
      </ThemeProvider>
    </BrowserRouter>
  );
};
`.trim();
const CreateTsxCode = /* jsx */ `
import { HttpError } from "@refinedev/core";
import { Create, useAutocomplete } from "@refinedev/mui";
import Box from "@mui/material/Box";
import TextField from "@mui/material/TextField";
import Autocomplete from "@mui/material/Autocomplete";
import { useForm } from "@refinedev/react-hook-form";
import { Controller } from "react-hook-form";
export const ProductCreate = () => {
  const {
    saveButtonProps,
    refineCore: { query, autoSaveProps },
    register,
    control,
    formState: { errors },
  } = useForm();
  return (
    <Create saveButtonProps={saveButtonProps}>
      <Box
      component="form"
      sx={{ display: "flex", flexDirection: "column" }}
      autoComplete="off"
      >
        <TextField
            id="name"
            {...register("name")}
            error={!!errors.name}
            helperText={errors.name?.message}
            margin="normal"
            fullWidth
            label="Name"
            name="name"
            autoFocus
        />
        <TextField
            id="material"
            {...register("material")}
            error={!!errors.material}
            helperText={errors.material?.message}
            margin="normal"
            fullWidth
            label="Material"
            name="material"
            autoFocus
        />
        <TextField
          id="description"
          {...register("description")}
          error={!!errors.description}
          helperText={errors.description?.message}
          margin="normal"
          label="Description"
          multiline
          rows={4}
        />
      </Box>
  </Create>
  );
};
`.trim();

================
File: guides-concepts/forms/server-side-validation-react-hook-form.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function ServerSideValidationReactHookForm() {
  return (
    <Sandpack
      height={460}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@tabler/icons-react": "^3.1.0",
        "@refinedev/core": "^4.45.1",
        "@refinedev/react-router": "latest",
        "@refinedev/simple-rest": "^4.5.4",
        "@refinedev/react-hook-form": "^4.8.12",
        "react-dom": "^18.0.0",
        "react-router": "^7.0.2",
        "react-hook-form": "^7.43.5",
      }}
      startRoute="/products/create"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "/data-provider.tsx": {
          code: DataProviderTsxCode,
          active: true,
        },
        "/create.tsx": {
          code: CreateTsxCode,
        },
      }}
    />
  );
}
const DataProviderTsxCode = /* jsx */ `
import type { HttpError } from "@refinedev/core";
import baseDataProvider from "@refinedev/simple-rest";
const dataProvider = {
    ...baseDataProvider("https://api.fake-rest.refine.dev"),
    create: async () => {
        // For demo purposes, we're hardcoding the error response.
        // In a real-world application, the error of the server should match the \`HttpError\` interface
        // or should be transformed to match it.
        return Promise.reject({
            message: "This is an error from the server",
            statusCode: 400,
            errors: {
                name: "Name should be at least 3 characters long",
                material: "Material should start with a capital letter",
                description: "Description should be at least 10 characters long",
            },
        } as HttpError);
    }
};
export default dataProvider;
`.trim();
const StyleCssCode = /* css */ `
body {
    margin: 0;
    padding: 0;
    font-family: sans-serif;
}
form {
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}
label {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
}
label span {
  display: inline-flex;
  min-width: 120px;
}
form button[type="button"] {
  margin-top: 12px;
  align-self: flex-end;
}
`.trim();
const AppTsxCode = /* jsx */ `
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";
import "./style.css";
import dataProvider from "./data-provider";
import { ProductCreate } from "./create";
const App: React.FC = () => {
    return (
        <BrowserRouter>
                <Refine
                    routerProvider={routerProvider}
                    dataProvider={dataProvider}
                    resources={[
                        {
                            name: "products",
                            create: "/products/create",
                        },
                    ]}
                    options={{ mutationMode: "pessimistic", syncWithLocation: true, redirect: { afterCreate: false } }}
                >
                    <Routes>
                      <Route path="/products" element={<Outlet />}>
                          <Route path="create" element={<ProductCreate />} />
                      </Route>
                    </Routes>
                </Refine>
        </BrowserRouter>
    );
};
export default App;
`.trim();
const CreateTsxCode = /* jsx */ `
import { useForm } from "@refinedev/react-hook-form";
export const ProductCreate = () => {
    const {
        refineCore: { formLoading },
        saveButtonProps,
        register,
        formState: { errors },
    } = useForm();
    return (
      <div style={{ position: "relative" }}>
        <form style={{ display: "flex", flexDirection: "column", gap: "12px" }}>
          <label>
            <span>Name</span>
            <input type="text" id="name" {...register("name")} />
            </label>
            <span style={{ color: "red" }}>{errors?.name?.message}</span>
          <label>
            <span>Material</span>
            <input type="text" id="material" {...register("material")} />
            </label>
            <span style={{ color: "red" }}>{errors?.material?.message}</span>
          <label>
            <span>Description</span>
            <textarea id="description" {...register("description")} />
            </label>
            <span style={{ color: "red" }}>{errors?.description?.message}</span>
          <button type="button" {...saveButtonProps}>Save</button>
        </form>
        {formLoading && (<div style={{
          position: "absolute",
          inset: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          backgroundColor: "rgba(255, 255, 255, 0.5)",
          color: "#000",
        }}>loading...</div>)}
      </div>
    );
};
`.trim();

================
File: guides-concepts/forms/use-select-antd.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function UseSelectAntd() {
  return (
    <Sandpack
      // showNavigator
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-hook-form": "latest",
        "@refinedev/antd": "latest",
        antd: "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/edit-page.tsx": {
          code: EditPageTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import { useNotificationProvider, RefineThemes } from "@refinedev/antd";
import dataProvider from "@refinedev/simple-rest";
import { ConfigProvider, App as AntdApp } from "antd";
import "@refinedev/antd/dist/reset.css";
import { EditPage } from "./edit-page";
const API_URL = "https://api.fake-rest.refine.dev";
const App: React.FC = () => {
    return (
        <ConfigProvider theme={RefineThemes.Blue}>
            <AntdApp>
                <Refine
                    dataProvider={dataProvider(API_URL)}
                    resources={[
                        {
                            name: "posts",
                            list: "/posts",
                            show: "/posts/show/:id",
                            create: "/posts/create",
                            edit: "/posts/edit/:id",
                            meta: {
                                canDelete: true,
                            },
                        },
                    ]}
                    notificationProvider={useNotificationProvider}
                    options={{
                        syncWithLocation: true,
                        warnWhenUnsavedChanges: true,
                    }}
                >
                    <EditPage />
                </Refine>
            </AntdApp>
        </ConfigProvider>
    );
};
export default App;
`.trim();
const EditPageTsxCode = `
import { useForm, useSelect } from "@refinedev/antd";
import { Form, Input, Select, Button, Row, Col } from "antd";
export const EditPage: React.FC = () => {
    const {
        formProps,
        saveButtonProps,
        query: productResult,
    } = useForm<IProduct>({
        resource: "products",
        id: 1,
        action: "edit",
    });
    const product = productResult?.data?.data;
    const { selectProps: categorySelectProps, queryResult: categoriesResult } =
        useSelect<ICategory>({
            resource: "categories",
            defaultValue: product?.category.id,
        });
    const categories = categoriesResult?.data?.data;
    // find category of product by id from categories
    const categoryOfProduct = categories?.find(
        (category) => Number(category.id) === Number(product?.category.id),
    );
    return (
        <>
            <Row
                justify="center"
                style={{
                    paddingTop: 24,
                    paddingBottom: 24,
                }}
            >
                <Col
                    style={{
                        textAlign: "center",
                    }}
                >
                    <h2>{\`Edit "\${product?.name}" Product\`}</h2>
                    <h2>{\`Category: \${categoryOfProduct?.title}\`}</h2>
                </Col>
            </Row>
            <Row justify="center">
                <Col span={12}>
                    <Form {...formProps} layout="vertical">
                        <Form.Item
                            label="Name"
                            name="name"
                            rules={[
                                {
                                    required: true,
                                },
                            ]}
                        >
                            <Input />
                        </Form.Item>
                        <Form.Item
                            label="Category"
                            name={["category", "id"]}
                            rules={[
                                {
                                    required: true,
                                },
                            ]}
                        >
                            <Select {...categorySelectProps} />
                        </Form.Item>
                        <Button type="primary" {...saveButtonProps}>
                            Save
                        </Button>
                    </Form>
                </Col>
            </Row>
        </>
    );
};
interface ICategory {
    id: number;
    title: string;
}
interface IProduct {
    id: number;
    name: string;
    category: { id: number };
}
`.trim();

================
File: guides-concepts/forms/use-select-headless.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function UseSelectHeadless() {
  return (
    <Sandpack
      // showNavigator
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-hook-form": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/edit-page.tsx": {
          code: EditPageTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { EditPage } from "./edit-page";
const App: React.FC = () => {
    return (
        <Refine
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            resources={[
                {
                    name: "posts",
                },
            ]}
        >
            <EditPage />
        </Refine>
    );
};
export default App;
`.trim();
const EditPageTsxCode = `
import React from "react";
import { useForm } from "@refinedev/react-hook-form";
import { useSelect } from "@refinedev/core";
export const EditPage: React.FC = () => {
    const {
        refineCore: { onFinish, formLoading, query: productQuery },
        register,
        handleSubmit,
    } = useForm<IProduct>({
        refineCoreProps: {
            resource: "products",
            id: 1,
            action: "edit",
        },
    });
    const product = productQuery?.data?.data;
    const { options, queryResult: categoriesQueryResult } =
        useSelect<ICategory>({
            resource: "categories",
            defaultValue: product?.category.id,
        });
    const categories = categoriesQueryResult?.data?.data;
    // find category of product by id from categories
    const categoryOfProduct = categories?.find(
        (category) => Number(category.id) === Number(product?.category.id),
    );
    return (
        <div>
            <div>
                <h2>{\`Edit "\${product?.name}" Product\`}</h2>
                <h2>{\`Category: \${categoryOfProduct?.title}\`}</h2>
            </div>
            <form onSubmit={handleSubmit(onFinish)}>
                <label>Name: </label>
                <input {...register("name", { required: true })} />
                <br />
                <label>Category: </label>
                <select
                    {...register("category.id", {
                        required: true,
                    })}
                    defaultValue={product?.category.id}
                >
                    {options?.map((category) => {
                        return (
                            <option key={category.value} value={category.value}>
                                {category.label}
                            </option>
                        );
                    })}
                </select>
                <br />
                <br />
                <input type="submit" value="Submit" />
                {formLoading && <p>Loading</p>}
            </form>
        </div>
    );
};
interface ICategory {
    id: number;
    title: string;
}
interface IProduct {
    id: number;
    name: string;
    category: { id: number };
}
`.trim();

================
File: guides-concepts/forms/use-select-mantine.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function UseSelectMantine() {
  return (
    <Sandpack
      // showNavigator
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-hook-form": "latest",
        "@refinedev/mantine": "^2.28.21",
        "@mantine/core": "^5.10.4",
        "@mantine/notifications": "^5.10.4",
        "@emotion/react": "^11.8.2",
        "@mantine/form": "^5.10.4",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/edit-page.tsx": {
          code: EditPageTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import { useNotificationProvider, RefineThemes } from "@refinedev/mantine";
import { NotificationsProvider } from "@mantine/notifications";
import { MantineProvider, Global } from "@mantine/core";
import dataProvider from "@refinedev/simple-rest";
import { EditPage } from "./edit-page";
const App: React.FC = () => {
    return (
        <MantineProvider
            theme={RefineThemes.Blue}
            withNormalizeCSS
            withGlobalStyles
        >
            <Global styles={{ body: { WebkitFontSmoothing: "auto" } }} />
            <NotificationsProvider position="top-right">
                <Refine
                    dataProvider={dataProvider(
                        "https://api.fake-rest.refine.dev",
                    )}
                    notificationProvider={useNotificationProvider}
                    resources={[
                        {
                            name: "posts",
                            list: "/posts",
                            show: "/posts/show/:id",
                            create: "/posts/create",
                            edit: "/posts/edit/:id",
                            meta: {
                                canDelete: true,
                            },
                        },
                    ]}
                    options={{
                        syncWithLocation: true,
                        warnWhenUnsavedChanges: true,
                    }}
                >
                    <EditPage />
                </Refine>
            </NotificationsProvider>
        </MantineProvider>
    );
};
export default App;
`.trim();
const EditPageTsxCode = `
import React from "react";
import { useForm, useSelect } from "@refinedev/mantine";
import { Flex, Button, Select, TextInput, Text, Grid } from "@mantine/core";
export const EditPage: React.FC = () => {
    const {
        saveButtonProps,
        getInputProps,
        refineCore: { query: productQuery },
    } = useForm<IProduct>({
        initialValues: {
            name: "",
            category: {
                id: "",
            },
        },
        refineCoreProps: {
            resource: "products",
            id: 1,
            action: "edit",
        },
    });
    const product = productQuery?.data?.data;
    const { selectProps, queryResult: categoriesQueryResult } =
        useSelect<ICategory>({
            resource: "categories",
            defaultValue: product?.category.id,
        });
    const categories = categoriesQueryResult?.data?.data;
    // find category of product by id from categories
    const categoryOfProduct = categories?.find(
        (category) => Number(category.id) === Number(product?.category.id),
    );
    return (
        <Flex
            align="center"
            direction="column"
            style={{
                paddingTop: 24,
            }}
        >
            <Grid>
                <Grid.Col
                    style={{
                        textAlign: "center",
                    }}
                >
                    <Text>{\`Edit "$\{product?.name}" Product\`}</Text>
                    <Text>{\`Category: $\{categoryOfProduct?.title}\`}</Text>
                </Grid.Col>
                <Grid.Col>
                    <form>
                        <TextInput
                            mt={8}
                            id="name"
                            label="Name"
                            placeholder="Name"
                            {...getInputProps("name")}
                        />
                        <Select
                            mt={8}
                            id="categoryId"
                            label="Category"
                            placeholder="Pick one"
                            {...getInputProps("category.id")}
                            {...selectProps}
                        />
                        <Button
                            mt={8}
                            variant="outline"
                            color="blue"
                            {...saveButtonProps}
                        >
                            Save
                        </Button>
                    </form>
                </Grid.Col>
            </Grid>
        </Flex>
    );
};
interface ICategory {
    id: number;
    title: string;
}
interface IProduct {
    id: number;
    name: string;
    category: { id: number };
}
`.trim();

================
File: guides-concepts/general-concepts/auth-pages/antd.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function AntdAuth() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import "@refinedev/antd/dist/reset.css";
import { App as AntdApp, ConfigProvider } from "antd";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import {
    AuthPage,
    ErrorComponent,
    RefineThemes,
    ThemedLayoutV2,
} from "@refinedev/antd";
import { Authenticated, Refine } from "@refinedev/core";
import routerProvider, {
    CatchAllNavigate,
    NavigateToResource,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
    return (
        <BrowserRouter>
            <ConfigProvider theme={RefineThemes.Blue}>
                <AntdApp>
                    <Refine
                        routerProvider={routerProvider}
                        dataProvider={dataProvider(
                            "https://api.fake-rest.refine.dev",
                        )}
                        authProvider={{
                            check: async () => ({
                                authenticated: false,
                                redirectTo: "/login",
                            }),
                            login: async () => {
                                return {
                                    success: false,
                                };
                            },
                            logout: async () => {
                                return {
                                    success: false,
                                };
                            },
                            onError: async () => ({}),
                            getIdentity: async () => ({
                                id: 1,
                                name: "John Doe",
                                avatar: "https://i.pravatar.cc/300",
                            }),
                        }}
                        resources={[
                            {
                                name: "dashboard",
                                list: "/",
                            },
                        ]}
                        options={{ syncWithLocation: true }}
                    >
                        <Routes>
                            <Route
                                element={
                                    <Authenticated
                                        fallback={
                                            <CatchAllNavigate to="/login" />
                                        }
                                    >
                                        <ThemedLayoutV2>
                                            <Outlet />
                                        </ThemedLayoutV2>
                                    </Authenticated>
                                }
                            >
                                <Route index element={<div>Welcome!</div>} />
                            </Route>
                            <Route
                                element={
                                    <Authenticated fallback={<Outlet />}>
                                        <NavigateToResource resource="dashboard" />
                                    </Authenticated>
                                }
                            >
                                <Route
                                    path="/login"
                                    element={
                                        <AuthPage
                                            type="login"
                                            wrapperProps={{
                                                style: {
                                                    paddingTop: 24,
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/register"
                                    element={
                                        <AuthPage
                                            type="register"
                                            wrapperProps={{
                                                style: {
                                                    paddingTop: 24,
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/forgot-password"
                                    element={
                                        <AuthPage
                                            type="forgotPassword"
                                            wrapperProps={{
                                                style: {
                                                    paddingTop: 24,
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/update-password"
                                    element={
                                        <AuthPage
                                            type="updatePassword"
                                            wrapperProps={{
                                                style: {
                                                    paddingTop: 24,
                                                },
                                            }}
                                        />
                                    }
                                />
                            </Route>
                            <Route
                                element={
                                    <Authenticated>
                                        <ThemedLayoutV2>
                                            <Outlet />
                                        </ThemedLayoutV2>
                                    </Authenticated>
                                }
                            >
                                <Route path="*" element={<ErrorComponent />} />
                            </Route>
                        </Routes>
                    </Refine>
                </AntdApp>
            </ConfigProvider>
        </BrowserRouter>
    );
}
`.trim();

================
File: guides-concepts/general-concepts/auth-pages/chakra.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function ChakraUIAuth() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/chakra-ui": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/react-table": "latest",
        "react-router": "^7.0.2",
        "@tabler/icons-react": "^3.1.0",
        "@chakra-ui/react": "^2.5.1",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `import React from "react";
import { ChakraProvider } from "@chakra-ui/react";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import {
    AuthPage,
    ErrorComponent,
    RefineThemes,
    ThemedLayoutV2,
} from "@refinedev/chakra-ui";
import { Authenticated, Refine } from "@refinedev/core";
import routerProvider, {
    CatchAllNavigate,
    NavigateToResource,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
    return (
        <BrowserRouter>
            <ChakraProvider theme={RefineThemes.Blue}>
                <Refine
                    routerProvider={routerProvider}
                    dataProvider={dataProvider(
                        "https://api.fake-rest.refine.dev",
                    )}
                    authProvider={{
                        check: async () => ({
                            authenticated: false,
                            redirectTo: "/login",
                        }),
                        login: async () => {
                            return {
                                success: false,
                            };
                        },
                        logout: async () => {
                            return {
                                success: false,
                            };
                        },
                        onError: async () => ({}),
                        getIdentity: async () => ({
                            id: 1,
                            name: "John Doe",
                            avatar: "https://i.pravatar.cc/300",
                        }),
                    }}
                    resources={[
                        {
                            name: "dashboard",
                            list: "/",
                        },
                    ]}
                    options={{ syncWithLocation: true }}
                >
                    <Routes>
                        <Route
                            element={
                                <Authenticated
                                    fallback={<CatchAllNavigate to="/login" />}
                                >
                                    <ThemedLayoutV2>
                                        <Outlet />
                                    </ThemedLayoutV2>
                                </Authenticated>
                            }
                        >
                            <Route index element={<div>Welcome!</div>} />
                        </Route>
                        <Route
                            element={
                                <Authenticated fallback={<Outlet />}>
                                    <NavigateToResource resource="dashboard" />
                                </Authenticated>
                            }
                        >
                            <Route
                                path="/login"
                                element={
                                    <AuthPage
                                        type="login"
                                        wrapperProps={{
                                            style: {
                                                margin: "24px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/register"
                                element={
                                    <AuthPage
                                        type="register"
                                        wrapperProps={{
                                            style: {
                                                margin: "24px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/forgot-password"
                                element={
                                    <AuthPage
                                        type="forgotPassword"
                                        wrapperProps={{
                                            style: {
                                                margin: "24px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/update-password"
                                element={
                                    <AuthPage
                                        type="updatePassword"
                                        wrapperProps={{
                                            style: {
                                                margin: "24px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                        </Route>
                        <Route
                            element={
                                <Authenticated>
                                    <ThemedLayoutV2>
                                        <Outlet />
                                    </ThemedLayoutV2>
                                </Authenticated>
                            }
                        >
                            <Route path="*" element={<ErrorComponent />} />
                        </Route>
                    </Routes>
                </Refine>
            </ChakraProvider>
        </BrowserRouter>
    );
}
`.trim();

================
File: guides-concepts/general-concepts/auth-pages/headless.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function HeadlessAuth() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import { Refine, AuthPage, Authenticated, ErrorComponent } from "@refinedev/core";
import routerProvider, {
  CatchAllNavigate,
  NavigateToResource,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
  return (
      <BrowserRouter>
          <Refine
              routerProvider={routerProvider}
              dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
              authProvider={{
                  check: async () => ({
                      authenticated: false,
                      redirectTo: "/login",
                  }),
                  login: async () => {
                      return {
                          success: false,
                      };
                  },
                  logout: async () => {
                      return {
                          success: false,
                      };
                  },
                  onError: async () => ({}),
                  getIdentity: async () => ({
                      id: 1,
                      name: "John Doe",
                      avatar: "https://i.pravatar.cc/300",
                  }),
              }}
              resources={[
                  {
                      name: "dashboard",
                      list: "/",
                  },
              ]}
          >
              <Routes>
                  <Route
                      element={
                          <Authenticated
                              fallback={<CatchAllNavigate to="/login" />}
                          >
                              <Outlet />
                          </Authenticated>
                      }
                  >
                      <Route index element={<div>Welcome!</div>} />
                  </Route>
                  <Route
                      element={
                          <Authenticated
                              fallback={
                                  <div
                                      style={{
                                          margin: "24px auto",
                                          maxWidth: "400px",
                                      }}
                                  >
                                      <Outlet />
                                  </div>
                              }
                          >
                              <NavigateToResource resource="dashboard" />
                          </Authenticated>
                      }
                  >
                      <Route
                          path="/login"
                          element={<AuthPage type="login" />}
                      />
                      <Route
                          path="/register"
                          element={<AuthPage type="register" />}
                      />
                      <Route
                          path="/forgot-password"
                          element={<AuthPage type="forgotPassword" />}
                      />
                      <Route
                          path="/update-password"
                          element={<AuthPage type="updatePassword" />}
                      />
                  </Route>
                  <Route
                      element={
                          <Authenticated>
                              <Outlet />
                          </Authenticated>
                      }
                  >
                      <Route path="*" element={<ErrorComponent />} />
                  </Route>
              </Routes>
          </Refine>
      </BrowserRouter>
  );
}
`.trim();

================
File: guides-concepts/general-concepts/auth-pages/mantine.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function MantineAuth() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/mantine": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/react-table": "latest",
        "react-router": "^7.0.2",
        "@mantine/core": "^5.10.4",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Global, MantineProvider } from "@mantine/core";
import { NotificationsProvider } from "@mantine/notifications";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import { Authenticated, Refine } from "@refinedev/core";
import {
    AuthPage,
    ErrorComponent,
    RefineThemes,
    ThemedLayoutV2,
} from "@refinedev/mantine";
import routerProvider, {
    CatchAllNavigate,
    NavigateToResource,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
    return (
        <BrowserRouter>
            <MantineProvider
                theme={RefineThemes.Blue}
                withNormalizeCSS
                withGlobalStyles
            >
                <Global styles={{ body: { WebkitFontSmoothing: "auto" } }} />
                <NotificationsProvider position="top-right">
                    <Refine
                        routerProvider={routerProvider}
                        dataProvider={dataProvider(
                            "https://api.fake-rest.refine.dev",
                        )}
                        authProvider={{
                            check: async () => ({
                                authenticated: false,
                                redirectTo: "/login",
                            }),
                            login: async () => {
                                return {
                                    success: false,
                                };
                            },
                            logout: async () => {
                                return {
                                    success: false,
                                };
                            },
                            onError: async () => ({}),
                            getIdentity: async () => ({
                                id: 1,
                                name: "John Doe",
                                avatar: "https://i.pravatar.cc/300",
                            }),
                        }}
                        resources={[
                            {
                                name: "dashboard",
                                list: "/",
                            },
                        ]}
                        options={{ syncWithLocation: true }}
                    >
                        <Routes>
                            <Route
                                element={
                                    <Authenticated
                                        fallback={
                                            <CatchAllNavigate to="/login" />
                                        }
                                    >
                                        <ThemedLayoutV2>
                                            <Outlet />
                                        </ThemedLayoutV2>
                                    </Authenticated>
                                }
                            >
                                <Route index element={<div>Welcome</div>} />
                            </Route>
                            <Route
                                element={
                                    <Authenticated fallback={<Outlet />}>
                                        <NavigateToResource resource="dashboard" />
                                    </Authenticated>
                                }
                            >
                                <Route
                                    path="/login"
                                    element={
                                        <AuthPage
                                            type="login"
                                            wrapperProps={{
                                                style: {
                                                    display: "flex",
                                                    flexDirection: "column",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    minHeight: "100vh",
                                                    margin: "24px auto",
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/register"
                                    element={
                                        <AuthPage
                                            type="register"
                                            wrapperProps={{
                                                style: {
                                                    display: "flex",
                                                    flexDirection: "column",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    minHeight: "100vh",
                                                    margin: "24px auto",
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/forgot-password"
                                    element={
                                        <AuthPage
                                            type="forgotPassword"
                                            wrapperProps={{
                                                style: {
                                                    display: "flex",
                                                    flexDirection: "column",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    minHeight: "100vh",
                                                    margin: "24px auto",
                                                },
                                            }}
                                        />
                                    }
                                />
                                <Route
                                    path="/update-password"
                                    element={
                                        <AuthPage
                                            type="updatePassword"
                                            wrapperProps={{
                                                style: {
                                                    display: "flex",
                                                    flexDirection: "column",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    minHeight: "100vh",
                                                    margin: "24px auto",
                                                },
                                            }}
                                        />
                                    }
                                />
                            </Route>
                            <Route
                                element={
                                    <Authenticated>
                                        <ThemedLayoutV2>
                                            <Outlet />
                                        </ThemedLayoutV2>
                                    </Authenticated>
                                }
                            >
                                <Route path="*" element={<ErrorComponent />} />
                            </Route>
                        </Routes>
                    </Refine>
                </NotificationsProvider>
            </MantineProvider>
        </BrowserRouter>
    );
}
`.trim();

================
File: guides-concepts/general-concepts/auth-pages/mui.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function MaterialUIAuth() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/mui": "latest",
        "react-router": "^7.0.2",
        "@emotion/react": "^11.8.2",
        "@emotion/styled": "^11.8.1",
        "@mui/lab": "^6.0.0-beta.14",
        "@mui/material": "^6.1.7",
        "@mui/system": "latest",
        "@mui/x-data-grid": "7.23.5",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import CssBaseline from "@mui/material/CssBaseline";
import GlobalStyles from "@mui/material/GlobalStyles";
import { ThemeProvider } from "@mui/material/styles";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import { Authenticated, Refine } from "@refinedev/core";
import {
    AuthPage,
    ErrorComponent,
    RefineThemes,
    ThemedLayoutV2,
} from "@refinedev/mui";
import routerProvider, {
    CatchAllNavigate,
    NavigateToResource,
} from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
    return (
        <BrowserRouter>
            <ThemeProvider theme={RefineThemes.Blue}>
                <CssBaseline />
                <GlobalStyles
                    styles={{ html: { WebkitFontSmoothing: "auto" } }}
                />
                <Refine
                    routerProvider={routerProvider}
                    dataProvider={dataProvider(
                        "https://api.fake-rest.refine.dev",
                    )}
                    authProvider={{
                        check: async () => ({
                            authenticated: false,
                            redirectTo: "/login",
                        }),
                        login: async () => {
                            return {
                                success: false,
                            };
                        },
                        logout: async () => {
                            return {
                                success: false,
                            };
                        },
                        onError: async () => ({}),
                        getIdentity: async () => ({
                            id: 1,
                            name: "John Doe",
                            avatar: "https://i.pravatar.cc/300",
                        }),
                    }}
                    resources={[
                        {
                            name: "dashboard",
                            list: "/",
                        },
                    ]}
                    options={{ syncWithLocation: true }}
                >
                    <Routes>
                        <Route
                            element={
                                <Authenticated
                                    fallback={<CatchAllNavigate to="/login" />}
                                >
                                    <ThemedLayoutV2>
                                        <Outlet />
                                    </ThemedLayoutV2>
                                </Authenticated>
                            }
                        >
                            <Route
                                path="/dashboard"
                                element={<div>Welcome</div>}
                            />
                        </Route>
                        <Route
                            element={
                                <Authenticated fallback={<Outlet />}>
                                    <NavigateToResource resource="dashboard" />
                                </Authenticated>
                            }
                        >
                            <Route
                                path="/login"
                                element={
                                    <AuthPage
                                        type="login"
                                        wrapperProps={{
                                            style: {
                                                margin: "72px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/register"
                                element={
                                    <AuthPage
                                        type="register"
                                        wrapperProps={{
                                            style: {
                                                margin: "72px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/forgot-password"
                                element={
                                    <AuthPage
                                        type="forgotPassword"
                                        wrapperProps={{
                                            style: {
                                                margin: "72px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                            <Route
                                path="/update-password"
                                element={
                                    <AuthPage
                                        type="updatePassword"
                                        wrapperProps={{
                                            style: {
                                                margin: "72px 0px",
                                                height: "max-content",
                                            },
                                        }}
                                    />
                                }
                            />
                        </Route>
                        <Route
                            element={
                                <Authenticated>
                                    <ThemedLayoutV2>
                                        <Outlet />
                                    </ThemedLayoutV2>
                                </Authenticated>
                            }
                        >
                            <Route path="*" element={<ErrorComponent />} />
                        </Route>
                    </Routes>
                </Refine>
            </ThemeProvider>
        </BrowserRouter>
    );
}
`.trim();

================
File: guides-concepts/general-concepts/index.md
================
---
title: General Concepts
---

Refine is an extensible framework designed for rapidly building web applications. It offers a modern, **hook-based architecture**, a **pluggable system of providers**, and a robust **state management** solution. This section provides an overview of the key concepts in Refine.

## Headless Concept

Instead of being limited to a set of pre-styled components, **Refine** provides collections of helper `hooks`, `components` and `providers` and more. Since business logic and UI are completely decoupled, you can customize UI without constraints.

It means, **Refine** just works _seamlessly_ with any _custom designs_ or _UI frameworks_. Thanks to its headless architecture, you can use popular CSS frameworks like [TailwindCSS](https://tailwindcss.com/) or even create your own styles from scratch.

Refine also provides integrations with [Ant Design](https://ant.design/), [Material UI](https://mui.com/material-ui/getting-started/overview/), [Mantine](https://mantine.dev/), and [Chakra UI](https://chakra-ui.com/) to get you started quickly. These libraries are set of components which are nicely integrated with headless `@refinedev/core` package.

## Resource Concept

In Refine, a **resource** is a central concept representing an **entity**, which ties together various aspects of your application.

It typically refers to a data entity, like `products`, `blogPosts`, or `orders`.

Resource definitions allow you to manage your application in a structured way, abstracting complex operations into simpler actions through various **providers** and **UI integrations**.

A typical resource definition looks like this:

```tsx title=App.tsx
import { Refine } from "@refinedev/core";

export const App = () => {
  return (
    <Refine
      resources={[
        {
          name: "products",
          list: "/my-products",
          show: "/my-products/:id",
          edit: "/my-products/:id/edit",
          create: "/my-products/new",
        },
      ]}
    >
      {/* ... */}
    </Refine>
  );
};
```

## Provider Concept

Providers are the building blocks of Refine, used to manage different aspects of your application, such as data fetching, routing, access control, and more.

They are pluggable, which means you can use the **built-in providers** or **create your own**. This allows you to customize the behavior of your application to suit your needs.

- **Data Provider**: Communication with the backend data source, handling data operations such as fetching, creating, updating, deleting records, caching, and invalidation.
- **Authentication Provider**: Manages user authentication and authorization processes. Handles redirection, error cases.
- **Access Control Provider**: Handles authorization and access control. Used to hide/disable buttons and menu items, or to protect routes and components.
- **Notification Provider**: Enables notification features like showing notification after successful mutations or errors.
- **I18n Provider**: Enables i18n features such as rendering translated menu items, button texts, table columns, page titles, and more.
- **Live Provider**: Enables real-time updates to your application. For example, when a user creates a new record, other users can see the new record in the list page without refreshing the page.
- **Router Provider**: Matches routes to resources, enables navigation features like breadcrumbs, automatic redirections after CRUD operations, rendering menu items.
- **Audit Log Provider**: Handles sending Audit Logs for CRUD operations.

## Hook Concept

Refine adopts a hook-based architecture, a modern and powerful pattern in React development, which significantly enhances the development experience and application performance.

Refine's hooks are **headless**, which means they are library agnostic, provides **a unified interface** for your needs regardless of your library or framework of your choice.

For example, we have different built-in router providers for **React Router**, **Next.js**, **Remix**, **Expo** that handles routing in your application.

But we have a single `useGo` hook, exported from `@refinedev/core` package, can be used to navigate to a specific resource's page in your application **regardless of your routing solution**.

This is just one example, we have many other hooks for data fetching, authentication, access control, notifications, i18n and more.

They are all **headless**, **library agnostic**, and **unified**.

You might be using [Casbin](https://casbin.org) or [Cerbos](https://cerbos.dev) for authorization, we have a single `useCan` hook to control access in your components.

Or you may prefer either `next-i18next` or `react-i18next` for i18n, we have a single `useTranslate` hook to handle translation.

## Providers

### Data Provider <GuideBadge id="guides-concepts/data-fetching" />

The Data Provider is the bridge between your frontend and your backend data source. It is responsible for handling all data-related operations such as fetching, caching, creating, updating, and deleting records.

Each data operation in the Data Provider is typically associated with a specific resource. For example, when fetching data for a `products` resource, the Data Provider will know which endpoint to hit and how to handle the response.

```tsx title=data-provider.ts
import { DataProvider } from "@refinedev/core";

const myDataProvider: DataProvider = {
  getOne: async ({ resource, id }) => {
    const response = await fetch(
      `https://example.com/api/v1/${resource}/${id}`,
    );
    const data = await response.json();

    return { data };
  },
  // other methods...
};
```

> Refine offers various built-in data providers for popular data sources like REST, Strapi, AirTable, Supabase, GraphQL, and more. See the [Data Providers](/docs/data/data-provider) page for more information.

#### Hooks

You can use `useList`, `useOne`, `useCreate`, `useEdit`, `useShow` hooks to fetch data in your components.

```tsx title=show.tsx
import { useOne } from "@refinedev/core";

export const MyPage = () => {
  const { data, isLoading } = useOne({ resource: "products", id: 1 });

  if (isLoading) {
    return <>Loading...</>;
  }

  return <>{data.name}</>;
};
```

### Authentication Provider <GuideBadge id="guides-concepts/authentication" />

The Authentication Provider centralizes the authentication and authorization processes in Refine applications.

It handles authentication and authorization processes such as login, logout, redirection, error handling, and more.

```tsx title=auth-provider.ts
import { AuthProvider } from "@refinedev/core'";

export const authProvider: AuthProvider = {
  login: async ({ email, password }) => {
    const { status } = handleLogin(email, password);

    if (status === 200) {
      return { success: true, redirectTo: "/dashboard" };
    } else {
      return {
        success: false,
        error: { name: "Login Error", message: "Invalid credentials" },
      };
    }
  },
  check: async (params) => ({}),
  logout: async (params) => ({}),
  onError: async (params) => ({}),
  register: async (params) => ({}),
  forgotPassword: async (params) => ({}),
  updatePassword: async (params) => ({}),
  getPermissions: async (params) => ({}),
  getIdentity: async (params) => ({}),
};
```

#### Components

You can use `Authenticated` component from `@refinedev/core` to protect your routes, components with authentication.

```tsx title=my-page.tsx
import { Authenticated } from "@refinedev/core";

const MyPage = () => (
  <Authenticated>
    // Only authenticated users can see this.
    <MyComponent />
  </Authenticated>
);
```

> See the [Authentication Components](/docs/guides-concepts/authentication#components) page for more information.

#### Hooks

You can use `useGetIdentity` hook to get current user.

```tsx title=show.tsx
import { useGetIdentity } from "@refinedev/core";

export const DashboardPage = () => {
  const {
    data: { name },
  } = useGetIdentity();

  return <>Welcome {name}!</>;
};
```

> See the [Authentication Hooks](/docs/guides-concepts/authentication#hooks) page for more information.

#### UI Integrations

We have pre-built components which work with Auth Provider out-of-the-box.

When provided, their Layout components can automatically render current user information on the header and add logout button to appropriate places.

You can also use `AuthPage` component of these integrations for `Login`, `Register`, `Forgot Password`, `Reset Password` pages.

See the [Auth Pages](#auth-pages) section below for live examples.

### Access Control Provider <GuideBadge id="guides-concepts/authorization" />

The Access Control Provider manages what users can access or perform within the application based on their permissions.

It uses the resource definition to determine access rights. For instance, it can decide whether a user can edit or delete record for `products` resource based on the resource definition.

```tsx title=App.tsx
import { AccessControlProvider, Refine } from "@refinedev/core";

const myAccessControlProvider: AccessControlProvider = {
  can: async ({ resource, action }) => {
    if (resource === "users" && action === "block") {
      return { can: false };
    }

    return { can: true };
  },
};

export const App = () => {
  return (
    <Refine accessControlProvider={myAccessControlProvider}>{/* ... */}</Refine>
  );
};
```

#### Components

You can wrap `CanAccess` component to wrap relevant parts of your application to control access.

```tsx title=my-page.tsx
import { CanAccess } from "@refinedev/core";

export const MyPage = () => {
  return (
    <CanAccess resource="users" action="show" params={{ id: 1 }}>
      <>
        My Page
        <CanAccess
          resource="users"
          action="block"
          params={{ id: 1 }}
          fallback={"You are not authorized."}
        >
          // Only authorized users can see this button.
          <BlockUserButton />
        </CanAccess>
      </>
    </CanAccess>
  );
};
```

#### Hooks

You can use `useCan` hook to control access in your components.

```tsx title=my-page.tsx
import { ErrorComponent, useCan } from "@refinedev/core";

export const MyPage = () => {
  const { data: show } = useCan({
    resource: "users",
    action: "show",
    params: { id: 1 },
  });
  const { data: block } = useCan({
    resource: "users",
    action: "block",
    params: { id: 1 },
  });

  if (!show?.can) {
    return <ErrorComponent />;
  }

  return (
    <>
      My Page
      {block?.can && <BlockUserButton />}
      {!block?.can && "You are not authorized."}
    </>
  );
};
```

#### UI Integrations

When provided, our UI Integrations work out-of-the-box with Access Control Provider.

For example if user isn't authorized to see `orders` resource, it will be hidden on the sidebar menu automatically.

Or if the current user isn't authorized to delete a product, the delete button will be disabled or hidden automatically.

```tsx title=my-page.tsx
import { DeleteButton } from "@refinedev/antd"; // or @refinedev/mui, @refinedev/chakra-ui, @refinedev/mantine

export const MyPage = () => {
  return (
    <>
      My Page
      {/* Only authorized users can see this button. */}
      <DeleteButton resource="users" recordItemId={1} />
    </>
  );
};
```

This applies to all buttons like `CreateButton`, `EditButton`, `ShowButton`, `ListButton`.

### Notification Provider <GuideBadge id="guides-concepts/notifications" />

Refine can automatically show notifications for CRUD operations and errors.

For example, after creating, updating, or deleting a record for `products` resource, or when an error occurs on form submission.

Refine has out-of-the-box notification providers for popular UI libraries like **Ant Design**, **Material UI**, **Chakra UI**, and **Mantine**.

#### Hooks

Our **data hooks**, **mutation hooks**, and **auth hooks** can automatically show notifications for actions and errors.

It's also possible to modify these notifications per hook.

```tsx title=my-page.tsx
import { useDelete } from "@refinedev/core";

export const MyPage = () => {
  const { mutate } = useDelete();

  return (
    <Button
      onClick={() => {
        mutate({
          resource: "products",
          id: 1,
          successNotification: () => ({
            message: "Product Deleted",
            description: "Product has been deleted successfully.",
            type: "success",
          }),
          errorNotification: () => ({
            message: "Product Delete Error",
            description: "An error occurred while deleting the product.",
            type: "error",
          }),
        });
      }}
    >
      Delete Product
    </Button>
  );
};
```

If you have a use-case that isn't covered, you can use `useNotification` hook to show notifications in your application.

```tsx title=my-page.tsx
import { useNotification } from "@refinedev/core";

export const MyPage = () => {
  const { open, close } = useNotification();

  return (
    <>
      <Button
        onClick={() => {
          open?.({
            key: "my-notification",
            message: "Test Notification",
            description: "This is a test notification.",
            type: "success", // success | error | progress
          });
        }}
      >
        Show notification
      </Button>
      <Button
        onClick={() => {
          close?.("my-notification");
        }}
      >
        Close Notification
      </Button>
    </>
  );
};
```

### I18n Provider <GuideBadge id="guides-concepts/i18n" />

I18n provider centralizes localization process in Refine applications.

```tsx title=App.tsx
import { Refine, I18nProvider } from "@refinedev/core";

const i18nProvider: I18nProvider = {
    translate: (key: string, options?: any, defaultMessage?: string) => string,
    changeLocale: (lang: string, options?: any) => Promise,
    getLocale: () => string,
};

export const App = () => {
  return (
    <Refine i18nProvider={i18nProvider} {/* ...*/}>
      {/* ... */}
    </Refine>
  )
}
```

#### Hooks

You can use `useTranslate`, `useSetLocale`, `useGetLocale` hooks to handle i18n in your components.

```tsx title=my-page.tsx
import { useTranslate, useSetLocale, useGetLocale } from "@refinedev/core";

export const MyPage = () => {
  const translate = useTranslate();
  const setLocale = useSetLocale();
  const getLocale = useGetLocale();

  return (
    <>
      Current Locale: {getLocale()}
      <Button onClick={() => setLocale("en")}>Set Locale to English</Button>
      <Button onClick={() => setLocale("de")}>Set Locale to German</Button>

      <Button>{translate("Hello")</Button>
    </>
  );
};

```

#### UI Integrations

When provided, our UI Integrations work out-of-the-box with I18n Provider.

For example, it will automatically translate menu items, button texts, table columns, page titles, and more.

### Router Provider <GuideBadge id="guides-concepts/routing" />

Router provider helps Refine understand the relationship between resources and routes. Enables navigation features like breadcrumbs, automatic redirections after CRUD operations, rendering menu items, inferring hook parameters, and more.

We have built-in router integrations for the following packages:

- React Router
- Next.js
- Remix
- Expo Router (React Native)

#### Components

**UI Integration** components can infer resource information from the current URL.

For example, we are in the list page of `products` resource, we have `List` layout component and we are adding `CreateButton` from one of our UI Integrations to redirect user to the create page of the resource.

With **router provider** current resource information will be inferred from the current URL.

```tsx title=products.tsx
import { List, CreateButton } from "@refinedev/antd"; // or @refinedev/mui, @refinedev/chakra-ui, @refinedev/mantine

export const ProductsListPage = () => {
  return (
    // Instead of <List resource="products">
    <List>
      {/* Instead of <CreateButton resource="products" /> */}
      <CreateButton /> // Redirects to /products/new
    </List>
  );
};
```

#### Hooks

Refine hooks can synchronize **resource**, **id**, **action** parameters from the current URL. This eliminates the need to pass them manually.

For example, `useShow` hook can infer `resource` and `id` parameters from the current URL.

```tsx title=show.tsx
import { useShow } from "@refinedev/core";

export const ShowPage = () => {
  // const { query } = useShow({ resource: "products", id: 1 });
  // We don't need to pass "resource" and "id" parameters manually.
  const { query } = useShow();

  const { data, isLoading } = query;

  if (isLoading) {
    return <>Loading...</>;
  }

  return <>{data?.data.name}</>;
};
```

Another example is `useTable` hook. While it can infer **resource**, **pagination**, **filters**, and **sorters** parameters from the current route, it can also update the current route if any of these parameters changes.

### Audit Log Provider <GuideBadge id="guides-concepts/audit-logs" />

Audit Log Provider centralizes retrieving audit logs in Refine applications.

It can be useful to show previous changes to your resources.

```tsx title="App.tsx"
import { AuditLogProvider, Refine } from "@refinedev/core";

const auditLogProvider: AuditLogProvider = {
  get: async (params) => {
    const { resource, meta, action, author, metaData } = params;

    const response = await fetch(
      `https://example.com/api/audit-logs/${resource}/${meta.id}`,
      {
        method: "GET",
      },
    );

    const data = await response.json();

    return data;
  },
};

export const App = () => {
  return <Refine auditLogProvider={auditLogProvider}>{/* ... */}</Refine>;
};
```

#### Hooks

You can use `useLogList` hook to retrieve audit logs for your resources in your components. It uses `AuditLogProvider`'s `get` method under the hood.

```tsx
import { useLogList } from "@refinedev/core";

const productsAuditLogResults = useLogList({
  resource: "products",
});
```

## UI Integrations <GuideBadge id="guides-concepts/ui-libraries" />

While Refine itself is headless, it offers UI Integrations for popular UI libraries:

- [Ant Design](/docs/ui-integrations/ant-design/introduction)
- [Material UI](/docs/ui-integrations/material-ui/introduction)
- [Chakra UI](/docs/ui-integrations/chakra-ui/introduction)
- [Mantine](/docs/ui-integrations/mantine/introduction)

These integrations use `@refinedev/core` under the hood, becomes a bridge between the UI library and the Refine framework.

<Tabs wrapContent={false}>

<TabItem value="Ant Design">

import { AntdLayout } from './layout/antd';

<AntdLayout />

</TabItem>

<TabItem value="Material UI">

import { MaterialUILayout } from './layout/mui';

<MaterialUILayout />

</TabItem>

<TabItem value="Chakra UI">

import { ChakraUILayout } from './layout/chakra';

<ChakraUILayout />

</TabItem>

<TabItem value="Mantine">

import { MantineLayout } from './layout/mantine';

<MantineLayout />

</TabItem>

</Tabs>

### Forms <GuideBadge id="guides-concepts/forms" />

Refine provides a set of hooks to handle form state, validation, submission, autosave, and more. These hooks seamlessly integrate with popular UI libraries, making it easier to use their form components.

- [React Hook Form](https://react-hook-form.com/) (for Headless, Material UI, Chakra UI) - [Documentation](/docs/packages/list-of-packages) - [Example](/examples/form/react-hook-form/useForm.md)
- [Ant Design Form](https://ant.design/components/form/#header) - [Documentation](/docs/ui-integrations/ant-design/hooks/use-form) - [Example](/examples/form/antd/useForm.md)
- [Mantine Form](https://mantine.dev/form/use-form) - [Documentation](/docs/ui-integrations/mantine/hooks/use-form) - [Example](/examples/form/mantine/useForm.md)

### Tables <GuideBadge id="guides-concepts/tables" />

Refine offers seamless integration with several popular UI libraries, simplifying the use of their table component features such as pagination, sorting, filtering, and more.

- [TanStack Table](https://react-table.tanstack.com/) (for Headless, Chakra UI, Mantine) - [Documentation](/docs/packages/list-of-packages) - [Example](/docs/examples/table/tanstack-table/basic-tanstack-table/)
- [Ant Design Table](https://ant.design/components/table/#header) - [Documentation](/docs/ui-integrations/ant-design/hooks/use-table) - [Example](/examples/table/antd/useTable.md)
- [Material UI DataGrid](https://mui.com/x/react-data-grid/) - [Documentation](/docs/ui-integrations/material-ui/hooks/use-data-grid) - [Example](/examples/table/mui/useDataGrid.md)

### Layout

UI Integrations provide a Layout component, which renders the **sidebar menu**, **header**, and **content** area of your application.

It automatically renders the sidebar menu based on the **resource definitions**, and the header based on the **current user**.

### CRUD Pages

`List`, `Create`, `Edit`, `Show` components.

These components provide layout views based on the resource information automatically like:

- Header with title
- Breadcrumb
- Translated texts
- CRUD Buttons

On top of that, Refine adds some features to these layouts:

- **Access Control**: If the current user isn't authorized to create a product, the create button will be disabled or hidden automatically.
- **Translation**: buttons, titles, columns will be translated to the current language of the user.

### Buttons

For example, our **UI Integrations** export `CreateButton`, for redirecting the user to the create page of the resource.

While the button itself is imported from underlying UI package, Refine adds some capabilities to it:

- **Routing**: when the button is clicked, the user will be redirected to the create page of the resource.
- **Access Control**: if current user isn't authorized, this button will be disabled or hidden automatically.
- **Translation**: the button's text will be translated to the current language of the user.

### Auth Pages

Common authentication pages like `Login`, `Register`, `Forgot Password`, `Reset Password` are integrated with `AuthProvider` automatically.

<Tabs wrapContent={false}>

<TabItem value="Headless">

import { HeadlessAuth } from './auth-pages/headless';

<HeadlessAuth/>

</TabItem>

<TabItem value="Ant Design">

import { AntdAuth } from "./auth-pages/antd";

<AntdAuth />

</TabItem>

<TabItem value="Material UI">

import { MaterialUIAuth } from "./auth-pages/mui";

<MaterialUIAuth />

</TabItem>

<TabItem value="Chakra UI">

import { ChakraUIAuth } from "./auth-pages/chakra";

<ChakraUIAuth />

</TabItem>

<TabItem value="Mantine">

import { MantineAuth } from "./auth-pages/mantine";

<MantineAuth />

</TabItem>

</Tabs>

### UI Integration Hooks

UI Integration hooks use `@refinedev/core` hooks under the hood, making it easier to use them in your UI specific components.

One example is, `useTable` hook from `@refinedev/antd` package. This hook uses `@refinedev/core`'s `useTable` under the hood, but returns props compatible with `Ant Design`'s `Table` component. So you don't need to manually map the props.

## Meta Concept

`meta` is a special property that can be used to provide additional information to **providers** and **UI Integrations**.

There are 3 ways to populate meta, they all will be **merged into a single meta property** and will be available to **providers** and **UI integrations**.

<Tabs>
<TabItem value="Meta from resource">

```tsx title=App.tsx
import { Refine } from "@refinedev/core";

export const App = () => {
  return (
    <Refine
      resources={[
        {
          name: "products",
          list: "/my-products",
          // highlight-start
          meta: {
            fromResource: "Hello from resource.meta",
          },
          // highlight-end
        },
      ]}
    >
      {/* ... */}
    </Refine>
  );
};
```

</TabItem>
<TabItem value="Meta from hook">

```tsx title=show.tsx
import { useShow } from "@refinedev/core";

export const ShowPage = () => {
  const {
    query: { data, isLoading },
    /* or use useOne */
  } = useShow({
    resource: "posts",
    id: "1",
    // highlight-start
    meta: {
      fromHook: "Hello from hook.meta",
    },
    // highlight-end
  });
};
```

</TabItem>
<TabItem value="Meta from URL">

Navigate to the following URL:

```
https://example.com/products?fromURL=Hello%20from%20URL
```

</TabItem>
</Tabs>

Given the above examples, meta fields from **3 different sources** will be available in the providers:

```tsx title=providers.tsx
import { AccessControlProvider, DataProvider } from "@refinedev/core";

export const myDataProvider = {
  getOne: async ({ meta }) => {
    console.log(meta.fromResource); // "Hello from resource.meta"
    console.log(meta.fromHook); // "Hello from hook.meta"
    console.log(meta.fromURL); // "Hello from URL"
  },
};

export const myAccessControlProvider = {
  can: async ({ meta }) => {
    console.log(meta.fromResource); // "Hello from resource.meta"
    console.log(meta.fromHook); // "Hello from hook.meta"
    console.log(meta.fromURL); // "Hello from URL"
  },
};
```

### Example Use Cases

- **Global filters**: pass a filter to your **data provider**.
- **Multi-tenancy**: make current tenant available id to providers.
- **Advanced Access Control**: configuration per resource.
- **Customize UI**: manage sidebar label and icon per resource.

These are some but not all examples of how you can use the `meta` property.

> See the [Refine Component](/docs/core/refine-component) page for more information.

## State Management

Refine leverages **React Query** for data fetching and caching, which enhances the performance and user experience of applications. React Query provides efficient data synchronization between your server and UI, making it easier to handle background updates, cache management, and data invalidation.

#### Data Fetching, Cache Management and Deduplication

Refine uses structured keys to identify and cache server responses for queries and mutations. These keys also help optimize performance by reusing cached data when needed. Using composable structured keys also allows for automatic deduplication of queries, which means that if there are multiple calls for the same query, only one request will be made and shared across all subscribers.

By default, Refine has 5 minutes of cache time and 0 seconds of stale time for queries. This means that if a query is re-used in 5 minutes, it will be populated with cached data and in the meantime, it will be refetched in the background. If the query is not re-used in 5 minutes, it will be refetched immediately.

To learn more about data fetching and caching, see the [Data Fetching](/docs/guides-concepts/data-fetching) guide.

#### Invalidation and Refetching

Structured key based state management of Refine also help with invalidation of related queries when a mutation occurs. For example, when a user creates a new record, Refine will automatically invalidate the related queries meaning that the data your users interact with is always fresh and consistent with the backend.

By default, invalidation is done for every related query of a mutation but refetching is done only for the queries that are currently in use, this means that if a user is not on the list page of a resource, the list query will not be refetched but will be invalidated so that when the user navigates to the list page, the data will be freshly fetched. Invalidation and refetching behavior can be customized by providing an `invalidates` property to the mutation or globally via [`<Refine />`](/docs/core/refine-component) component.

To learn more about invalidation, see the [Invalidation section of Forms](/docs/guides-concepts/forms#invalidation-) guide.

#### Optimistic Updates and Rollbacks

It's almost crucial to provide instant feedback to your users when they perform a mutation. Refine allows you to do this by providing **optimistic updates**. When a mutation occurs, Refine will automatically update the related queries with the new data, this means that your users will see the changes instantly. If the mutation fails, Refine will automatically rollback the changes and re-fetch the related queries.

Refine offers 3 different mutation modes, **pessimistic**, **optimistic**, and **undoable**. Optimistic updates will be done for **optimistic** and **undoable** modes. Additionally, **undoable** mode will allow your users to undo the changes they made for a certain period of time by showing a notification.

By default,

- **Update** mutations will perform optimistic updates to the related list, many and detail queries of the target resource.
- **Create** mutations will perform optimistic updates to the related list and many queries of the target resource.
- **Delete** mutations will perform optimistic updates to the related list and many queries of the target resource.

You can customize the optimistic update behavior and mutation modes through `optimisticUpdateMap` and `mutationMode` properties of the hooks or globally via [`<Refine />`](/docs/core/refine-component) component.

To learn more about optimistic updates, see the [Optimistic Updates section of Forms](/docs/guides-concepts/forms#optimistic-updates) guide.

#### Key Structure

Keys are used to identify and cache server responses for queries and mutations. Refine uses a structured key format which can be re-composed with the same parameters to get the same key. This allows Refine users to have full control over the cache and invalidation behavior of their applications. All the query cache and mutations can be tracked and managed by using these keys.

`@refinedev/core` exposes a `keys` method which can be used to generate keys for queries and mutations. If you are willing to perform some advanced operations on the cache, you can use this method to generate keys and use them to get the related query or mutation cache.

:::simple Structural Order of Keys

- Refine's query keys are structured to go from general to specific. At the outmost level, the key contains the information about the operation type (It can be `"auth"`, `"data"`, `"audit"` or `"access"`).

- If it's the `"data"` type, the next level contains the information about the data provider it uses.

- Then the next level contains the information about the resource it operates on.

- After the resource information, the next level contains the information about the operation type (It can be `"list"`, `"infinite"`, `"many"`, `"one"`).

- Then the next level contains the information about the operation parameters (It can be `"filters"`, `"sorters"`, `"pagination"`, `"id"` etc.) and also the content of the `meta` property.

- Keep in mind, Refine will treat `meta` properties as a part of the keys and differentiate the queries based on the `meta` properties.

:::

An example key for a list query of the `products` resource with `filters` would be generated as follows:

```tsx
import { useList, keys } from "@refinedev/core";

const Component = () => {
  const response = useList({
    resource: "products",
    filters: [
      {
        field: "title",
        operator: "contains",
        value: "test",
      },
    ],
  });

  // This key will be generated by useList and used to identify the query and cache the response.
  const generatedKey = keys()
    .data("default") // Name of the data provider
    .resource("products") // Identifier of the resource
    .action("list") // Type of the operation
    .params({
      filters: [{ field: "title", operator: "contains", value: "test" }],
    }) // Parameters of the operation
    .get();

  console.log(generatedKey);
  // ^ ["data", "default", "products", "list", { filters: [{ field: "title", operator: "contains", value: "test" }] }]
};
```

## Developer Experience

### CLI

Refine CLI allows you to interact with your Refine project and perform certain tasks such as creating a new resource, managing version updates, swizzling components, running your project (build, start, dev).

> See the [CLI](/docs/packages/list-of-packages) page for more information.

### Devtools

**Refine Devtools** is designed to help you debug and develop your Refine apps. It will be a collection of features including monitoring queries and mutations, testing out inferencer generated codes, adding and updating Refine packages from the UI and more.

> See the [Devtools](https://github.com/refinedev/refine/tree/main/packages/devtools) package for more information.

### Inferencer

`@refinedev/inferencer` is a package that automatically generates basic boilerplate code for your application based on API responses, serving as a starting point to save time. However, it's not always reliable for all cases and isn't intended for production use.

> See the [Inferencer](/docs/packages/list-of-packages) page for more information.

For example, the following code:

```tsx title="list.tsx"
import { AntdInferencer } from "@refinedev/inferencer/antd";
// or @refinedev/inferencer/mui, @refinedev/inferencer/chakra, @refinedev/inferencer/mantine, @refinedev/inferencer/headless

export const ProductList = () => {
  // Scaffolds List page.
  return <AntdInferencer />;
};

export const ProductShow = () => {
  // Scaffolds Show page.
  return <AntdInferencer />;
};

export const ProductEdit = () => {
  // Scaffolds Edit page with form.
  return <AntdInferencer />;
};

export const ProductCreate = () => {
  // Scaffolds Create page with form.
  return <AntdInferencer />;
};
```

An example of **List Page** scaffolded by inferencer looks like this;

```tsx title="generated-list.tsx"
import { List, ShowButton, useTable } from "@refinedev/antd";
import { BaseRecord } from "@refinedev/core";
import { Space, Table } from "antd";
import React from "react";

export const ProductList = () => {
  const { tableProps } = useTable({
    syncWithLocation: true,
  });

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
        <Table.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record: BaseRecord) => (
            <Space>
              <ShowButton hideText size="small" recordItemId={record.id} />
            </Space>
          )}
        />
      </Table>
    </List>
  );
};
```

================
File: guides-concepts/general-concepts/layout/antd.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function AntdLayout() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/inferencer": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/my-products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
        },
        "/pages/products/show.tsx": {
          code: ShowTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { App as AntdApp, ConfigProvider } from "antd";
import { BrowserRouter, Route, Routes, Outlet } from "react-router";
import "@refinedev/antd/dist/reset.css";
import { ErrorComponent, RefineThemes, ThemedLayoutV2 } from "@refinedev/antd";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
import { ProductList } from "./pages/products/list.tsx";
import { ProductShow } from "./pages/products/show.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <AntdApp>
          <Refine
            routerProvider={routerProvider}
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            authProvider={{
              check: async () => ({  authenticated: true }),
              getIdentity: async () => ({ id: 1, name: "John Doe", avatar: "https://i.pravatar.cc/300"})
            }}
            resources={[
              {
                name: "products",
                list: "/my-products",
                show: "/my-products/:id"
              }
            ]}
            options={{ syncWithLocation: true }}
          >
            <Routes>
              <Route
                element={
                  <ThemedLayoutV2>
                    <Outlet />
                  </ThemedLayoutV2>
                }
              >
                <Route path="/my-products" element={<ProductList />} />
                <Route path="/my-products/:id" element={<ProductShow />} />
                <Route path="*" element={<ErrorComponent />} />
              </Route>
            </Routes>
          </Refine>
        </AntdApp>
      </ConfigProvider>
    </BrowserRouter>
  );
};
`.trim();
const ListTsxCode = `
import { List, ShowButton, useTable } from "@refinedev/antd";
import { BaseRecord } from "@refinedev/core";
import { Space, Table } from "antd";
import React from "react";
export const ProductList = () => {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
        <Table.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record: BaseRecord) => (
            <Space>
              <ShowButton hideText size="small" recordItemId={record.id} />
            </Space>
          )}
        />
      </Table>
    </List>
  );
};
`.trim();
const ShowTsxCode = `
import { MarkdownField, NumberField, Show, TextField } from "@refinedev/antd";
import { useShow } from "@refinedev/core";
import { Typography } from "antd";
import React from "react";
const { Title } = Typography;
export const ProductShow = () => {
  const { query } = useShow();
  const { data, isLoading } = query;
  const record = data?.data;
  return (
    <Show isLoading={isLoading}>
      <Title level={5}>Id</Title>
      <NumberField value={record?.id ?? ""} />
      <Title level={5}>Name</Title>
      <TextField value={record?.name} />
      <Title level={5}>Material</Title>
      <TextField value={record?.material} />
      <Title level={5}>Description</Title>
      <MarkdownField value={record?.description} />
      <Title level={5}>Price</Title>
      <NumberField value={record?.price ?? ""} />
    </Show>
  );
};
`.trim();

================
File: guides-concepts/general-concepts/layout/chakra.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function ChakraUILayout() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/chakra-ui": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/inferencer": "latest",
        "@refinedev/react-table": "latest",
        "react-router": "^7.0.2",
        "@tabler/icons-react": "^3.1.0",
        "@chakra-ui/react": "^2.5.1",
      }}
      startRoute="/my-products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
        },
        "/pages/products/show.tsx": {
          code: ShowTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { ChakraProvider } from "@chakra-ui/react";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import {
  ErrorComponent,
  RefineThemes,
  ThemedLayoutV2,
} from "@refinedev/chakra-ui";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
import { ProductList } from "./pages/products/list.tsx";
import { ProductShow } from "./pages/products/show.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <ChakraProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          authProvider={{
            check: async () => ({ authenticated: true }),
            getIdentity: async () => ({
              id: 1,
              name: "John Doe",
              avatar: "https://i.pravatar.cc/300",
            }),
          }}
          resources={[
            {
              name: "products",
              list: "/my-products",
              show: "/my-products/:id",
            },
          ]}
          options={{ syncWithLocation: true }}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="/my-products" element={<ProductList />} />
              <Route path="/my-products/:id" element={<ProductShow />} />
              <Route path="*" element={<ErrorComponent />} />
            </Route>
          </Routes>
        </Refine>
      </ChakraProvider>
    </BrowserRouter>
  );
}
`.trim();
const ListTsxCode = `
import React from "react";
import {
  Box,
  Button,
  HStack,
  IconButton,
  Table,
  TableContainer,
  Tbody,
  Td,
  Th,
  Thead,
  Tr,
} from "@chakra-ui/react";
import { List, ShowButton, usePagination } from "@refinedev/chakra-ui";
import { useTable } from "@refinedev/react-table";
import { IconChevronLeft, IconChevronRight } from "@tabler/icons-react";
import { ColumnDef, flexRender } from "@tanstack/react-table";
export const ProductList = () => {
  const columns = React.useMemo<ColumnDef<any>[]>(
    () => [
      {
        id: "id",
        accessorKey: "id",
        header: "Id",
      },
      {
        id: "name",
        accessorKey: "name",
        header: "Name",
      },
      {
        id: "material",
        accessorKey: "material",
        header: "Material",
      },
      {
        id: "actions",
        accessorKey: "id",
        header: "Actions",
        cell: function render({ getValue }) {
          return (
            <HStack>
              <ShowButton hideText recordItemId={getValue() as string} />
            </HStack>
          );
        },
      },
    ],
    [],
  );
  const {
    getHeaderGroups,
    getRowModel,
    refineCore: { setCurrent, pageCount, current },
  } = useTable({
    columns,
  });
  return (
    <List>
      <TableContainer whiteSpace="pre-line">
        <Table variant="simple">
          <Thead>
            {getHeaderGroups().map((headerGroup) => (
              <Tr key={headerGroup.id}>
                {headerGroup.headers.map((header) => (
                  <Th key={header.id}>
                    {!header.isPlaceholder &&
                      flexRender(
                        header.column.columnDef.header,
                        header.getContext(),
                      )}
                  </Th>
                ))}
              </Tr>
            ))}
          </Thead>
          <Tbody>
            {getRowModel().rows.map((row) => (
              <Tr key={row.id}>
                {row.getVisibleCells().map((cell) => (
                  <Td key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </Td>
                ))}
              </Tr>
            ))}
          </Tbody>
        </Table>
      </TableContainer>
      <Pagination
        current={current}
        pageCount={pageCount}
        setCurrent={setCurrent}
      />
    </List>
  );
};
type PaginationProps = {
  current: number;
  pageCount: number;
  setCurrent: (page: number) => void;
};
const Pagination: React.FC<PaginationProps> = ({
  current,
  pageCount,
  setCurrent,
}) => {
  const pagination = usePagination({
    current,
    pageCount,
  });
  return (
    <Box display="flex" justifyContent="flex-end">
      <HStack my="3" spacing="1">
        {pagination?.prev && (
          <IconButton
            aria-label="previous page"
            onClick={() => setCurrent(current - 1)}
            disabled={!pagination?.prev}
            variant="outline"
          >
            <IconChevronLeft size="18" />
          </IconButton>
        )}
        {pagination?.items.map((page) => {
          if (typeof page === "string") return <span key={page}>...</span>;
          return (
            <Button
              key={page}
              onClick={() => setCurrent(page)}
              variant={page === current ? "solid" : "outline"}
            >
              {page}
            </Button>
          );
        })}
        {pagination?.next && (
          <IconButton
            aria-label="next page"
            onClick={() => setCurrent(current + 1)}
            variant="outline"
          >
            <IconChevronRight size="18" />
          </IconButton>
        )}
      </HStack>
    </Box>
  );
};
`.trim();
const ShowTsxCode = `
import { Heading } from "@chakra-ui/react";
import {
  MarkdownField,
  NumberField,
  Show,
  TextField,
} from "@refinedev/chakra-ui";
import { useShow } from "@refinedev/core";
export const ProductShow = () => {
  const { query } = useShow();
  const { data, isLoading } = query;
  const record = data?.data;
  return (
    <Show isLoading={isLoading}>
      <Heading as="h5" size="sm" mt={4}>
        Id
      </Heading>
      <NumberField value={record?.id ?? ""} />
      <Heading as="h5" size="sm" mt={4}>
        Name
      </Heading>
      <TextField value={record?.name} />
      <Heading as="h5" size="sm" mt={4}>
        Material
      </Heading>
      <TextField value={record?.material} />
      <Heading as="h5" size="sm" mt={4}>
        Description
      </Heading>
      <MarkdownField value={record?.description} />
      <Heading as="h5" size="sm" mt={4}>
        Price
      </Heading>
      <NumberField value={record?.price ?? ""} />
    </Show>
  );
};
`.trim();

================
File: guides-concepts/general-concepts/layout/mantine.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function MantineLayout() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/mantine": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/inferencer": "latest",
        "@refinedev/react-table": "latest",
        "react-router": "^7.0.2",
        "@tabler/icons-react": "^3.1.0",
        "@emotion/react": "^11.8.2",
        "@mantine/core": "^5.10.4",
        "@mantine/hooks": "^5.10.4",
        "@mantine/notifications": "^5.10.4",
      }}
      startRoute="/my-products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
        },
        "/pages/products/show.tsx": {
          code: ShowTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Global, MantineProvider } from "@mantine/core";
import { NotificationsProvider } from "@mantine/notifications";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import { Refine } from "@refinedev/core";
import {
  ErrorComponent,
  RefineThemes,
  ThemedLayoutV2,
} from "@refinedev/mantine";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
import { ProductList } from "./pages/products/list.tsx";
import { ProductShow } from "./pages/products/show.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <MantineProvider
        theme={RefineThemes.Blue}
        withNormalizeCSS
        withGlobalStyles
      >
        <Global styles={{ body: { WebkitFontSmoothing: "auto" } }} />
        <NotificationsProvider position="top-right">
          <Refine
            routerProvider={routerProvider}
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            authProvider={{
              check: async () => ({ authenticated: true }),
              getIdentity: async () => ({
                id: 1,
                name: "John Doe",
                avatar: "https://i.pravatar.cc/300",
              }),
            }}
            resources={[
              {
                name: "products",
                list: "/my-products",
                show: "/my-products/:id",
              },
            ]}
            options={{ syncWithLocation: true }}
          >
            <Routes>
              <Route
                element={
                  <ThemedLayoutV2>
                    <Outlet />
                  </ThemedLayoutV2>
                }
              >
                <Route path="/my-products" element={<ProductList />} />
                <Route path="/my-products/:id" element={<ProductShow />} />
                <Route path="*" element={<ErrorComponent />} />
              </Route>
            </Routes>
          </Refine>
        </NotificationsProvider>
      </MantineProvider>
    </BrowserRouter>
  );
}
`.trim();
const ListTsxCode = `
import { Group, Pagination, ScrollArea, Table } from "@mantine/core";
import { List, ShowButton } from "@refinedev/mantine";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";
import React from "react";
export const ProductList = () => {
  const columns = React.useMemo<ColumnDef<any>[]>(
    () => [
      {
        id: "id",
        accessorKey: "id",
        header: "Id",
      },
      {
        id: "name",
        accessorKey: "name",
        header: "Name",
      },
      {
        id: "actions",
        accessorKey: "id",
        header: "Actions",
        cell: function render({ getValue }) {
          return (
            <Group spacing="xs" noWrap>
              <ShowButton hideText recordItemId={getValue() as string} />
            </Group>
          );
        },
      },
    ],
    [],
  );
  const {
    getHeaderGroups,
    getRowModel,
    setOptions,
    refineCore: {
      setCurrent,
      pageCount,
      current,
      tableQuery: { data: tableData },
    },
  } = useTable({
    columns,
  });
  return (
    <List>
      <ScrollArea>
        <Table highlightOnHover>
          <thead>
            {getHeaderGroups().map((headerGroup) => (
              <tr key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  return (
                    <th key={header.id}>
                      {!header.isPlaceholder &&
                        flexRender(
                          header.column.columnDef.header,
                          header.getContext(),
                        )}
                    </th>
                  );
                })}
              </tr>
            ))}
          </thead>
          <tbody>
            {getRowModel().rows.map((row) => {
              return (
                <tr key={row.id}>
                  {row.getVisibleCells().map((cell) => {
                    return (
                      <td key={cell.id}>
                        {flexRender(
                          cell.column.columnDef.cell,
                          cell.getContext(),
                        )}
                      </td>
                    );
                  })}
                </tr>
              );
            })}
          </tbody>
        </Table>
      </ScrollArea>
      <br />
      <Pagination
        position="right"
        total={pageCount}
        page={current}
        onChange={setCurrent}
      />
    </List>
  );
};
`.trim();
const ShowTsxCode = `
import { Title } from "@mantine/core";
import { useShow } from "@refinedev/core";
import {
  MarkdownField,
  NumberField,
  Show,
  TextField,
} from "@refinedev/mantine";
export const ProductShow = () => {
  const { query } = useShow();
  const { data, isLoading } = query;
  const record = data?.data;
  return (
    <Show isLoading={isLoading}>
      <Title my="xs" order={5}>
        Id
      </Title>
      <NumberField value={record?.id ?? ""} />
      <Title my="xs" order={5}>
        Name
      </Title>
      <TextField value={record?.name} />
      <Title my="xs" order={5}>
        Material
      </Title>
      <TextField value={record?.material} />
      <Title mt="xs" order={5}>
        Description
      </Title>
      <MarkdownField value={record?.description} />
      <Title my="xs" order={5}>
        Price
      </Title>
      <NumberField value={record?.price ?? ""} />
    </Show>
  );
};
`.trim();

================
File: guides-concepts/general-concepts/layout/mui.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function MaterialUILayout() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/inferencer": "latest",
        "@refinedev/mui": "latest",
        "react-router": "^7.0.2",
        "@emotion/react": "^11.8.2",
        "@emotion/styled": "^11.8.1",
        "@mui/lab": "^6.0.0-beta.14",
        "@mui/material": "^6.1.7",
        "@mui/system": "latest",
        "@mui/x-data-grid": "7.23.5",
      }}
      startRoute="/my-products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
        },
        "/pages/products/show.tsx": {
          code: ShowTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import CssBaseline from "@mui/material/CssBaseline";
import GlobalStyles from "@mui/material/GlobalStyles";
import { ThemeProvider } from "@mui/material/styles";
import { BrowserRouter, Outlet, Route, Routes } from "react-router";
import { Refine } from "@refinedev/core";
import { ErrorComponent, RefineThemes, ThemedLayoutV2 } from "@refinedev/mui";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
import { ProductList } from "./pages/products/list.tsx";
import { ProductShow } from "./pages/products/show.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <ThemeProvider theme={RefineThemes.Blue}>
        <CssBaseline />
        <GlobalStyles styles={{ html: { WebkitFontSmoothing: "auto" } }} />
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          authProvider={{
            check: async () => ({ authenticated: true }),
            getIdentity: async () => ({
              id: 1,
              name: "John Doe",
              avatar: "https://i.pravatar.cc/300",
            }),
          }}
          resources={[
            {
              name: "products",
              list: "/my-products",
              show: "/my-products/:id",
            },
          ]}
          options={{ syncWithLocation: true }}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="/my-products" element={<ProductList />} />
              <Route path="/my-products/:id" element={<ProductShow />} />
              <Route path="*" element={<ErrorComponent />} />
            </Route>
          </Routes>
        </Refine>
      </ThemeProvider>
    </BrowserRouter>
  );
}
`.trim();
const ListTsxCode = `
import { DataGrid, GridColDef } from "@mui/x-data-grid";
import { List, ShowButton, useDataGrid } from "@refinedev/mui";
import React from "react";
export const ProductList = () => {
  const { dataGridProps } = useDataGrid();
  const columns = React.useMemo<GridColDef[]>(
    () => [
      {
        field: "id",
        headerName: "Id",
        type: "number",
        minWidth: 50,
      },
      {
        field: "name",
        flex: 1,
        headerName: "Name",
        minWidth: 200,
      },
      {
        field: "material",
        flex: 1,
        headerName: "Material",
        minWidth: 200,
      },
      {
        field: "actions",
        headerName: "Actions",
        sortable: false,
        display: "flex",
        renderCell: function render({ row }) {
          return (
            <>
              <ShowButton hideText recordItemId={row.id} />
            </>
          );
        },
        align: "center",
        headerAlign: "center",
        minWidth: 80,
      },
    ],
    [],
  );
  return (
    <List>
      <DataGrid {...dataGridProps} columns={columns} />
    </List>
  );
};
`.trim();
const ShowTsxCode = `
import { Stack, Typography } from "@mui/material";
import { useShow } from "@refinedev/core";
import {
  MarkdownField,
  NumberField,
  Show,
  TextFieldComponent as TextField,
} from "@refinedev/mui";
export const ProductShow = () => {
  const { query } = useShow();
  const { data, isLoading } = query;
  const record = data?.data;
  return (
    <Show isLoading={isLoading}>
      <Stack gap={1}>
        <Typography variant="body1" fontWeight="bold">
          Id
        </Typography>
        <NumberField value={record?.id ?? ""} />
        <Typography variant="body1" fontWeight="bold">
          Name
        </Typography>
        <TextField value={record?.name} />
        <Typography variant="body1" fontWeight="bold">
          Material
        </Typography>
        <TextField value={record?.material} />
        <Typography variant="body1" fontWeight="bold">
          Description
        </Typography>
        <MarkdownField value={record?.description} />
        <Typography variant="body1" fontWeight="bold">
          Price
        </Typography>
        <NumberField value={record?.price ?? ""} />
      </Stack>
    </Show>
  );
};
`.trim();

================
File: guides-concepts/i18n/i18n-headless.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
import en from "./locales/en/common.json";
import de from "./locales/de/common.json";
export default function I18nExample() {
  return (
    <Sandpack
      height={460}
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "react-i18next": "^11.8.11",
        i18next: "^20.1.0",
        "i18next-browser-languagedetector": "^6.1.1",
        "i18next-xhr-backend": "^3.2.2",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          active: true,
        },
        "i18n.ts": {
          code: i18nTsxCode,
        },
        "/locales/en/common.json": {
          code: JSON.stringify(en, null, 2),
        },
        "/locales/de/common.json": {
          code: JSON.stringify(de, null, 2),
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { I18nProvider } from "@refinedev/core";
import { useTranslation } from "react-i18next";
import { HomePage } from "./home-page";
import "./i18n";
const App: React.FC = () => {
  const { t, i18n } = useTranslation();
  const i18nProvider: I18nProvider = {
      translate: (key: string, params: object) => {
          return t(key, params);
      },
      changeLocale: (lang: string) => i18n.changeLanguage(lang),
      getLocale: () => i18n.language,
  };
  return (
      <Refine
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          i18nProvider={i18nProvider}
      >
          <HomePage />
      </Refine>
  );
};
export default App;
`.trim();
const HomePageTsxCode = /* jsx */ `
import React from "react";
import { useTranslation } from "@refinedev/core";
export const HomePage = () => {
    const { translate, getLocale, changeLocale } = useTranslation();
    return (
        <div>
            <h1>{translate("page.home.title")}</h1>
            <select
                value={getLocale()}
                onChange={(e) => changeLocale(e.target.value)}
            >
                <option value="en">English</option>
                <option value="de">German</option>
            </select>
        </div>
    );
};
`.trim();
const i18nTsxCode = /* jsx */ `
import i18n from "i18next";
import { initReactI18next } from "react-i18next";
import en from "./locales/en/common.json";
import de from "./locales/de/common.json";
i18n.use(initReactI18next).init({
    lng: "en",
    resources: {
        en: {
            translation: en,
        },
        de: {
            translation: de,
        },
    },
    supportedLngs: ["en", "de"],
    fallbackLng: ["en", "de"],
});
export default i18n;
`.trim();

================
File: guides-concepts/i18n/index.md
================
---
title: Internationalization (i18n)
---

import I18nHeadless from './i18n-headless.tsx';
import TranslationFileEN from '../../partials/\_partial-translation-file-en.md';
import TranslationFileDE from '../../partials/\_partial-translation-file-de.md';

Internationalization (i18n) is a process that allows software applications to be localized for different regions and languages. Refine can work with any i18n framework, but needs an [`i18nProvider`](/docs/i18n/i18n-provider) to be created based on the chosen library.

## i18n Provider

[`i18nProvider`](/docs/i18n/i18n-provider) centralizes localization process in Refine applications. With flexible interface you can use any i18n library you want.

Here is the basic example `i18nProvider` with [react-i18next](https://react.i18next.com/). We will explain the details in the following sections.

<I18nHeadless />

## Example

:::simple Good to know

- We will use the [Ant Design](https://ant.design/) UI library in this example. You can use any UI library you want.
- We recommend using [`create refine-app`][create-refine-app] to initialize your Refine projects as it configures the project according to your needs, i18n support included if you choose it in the CLI
- For more information, refer to the [react-i18next documentation&#8594](https://react.i18next.com/getting-started)
- This example is for SPA react apps, for Next.js refer to [i18n Next.js example&#8594][i18nnextjs]

:::

First of all, Refine expects the `i18nProvider` type as follows:

```ts
import { I18nProvider } from "@refinedev/core";

const i18nProvider: I18nProvider = {
  translate: (key: string, options?: any, defaultMessage?: string) => string,
  changeLocale: (lang: string, options?: any) => Promise,
  getLocale: () => string,
};
```

After creating a `i18nProvider`, you can pass it to the `<Refine />` component:

```tsx title="src/App.tsx"
import { Refine } from "@refinedev/core";

import i18nProvider from "./i18nProvider";

const App: React.FC = () => {
  return (
    <Refine
      // highlight-next-line
      i18nProvider={i18nProvider}
      /* ... */
    >
      {/* ... */}
    </Refine>
  );
};
```

This will allow us to put translation features to the [`useTranslation`][use-translation] hook

Let's add multi-language support to our application using the `react-i18next` framework. When we are done, our application will support both German and English.

### Installation

To install both `react-i18next` and `i18next` packages, run the following command within your project directory:

<InstallPackagesCommand args="react-i18next i18next i18next-http-backend i18next-browser-languagedetector"/>

### Creating the i18n Instance

First, we will create an i18n instance using `react-i18next`.

```ts title="src/i18n.ts"
import i18n from "i18next";
import { initReactI18next } from "react-i18next"; // https://react.i18next.com/latest/using-with-hooks
import Backend from "i18next-http-backend"; // For lazy loading for translations: https://github.com/i18next/i18next-http-backend
import detector from "i18next-browser-languagedetector"; // For auto detecting the user language: https://github.com/i18next/i18next-browser-languageDetector

i18n
  .use(Backend)
  .use(detector)
  .use(initReactI18next)
  .init({
    supportedLngs: ["en", "de"],
    backend: {
      loadPath: "/locales/{{lng}}/{{ns}}.json", // locale files path
    },
    ns: ["common"],
    defaultNS: "common",
    fallbackLng: ["en", "de"],
  });

export default i18n;
```

### Wrapping the app with React.Suspense

Then we will import the i18n instance we created and wrap the application with `React.Suspense`.

```tsx title="src/index.tsx"
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";

// highlight-next-line
import "./i18n";

const container = document.getElementById("root");
const root = createRoot(container!);
root.render(
  <React.StrictMode>
    // highlight-start
    <React.Suspense fallback="loading">
      <App />
    </React.Suspense>
    // highlight-end
  </React.StrictMode>,
);
```

### Creating the i18n Provider

Next, we will include the i18n instance and create the `i18nProvider` using `react-i18next`.

```tsx title="src/App.tsx"
// highlight-next-line
import type { I18nProvider } from "@refinedev/core";
import { Refine } from "@refinedev/core";
// highlight-next-line
import { useTranslation } from "react-i18next";

const App: React.FC = () => {
  // highlight-start
  const { t, i18n } = useTranslation();

  const i18nProvider: I18nProvider = {
    translate: (key: string, options?: any) => t(key, options),
    changeLocale: (lang: string) => i18n.changeLanguage(lang),
    getLocale: () => i18n.language,
  };
  // highlight-end

  return (
    <Refine
      // highlight-next-line
      i18nProvider={i18nProvider}
      /* ... */
    >
      {/* ... */}
    </Refine>
  );
};
```

After we pass the `i18nProvider` to the `<Refine />` component, [`useTranslation`][use-translation] hook will be ready for use.

### Adding the Translations Files

Before we get started, let's look at which parts are going to be translated:

<details>
<summary>The translation file</summary>

 <TranslationFileEN />

</details>

Now, let's add the language files:

```
|-- public
|   |-- locales
|       |-- en
|       |   |-- common.json
|       |-- de
|           |-- common.json
|-- src
|-- package.json
|-- tsconfig.json
```

<Tabs
defaultValue="en"
values={[{ label: "English", value: "en" }, { label: "German", value: "de" }]}>
<TabItem value="en">

<details>
<summary>Show translation file</summary>

<TranslationFileEN />

</details>

</TabItem>
<TabItem value="de">

<details>
<summary>Show translation file</summary>

<TranslationFileDE />

</details>

</TabItem>
</Tabs>

All of Refine's components support i18n, meaning that if you want to change their text, you can create your own translation files with the reference to the keys above. We can override Refine's default texts by changing the `common.json` files in the example above.

### Changing The Locale

Next, we will create a `<Header />` component. This component will allow us to change the language.

```tsx title="src/components/header.tsx"
import { DownOutlined } from "@ant-design/icons";
import { useTranslation } from "@refinedev/core";
import { Avatar, Button, Dropdown, Layout, Menu, Space } from "antd";
import { useTranslation } from "react-i18next";

export const Header: React.FC = () => {
  const { i18n } = useTranslation();
  const { getLocale, changeLocale } = useTranslation();
  const currentLocale = getLocale();

  const menu = (
    <Menu selectedKeys={currentLocale ? [currentLocale] : []}>
      {[...(i18n.languages || [])].sort().map((lang: string) => (
        <Menu.Item
          key={lang}
          onClick={() => changeLocale(lang)}
          icon={
            <span style={{ marginRight: 8 }}>
              <Avatar size={16} src={`/images/flags/${lang}.svg`} />
            </span>
          }
        >
          {lang === "en" ? "English" : "German"}
        </Menu.Item>
      ))}
    </Menu>
  );

  return (
    <Layout.Header
      style={{
        display: "flex",
        justifyContent: "flex-end",
        alignItems: "center",
        padding: "0px 24px",
        height: "48px",
        backgroundColor: "#FFF",
      }}
    >
      <Dropdown overlay={menu}>
        <Button type="link">
          <Space>
            <Avatar size={16} src={`/images/flags/${currentLocale}.svg`} />
            {currentLocale === "en" ? "English" : "German"}
            <DownOutlined />
          </Space>
        </Button>
      </Dropdown>
    </Layout.Header>
  );
};
```

<br/>

Then, we will pass `<Header>` to our `<Layout>` component.

```tsx title="src/App.tsx"
import { Refine, Resource } from "@refinedev/core";
import { ThemedLayoutV2 } from "@refinedev/antd";

import { useTranslation } from "react-i18next";

import "./i18n";

// highlight-next-line
import { Header } from "components";

const App: React.FC = () => {
    const { t, i18n } = useTranslation();

    const i18nProvider = {
        translate: (key: string, options?: any) => t(key, options),
        changeLocale: (lang: string) => i18n.changeLanguage(lang),
        getLocale: () => i18n.language,
    };

    return (
        <Refine
            i18nProvider={i18nProvider}
            /* ... */
        >
            <ThemedLayoutV2
                // highlight-next-line
                header={<Header />}
            >
                {/* ... */}
            </Layout>
        </Refine>
    );
};
```

<br />

Finally, we will create the `<PostList>` page and then we will translate texts using [`useTranslation`][use-translation].

```tsx title="src/App.tsx"
import {
  // highlight-next-line
  useTranslation,
  useMany,
} from "@refinedev/core";
import {
  List,
  useTable,
  TextField,
  EditButton,
  ShowButton,
} from "@refinedev/antd";
import { Table, Space } from "antd";

import { IPost, ICategory } from "interfaces";

export const PostList: React.FC = () => {
  // highlight-next-line
  const { translate } = useTranslation();
  const { tableProps } = useTable<IPost>();

  const categoryIds =
    tableProps?.dataSource?.map((item) => item.category.id) ?? [];
  const { data, isLoading } = useMany<ICategory>({
    resource: "categories",
    ids: categoryIds,
    queryOptions: {
      enabled: categoryIds.length > 0,
    },
  });

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column
          dataIndex="title"
          // highlight-next-line
          title={translate("posts.fields.title")}
        />
        <Table.Column
          dataIndex={["category", "id"]}
          // highlight-next-line
          title={translate("posts.fields.category")}
          render={(value) => {
            if (isLoading) {
              return <TextField value="Loading..." />;
            }

            return (
              <TextField
                value={data?.data.find((item) => item.id === value)?.title}
              />
            );
          }}
        />
        <Table.Column<IPost>
          // highlight-next-line
          title={translate("table.actions")}
          dataIndex="actions"
          key="actions"
          render={(_value, record) => (
            <Space>
              <EditButton size="small" recordItemId={record.id} />
              <ShowButton size="small" recordItemId={record.id} />
            </Space>
          )}
        />
      </Table>
    </List>
  );
};
```

```ts title="interfaces/index.d.ts"
export interface ICategory {
  id: number;
  title: string;
}

export interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}
```

<Image src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/i18n/changing-language.gif" alt="Language change action" />

## Translation file

All of Refine's components supports `i18n`, meaning that if you want to change their text, you can create your own translation files to override Refine's default texts.

Here is the list of all translation keys that you can override:

<details>
<summary>Show translation file</summary>

<TranslationFileEN />

</details>

[i18nnextjs]: /examples/i18n/i18n-nextjs.md
[react-i18next]: https://react.i18next.com/
[create-refine-app]: /docs/getting-started/quickstart.md
[use-translation]: /docs/i18n/hooks/use-translation

================
File: guides-concepts/i18n/locales/de/common.json
================
{
  "page": {
    "home": {
      "title": "Willkommen zum Refine i18n Beispiel"
    }
  }
}

================
File: guides-concepts/i18n/locales/en/common.json
================
{
  "page": {
    "home": {
      "title": "Welcome to the Refine i18n Example"
    }
  }
}

================
File: guides-concepts/import-export/index.md
================
---
title: Import - Export
---

# CSV Import - Export

import UseExportExample from "./use-export";
import UseImportExample from "./use-import";

Importing and exporting data are essential tasks for managing information in data extensive applications. With `CSV` export and import, we can speed up the process of data entry and data migration.

Refine provides [`useImport`](/docs/core/hooks/utilities/use-import/) and [`useExport`](/docs/core/hooks/utilities/use-export/) hooks for both bulk importing and exporting data, making it easy to move large datasets between your application and external sources.

## Import

`useImport` hook allows you to import data from a `CSV` file. For each row in the file, it calls the `create` or `createMany` method of your data provider according to your configuration.

Internally, it uses [Papa Parse][papaparse] to parse the file contents.

<UseImportExample />

You can use the following `CSV` file to test the import feature.

```csv title="products.csv"
name,material,description,price,category
"Test Product 1","Test Material 1","Test Description 1","100","{""id"":1}"
"Test Product 2","Test Material 2","Test Description 2","200","{""id"":2}"
"Test Product 3","Test Material 3","Test Description 3","300","{""id"":3}"
```

Refine also provides `<ImportButton />`. It's compatible with `useImport` hook to easily handle the import process.

- [Ant Design](/docs/ui-integrations/ant-design/components/buttons/import-button/)
- [Material UI](/docs/ui-integrations/material-ui/components/buttons/import-button/)
- [Mantine](/docs/ui-integrations/mantine/components/buttons/import-button/)
- [Chakra UI](/docs/ui-integrations/chakra-ui/components/buttons/import-button/)

## Export

`useExport` hook allows you to export data as a `CSV` file. It calls the `getList` method of your data provider and downloads the data as a `CSV` file.

Internally, it uses [Papa Parse][papaparse] to create the `CSV` file.

> 🚨 The download feature for `CSV` files does not function within an iframe (live-previews). You can copy the code and run it in your own project to see it in action.

<UseExportExample />

Refine also provides `<ExportButton />`. It's compatible with `useExport` hook to easily handle the export process.

- [Ant Design](/docs/ui-integrations/ant-design/components/buttons/export-button/)
- [Material UI](/docs/ui-integrations/material-ui/components/buttons/export-button/)
- [Mantine](/docs/ui-integrations/mantine/components/buttons/export-button/)
- [Chakra UI](/docs/ui-integrations/chakra-ui/components/buttons/export-button/)

[papaparse]: https://www.papaparse.com/

================
File: guides-concepts/import-export/use-export.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export default function UseExportExample() {
  return (
    <Sandpack
      height={460}
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { HomePage } from "./home-page";
const API_URL = "https://api.fake-rest.refine.dev";
const App: React.FC = () => {
  return (
      <Refine
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          resources={[
              {
                  name: "products",
              },
          ]}
      >
          <HomePage />
      </Refine>
  );
};
export default App;
`.trim();
const HomePageTsxCode = /* jsx */ `
import React from "react";
import { useExport, useList } from "@refinedev/core";
export const HomePage = () => {
  const { data } = useList({ resource: "products" });
  const products = data?.data;
  const { triggerExport, isLoading } = useExport<IProduct>({
      resource: "products",
      mapData: (item) => {
          return {
              ...item,
              // category is an object, we need to stringify it
              category: JSON.stringify(item.category),
          };
      },
  });
  return (
      <div
          style={{
              display: "flex",
              flexDirection: "column",
              alignItems: "flex-start",
              padding: "16px",
          }}
      >
          <div style={{ display: "flex", alignItems: "center", gap: "16px" }}>
              <h2>Products</h2>
              <button onClick={triggerExport} disabled={isLoading}>
                  {isLoading ? "Exporting..." : "Export Products"}
              </button>
          </div>
          {products?.map((product) => (
              <div key={product.id}>
                  <h4>[ID: {product.id}] - {product.name}</h4>
                  <p>{product.description}</p>
              </div>
          ))}
      </div>
  );
};
interface IProduct {
  id: string;
  name: string;
  description: string;
  material: string;
  price: number;
  category: {
      id: string;
  };
}
`.trim();

================
File: guides-concepts/import-export/use-import.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export default function UseImportExample() {
  return (
    <Sandpack
      height={460}
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { HomePage } from "./home-page";
const API_URL = "https://api.fake-rest.refine.dev";
const App: React.FC = () => {
  return (
      <Refine
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          resources={[
              {
                  name: "products",
              },
          ]}
      >
          <HomePage />
      </Refine>
  );
};
export default App;
`.trim();
const HomePageTsxCode = /* jsx */ `
import React, { useState } from "react";
import { useImport, useList } from "@refinedev/core";
export const HomePage = () => {
  const { data } = useList({
      resource: "products",
      sorters: [{ field: "id", order: "desc" }],
  });
  const products = data?.data;
  const [importProgress, setImportProgress] = useState({
      processed: 0,
      total: 0,
  });
  const { inputProps, isLoading } = useImport<IProduct>({
      resource: "products",
      onFinish: () => {
          alert("Import completed!");
      },
      onProgress: (progress) => {
          setImportProgress({
              processed: progress.processedAmount,
              total: progress.totalAmount,
          });
      },
  });
  return (
      <div
          style={{
              display: "flex",
              flexDirection: "column",
              alignItems: "flex-start",
              padding: "16px",
          }}
      >
          <div style={{ display: "flex", alignItems: "center", gap: "16px" }}>
              <h2>Products</h2>
              <label
                  style={{
                      display: "flex",
                      alignItems: "center",
                      gap: "8px",
                      cursor: "pointer",
                      padding: "8px",
                      border: "1px solid #ccc",
                      borderRadius: "4px",
                  }}
              >
                  {isLoading ? (
                      <p>
                          {importProgress.processed} / {importProgress.total}
                      </p>
                  ) : (
                      <p>Import CSV</p>
                  )}
                  <input name="csv" {...inputProps} />
              </label>
          </div>
          {products?.map((product) => (
              <div key={product.id}>
                  <h4>
                      [ID: {product.id}] - {product.name}
                  </h4>
                  <p>{product.description}</p>
              </div>
          ))}
      </div>
  );
};
interface IProduct {
  id: string;
  name: string;
  description: string;
  material: string;
  price: number;
  category: {
      id: string;
  };
}
`.trim();

================
File: guides-concepts/multitenancy/examples/nextjs.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function RouteDefinitions() {
  return (
    <Sandpack
      hidePreview={true}
      showFiles={true}
      showOpenInCodeSandbox={false}
      showReadOnly={false}
      template="react-ts"
      dependencies={{
        "@refinedev/core": "latest",
      }}
      files={{
        "/pages/_app.tsx": {
          code: AppTsxCode,
          active: true,
          readOnly: true,
        },
        "/pages/[tenantId]/products/index.tsx": {
          code: ListTsxCode,
          readOnly: true,
        },
        "/pages/[tenantId]/products/create.tsx": {
          code: CreateTsxCode,
          readOnly: true,
        },
        "/pages/[tenantId]/products/[id]/index.tsx": {
          code: ShowTsxCode,
          readOnly: true,
        },
        "/pages/[tenantId]/products/[id]/edit.tsx": {
          code: EditTsxCode,
          readOnly: true,
        },
        "/providers/multitenancy.ts": {
          code: MultitenancyProviderTsxCode,
          readOnly: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { RefineEnterprise } from "@refinedev/enterprise";
import { WithTenant } from "@refinedev/multitenancy";
import routerProvider from "@refinedev/nextjs-router/pages";
import dataProvider from "@refinedev/simple-rest";
import type { AppProps } from "next/app";
import { multitenancyProvider } from "./providers/multitenancy";
function App({ Component, pageProps }: AppProps) {
    return (
      <RefineEnterprise
          multitenancyProvider={multitenancyProvider}
          dataProvider={dataProvider("<API_URL>")}
          routerProvider={routerProvider}
          resources={[
            {
              name: "products",
              // We're prefixing the routes with \`/:tenantId\` to make them tenant-aware.
              list: "/:tenantId/products",
              show: "/:tenantId/products/:id",
              edit: "/:tenantId/products/:id/edit",
              create: "/:tenantId/products/create",
            },
          ]}
      >
        <WithTenant
          fallback={<div>Tenant not found</div>}
          loadingComponent={<div>Loading...</div>}
        >
          <Component {...pageProps} />
        </WithTenant>
      </RefineEnterprise>
    );
}
export default App;
`.trim();
const ListTsxCode = /* jsx */ `
import React from "react";
import { useList } from "@refinedev/core";
export default function ProductsList() {
  const { data, isLoading } = useList();
  if (isLoading) {
    return <div>Loading...</div>;
  }
  return (
    <div>
      <h1>Products</h1>
      <ul>
        {data?.data.map((record) => (
          <li key={record.id}>{record.name}</li>
        ))}
      </ul>
    </div>
  );
}
`.trim();
const CreateTsxCode = /* jsx */ `
import React from "react";
import { useCreate } from "@refinedev/core";
export default function ProductsCreate() {
  const { onFinish } = useForm();
  return (
    <div>
      <h1>Create Product</h1>
      <form onSubmit={(event) => { /* ... */ }}>
        <label htmlFor="name">Name</label>
        <input id="name" type="text" name="name" />
        <button type="submit">Create</button>
      </form>
    </div>
  );
}
`.trim();
const ShowTsxCode = /* jsx */ `
import React from "react";
import { useShow } from "@refinedev/core";
export default function ProductsShow() {
  const { query: { data, isLoading } } = useShow();
  const record = data?.data;
  if (isLoading) {
    return <div>Loading...</div>;
  }
  return (
    <div>
      <h1>{record?.name}</h1>
      <p>{record?.description}</p>
    </div>
  );
}
`.trim();
const EditTsxCode = /* jsx */ `
import React from "react";
import { useForm } from "@refinedev/core";
export default function ProductsEdit() {
  const { onFinish, query, formLoading } = useForm();
  const record = query?.data?.data;
  if (isLoading) {
    return <div>Loading...</div>;
  }
  return (
    <div>
      <h1>Edit Product</h1>
      <form onSubmit={(event) => { /* ... */ }}>
        <label htmlFor="name">Name</label>
        <input id="name" type="text" name="name" defaultValue={record?.name} />
        <button type="submit">Save</button>
      </form>
    </div>
  );
}
`.trim();
const MultitenancyProviderTsxCode = /* jsx */ `
import type { MultiTenancyProvider } from "@refinedev/enterprise";
import { useRouterAdapter } from "@refinedev/multitenancy";
import dataProvider from "@refinedev/simple-rest";
export type Tenant = {
  id: string;
  name: string;
};
export const multitenancyProvider: MultiTenancyProvider = {
  adapter: useRouterAdapter(),
  fetchTenants: async () => {
    const response = await dataProvider("<API_URL>").getList<Tenant>({
      resource: "categories",
      pagination: {
        mode: "off",
      },
    });
    const tenants = response.data;
    const defaultTenant = tenants[0];
    return {
      tenants,
      defaultTenant,
    };
  },
};
`.trim();

================
File: guides-concepts/multitenancy/examples/react-router.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function RouteDefinitions() {
  return (
    <Sandpack
      hidePreview={true}
      showFiles={false}
      showOpenInCodeSandbox={false}
      showReadOnly={false}
      template="react-ts"
      dependencies={{
        "@refinedev/core": "latest",
      }}
      files={{
        "App.tsx": {
          code: AppTsxCode,
          readOnly: true,
        },
        "multitenancy.ts": {
          code: MultitenancyProviderTsxCode,
          readOnly: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import { RefineEnterprise } from "@refinedev/enterprise";
import { WithTenant } from "@refinedev/multitenancy";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Outlet, Routes, Route } from "react-router";
import { multitenancyProvider } from "./multitenancy";
import { ProductsList, ProductsCreate, ProductsShow, ProductsEdit } from "./products";
export const App: React.FC = () => {
  return (
    <BrowserRouter>
      <RefineEnterprise
        multitenancyProvider={multitenancyProvider}
        dataProvider={dataProvider("<API_URL>")}
        routerProvider={routerProvider}
        resources={[
          {
            name: "products",
            // We're prefixing the routes with \`/:tenantId\` to make them tenant-aware.
            list: "/:tenantId/products",
            show: "/:tenantId/products/:id",
            edit: "/:tenantId/products/:id/edit",
            create: "/:tenantId/products/create",
          },
        ]}
      >
        <Routes>
          {/* We're defining the \`tenantId\` as a route parameter. */}
          <Route path="/:tenantId" element={
            <WithTenant
              fallback={<div>Tenant not found</div>}
              loadingComponent={<div>Loading...</div>}
            >
              <Outlet />
            </WithTenant>
          }>
            <Route path="products" element={<ProductsList />} />
            <Route path="products/create" element={<ProductsCreate />} />
            <Route path="products/:id" element={<ProductsShow />} />
            <Route path="products/:id/edit" element={<ProductsEdit />} />
          </Route>
        </Routes>
      </RefineEnterprise>
    </BrowserRouter>
  );
};
`.trim();
const MultitenancyProviderTsxCode = /* jsx */ `
import type { MultiTenancyProvider } from "@refinedev/core";
import { useRouterAdapter } from "@refinedev/multitenancy";
import dataProvider from "@refinedev/simple-rest";
export type Tenant = {
  id: string;
  name: string;
};
export const multitenancyProvider: MultiTenancyProvider = {
  adapter: useRouterAdapter(),
  fetchTenants: async () => {
    const response = await dataProvider("<API_URL>").getList<Tenant>({
      resource: "categories",
      pagination: {
        mode: "off",
      },
    });
    const tenants = response.data;
    const defaultTenant = tenants[0];
    return {
      tenants,
      defaultTenant,
    };
  },
};
`.trim();

================
File: guides-concepts/multitenancy/examples/remix.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function RouteDefinitions() {
  return (
    <Sandpack
      hidePreview={true}
      showFiles={true}
      showOpenInCodeSandbox={false}
      showReadOnly={false}
      template="react-ts"
      dependencies={{
        "@refinedev/core": "latest",
      }}
      files={{
        "/app/root.tsx": {
          code: AppTsxCode,
          active: true,
          readOnly: true,
        },
        "/app/routes/$tenantId.products._index.tsx": {
          code: ListTsxCode,
          readOnly: true,
        },
        "/app/routes/$tenantId.products.create.tsx": {
          code: CreateTsxCode,
          readOnly: true,
        },
        "/app/routes/$tenantId.products.$id._index.tsx": {
          code: ShowTsxCode,
          readOnly: true,
        },
        "/app/routes/$tenantId.products.$id.edit.tsx": {
          code: EditTsxCode,
          readOnly: true,
        },
        "/app/providers/multitenancy.ts": {
          code: MultitenancyProviderTsxCode,
          readOnly: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";
import { RefineEnterprise } from "@refinedev/enterprise";
import { WithTenant } from "@refinedev/multitenancy";
import routerProvider from "@refinedev/remix-router";
import dataProvider from "@refinedev/simple-rest";
import { multitenancyProvider } from "./providers/multitenancy";
export default function App() {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <RefineEnterprise
          multitenancyProvider={multitenancyProvider}
          dataProvider={dataProvider("<API_URL>")}
          routerProvider={routerProvider}
          resources={[
            {
              name: "products",
              // We're prefixing the routes with \`/:tenantId\` to make them tenant-aware.
              list: "/:tenantId/products",
              show: "/:tenantId/products/:id",
              edit: "/:tenantId/products/:id/edit",
              create: "/:tenantId/products/create",
            },
          ]}
        >
          <WithTenant
            fallback={<div>Tenant not found</div>}
            loadingComponent={<div>Loading...</div>}
          >
            <Outlet />
          </WithTenant>
        </RefineEnterprise>
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}
`.trim();
const ListTsxCode = /* jsx */ `
import React from "react";
import { useList } from "@refinedev/core";
export default function ProductsList() {
  const { data, isLoading } = useList();
  if (isLoading) {
    return <div>Loading...</div>;
  }
  return (
    <div>
      <h1>Products</h1>
      <ul>
        {data?.data.map((record) => (
          <li key={record.id}>{record.name}</li>
        ))}
      </ul>
    </div>
  );
}
`.trim();
const CreateTsxCode = /* jsx */ `
import React from "react";
import { useCreate } from "@refinedev/core";
export default function ProductsCreate() {
  const { onFinish } = useForm();
  return (
    <div>
      <h1>Create Product</h1>
      <form onSubmit={(event) => { /* ... */ }}>
        <label htmlFor="name">Name</label>
        <input id="name" type="text" name="name" />
        <button type="submit">Create</button>
      </form>
    </div>
  );
}
`.trim();
const ShowTsxCode = /* jsx */ `
import React from "react";
import { useShow } from "@refinedev/core";
export default function ProductsShow() {
  const {
    query: { data, isLoading },
  } = useShow();
  const record = data?.data;
  if (isLoading) {
    return <div>Loading...</div>;
  }
  return (
    <div>
      <h1>{record?.name}</h1>
      <p>{record?.description}</p>
    </div>
  );
}
`.trim();
const EditTsxCode = /* jsx */ `
import React from "react";
import { useForm } from "@refinedev/core";
export default function ProductsEdit() {
  const { onFinish, query, formLoading } = useForm();
  const record = query?.data?.data;
  if (isLoading) {
    return <div>Loading...</div>;
  }
  return (
    <div>
      <h1>Edit Product</h1>
      <form onSubmit={(event) => { /* ... */ }}>
        <label htmlFor="name">Name</label>
        <input id="name" type="text" name="name" defaultValue={record?.name} />
        <button type="submit">Save</button>
      </form>
    </div>
  );
}
`.trim();
const MultitenancyProviderTsxCode = /* jsx */ `
import type { MultiTenancyProvider } from "@refinedev/enterprise";
import { useRouterAdapter } from "@refinedev/multitenancy";
import dataProvider from "@refinedev/simple-rest";
export type Tenant = {
  id: string;
  name: string;
};
export const multiTenancyProvider: MultiTenancyProvider = {
  adapter: useRouterAdapter(),
  fetchTenants: async () => {
    const response = await dataProvider("<API_URL>").getList<Tenant>({
      resource: "categories",
      pagination: {
        mode: "off",
      },
    });
    const tenants = response.data;
    const defaultTenant = tenants[0];
    return {
      tenants,
      defaultTenant,
    };
  },
};
`.trim();

================
File: guides-concepts/multitenancy/index.md
================
---
title: Multitenancy
---

Refine's architecture allows you to customize your app's data providers, access control and routing to support multi tenant features easily. This guide will provide you with a high level overview of the concepts and how to implement them. To see multi tenant app examples, check out the [Examples](#examples) section.

## What is Multitenancy?

Multitenancy, especially in cloud-based systems or software solutions, refers to the ability of a software application or system to serve multiple customers (tenants) simultaneously. While these customers share the same infrastructure and codebase, their data remains separate, and each customer has exclusive access to their own data.

**Benefits of Multitenancy:**

- **Resource Sharing:** Efficient use of shared infrastructure reduces costs.
- **Cost Savings:** Lower maintenance costs passed on to customers.
- **Customization:** Each tenant can adjust settings to their needs.
- **Easy Updates:** System-wide updates benefit all tenants at once.

**Use Cases:**

- **Cloud Office Tools:** Multiple organizations share document management and collaboration features.
- **CRM Systems:** Businesses manage customer interactions on a shared platform with secure, custom configurations.
- **ERP Systems:** Companies use shared ERP solutions with separate data and configurations.
- **E-commerce Platforms:** Sellers run personalized storefronts on a shared backend.
- **LMS Platforms:** Schools and organizations deliver courses on a shared learning system.

## Implementing Multitenancy in Refine

In the next sections, we'll show you how to set up multitenancy in Refine using a route-based approach. We'll use the [`multitenancyProvider`](/docs/enterprise-edition/multitenancy/) from the `"@refinedev/enterprise"` package. This Multi-Tenancy Provider is part of the [Refine Enterprise Edition](https://refine.dev/enterprise/). It makes managing multi-tenant applications easier by providing tools like context, hooks, and components that are designed to handle tenants.

### 1. Setting up the Multitenancy Provider

First, we need to install the `@refinedev/enterprise` and `@refinedev/multitenancy` packages.

<InstallPackagesCommand args="@refinedev/enterprise @refinedev/multitenancy"/>

Then we need to change `<Refine />` component to `<RefineEnterprise />` in your `App.tsx` file. You can use same props of `<Refine />` component in `<RefineEnterprise />` component.

> 🚨 All the props of the `<Refine />` component are also available in the `<RefineEnterprise />` component with additional features.

```diff
- import { Refine } from "@refinedev/core";
+ import { RefineEnterprise } from "@refinedev/enterprise";

export const App = () => {
  return (
-    <Refine>
+      <RefineEnterprise>
        {/* Your app code */}
+      </RefineEnterprise>
-    </Refine>
  );
};
```

After that, we need to provide the [`multitenancyProvider`](/docs/enterprise-edition/multitenancy/) to the `<RefineEnterprise />` component. The [`multitenancyProvider`](/docs/enterprise-edition/multitenancy/) prop accepts an object with two properties: `adapter` and `fetchTenants`.

- `adapter`: The adapter is a function that extracts the tenantId from the current route. You can use the provided `useRouterAdapter` or create your own custom adapter.

- `fetchTenants`: This function is used to fetch the list of tenants. You can fetch the list of tenants from your API and return them in the format `{ tenants: Tenant[], defaultTenant: Tenant }`.

- `<WithTenant />`: This component is required to wrap your app code. It fetches `tenants`, handling the loading state and error state.
  - `fallback`: You can provide a custom fallback component to be displayed while the tenant is not available.
  - `loadingComponent`: You can provide a custom loading component to be displayed while the tenant is loading.

When you mount `<RefineEnterprise />` and `<WithTenant />` components and provide the [`multitenancyProvider`](/docs/enterprise-edition/multitenancy/) prop, Refine will automatically extract the `tenantId` from the route and pass it to the data provider in the `meta` object.

```tsx
import { RefineEnterprise } from "@refinedev/enterprise";
import { useRouterAdapter, WithTenant } from "@refinedev/multitenancy";

// ... other imports

const App = () => {
  return (
    <RefineEnterprise
      // ... other props
      multitenancyProvider={{
        adapter: useRouterAdapter(),
        fetchTenants: async () => {
          const response = await dataProvider(API_URL).getList<ICategory>({
            resource: "categories",
            pagination: {
              mode: "off",
            },
          });
          const tenants = response.data;
          const defaultTenant = tenants[0];

          return {
            tenants,
            defaultTenant,
          };
        },
      }}
    >
      <WithTenant
        fallback={<div>Tenant not found</div>}
        loadingComponent={<div>Loading...</div>}
      >
        {/* Your app code */}
      </WithTenant>
    </RefineEnterprise>
  );
};
```

### 2. Configuring Multi-tenant Routes

We'll be using routes to determine which tenant is being selected. Once we've setup our routes, `useRouterAdapter` will automatically extract the `tenantId` from the route.

> Note: In the examples below, we are only showing the route definitions. You may need additional code to implement styling and layout depending on your choice of UI library. Regardless of the UI library you choose, the routing implementation will be similar to the examples below.

<Tabs wrapContent={false}>

<TabItem value="React Router Dom">

import ReactRouterRouteDefinitions from "./examples/react-router.tsx";

<ReactRouterRouteDefinitions />

</TabItem>

<TabItem value="Next.js">

import NextjsRouteDefinitions from "./examples/nextjs.tsx";

<NextjsRouteDefinitions />

</TabItem>

<TabItem value="Remix">

import RemixRouteDefinitions from "./examples/remix.tsx";

<RemixRouteDefinitions />

</TabItem>

</Tabs>

### Handling Multi-tenant Requests in Data Providers

We'll be using the `tenantId` from the route to determine which tenant is being accessed. Refine will infer the `tenantId` from the current route and pass it to the data provider in `meta`. You can access the `tenantId` from the `meta` object in your data provider and use it in your API calls.

To customize the data providers, you can override each method in the data provider instance or use the [`swizzle`](/docs/packages/cli/#swizzle) command to be fully able to customize the data provider for your needs.

An example implementation of a custom `getList` method is shown below.

```ts
import dataProvider from "@refinedev/simple-rest";

const API_URL = "<API_URL>";
const baseDataProvider = dataProvider(API_URL);

const customDataProvider = {
  ...baseDataProvider,
  getList: async ({ resource, filters = [], meta, ...props }) => {
    const { tenantId } = meta;

    // We're adding the tenantId to the filters
    // Your API may have a different way of handling this
    if (meta?.tenantId) {
      filters.push({
        field: "organization",
        operator: "eq",
        value: meta.tenantId,
      });
    }

    // Call the base data provider's getList method with the updated filters
    return baseDataProvider.getList({
      resource,
      filters,
      meta,
      ...props,
    });
  },
};
```

### Adding a Tenant Selector to the UI

Now we've defined our routes and data providers to use `tenantId` to determine which tenant is being accessed. We'll need to add a tenant selector to the UI to allow users to switch between tenants.

You can use the Tenant selector components from the `@refinedev/multitenancy` package to easily add a tenant selector to your app.

<Tabs wrapContent={false}>

<TabItem value="Ant Design">

```tsx
import { TenantSelect } from "@refinedev/multitenancy/antd";

<TenantSelect />;
```

</TabItem>

<TabItem value="Material UI">

```tsx
import { TenantSelect } from "@refinedev/multitenancy/mui";

<TenantSelect />;
```

</TabItem>

</Tabs>

### Examples

Here are some examples of multi-tenant apps built with [Refine Enterprise Edition](https://refine.dev/enterprise/):

- [Multitenancy App with Strapi](https://refine.dev/templates/multitenancy-strapi/)
- [Isolated Multitenancy App with Rest API](https://multitenancy-isolated.netlify.app/)

================
File: guides-concepts/notifications/index.md
================
---
title: Notifications
---

One of the most important parts of an application is the notifications and the visual feedbacks. Refine has this built-in notification integration that works automatically when it's needed in cases such as when a request fails or when a form is submitted.

While this integration is not coupled with the UI integrations, it will be a wise choice to use the one that is provided by the UI libraries for a consistent design language. This is why Refine's UI integrations also provides a [`notificationProvider`](/docs/notification/notification-provider/) to be used with the notification integration of refine.

## Notification Providers

Refine let's you set a notification API by providing the `notificationProvider` property to the `<Refine />` component. `notificationProvider` is an object with close and open methods. Refine uses these methods to show and hide notifications. These methods can be called from anywhere in the application with `useNotification` hook.

An `notificationProvider` must include `open` and `close` methods with the following types:

```ts
interface NotificationProvider {
  open: (params: OpenNotificationParams) => void;
  close: (key: string) => void;
}

interface OpenNotificationParams {
  key?: string;
  message: string;
  type: "success" | "error" | "progress";
  description?: string;
  cancelMutation?: () => void;
  undoableTimeout?: number;
}
```

Once you provide the notification provider, Refine seamlessly integrate with [data hooks](/docs/guides-concepts/data-fetching/#data-hooks) to displays user-friendly notifications for various data-related actions, ensuring a clear and informative user experience. This includes:

- **Form Submission**: Whether a [form](/docs/data/hooks/use-form/) is successfully submitted or encounters errors, Refine will display the appropriate notification to keep the user informed.
- **Resource Management**: [Creation](/docs/data/hooks/use-create/), [deletion](/docs/data/hooks/use-delete/), [update](/docs/data/hooks/use-update/), [import](/docs/core/hooks/utilities/use-import/), and [export](/docs/core/hooks/utilities/use-export/) of resources are all accompanied by success or error notifications, providing immediate feedback to the user.
- **Data Fetching**: Refine also displays notifications for failed data fetching operations, including those using [useList](/docs/data/hooks/use-list/), [useInfiniteList](/docs/data/hooks/use-infinite-list/), [useMany](/docs/data/hooks/use-many/), [useOne](/docs/data/hooks/use-one/).
- Auth Actions: [Login](/docs/authentication/hooks/use-login/), [logout](/docs/authentication/hooks/use-logout/), [register](/docs/authentication/hooks/use-register/), [update password](/docs/authentication/hooks/use-update-password/), and [forgot password](/docs/authentication/hooks/use-forgot-password/) actions are all integrated with Refine's notification provider to display error notifications.

### Built-in Notification Providers

Using of the prebuilt notification providers are optional and can be customized, extended or even swapped with a custom implementation if needed.

As an example, we'll demonstrate how to open and close notifications using the `useNotification` hook. However, in most cases, you won't need to do this, as Refine typically manages notifications for you automatically.

<Tabs wrapContent={false}>

<TabItem default value="antd" label="Ant Design">

import NotificationAntd from "./notifications-antd";

<NotificationAntd />

</TabItem>

<TabItem value="material-ui" label="Material UI">

import NotificationMui from "./notifications-mui";

<NotificationMui />

</TabItem>

<TabItem value="mantine" label="Mantine">

import NotificationMantine from "./notifications-mantine";

<NotificationMantine />

</TabItem>

<TabItem value="chakra-ui" label="Chakra UI">

import NotificationChakraUI from "./notifications-chakra-ui";

<NotificationChakraUI />

</TabItem>
</Tabs>

### Undoable

Refine also supports undoable notification.

You can trigger an undoable notification by setting the `type` to `progress`. After timeout, the notification will be closed automatically. If the user clicks the undo button, the `cancelMutation` callback will be called.

```tsx
const { open } = useNotification();

open?.({
  type: "progress",
  message: "Progress",
  undoableTimeout: 5,
  cancelMutation: () => {
    // when undo button is clicked, run this callback
  },
});
```

Mutation hooks such as `useUpdate`, `useDelete` and `useForm` supports undoable notifications. It can be used for canceling the mutation.

```ts
import { useForm } from "@refinedev/core";

// automatically cancel the mutation when undo button is clicked
useForm({ mutationMode: "undoable" });
```

## Customizing Notifications

### With props

All data hooks have a `successNotification` and `errorNotification` prop that can be used to customize the notification that will be shown when the hook is called.

We will look `useUpdate` and `useForm` hooks as an example but all data hooks have the same props and they work the same way.

<Tabs>

<TabItem default value="useUpdate" label="useUpdate">

```tsx
import { useUpdate } from "@refinedev/core";

const { mutate } = useUpdate();

mutate({
  // it will be called when the mutation is successful
  // By setting it to `false`, you can disable the notification.
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
  // it will be called when the mutation is failed
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

</TabItem>

<TabItem value="useForm" label="useForm">

```tsx
import { useForm } from "@refinedev/core";

useForm({
  //  it will be called when the form is submitted successfully
  // By setting it to `false`, you can disable the notification.
  successNotification: (data, values, resource) => {
    return {
      message: `Successfully created ${data.title}`,
      description: "good job!",
      type: "success",
    };
  },
  // it will be called when the form is submitted with errors
  // By setting it to `false`, you can disable the notification.
  errorNotification: (error, values, resource) => {
    return {
      message: `Failed to create ${values.title}`,
      description: error.message,
      type: "error",
    };
  },
});
```

</TabItem>

</Tabs>

### With i18n <GuideBadge id="i18n/i18n-provider/" />

Refine's notification integration is also integrated with the [`i18n Provider`](/docs/i18n/i18n-provider/). This means that you can use the `i18n` integration to customize the notifications.

Refine uses following keys for the notifications and popultes `{{resource}}` and `{{statusCode}}`. You can override these keys in your `i18n` provider to customize the notifications.

```json title="/locales/en/common.json"
{
  "notifications": {
    "success": "Successful",
    "error": "Error (status code: {{statusCode}})",
    "undoable": "You have {{seconds}} seconds to undo",
    "createSuccess": "Successfully created {{resource}}",
    "createError": "There was an error creating {{resource}} (status code: {{statusCode}})",
    "deleteSuccess": "Successfully deleted {{resource}}",
    "deleteError": "Error when deleting {{resource}} (status code: {{statusCode}})",
    "editSuccess": "Successfully edited {{resource}}",
    "editError": "Error when editing {{resource}} (status code: {{statusCode}})",
    "importProgress": "Importing: {{processed}}/{{total}}"
  }
}
```

================
File: guides-concepts/notifications/notifications-antd.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function NotificationAntd() {
  return (
    <Sandpack
      height={460}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        antd: "^5.0.5",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import { useNotificationProvider, RefineThemes } from "@refinedev/antd";
import { ConfigProvider, App as AntdApp } from "antd";
import dataProvider from "@refinedev/simple-rest";
import "@refinedev/antd/dist/reset.css";
import { HomePage } from "./home-page";
const API_URL = "https://api.fake-rest.refine.dev";
const App: React.FC = () => {
    return (
        <ConfigProvider theme={RefineThemes.Blue}>
            <AntdApp>
                <Refine
                    dataProvider={dataProvider(API_URL)}
                    notificationProvider={useNotificationProvider}
                >
                    <HomePage />
                </Refine>
            </AntdApp>
        </ConfigProvider>
    );
};
export default App;
`.trim();
const HomePageTsxCode = /* jsx */ `
import React from "react";
import { useNotification } from "@refinedev/core";
import { Button, Col, Row } from "antd";
export const HomePage: React.FC = () => {
  const { open, close } = useNotification();
  return (
      <Row
          gutter={[16, 16]}
          style={{
              justifyContent: "center",
              alignItems: "center",
              height: "100vh",
          }}
      >
          <Col>
              <Button
                  type="primary"
                  onClick={() => {
                      open?.({
                          type: "success",
                          message: "Notification Title",
                          description:
                              "This is the content of the notification.",
                          key: "notification-key",
                      });
                  }}
              >
                  Open Notification
              </Button>
          </Col>
          <Col>
              <Button
                  type="default"
                  onClick={() => {
                      close?.("notification-key");
                  }}
              >
                  Close Notification
              </Button>
          </Col>
      </Row>
  );
};
`.trim();

================
File: guides-concepts/notifications/notifications-chakra-ui.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function NotificationChakraUI() {
  return (
    <Sandpack
      height={460}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@chakra-ui/react": "^2.5.1",
        "@refinedev/chakra-ui": "^2.26.17",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import { RefineThemes, useNotificationProvider } from "@refinedev/chakra-ui";
import { ChakraProvider } from "@chakra-ui/react";
import dataProvider from "@refinedev/simple-rest";
import { HomePage } from "./home-page";
const App: React.FC = () => {
    return (
        <ChakraProvider theme={RefineThemes.Blue}>
            <Refine
                notificationProvider={useNotificationProvider()}
                dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            >
                <HomePage />
            </Refine>
        </ChakraProvider>
    );
};
export default App;
`.trim();
const HomePageTsxCode = /* jsx */ `
import React from "react";
import { Flex, Button } from "@chakra-ui/react";
import { useNotification } from "@refinedev/core";
export const HomePage = () => {
    const { open, close } = useNotification();
    return (
        <Flex align="center" justify="center" height="100vh" gap={4}>
            <Button
                onClick={() => {
                    open?.({
                        type: "success",
                        message: "Notification Title",
                        description: "This is the content of the notification.",
                        key: "notification-key",
                    });
                }}
            >
                Open Notification
            </Button>
            <Button
                variant="outline"
                onClick={() => {
                    close?.("notification-key");
                }}
            >
                Close Notification
            </Button>
        </Flex>
    );
};
`.trim();

================
File: guides-concepts/notifications/notifications-mantine.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function NotificationMantine() {
  return (
    <Sandpack
      height={460}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@mantine/notifications": "^5.10.4",
        "@emotion/react": "^11.8.2",
        "@mantine/core": "^5.10.4",
        "@mantine/hooks": "^5.10.4",
        "@refinedev/mantine": "^2.28.21",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import { useNotificationProvider, RefineThemes } from "@refinedev/mantine";
import { NotificationsProvider } from "@mantine/notifications";
import { MantineProvider, Global } from "@mantine/core";
import dataProvider from "@refinedev/simple-rest";
import { HomePage } from "./home-page";
const App: React.FC = () => {
    return (
        <MantineProvider
            theme={RefineThemes.Blue}
            withNormalizeCSS
            withGlobalStyles
        >
            <Global styles={{ body: { WebkitFontSmoothing: "auto" } }} />
            <NotificationsProvider position="top-right">
                <Refine
                    dataProvider={dataProvider(
                        "https://api.fake-rest.refine.dev",
                    )}
                    notificationProvider={useNotificationProvider}
                >
                    <HomePage />
                </Refine>
            </NotificationsProvider>
        </MantineProvider>
    );
};
export default App;
`.trim();
const HomePageTsxCode = /* jsx */ `
import React from "react";
import { Flex, Button } from "@mantine/core";
import { useNotification } from "@refinedev/core";
export const HomePage = () => {
    const { open, close } = useNotification();
    return (
        <Flex mih={"100vh"} gap="md" justify="center" align="center">
            <Button
                onClick={() => {
                    open?.({
                        type: "success",
                        message: "Notification Title",
                        description: "This is the content of the notification.",
                        key: "notification-key",
                    });
                }}
            >
                Open Notification
            </Button>
            <Button
                variant="outline"
                onClick={() => {
                    close?.("notification-key");
                }}
            >
                Close Notification
            </Button>
        </Flex>
    );
};
`.trim();

================
File: guides-concepts/notifications/notifications-mui.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function NotificationMui() {
  return (
    <Sandpack
      height={460}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@emotion/react": "^11.8.2",
        "@emotion/styled": "^11.8.1",
        "@mui/lab": "^6.0.0-beta.14",
        "@mui/material": "^6.1.7",
        "@mui/system": "latest",
        "@refinedev/mui": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import {
    RefineThemes,
    useNotificationProvider,
    RefineSnackbarProvider,
} from "@refinedev/mui";
import CssBaseline from "@mui/material/CssBaseline";
import GlobalStyles from "@mui/material/GlobalStyles";
import { ThemeProvider } from "@mui/material/styles";
import dataProvider from "@refinedev/simple-rest";
import { HomePage } from "./home-page";
const App: React.FC = () => {
    return (
        <ThemeProvider theme={RefineThemes.Blue}>
            <CssBaseline />
            <GlobalStyles styles={{ html: { WebkitFontSmoothing: "auto" } }} />
            <RefineSnackbarProvider preventDuplicate={true}>
                <Refine
                    dataProvider={dataProvider(
                        "https://api.fake-rest.refine.dev",
                    )}
                    notificationProvider={useNotificationProvider}
                >
                    <HomePage />
                </Refine>
            </RefineSnackbarProvider>
        </ThemeProvider>
    );
};
export default App;
`.trim();
const HomePageTsxCode = /* jsx */ `
import React from "react";
import Grid from "@mui/material/Grid2";
import Button from "@mui/material/Button";
import { useNotification } from "@refinedev/core";
export const HomePage = () => {
    const { open, close } = useNotification();
    return (
        <Grid
            container
            spacing={2}
            sx={{
                justifyContent: "center",
                alignItems: "center",
                height: "100vh",
            }}
        >
            <Grid>
                <Button
                    variant="contained"
                    onClick={() => {
                        open?.({
                            type: "success",
                            message: "Notification Title",
                            description:
                                "This is the content of the notification.",
                            key: "notification-key",
                        });
                    }}
                >
                    Open Notification
                </Button>
            </Grid>
            <Grid>
                <Button
                    variant="outlined"
                    onClick={() => {
                        close?.("notification-key");
                    }}
                >
                    Close Notification
                </Button>
            </Grid>
        </Grid>
    );
};
`.trim();

================
File: guides-concepts/realtime/index.md
================
---
title: Realtime
---

Realtime data is an important part of modern applications. Seeing the changes in the details page, without refreshing the page not only improves the user experience but also increases the productivity of the users by preventing accidental updates.

Refine handles realtime data operations through [Live Provider](/docs/realtime/live-provider) which provides a common interface for any integration. Once integrated, you'll get realtime updates across your app out of the box, without needing a further configuration.

Once a **Live Provider** is integrated, Refine takes care of the **invalidation**, **refetching** logic for your resources.

For example if a new record is created for `products` resource, a page where you use `useList` hook will automatically refetch the latest `products` data.

```tsx title="App.tsx"
import { Refine, LiveProvider } from "@refinedev/core";

import { liveProvider } from "./my-live-provider";

const App = () => {
  return (
    <Refine
      liveProvider={liveProvider}
      options={{ liveMode: "auto" }}
      onLiveEvent={(event) => {
        console.log(event);
      }}
    >
      {/* ... */}
    </Refine>
  );
};
```

```tsx title=my-page.tsx
import { useList } from "@refinedev/core";

const { data } = useList({
  resource: "products",
  // Can be configured per-hook basis.
  liveMode: "auto", // manual or off
});
```

## Supported Hooks

Refine hooks works out-of-the-box with **Live Provider**, means if the data these hooks consume is updated, they will automatically refetch.

See the [Integrated Hooks](/docs/realtime/live-provider#integrated-hooks) section for more information.

## Built-in Integrations

We have the following built-in integrations:

- **Ably** &#8594 [Source Code](https://github.com/refinedev/refine/blob/main/packages/ably/src/index.ts) - [Demo](https://codesandbox.io/embed/github/refinedev/refine/tree/main/examples/live-provider-ably/?view=preview&theme=dark&codemirror=1)
- **Supabase** &#8594 [Source Code](https://github.com/refinedev/refine/blob/main/packages/supabase/src/index.ts#L187)
- **Appwrite** &#8594 [Source Code](https://github.com/refinedev/refine/blob/main/packages/appwrite/src/index.ts#L252)
- **Hasura** &#8594 [Source Code](https://github.com/refinedev/refine/blob/main/packages/hasura/src/liveProvider/index.ts#L16)

## Live Provider

The **Live Provider** is an object that contains `subscribe`, `unsubscribe` and `publish` methods. These methods are utilized by Refine to subscribe, unsubscribe to a certain resource updates and publish updates.

A basic **Live Provider** looks like this:

```tsx title="live-provider.ts"
import { LiveProvider } from "@refinedev/core";

export const liveProvider: LiveProvider = {
  subscribe: async ({ callback, channel, types, meta, params }) => {
    console.log(callback); // a function that will be called when there is an update
    console.log(channel); // products, orders, etc.
    console.log(types); // created, updated, deleted, "*", etc.
    console.log(meta); // { fields: [], operation: "", queryContext: {}, variables: {} }

    const { resource, id, ids } = params;

    // subscribe to the resource updates
    const unsubscribe = MyWSClient.subscribe({ channel });

    // call the callback function when there is an update
    MyWSClient.on("message", (data) => callback(data));

    // return value will be passed to `unsubscribe` method.
    return { unsubscribe };
  },
  unsubscribe: async ({ unsubscribe }) => {
    // unsubscribe from the resource updates
    unsubscribe();
  },
  publish: async ({ channel, type, payload, date }) => {
    console.log(channel); // products, orders, etc.
    console.log(type); // created, updated, deleted, etc.
    console.log(payload); // { id: 1, name: "Product 1" }, { id: 2, name: "Product 2" }, etc.
    console.log(date); // new Date()

    // publish the data to the resource channel.
    MyWSClient.publish({ channel, type, payload, date });
  },
};
```

## Hooks

While most of the features already works out-of-the-box with **Live Provider**, you can also use the following hooks to subscribe, unsubscribe and publish updates for your custom use cases.

### useSubscription

The `useSubscription` hook can be used to subscribe to a certain resource updates. It calls **Live Provider**'s `subscribe` method with the given parameters.

```tsx
import { useSubscription } from "@refinedev/core";

useSubscription({
  resource: "products",
  types: ["created", "updated"],
  onLiveEvent: (event) => {
    console.log(event.channel); // products, orders, etc.
    console.log(event.type); // created, updated, deleted, etc.
    console.log(event.payload); // { id: 1, name: "Product 1" }, { id: 2, name: "Product 2" }, etc.
  },
});
```

### usePublish

While generally it's not recommended to publish updates from the frontend, you can use `usePublish` hook to publish updates to a certain resource. It calls **Live Provider**'s `publish` method with the given parameters.

```tsx
import { usePublish } from "@refinedev/core";

const publish = usePublish();

publish({
  channel: "products",
  type: "deleted",
  payload: { id: 1 },
  date: new Date(),
});
```

## Creating a live provider with Ably

We will build the **"Ably Live Provider"** of [`@refinedev/ably`](https://github.com/refinedev/refine/tree/main/packages/ably) from scratch to show the logic of how live provider methods interact with Ably.

### Implementing `subscribe` method

This method is used to subscribe to a Realtime channel. Refine subscribes to the related channels using subscribe method in supported hooks to be aware of the data changes.

```ts title="liveProvider.ts"
import { LiveProvider, LiveEvent } from "@refinedev/core";
import Ably from "ably/promises";
import { Types } from "ably";

export const liveProvider = (client: Ably.Realtime): LiveProvider => {
  return {
    subscribe: ({ channel, types, params, callback, meta }) => {
      console.log(channel); // products, orders, etc.
      console.log(types); // created, updated, deleted, "*", etc.
      console.log(params); // { id: 1 } or { ids: [1, 2, 3] }, etc.
      console.log(callback); // a function that will be called when there is an update
      console.log(meta); // { fields: [], operation: "", queryContext: {}, variables: {} }

      const channelInstance = client.channels.get(channel);

      const listener = function (message: MessageType) {
        if (types.includes("*") || types.includes(message.data.type)) {
          if (
            message.data.type !== "created" &&
            params?.ids !== undefined &&
            message.data?.payload?.ids !== undefined
          ) {
            if (
              params.ids.filter((value) =>
                message.data.payload.ids!.includes(value),
              ).length > 0
            ) {
              callback(message.data as LiveEvent);
            }
          } else {
            callback(message.data);
          }
        }
      };

      channelInstance.subscribe(listener);

      // returned value will be passed to `unsubscribe` method.
      // required for unsubscribing from the channel.
      return { channelInstance, listener };
    },
  };
};

interface MessageType extends Types.Message {
  data: LiveEvent;
}
```

Refine will use this subscribe method in the [`useSubscription`](/docs/realtime/hooks/use-subscription) hook.

```ts
import { useSubscription } from "@refinedev/core";

useSubscription({
  channel: "channel-name",
  onLiveEvent: (event) => {},
});
```

> For more information, refer to the [useSubscription documentation&#8594](/docs/realtime/hooks/use-subscription)

### Implementing `unsubscribe` method

This method is used to unsubscribe from a channel. The values returned from the `subscribe` method are passed to this method.

```ts title="liveProvider.ts"
export const liveProvider = (client: Ably.Realtime): LiveProvider => {
  return {
    unsubscribe: (payload: {
      channelInstance: Types.RealtimeChannelPromise;
      listener: () => void;
    }) => {
      const { channelInstance, listener } = payload;
      channelInstance.unsubscribe(listener);
    },
  };
};
```

:::caution

If you don't handle unsubscription, it could lead to memory leaks.

:::

### Implementing `publish` method

This method is used to publish an event on client side. Beware that publishing events on client side is not recommended and the best practice is to publish events from server side. You can refer [Publish Events from API](#publish-events-from-api) to see which events must be published from the server.

This `publish` is used in [related hooks](#publish-events-from-hooks). When `publish` is used, subscribers to these events are notified. You can also publish your custom events using [`usePublish`](/docs/realtime/hooks/use-publish).

```ts title="liveProvider.ts"
export const liveProvider = (client: Ably.Realtime): LiveProvider => {
  return {
    publish: ({ channel, type, payload, date, meta }: LiveEvent) => {
      const channelInstance = client.channels.get(channel);

      channelInstance.publish(type, event);
    },
  };
};
```

:::caution

If `publish` is used on client side you must handle the security of it by yourself.

:::

Refine will provide this publish method via the [`usePublish`](/docs/realtime/hooks/use-publish) hook.

```ts
import { usePublish } from "@refinedev/core";

const publish = usePublish();
```

### Usage

Now that we have created our live provider, we can use it in our application like below:

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";
import Ably from "ably/promises";

import { liveProvider } from "./liveProvider";

const ablyClient = new Ably.Realtime("your-ably-token");

const App = () => {
  return <Refine liveProvider={liveProvider(ablyClient)}>{/*...*/}</Refine>;
};
```

## Creating a live provider with GraphQL subscriptions

In this section, we will create a live provider for GraphQL subscriptions from scratch. We will use [Hasura](https://hasura.io/) as an example, but the same logic can be applied to any GraphQL subscription provider.

`@refinedev/hasura` has a built-in live provider for Hasura subscriptions, but we will create our own from scratch to learn how it works.

Before diving into the code, let's see the difference between GraphQL queries and subscriptions.

**GraphQL queries**

```ts
// highlight-next-line
query GetPosts {
  posts {
    id
    title
    content
  }
}
```

**GraphQL subscriptions**

```ts
// highlight-next-line
subscription GetPosts {
  posts {
    id
    title
    content
  }
}
```

As you can see, the only difference between queries and subscriptions is the `subscription` keyword. This means that we can use the same logic for both queries and subscriptions. We already have a data provider for creating GraphQL queries, so we will use the same logic for GraphQL subscriptions.

### Implementing `subscribe` method

When you call the [`useList`](/docs/data/hooks/use-list), [`useOne`](/docs/data/hooks/use-one) or [`useMany`](/docs/data/hooks/use-many) hooks, they will call the `subscribe` method of the live provider.

Thus, we will be able to create subscription queries using the parameters of these hooks. After creating the subscription query, we will listen it using the [`graphql-ws`](https://github.com/enisdenjo/graphql-ws) client and return the unsubscribe method to use in the `unsubscribe` method of the live provider.

```ts title="liveProvider.ts"
import { LiveProvider } from "@refinedev/core";
import { Client } from "graphql-ws";

import {
  generateUseListSubscription,
  generateUseManySubscription,
  generateUseOneSubscription,
} from "../utils";

const subscriptions = {
  useList: generateUseListSubscription,
  useOne: generateUseOneSubscription,
  useMany: generateUseManySubscription,
};

export const liveProvider = (client: Client): LiveProvider => {
  return {
    subscribe: ({ callback, params, meta }) => {
      const {
        resource,
        pagination,
        sorters,
        filters,
        subscriptionType,
        id,
        ids,
      } = params ?? {};

      if (!meta) {
        throw new Error(
          "[useSubscription]: `meta` is required in `params` for graphql subscriptions",
        );
      }

      if (!subscriptionType) {
        throw new Error(
          "[useSubscription]: `subscriptionType` is required in `params` for graphql subscriptions",
        );
      }

      if (!resource) {
        throw new Error(
          "[useSubscription]: `resource` is required in `params` for graphql subscriptions",
        );
      }

      const generateSubscription = subscriptions[subscriptionType];

      const { query, variables, operation } = generateSubscription({
        ids,
        id,
        resource,
        filters,
        meta,
        pagination,
        sorters,
      });

      const onNext = (payload: { data: any }) => {
        callback(payload.data[operation]);
      };

      const unsubscribe = client.subscribe(
        {
          query,
          variables,
        },
        {
          next: onNext,
          error: () => null,
          complete: () => null,
        },
      );

      // Will be passed to `unsubscribe` method.
      return unsubscribe;
    },
  };
};
```

:::info

`generateUseListSubscription`, `generateUseOneSubscription` and `generateUseManySubscription` are helper functions that generate subscription queries. They are same as the methods in the data provider of `@refinedev/hasura`. You can check them out [here](https://github.com/refinedev/refine/tree/main/packages/hasura/src/utils).

:::

Refine hooks will create a subscription query using the parameters of the [useSubscription](/docs/realtime/hooks/use-subscription) hook and listen to it. When a live event is received, it will call the `onLiveEvent` method of the `useSubscription` hook.

```ts
import { useSubscription } from "@refinedev/core";

useSubscription({
  channel: "posts",
  enabled: true,
  onLiveEvent: (event) => {
    // called when a live event is received
    console.log(event);
  },
  params: {
    resource: "posts",
    pagination: {
      current: 1,
      pageSize: 10,
    },
    subscriptionType: "useList",
  },
  meta: {
    fields: [
      "id",
      "title",
      {
        category: ["title"],
      },
      "content",
      "category_id",
      "created_at",
    ],
  },
});
```

### Implementing `unsubscribe` method

We will call the `unsubscribe` method that we returned from the `subscribe` method to unsubscribe from the subscription query.

```ts title="liveProvider.ts"
import { LiveProvider } from "@refinedev/core";
import { Client } from "graphql-ws";

...

export const liveProvider = (client: Client): LiveProvider => {
    return {
        ...
        unsubscribe: (unsubscribe) => {
            unsubscribe();
        },
    };
};
```

### Usage

Now that we have created our live provider, we can use it in our application like below:

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";
import { createClient } from "graphql-ws";

import { liveProvider } from "./liveProvider";

const gqlWebSocketClient = createClient({
  url: "YOUR_WS_URL",
});

const App: React.FC = () => {
  return (
    <Refine liveProvider={liveProvider(gqlWebSocketClient)}>
      {/* ... */}{" "}
    </Refine>
  );
};
```

================
File: guides-concepts/routing/index.md
================
---
title: Routing
---

Routing is essential for any CRUD application. Refine's headless architecture allows you to use any router solution, without being locked into a specific router/framework.

Refine also offers built-in router integrations for the most popular frameworks such as **React Router**, **Next.js** and **Remix**.

These integrations makes it easier to use Refine with these frameworks and offers a lot of benefits such as:

- Automatic parameter detection in hooks/components.
- Automatic redirections after mutation or authentication.
- Set of utility components & hooks which can be used to navigate between pages/routes.

Since Refine is router agnostic, you are responsible for creating your own routes.

If you are using **React Router**, you'll be defining your routes under the `Routes` component.<br />
If you are using **Next.js**, you'll be defining your routes in the `pages` or `app` directory.<br />
If you are using **Remix**, you'll be defining your routes in the `app/routes` directory.

## Router Integrations

To integrate a router provider with Refine, all you need to do is to import the router integration of your choice and pass it to the `<Refine />`'s `routerProvider` prop.

<Tabs>
<TabItem value="react-router-v6" label="React Router" default>

```tsx title="App.tsx"
import { BrowserRouter, Routes } from "react-router";
// highlight-next-line
import routerProvider from "@refinedev/react-router";

const App = () => (
  <BrowserRouter>
    // highlight-next-line
    <Refine routerProvider={routerProvider}>
      <Routes>{/* Your route definitions */}</Routes>
    </Refine>
  </BrowserRouter>
);
```

[Check out React Router documentation for detailed information](/docs/packages/list-of-packages)

</TabItem>
<TabItem value="nextjs-app" label="Next.js App">

```tsx title="app/layout.tsx"
"use client";
import { Refine } from "@refinedev/core";
// highlight-next-line
import routerProvider from "@refinedev/nextjs-router";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <Refine
          // highlight-next-line
          routerProvider={routerProvider}
        >
          {children}
        </Refine>
      </body>
    </html>
  );
}
```

</TabItem>
<TabItem value="next-js" label="Next.js Pages">

```tsx title="pages/_app.tsx"
import { Refine } from "@refinedev/core";
// highlight-next-line
import routerProvider from "@refinedev/nextjs-router/pages";

export function MyApp({ Component, pageProps }) {
  return (
    <Refine
      // highlight-next-line
      routerProvider={routerProvider}
    >
      <Component {...pageProps} />
    </Refine>
  );
}
```

> While using this integration, you won't be missing out Next.js features such as **SSR** and **ISR**.

[Check out Next.js Router documentation for detailed information](/docs/packages/list-of-packages)

</TabItem>
<TabItem value="remix" label="Remix">

```tsx title="app/root.tsx"
// highlight-next-line
import routerProvider from "@refinedev/remix-router";

export default function App() {
  return (
    <html>
      <body>
        <Refine
          // highlight-next-line
          routerProvider={routerProvider}
        >
          <Outlet />
        </Refine>
      </body>
    </html>
  );
}
```

> While using this integration, you won't be missing out Remix features such as **SSR** and **ISR**.

[Check out Remix Router documentation for detailed information](/docs/packages/list-of-packages)

</TabItem>
<TabItem value="expo-router" label="Expo Router (React Native)">

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";
// highlight-next-line
import routerProvider from "@refinenative/expo-router";

export const App = () => (
  <Refine
    // highlight-next-line
    routerProvider={routerProvider}
  >
    {/* ... */}
  </Refine>
);
```

Refine is able to work on React Native apps and with the help of the community package `@refinenative/expo-router`, you can use Refine's routing features on React Native as well.

[Check out Expo Router (Community Package) documentation for detailed information](https://www.npmjs.com/package/@refinenative/expo-router)

</TabItem>
</Tabs>

Once you passed router provider to `<Refine />` component, you can use all the features of Refine in a same way, regardless of your application's framework/router.

## Relationship Between Resources and Routes <GuideBadge id="guides-concepts/general-concepts" />

Refine can infer current `resource`, `action` and it's `id` from the **current route** based on your **resource definitions**.

This eliminates the need of passing these parameters to the components/hooks manually.

All you have to do is to define your resource and their routes.

```tsx
<Refine
  resources={[
    {
      name: "products",
      list: "/my-products", // http://localhost:3000/my-products
      show: "my-products/:id", // http://localhost:3000/my-products/1
      create: "/my-products/new", // http://localhost:3000/my-products/new
      edit: "/my-products/:id/edit", // http://localhost:3000/my-products/1/edit
      clone: "/my-products/:id/clone", // http://localhost:3000/my-products/1/clone
    },
  ]}
/>
```

You can see how we omit **resource** and **id** parameters for `useList`, and `useShow` hooks in the examples below.

#### React Router

import { ReactRouterResourceAndRoutesUsage } from "./react-router/resource-and-routes-usage";

<ReactRouterResourceAndRoutesUsage />

#### Next.js

import { NextJSResourceAndRoutesUsage } from "./nextjs/resource-and-routes-usage";

<NextJSResourceAndRoutesUsage />

:::info Usage with App Router

You can see the example here: https://github.com/refinedev/refine/tree/main/examples/with-nextjs

:::

#### Remix

import { RemixResourceAndRoutesUsage } from "./remix/resource-and-routes-usage";

<RemixResourceAndRoutesUsage />

## Hook Integrations

### useForm <GuideBadge id="guides-concepts/forms/#integration-with-routers" />

Router integration of Refine allows you to use `useForm` without passing **resource**, **id** and **action** parameters.
It will also redirect you to resource's action route defined in `redirect` prop. `redirect` prop is `list` by default.

import { ReactRouterUseFormUsage } from "./react-router/use-form-usage";

<ReactRouterUseFormUsage />

Additionally, router integrations exposes an `<UnsavedChangesNotifier />` component which can be used to notify the user about unsaved changes before navigating away from the current page. This component provides this feature which can be enabled by setting `warnWhenUnsavedChanges` to `true` in `useForm` hooks.

<Tabs wrapContent={false}>
<TabItem value="react-router" label="React Router">

```tsx title="app.tsx"
import { Refine } from "@refinedev/core";
import {
  routerProvider,
  UnsavedChangesNotifier,
} from "@refinedev/react-router";
import { BrowserRouter, Routes } from "react-router";

const App = () => (
  <BrowserRouter>
    <Refine
      // ...
      routerProvider={routerProvider}
      options={{
        // highlight-next-line
        warnWhenUnsavedChanges: true,
      }}
    >
      <Routes>{/* ... */}</Routes>
      {/* highlight-start */}
      {/* The `UnsavedChangesNotifier` component should be placed under <Refine /> component. */}
      <UnsavedChangesNotifier />
      {/* highlight-end */}
    </Refine>
  </BrowserRouter>
);
```

Check out the [`UnsavedChangesNotifier` section of the React Router integration documentation](/docs/packages/list-of-packages#unsavedchangesnotifier) for more information.

</TabItem>
<TabItem value="next-js" label="Next.js">

```tsx title="_app.tsx"
import type { AppProps } from "next/app";
import { Refine } from "@refinedev/core";
import {
  routerProvider,
  UnsavedChangesNotifier,
} from "@refinedev/nextjs-router/pages";

export default function App({ Component, pageProps }) {
  return (
    <Refine
      // ...
      routerProvider={routerProvider}
      options={{
        // highlight-next-line
        warnWhenUnsavedChanges: true,
      }}
    >
      <Component {...pageProps} />
      {/* highlight-start */}
      {/* The `UnsavedChangesNotifier` component should be placed under <Refine /> component. */}
      <UnsavedChangesNotifier />
      {/* highlight-end */}
    </Refine>
  );
}
```

Check out the [`UnsavedChangesNotifier` section of the React Router integration documentation](/docs/packages/list-of-packages#unsavedchangesnotifier) for more information.

</TabItem>
<TabItem value="remix" label="Remix">

```tsx title="app/root.tsx"
import type { MetaFunction } from "@remix-run/node";

import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

import { Refine } from "@refinedev/core";

// highlight-next-line
import routerProvider, {
  UnsavedChangesNotifier,
} from "@refinedev/remix-router";

export default function App() {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Refine
          // ...
          routerProvider={routerProvider}
          options={{
            // highlight-next-line
            warnWhenUnsavedChanges: true,
          }}
        >
          <Outlet />
          {/* highlight-next-line */}
          <UnsavedChangesNotifier />
        </Refine>
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}
```

Check out the [`UnsavedChangesNotifier` section of the React Router integration documentation](/docs/packages/list-of-packages#unsavedchangesnotifier) for more information.

</TabItem>
</Tabs>

### useTable <GuideBadge id="guides-concepts/tables/#integrating-with-routers" />

`useTable` can synchronize it's parameters (filters, pagination, sorting) with the current route.

To enable synchronization, you need to pass `syncWithLocation: true` to `<Refine />` component's `options` prop.

```tsx
<Refine {...} options={{ syncWithLocation: true }}>

```

Once you pass `syncWithLocation: true` to `<Refine />` component's `options` prop, `useTable` will:

- Read the current route and update it's parameters (filters, pagination, sorting) accordingly.
- Update the current route when it's parameters (filters, pagination, sorting) change.

Let's say we have a `products` list page with the following route:

```
/my-products
```

And we want to filter products by `category.id` and sort them by `id` in `asc` order.

We can pass these parameters to `useTable` hook as follows:

```ts
const { ... } = useTable(
    {
        current: 1,
        pageSize: 2,
        filters: { initial: [{ field: "category.id", operator: "eq", value: 1 }]},
        sorters: { initial: [{ field: "id", direction: "asc" }] }
    }
);
```

`useTable` will automatically update the route to:

```tsx title=http://localhost:3000/my-products
// removed-line
/my-products

// added-line
/my-products?current=1&pageSize=2&sorters[0][field]=id&sorters[0][order]=asc&filters[0][field]=category.id&filters[0][operator]=eq&filters[0][value]=1
```

And you will see a list of products, already **filtered**, **sorted** and **paginated** automatically based on the query parameters of the **current route**.

```ts
const { tableQuery, current, pageSize, filters, sorters } = useTable();

console.log(tableQuery.data.data); // [{...}, {...}]
console.log(tableQuery.data.total); // 32 - total number of unpaginated records
console.log(current); // 1 - current page
console.log(pageSize); // 2 - page size
console.log(filters); // [{ field: "category.id", operator: "eq", value: "1" }]
console.log(sorters); // [{ field: "id", order: "asc" }]
```

Check the examples below to see how you can use `useTable` with router integration.

Notice how `components/products/list.tsx` is the same, regardless of the router integration.

#### React Router

import { ReactRouterUseTableUsage } from "./react-router/use-table-usage";

<ReactRouterUseTableUsage />

#### Next.js

You can use SSR feature with Next.js to fetch initial data on the server side.

import { NextJSUseTableUsage } from "./nextjs/use-table-usage";

<NextJSUseTableUsage />

#### Remix

You can use SSR feature with Remix to fetch initial data on the server side.

import { RemixUseTableUsage } from "./remix/use-table-usage";

<RemixUseTableUsage />

### useModalForm

`useModalForm` can automatically detect `resource` parameter from the current route.

It can also sync it's parameters with the current route.

```tsx
const { ... } = useModalForm({ syncWithLocation: true })
```

Once the modal is visible, current route will look like this:

```
/my-products?modal-products-edit[open]=true&modal-products-edit[id]=1
```

You can see the example below for usage.

import { ReactRouterUseModalFormUsage } from "./react-router/use-modal-form-usage";

<ReactRouterUseModalFormUsage />

### useOne

`useOne` can automatically detect `resource` and `id` parameters from the current route.

```tsx title=components/products/show.tsx
import { useOne } from "@refinedev/core";

// removed-line
const { data: productResponse } = useOne({ resource: "products", id: "1" });

console.log(productResponse.data); // { id: "1", title: "Product 1", ... }

// added-line
const { data: productResponse } = useOne();

console.log(productResponse.data); // { id: "1", title: "Product 1", ... }
```

### useShow

`useShow` can automatically detect `resource` and `id` parameters from the current route.

```tsx title=components/products/show.tsx
import { useShow } from "@refinedev/core";

const { queryResult: showResponse } = useShow({
  // removed-start
  resource: "products",
  id: "1",
  // removed-end
});

console.log(showResponse.data.data); // { id: "1", title: "Product 1", ... }

// added-line
const { queryResult: showResponse } = useShow();

console.log(showResponse.data.data); // { id: "1", title: "Product 1", ... }
```

### useList

`useList` can automatically detect `resource` parameter from the current route.

```tsx title=components/products/list.tsx
import { useList } from "@refinedev/core";

// removed-line
const { data: listResponse } = useList({ resource: "products" });

console.log(listResponse.data); // [{ id: "1", title: "Product 1", ... }, { id: "2", title: "Product 2", ... }]
console.log(listResponse.total); // 32 - total number of unpaginated records

// added-line
const { data: listResponse } = useList();

console.log(listResponse.data); // [{ id: "1", title: "Product 1", ... }, { id: "2", title: "Product 2", ... }]
console.log(listResponse.total); // 32 - total number of unpaginated records
```

:::caution

`config.pagination`, `config.filters`, `config.sorters` will not be automatically detected from the current route.

:::

## The `routerProvider` Interface

A router integration of Refine consists of a set of basic implementations for:

- Ability to navigate between pages/routes
- An interface to interact with the parameters and query strings of the current route
- An utility to navigate back in the history
- A simple component to use for anchor tags

These implementations will be provided via `routerProvider` which expects an object with the following methods:

- `go`: A function that accepts an object and returns a function that handles the navigation.
- `back`: A function that returns a function that handles the navigation back in the history.
- `parse`: A function that returns a function that parses the current route and returns an object.
- `Link`: A React component that accepts a `to` prop and renders a component that handles the navigation to the given `to` prop.

While all these methods are optional, if you're working on creating a custom router integration, you'll be able to incrementally add more features and adopt more of Refine's features by implementing more of these methods.

To learn more about the `routerProvider` interface, check out the [`Router Provider` section of the Core API Reference](/docs/routing/router-provider).

================
File: guides-concepts/routing/nextjs/resource-and-routes-usage.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function NextJSResourceAndRoutesUsage() {
  return (
    <Sandpack
      template="nextjs"
      showFiles
      startRoute="/my-products"
      files={{
        "/pages/_app.tsx": {
          code: AppTsxCode,
        },
        "/style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "/pages/my-products/index.tsx": {
          code: ListTsxCode,
        },
        "/pages/my-products/[id].tsx": {
          code: ShowTsxCode,
          active: true,
        },
      }}
    />
  );
}
const StyleCssCode = /* css */ `
html {
    margin: 0;
    padding: 0;
}
body {
    margin: 0;
    padding: 12px;
}
* {
    box-sizing: border-box;
}
body {
    font-family: sans-serif;
}
form label,
form input,
form button {
    display: block;
    width: 100%;
    margin-bottom: 6px;
}
span + button {
    margin-left: 6px;
}
ul > li {
    margin-bottom: 6px;
}
`.trim();
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/nextjs-router/pages";
import dataProvider from "@refinedev/simple-rest";
import type { AppProps } from "next/app";
import "../style.css";
function App({ Component, pageProps }: AppProps) {
  return (
    <Refine
      routerProvider={routerProvider}
      dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
      resources={[
        {
          name: "products",
          // We're defining the routes and assigning them to an action of a resource
          list: "/my-products",
          show: "/my-products/:id",
          // For sake of simplicity, we are not defining other routes here but the implementation is the same
          // create: "/my-products/new",
          // edit: "/my-products/:id/edit",
          // clone: "/my-products/:id/clone",
        },
      ]}
    >
      <Component {...pageProps} />
    </Refine>
  );
}
export default App;
`.trim();
const ListTsxCode = /* tsx */ `
import React from "react";
import { useGo, useList } from "@refinedev/core";
const ProductList = () => {
  // We're inferring the resource from the route
  // So we call \`useList\` hook without any arguments.
  // const { ... } = useList({ resource: "products" })
  const { data, isLoading } = useList();
  const go = useGo();
  if (isLoading) return <div>Loading...</div>;
  return (
    <ul>
      {data?.data?.map((product) => (
        <li key={product.id}>
          <span>{product.name}</span>
          <button
            onClick={() => {
              go({
                to: {
                  resource: "products",
                  action: "show",
                  id: product.id,
                },
              });
            }}
          >
            show
          </button>
        </li>
      ))}
    </ul>
  );
};
export default ProductList;
`.trim();
const ShowTsxCode = /* tsx */ `
import React from "react";
import { useGo, useShow } from "@refinedev/core";
const ProductShow = () => {
  // We're inferring the resource and the id from the route params
  // So we can call useShow hook without any arguments.
  // const result = useShow({ resource: "products", id: "xxx" })
  const result = useShow();
  const {
    queryResult: { data, isLoading },
  } = result;
  const go = useGo();
  if (isLoading) return <div>Loading...</div>;
  return (
    <>
      <div>
        <h1>{data?.data?.name}</h1>
        <p>Material: {data?.data?.material}</p>
        <small>ID: {data?.data?.id}</small>
      </div>
      <button
        onClick={() => {
          go({ to: { resource: "products", action: "list" } });
        }}
      >
        Go to Products list
      </button>
    </>
  );
};
export default ProductShow;
`.trim();

================
File: guides-concepts/routing/nextjs/use-table-usage.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function NextJSUseTableUsage() {
  return (
    <Sandpack
      template="nextjs"
      showFiles
      startRoute="/my-products"
      files={{
        "/pages/_app.tsx": {
          code: AppTsxCode,
        },
        "/pages/my-products/index.tsx": {
          code: ListPageTsxCode,
          active: true,
        },
        "/components/products/list.tsx": {
          code: ListTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/nextjs-router/pages";
import dataProvider from "@refinedev/simple-rest";
import type { AppProps } from "next/app";
function App({ Component, pageProps }: AppProps) {
  return (
    <Refine
      routerProvider={routerProvider}
      dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
      resources={[
        {
          name: "products",
          list: "/my-products",
        },
      ]}
      options={{ syncWithLocation: true }}
    >
      <Component {...pageProps} />
    </Refine>
  );
}
export default App;
`.trim();
const ListPageTsxCode = /* tsx */ `
import React from "react";
import { useTable } from "@refinedev/core";
import { parseTableParams } from "@refinedev/nextjs-router/pages";
import dataProvider from "@refinedev/simple-rest";
import { ProductList } from "../../components/products/list";
export const getServerSideProps = async (context) => {
  const {
    pagination: queryPagination,
    filters: queryFilters,
    sorters: querySorters,
  } = parseTableParams(context.resolvedUrl?.split("?")[1] ?? "");
  const pagination = {
    current: queryPagination.current ?? 1,
    pageSize: queryPagination.pageSize ?? 2,
  };
  const filters = queryFilters ?? [
    {
      field: "category.id",
      operator: "eq",
      value: "1",
    },
  ];
  const sorters = querySorters ?? [{ field: "id", order: "asc" }];
  const data = await dataProvider("https://api.fake-rest.refine.dev").getList({
    resource: "products",
    filters,
    pagination,
    sorters,
  });
  return {
    props: {
      initialData: data,
      initialProps: { pagination, filters, sorters },
    },
  };
};
const ProductListPage = (props) => {
  const {
    initialData,
    initialProps: { filters, sorters, pagination },
  } = props;
  const tableProps = useTable({
    queryOptions: { initialData },
    filters: { initial: filters },
    sorters: { initial: sorters },
    pagination,
  });
  return <ProductList tableProps={tableProps} />;
};
export default ProductListPage;
`.trim();
const ListTsxCode = `
import React from "react";
export const ProductList: React.FC = ({ tableProps }) => {
  const {
    tableQuery,
    isLoading,
    current,
    setCurrent,
    pageSize,
    pageCount,
    filters,
    setFilters,
    sorters,
    setSorters,
  } = tableProps;
  if (isLoading) return <div>Loading...</div>;
  return (
    <div>
      <h3>Products</h3>
      <table style={{ border: "1px solid black" }}>
        <thead>
          <tr key="header">
            <td>id</td>
            <td>name</td>
            <td>categoryId</td>
          </tr>
        </thead>
        <tbody>
          {tableQuery.data?.data?.map((record) => (
            <tr key={record.id}>
              <td>{record.id}</td>
              <td>{record.name}</td>
              <td>{record.category.id}</td>
            </tr>
          ))}
        </tbody>
      </table>
      <hr />
      Sorting by field:
      <b>
        {sorters[0]?.field}, order {sorters[0]?.order}
      </b>
      <br />
      <button
        onClick={() => {
          setSorters([
            {
              field: "id",
              order: sorters[0]?.order === "asc" ? "desc" : "asc",
            },
          ]);
        }}
      >
        Toggle Sort
      </button>
      <hr />
      Filtering by field:
      <b>
        {filters[0]?.field}, operator {filters[0]?.operator}, value:{" "}
        {filters[0]?.value}
      </b>
      <br />
      <button
        onClick={() => {
          setFilters([
            {
              field: "category.id",
              operator: "eq",
              value: filters[0]?.value === "1" ? "2" : "1",
            },
          ]);
        }}
      >
        Toggle Filter
      </button>
      <hr />
      <p>Current Page: {current}</p>
      <p>Page Size: {pageSize}</p>
      <button
        onClick={() => {
          setCurrent(+current - 1);
        }}
        disabled={+current < 2}
      >
        Previous Page
      </button>
      <button
        onClick={() => {
          setCurrent(+current + 1);
        }}
        disabled={current === pageCount}
      >
        Next Page
      </button>
    </div>
  );
};
`.trim();

================
File: guides-concepts/routing/react-router/resource-and-routes-usage.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function ReactRouterResourceAndRoutesUsage() {
  return (
    <Sandpack
      showNavigator
      showFiles
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/my-products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
        },
        "/pages/products/show.tsx": {
          code: ShowTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
import { BrowserRouter, Route, Routes } from "react-router";
import "./style.css";
import { ProductList } from "./pages/products/list.tsx";
import { ProductShow } from "./pages/products/show.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        resources={[
          {
            name: "products",
            // We're defining the routes and assigning them to an action of a resource
            list: "/my-products",
            show: "/my-products/:id",
            // For sake of simplicity, we are not defining other routes here but the implementation is the same
            // create: "/my-products/new",
            // edit: "/my-products/:id/edit",
            // clone: "/my-products/:id/clone",
          },
        ]}
      >
        <Routes>
          <Route path="/my-products" element={<ProductList />} />
          <Route path="/my-products/:id" element={<ProductShow />} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
}
`.trim();
const StyleCssCode = `
html {
    margin: 0;
    padding: 0;
}
body {
    margin: 0;
    padding: 12px;
}
* {
    box-sizing: border-box;
}
body {
    font-family: sans-serif;
}
form label, form input, form button {
    display: block;
    width: 100%;
    margin-bottom: 6px;
}
span + button {
    margin-left: 6px;
}
ul > li {
    margin-bottom: 6px;
}
`.trim();
const ListTsxCode = `
import React from "react";
import { useGo, useList } from "@refinedev/core";
export const ProductList: React.FC = () => {
  // We're inferring the resource from the route
  // So we call \`useList\` hook without any arguments.
  // const { ... } = useList({ resource: "products" })
  const { data, isLoading } = useList();
  const go = useGo();
  if (isLoading) return <div>Loading...</div>;
  return (
    <ul>
      {data?.data?.map((product) => (
        <li key={product.id}>
          <span>{product.name}</span>
          <button
            onClick={() => {
              go({
                to: {
                  resource: "products",
                  action: "show",
                  id: product.id,
                },
              });
            }}
          >
            show
          </button>
        </li>
      ))}
    </ul>
  );
};
`.trim();
const ShowTsxCode = `
import React from "react";
import { useGo, useShow } from "@refinedev/core";
export const ProductShow: React.FC = () => {
  // We're inferring the resource and the id from the route params
  // So we can call useShow hook without any arguments.
  // const result = useShow({ resource: "products", id: "xxx" })
  const result = useShow();
  const {
    queryResult: { data, isLoading },
  } = result;
  const go = useGo();
  if (isLoading) return <div>Loading...</div>;
  return (
    <>
      <div>
        <h1>{data?.data?.name}</h1>
        <p>Material: {data?.data?.material}</p>
        <small>ID: {data?.data?.id}</small>
      </div>
      <button
        onClick={() => {
          go({
            to: {
              resource: "products",
              action: "list",
            },
          });
        }}
      >
        Go to Products list
      </button>
    </>
  );
};
`.trim();

================
File: guides-concepts/routing/react-router/use-form-usage.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function ReactRouterUseFormUsage() {
  return (
    <Sandpack
      showNavigator
      showFiles
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/my-products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "list.tsx": {
          code: ListTsxCode,
        },
        "edit.tsx": {
          code: EditTsxCode,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
import { BrowserRouter, Route, Routes } from "react-router";
import "./style.css";
import { ProductEdit } from "./edit.tsx";
import { ProductList } from "./list.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        resources={[
          {
            name: "products",
            list: "/my-products",
            edit: "/my-products/:id/edit",
          },
        ]}
      >
        <Routes>
          <Route path="/my-products" element={<ProductList />} />
          <Route path="/my-products/:id/edit" element={<ProductEdit />} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
}
`.trim();
const StyleCssCode = `
html {
    margin: 0;
    padding: 0;
}
body {
    margin: 0;
    padding: 12px;
}
* {
    box-sizing: border-box;
}
body {
    font-family: sans-serif;
}
form label, form input, form button {
    display: block;
    width: 100%;
    margin-bottom: 6px;
}
span + button {
    margin-left: 6px;
}
ul > li {
    margin-bottom: 6px;
}
`.trim();
const ListTsxCode = `
import React from "react";
import { useGo, useList } from "@refinedev/core";
export const ProductList: React.FC = () => {
  const { data, isLoading } = useList();
  const go = useGo();
  if (isLoading) return <div>Loading...</div>;
  return (
    <ul>
      {data?.data?.map((product) => (
        <li key={product.id}>
          <span>{product.name}</span>
          <button
            onClick={() => {
              go({
                to: {
                  resource: "products",
                  action: "edit",
                  id: product.id,
                },
              });
            }}
          >
            edit
          </button>
        </li>
      ))}
    </ul>
  );
};
`.trim();
const EditTsxCode = `
import React from "react";
import { useForm } from "@refinedev/core";
export const ProductEdit: React.FC = () => {
  const { formLoading, onFinish, query } = useForm();
  const defaultValues = query?.data?.data;
  const onSubmit = (e) => {
    e.preventDefault();
    const data = Object.fromEntries(new FormData(e.target).entries());
    onFinish(data);
  };
  return (
    <div>
      <br />
      <form onSubmit={onSubmit}>
        <div>
          <label htmlFor="name">name</label>
          <input
            type="text"
            id="name"
            name="name"
            placeholder="name"
            defaultValue={defaultValues?.name}
          />
        </div>
        <button type="submit" disabled={formLoading}>
          <span>Save</span>
        </button>
      </form>
    </div>
  );
};
`.trim();

================
File: guides-concepts/routing/react-router/use-modal-form-usage.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function ReactRouterUseModalFormUsage() {
  return (
    <Sandpack
      showNavigator
      showFiles
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "@refinedev/react-hook-form": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/my-products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "/components/modal.tsx": {
          code: ModalComponentTsxCode,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
          active: true,
        },
      }}
    />
  );
}
const ModalComponentTsxCode = /* tsx */ `
import React from "react";
export const Modal: React.FC = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null;
  return (
    <>
      <div className="overlay" onClick={onClose}></div>
      <div className="modal">
        <div className="modal-title">
          <button className="close-button" onClick={onClose}>
            &times;
          </button>
        </div>
        <div className="modal-content">{children}</div>
      </div>
    </>
  );
};
`.trim();
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
import { BrowserRouter, Route, Routes } from "react-router";
import "./style.css";
import { ProductList } from "./pages/products/list.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        resources={[
          {
            name: "products",
            list: "/my-products",
          },
        ]}
      >
        <Routes>
          <Route path="/my-products" element={<ProductList />} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
}
`.trim();
const StyleCssCode = `
html {
    margin: 0;
    padding: 0;
}
body {
    margin: 0;
    padding: 12px;
}
* {
    box-sizing: border-box;
}
body {
    font-family: sans-serif;
}
.overlay {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 1000;
}
.modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #fff;
    z-index: 1000;
    width: 75%;
    overflow-y: auto;
}
.modal .modal-title {
    display: flex;
    justify-content: flex-end;
    padding: 4px;
}
.modal .modal-content {
    padding: 0px 16px 16px 16px;
}
form label, form input, form button {
    display: block;
    width: 100%;
    margin-top: 3px;
    margin-bottom: 3px;
}
span + button {
    margin-left: 6px;
}
ul > li {
    margin-bottom: 6px;
}
`.trim();
const ListTsxCode = `
import React from "react";
import { useList } from "@refinedev/core";
import { useModalForm } from "@refinedev/react-hook-form";
import { Modal } from "../../components/modal.tsx";
export const ProductList: React.FC = () => {
  const { data, isLoading } = useList();
  const {
    modal: { visible, close, show },
    refineCore: { onFinish, formLoading },
    handleSubmit,
    register,
    saveButtonProps,
  } = useModalForm({
    refineCoreProps: { action: "edit" },
    syncWithLocation: true,
  });
  if (isLoading) return <div>Loading...</div>;
  return (
    <>
      <Modal isOpen={visible} onClose={close}>
        <form onSubmit={handleSubmit(onFinish)}>
          <div>
            <label htmlFor="name">name</label>
            <input {...register("name")} />
          </div>
          <button type="submit" {...saveButtonProps}>
            <span>Save</span>
          </button>
        </form>
      </Modal>
      <ul>
        {data?.data?.map((product) => (
          <li key={product.id}>
            <span>{product.name}</span>
            <button
              onClick={() => {
                show(product.id);
              }}
            >
              edit
            </button>
          </li>
        ))}
      </ul>
    </>
  );
};
`.trim();

================
File: guides-concepts/routing/react-router/use-table-usage.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function ReactRouterUseTableUsage() {
  return (
    <Sandpack
      showNavigator
      showFiles
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/my-products"
      theme={{}}
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "/style.css": {
          code: StyleCssCode,
          hidden: true,
        },
        "/pages/products/list.tsx": {
          code: ListPageTsxCode,
          active: true,
        },
        "/components/products/list.tsx": {
          code: ListTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
import { BrowserRouter, Route, Routes } from "react-router";
import "./style.css";
import { ListPage } from "./pages/products/list.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        resources={[
          {
            name: "products",
            list: "/my-products",
          },
        ]}
        options={{ syncWithLocation: true }}
      >
        <Routes>
          <Route path="/my-products" element={<ListPage />} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
}
`.trim();
const StyleCssCode = `
html {
    margin: 0;
    padding: 0;
    font-size: 14px;
}
body {
    margin: 0;
    padding: 12px;
}
* {
    box-sizing: border-box;
}
body {
    font-family: sans-serif;
}
form label, form input, form button {
    display: block;
    width: 100%;
    margin-bottom: 6px;
}
span, button {
    margin: 6px 0;
}
ul > li {
    margin-bottom: 6px;
}
`.trim();
const ListPageTsxCode = `
import React from "react";
import { useTable } from "@refinedev/core";
import { ProductList } from "../../components/products/list";
export const ListPage: React.FC = () => {
  const tableProps = useTable({
    pagination: { current: 1, pageSize: 2 },
    filters: {
      initial: [{ field: "category.id", operator: "eq", value: "1" }],
    },
    sorters: { initial: [{ field: "id", order: "asc" }] },
  });
  return <ProductList tableProps={tableProps} />;
};
`.trim();
const ListTsxCode = `
import React from "react";
export const ProductList: React.FC = ({ tableProps }) => {
  const {
    tableQuery,
    isLoading,
    current,
    setCurrent,
    pageSize,
    pageCount,
    filters,
    setFilters,
    sorters,
    setSorters,
  } = tableProps;
  if (isLoading) return <div>Loading...</div>;
  return (
    <div>
      <h3>Products</h3>
      <table style={{ border: "1px solid black" }}>
        <thead>
          <tr key="header">
            <td>id</td>
            <td>name</td>
            <td>categoryId</td>
          </tr>
        </thead>
        <tbody>
          {tableQuery.data?.data?.map((record) => (
            <tr key={record.id}>
              <td>{record.id}</td>
              <td>{record.name}</td>
              <td>{record.category.id}</td>
            </tr>
          ))}
        </tbody>
      </table>
      <hr />
      Sorting by field:
      <b>
        {sorters[0].field}, order {sorters[0].order}
      </b>
      <br />
      <button
        onClick={() => {
          setSorters([
            {
              field: "id",
              order: sorters[0].order === "asc" ? "desc" : "asc",
            },
          ]);
        }}
      >
        Toggle Sort
      </button>
      <hr />
      Filtering by field:
      <b>
        {filters[0].field}, operator {filters[0].operator}, value
        {filters[0].value}
      </b>
      <br />
      <button
        onClick={() => {
          setFilters([
            {
              field: "category.id",
              operator: "eq",
              value: filters[0].value === "1" ? "2" : "1",
            },
          ]);
        }}
      >
        Toggle Filter
      </button>
      <hr />
      <p>Current Page: {current}</p>
      <p>Page Size: {pageSize}</p>
      <button
        onClick={() => {
          setCurrent(current - 1);
        }}
        disabled={current < 2}
      >
        Previous Page
      </button>
      <button
        onClick={() => {
          setCurrent(current + 1);
        }}
        disabled={current === pageCount}
      >
        Next Page
      </button>
    </div>
  );
};
`.trim();

================
File: guides-concepts/routing/remix/resource-and-routes-usage.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function RemixResourceAndRoutesUsage() {
  return (
    <Sandpack
      hidePreview
      showFiles
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/remix-router": "latest",
        "react-router": "^7.0.2",
      }}
      files={{
        "/app/root.tsx": {
          code: RootTsxCode,
        },
        "/app/routes/my-products._index.tsx": {
          code: ListTsxCode,
        },
        "/app/routes/my-products.$id.tsx": {
          code: ShowTsxCode,
          active: true,
        },
      }}
    />
  );
}
const RootTsxCode = /* tsx */ `
import React from "react";
import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/remix-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          resources={[
            {
              name: "products",
              // We're defining the routes and assigning them to an action of a resource
              list: "/my-products",
              show: "/my-products/:id",
              // For sake of simplicity, we are not defining other routes here but the implementation is the same
              // create: "/my-products/new",
              // edit: "/my-products/:id/edit",
              // clone: "/my-products/:id/clone",
            },
          ]}
        >
          <Outlet />
        </Refine>
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}
`.trim();
const ListTsxCode = /* tsx */ `
import { useGo, useList } from "@refinedev/core";
import React from "react";
const ProductList = () => {
  // We're inferring the resource from the route
  // So we call \`useList\` hook without any arguments.
  // const { ... } = useList({ resource: "products" })
  const { data, isLoading } = useList();
  const go = useGo();
  if (isLoading) return <div>Loading...</div>;
  return (
    <ul>
      {data?.data?.map((product) => (
        <li key={product.id}>
          <span>{product.name}</span>
          <button
            onClick={() => {
              go({
                to: {
                  resource: "products",
                  action: "show",
                  id: product.id,
                },
              });
            }}
          >
            show
          </button>
        </li>
      ))}
    </ul>
  );
};
export default ProductList;
`.trim();
const ShowTsxCode = /* tsx */ `
import React from "react";
import { useGo, useShow } from "@refinedev/core";
const ProductShow = () => {
  // We're inferring the resource and the id from the route params
  // So we can call useShow hook without any arguments.
  // const result = useShow({ resource: "products", id: "xxx" })
  const result = useShow();
  const {
    queryResult: { data, isLoading },
  } = result;
  const go = useGo();
  if (isLoading) return <div>Loading...</div>;
  return (
    <>
      <div>
        <h1>{data?.data?.name}</h1>
        <p>Material: {data?.data?.material}</p>
        <small>ID: {data?.data?.id}</small>
      </div>
      <button
        onClick={() => {
          go({ to: { resource: "products", action: "list" } });
        }}
      >
        Go to Products list
      </button>
    </>
  );
};
export default ProductShow;
`.trim();

================
File: guides-concepts/routing/remix/use-table-usage.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export function RemixUseTableUsage() {
  return (
    <Sandpack
      hidePreview
      showFiles
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/remix-router": "latest",
      }}
      files={{
        "/app/root.tsx": {
          code: RootTsxCode,
        },
        "/app/components/products/list.tsx": {
          code: ListTsxCode,
        },
        "/app/routes/my-products._index.tsx": {
          code: ListPageTsxCode,
          active: true,
        },
      }}
    />
  );
}
const RootTsxCode = /* tsx */ `
import React from "react";
import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/remix-router";
import dataProvider from "@refinedev/simple-rest";
export default function App() {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          resources={[
            {
              name: "products",
              list: "/my-products",
            },
          ]}
        >
          <Outlet />
        </Refine>
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}
`.trim();
const ListPageTsxCode = /* tsx */ `
import React from "react";
import { json, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";
import { useTable } from "@refinedev/core";
import { parseTableParams } from "@refinedev/remix-router";
import dataProvider from "@refinedev/simple-rest";
import { ProductList } from "../components/products/list";
export async function loader({ request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  const {
    pagination: queryPagination,
    filters: queryFilters,
    sorters: querySorters,
  } = parseTableParams(url.search);
  const pagination = {
    current: queryPagination.current ?? 1,
    pageSize: queryPagination.pageSize ?? 2,
  };
  const filters = queryFilters ?? [
    {
      field: "category.id",
      operator: "eq",
      value: "1",
    },
  ];
  const sorters = querySorters ?? [{ field: "id", order: "asc" }];
  const data = await dataProvider("https://api.fake-rest.refine.dev").getList({
    resource: "products",
    filters,
    pagination,
    sorters,
  });
  return json({
    initialData: data,
    initialProps: { pagination, filters, sorters },
  });
}
const ProductList = () => {
  const {
    initialData,
    initialProps: { filters, sorters, pagination },
  } = useLoaderData<typeof loader>();
  const tableProps = useTable({
    queryOptions: { initialData },
    filters: { initial: filters },
    sorters: { initial: sorters },
    pagination,
  });
  return <ProductList tableProps={tableProps} />;
};
export default ProductList;
`.trim();
const ListTsxCode = /* tsx */ `
import React from "react";
export const ProductList: React.FC = ({ tableProps }) => {
  const {
    tableQuery,
    isLoading,
    current,
    setCurrent,
    pageSize,
    pageCount,
    filters,
    setFilters,
    sorters,
    setSorters,
  } = tableProps;
  if (isLoading) return <div>Loading...</div>;
  return (
    <div>
      <h3>Products</h3>
      <table style={{ border: "1px solid black" }}>
        <thead>
          <tr key="header">
            <td>id</td>
            <td>name</td>
            <td>categoryId</td>
          </tr>
        </thead>
        <tbody>
          {tableQuery.data?.data?.map((record) => (
            <tr key={record.id}>
              <td>{record.id}</td>
              <td>{record.name}</td>
              <td>{record.category.id}</td>
            </tr>
          ))}
        </tbody>
      </table>
      <hr />
      Sorting by field:
      <b>
        {sorters[0]?.field}, order {sorters[0]?.order}
      </b>
      <br />
      <button
        onClick={() => {
          setSorters([
            {
              field: "id",
              order: sorters[0]?.order === "asc" ? "desc" : "asc",
            },
          ]);
        }}
      >
        Toggle Sort
      </button>
      <hr />
      Filtering by field:
      <b>
        {filters[0]?.field}, operator {filters[0]?.operator}, value:{" "}
        {filters[0]?.value}
      </b>
      <br />
      <button
        onClick={() => {
          setFilters([
            {
              field: "category.id",
              operator: "eq",
              value: filters[0]?.value === "1" ? "2" : "1",
            },
          ]);
        }}
      >
        Toggle Filter
      </button>
      <hr />
      <p>Current Page: {current}</p>
      <p>Page Size: {pageSize}</p>
      <button
        onClick={() => {
          setCurrent(+current - 1);
        }}
        disabled={+current < 2}
      >
        Previous Page
      </button>
      <button
        onClick={() => {
          setCurrent(+current + 1);
        }}
        disabled={current === pageCount}
      >
        Next Page
      </button>
    </div>
  );
};
`.trim();

================
File: guides-concepts/tables/example/antd.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BaseAntdTableExample() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/antd": "latest",
        antd: "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { ConfigProvider, App as AntdApp } from "antd";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <ConfigProvider>
          <AntdApp>
            <Refine dataProvider={dataProvider(API_URL)}>
                <ProductTable />
            </Refine>
          </AntdApp>
        </ConfigProvider>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable, FilterDropdown } from "@refinedev/antd";
import { Table, Input } from "antd";
export const ProductTable: React.FC = () => {
    const { tableProps } = useTable<IProduct>({
        resource: "products",
        filters: {
            initial: [
                {
                    field: "name",
                    operator: "contains",
                    value: "",
                },
            ],
        },
    });
    return (
        <div style={{ padding: "4px" }}>
            <h2>Products</h2>
            <Table {...tableProps} rowKey="id">
                <Table.Column
                    dataIndex="id"
                    title="ID"
                    sorter={{ multiple: 2 }}
                />
                <Table.Column
                    dataIndex="name"
                    title="Name"
                    filterDropdown={(props) => (
                        <FilterDropdown {...props}>
                            <Input placeholder="Search by name" />
                        </FilterDropdown>
                    )}
                />
                <Table.Column
                    dataIndex="price"
                    title="Price"
                    sorter={{ multiple: 1 }}
                />
            </Table>
        </div>
    );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
    material: string;
}
`.trim();

================
File: guides-concepts/tables/example/chakra-ui.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BaseChakraUITable() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-table": "latest",
        "@tanstack/react-table": "latest",
        "@refinedev/chakra-ui": "latest",
        "@chakra-ui/react": "^2.5.1",
        "@tabler/icons-react": "^3.1.0",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
        "/pagination.tsx": {
          code: PaginationTsxCode,
          hidden: false,
        },
        "/column-sorter.tsx": {
          code: ColumnSorterTsxCode,
          hidden: false,
        },
        "/column-filter.tsx": {
          code: ColumnFilterTsxCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { ChakraProvider } from "@chakra-ui/react";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <ChakraProvider>
            <Refine dataProvider={dataProvider(API_URL)}>
                <ProductTable />
            </Refine>
        </ChakraProvider>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";
import {
    Table,
    Thead,
    Tbody,
    Tr,
    Th,
    Td,
    TableContainer,
    HStack,
    Text,
} from "@chakra-ui/react";
import { Pagination } from "./pagination";
import { ColumnSorter } from "./column-sorter";
import { ColumnFilter } from "./column-filter";
export const ProductTable: React.FC = () => {
    const columns = React.useMemo<ColumnDef<IProduct>[]>(
        () => [
            {
                id: "id",
                header: "ID",
                accessorKey: "id",
                meta: {
                    filterOperator: "eq",
                },
            },
            {
                id: "name",
                header: "Name",
                accessorKey: "name",
                meta: {
                    filterOperator: "contains",
                },
            },
            {
                id: "price",
                header: "Price",
                accessorKey: "price",
                meta: {
                    filterOperator: "eq",
                },
            },
        ],
        [],
    );
    const {
        getHeaderGroups,
        getRowModel,
        refineCore: { setCurrent, pageCount, current },
    } = useTable({
        refineCoreProps: {
            resource: "products",
        },
        columns,
    });
    return (
        <div style={{ padding:"8px" }}>
            <Text fontSize='3xl'>Products</Text>
            <TableContainer whiteSpace="pre-line">
                <Table variant="simple">
                    <Thead>
                        {getHeaderGroups().map((headerGroup) => (
                            <Tr key={headerGroup.id}>
                                {headerGroup.headers.map((header) => (
                                    <Th key={header.id}>
                                        {!header.isPlaceholder && (
                                            <HStack spacing="2">
                                                <Text>
                                                    {flexRender(
                                                        header.column.columnDef
                                                            .header,
                                                        header.getContext(),
                                                    )}
                                                </Text>
                                                <HStack spacing="2">
                                                    <ColumnSorter
                                                        column={header.column}
                                                    />
                                                    <ColumnFilter
                                                        column={header.column}
                                                    />
                                                </HStack>
                                            </HStack>
                                        )}
                                    </Th>
                                ))}
                            </Tr>
                        ))}
                    </Thead>
                    <Tbody>
                        {getRowModel().rows.map((row) => (
                            <Tr key={row.id}>
                                {row.getVisibleCells().map((cell) => (
                                    <Td key={cell.id}>
                                        {flexRender(
                                            cell.column.columnDef.cell,
                                            cell.getContext(),
                                        )}
                                    </Td>
                                ))}
                            </Tr>
                        ))}
                    </Tbody>
                </Table>
            </TableContainer>
            <Pagination
                current={current}
                pageCount={pageCount}
                setCurrent={setCurrent}
            />
        </div>
    );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
}
`.trim();
export const PaginationTsxCode = `
import { FC } from "react";
import { HStack, Button, Box } from "@chakra-ui/react";
import { usePagination } from "@refinedev/chakra-ui";
export const Pagination: FC<PaginationProps> = ({
    current,
    pageCount,
    setCurrent,
}) => {
    const pagination = usePagination({
        current,
        pageCount,
    });
    return (
        <Box display="flex" justifyContent="flex-end">
            <HStack my="3" spacing="1">
                {pagination?.prev && (
                    <Button
                        aria-label="previous page"
                        onClick={() => setCurrent(current - 1)}
                        disabled={!pagination?.prev}
                        variant="outline"
                    >
                        Prev
                    </Button>
                )}
                {pagination?.items.map((page) => {
                    if (typeof page === "string")
                        return <span key={page}>...</span>;
                    return (
                        <Button
                            key={page}
                            onClick={() => setCurrent(page)}
                            variant={page === current ? "solid" : "outline"}
                        >
                            {page}
                        </Button>
                    );
                })}
                {pagination?.next && (
                    <Button
                        aria-label="next page"
                        onClick={() => setCurrent(current + 1)}
                        variant="outline"
                    >
                        Next
                    </Button>
                )}
            </HStack>
        </Box>
    );
};
type PaginationProps = {
    current: number;
    pageCount: number;
    setCurrent: (page: number) => void;
};
`.trim();
export const ColumnSorterTsxCode = `
import React, { useState } from "react";
import { IconButton } from "@chakra-ui/react";
import { IconChevronDown, IconChevronUp, IconSelector } from "@tabler/icons-react";
import type { SortDirection } from "@tanstack/react-table";
export interface ColumnButtonProps {
    column: Column<any, any>; // eslint-disable-line
}
export const ColumnSorter: React.FC<ColumnButtonProps> = ({ column }) => {
    if (!column.getCanSort()) {
        return null;
    }
    const sorted = column.getIsSorted();
    return (
        <IconButton
            aria-label="Sort"
            size="xs"
            onClick={column.getToggleSortingHandler()}
            icon={<ColumnSorterIcon sorted={sorted} />}
            variant={sorted ? "light" : "transparent"}
            color={sorted ? "primary" : "gray"}
        />
    );
};
const ColumnSorterIcon = ({ sorted }: { sorted: false | SortDirection }) => {
    if (sorted === "asc") return <IconChevronDown size={18} />;
    if (sorted === "desc") return <IconChevronUp size={18} />;
    return <IconSelector size={18} />;
};
`.trim();
export const ColumnFilterTsxCode = `
import React, { useState } from "react";
import {
    Input,
    Menu,
    IconButton,
    MenuButton,
    MenuList,
    VStack,
    HStack,
} from "@chakra-ui/react";
import { IconFilter, IconX, IconCheck } from "@tabler/icons-react";
interface ColumnButtonProps {
    column: Column<any, any>; // eslint-disable-line
}
export const ColumnFilter: React.FC<ColumnButtonProps> = ({ column }) => {
    // eslint-disable-next-line
    const [state, setState] = useState(null as null | { value: any });
    if (!column.getCanFilter()) {
        return null;
    }
    const open = () =>
        setState({
            value: column.getFilterValue(),
        });
    const close = () => setState(null);
    // eslint-disable-next-line
    const change = (value: any) => setState({ value });
    const clear = () => {
        column.setFilterValue(undefined);
        close();
    };
    const save = () => {
        if (!state) return;
        column.setFilterValue(state.value);
        close();
    };
    const renderFilterElement = () => {
        // eslint-disable-next-line
        const FilterComponent = (column.columnDef?.meta as any)?.filterElement;
        if (!FilterComponent && !!state) {
            return (
                <Input
                    borderRadius="md"
                    size="sm"
                    autoComplete="off"
                    value={state.value}
                    onChange={(e) => change(e.target.value)}
                />
            );
        }
        return (
            <FilterComponent
                value={state?.value}
                onChange={(e: any) => change(e.target.value)}
            />
        );
    };
    return (
        <Menu isOpen={!!state} onClose={close}>
            <MenuButton
                onClick={open}
                as={IconButton}
                aria-label="Options"
                icon={<IconFilter size="16" />}
                variant="ghost"
                size="xs"
            />
            <MenuList p="2">
                {!!state && (
                    <VStack align="flex-start">
                        {renderFilterElement()}
                        <HStack spacing="1">
                            <IconButton
                                aria-label="Clear"
                                size="sm"
                                colorScheme="red"
                                onClick={clear}
                            >
                                <IconX size={18} />
                            </IconButton>
                            <IconButton
                                aria-label="Save"
                                size="sm"
                                onClick={save}
                                colorScheme="green"
                            >
                                <IconCheck size={18} />
                            </IconButton>
                        </HStack>
                    </VStack>
                )}
            </MenuList>
        </Menu>
    );
};
`.trim();

================
File: guides-concepts/tables/example/core.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BaseCoreTable() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine dataProvider={dataProvider(API_URL)}>
            <ProductTable />
        </Refine>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable, pageCount, pageSize, current, setCurrent } from "@refinedev/core";
export const ProductTable: React.FC = () => {
    const { tableQuery, pageCount, pageSize, current, setCurrent } = useTable<IProduct>({
        resource: "products",
        pagination: {
            current: 1, 
            pageSize: 10,
        },
    });
    const posts = tableQuery?.data?.data ?? [];
    if (tableQuery?.isLoading) {
        return <div>Loading...</div>;
    }
    return (
        <div style={{ padding:"8px" }}>
            <h1>Products</h1>
            <table>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Name</th>
                        <th>Price</th>
                    </tr>
                </thead>
                <tbody>
                    {posts.map((post) => (
                        <tr key={post.id}>
                            <td>{post.id}</td>
                            <td>{post.name}</td>
                            <td>{post.price}</td>
                        </tr>
                    ))}
                </tbody>
            </table>
            <hr />
            <p>Current Page: {current}</p>
            <p>Page Size: {pageSize}</p>
            <button
              onClick={() => {
                setCurrent(current - 1);
              }}
              disabled={current < 2}
            >
              Previous Page
            </button>
            <button
              onClick={() => {
                setCurrent(current + 1);
              }}
              disabled={current === pageCount}
            >
              Next Page
            </button>
        </div>
    );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
}
`.trim();

================
File: guides-concepts/tables/example/filtering.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function Filtering() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine dataProvider={dataProvider(API_URL)}>
            <ProductTable />
        </Refine>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable } from "@refinedev/core";
export const ProductTable: React.FC = () => {
  const { tableQuery, filters, setFilters } = useTable<IProduct>({
      resource: "products",
      filters: {
          permanent: [
              {
                  field: "price",
                  value: "200",
                  operator: "lte",
              },
          ],
          initial: [{ field: "category.id", operator: "eq", value: "1" }],
      },
  });
  const products = tableQuery?.data?.data ?? [];
  const getFilterByField = (field: string) => {
      return filters.find((filter) => {
          if ("field" in filter && filter.field === field) {
              return filter;
          }
      }) as LogicalFilter | undefined;
  };
  const resetFilters = () => {
    setFilters([], "replace");
  };
  if (tableQuery.isLoading) {
      return <div>Loading...</div>;
  }
  return (
      <div>
          <h1>Products with price less than 200</h1>
          <table>
              <thead>
                  <tr>
                      <th>ID</th>
                      <th>Name</th>
                      <th>Price</th>
                      <th>categoryId</th>
                  </tr>
              </thead>
              <tbody>
                  {products.map((product) => (
                      <tr key={product.id}>
                          <td>{product.id}</td>
                          <td>{product.name}</td>
                          <td>{product.price}</td>
                          <td>{product.category.id}</td>
                      </tr>
                  ))}
              </tbody>
          </table>
          <hr />
          Filtering by field:
          <b>
              {getFilterByField("category.id")?.field}, operator{" "}
              {getFilterByField("category.id")?.operator}, value
              {getFilterByField("category.id")?.value}
          </b>
          <br />
          <button
              onClick={() => {
                  setFilters([
                      {
                          field: "category.id",
                          operator: "eq",
                          value:
                              getFilterByField("category.id")?.value === "1"
                                  ? "2"
                                  : "1",
                      },
                  ]);
              }}
          >
              Toggle Filter
          </button>
          <button onClick={resetFilters}>Reset filter</button>
      </div>
  );
};
interface IProduct {
  id: number;
  name: string;
  price: string;
  category: {
      id: number;
  };
}
`.trim();

================
File: guides-concepts/tables/example/mantine.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BaseMantineTable() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/mantine": "latest",
        "@refinedev/react-table": "latest",
        "@tanstack/react-table": "latest",
        "@mantine/core": "^5.10.4",
        "@tabler/icons-react": "^3.1.0",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
        "/column-sorter.tsx": {
          code: ColumnSorterTsxCode,
          hidden: false,
        },
        "/column-filter.tsx": {
          code: ColumnFilterTsxCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { MantineProvider, Global } from "@mantine/core";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <MantineProvider
                withNormalizeCSS
                withGlobalStyles
        >
            <Global styles={{ body: { WebkitFontSmoothing: "auto" } }} />
            <Refine dataProvider={dataProvider(API_URL)}>
                <ProductTable />
            </Refine>
        </MantineProvider>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";
import { Box, Group, Table, Pagination } from "@mantine/core";
import { ColumnSorter } from "./column-sorter.tsx";
import { ColumnFilter } from "./column-filter.tsx";
export const ProductTable: React.FC = () => {
    const columns = React.useMemo<ColumnDef<IProduct>[]>(
        () => [
            {
                id: "id",
                header: "ID",
                accessorKey: "id",
                meta: {
                    filterOperator: "eq",
                },
            },
            {
                id: "name",
                header: "Name",
                accessorKey: "name",
                meta: {
                    filterOperator: "contains",
                },
            },
            {
                id: "price",
                header: "Price",
                accessorKey: "price",
                meta: {
                    filterOperator: "eq",
                },
            },
        ],
        [],
    );
    const {
        getHeaderGroups,
        getRowModel,
        refineCore: { setCurrent, pageCount, current },
    } = useTable({
        refineCoreProps: {
            resource: "products",
        },
        columns,
    });
    return (
        <div style={{ padding: "4px" }}>
            <h2>Products</h2>
            <Table highlightOnHover>
                <thead>
                    {getHeaderGroups().map((headerGroup) => (
                        <tr key={headerGroup.id}>
                            {headerGroup.headers.map((header) => {
                                return (
                                    <th key={header.id}>
                                        {!header.isPlaceholder && (
                                            <Group spacing="xs" noWrap>
                                                <Box>
                                                    {flexRender(
                                                        header.column.columnDef
                                                            .header,
                                                        header.getContext(),
                                                    )}
                                                </Box>
                                                <Group spacing="xs" noWrap>
                                                    <ColumnSorter
                                                        column={header.column}
                                                    />
                                                    <ColumnFilter
                                                        column={header.column}
                                                    />
                                                </Group>
                                            </Group>
                                        )}
                                    </th>
                                );
                            })}
                        </tr>
                    ))}
                </thead>
                <tbody>
                    {getRowModel().rows.map((row) => {
                        return (
                            <tr key={row.id}>
                                {row.getVisibleCells().map((cell) => {
                                    return (
                                        <td key={cell.id}>
                                            {flexRender(
                                                cell.column.columnDef.cell,
                                                cell.getContext(),
                                            )}
                                        </td>
                                    );
                                })}
                            </tr>
                        );
                    })}
                </tbody>
            </Table>
            <br />
            <Pagination
                position="right"
                total={pageCount}
                page={current}
                onChange={setCurrent}
            />
        </div>
    );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
}
`.trim();
export const ColumnSorterTsxCode = `
import { ActionIcon } from "@mantine/core";
import { IconChevronDown, IconSelector, IconChevronUp } from "@tabler/icons-react";
export interface ColumnButtonProps {
    column: Column<any, any>; // eslint-disable-line
}
export const ColumnSorter: React.FC<ColumnButtonProps> = ({ column }) => {
    if (!column.getCanSort()) {
        return null;
    }
    const sorted = column.getIsSorted();
    return (
        <ActionIcon
            size="xs"
            onClick={column.getToggleSortingHandler()}
            style={{
                transition: "transform 0.25s",
                transform: \`rotate(\${sorted === "asc" ? "180" : "0"}deg)\`,
            }}
            variant={sorted ? "light" : "transparent"}
            color={sorted ? "primary" : "gray"}
        >
            {!sorted && <IconSelector size={18} />}
            {sorted === "asc" && <IconChevronDown size={18} />}
            {sorted === "desc" && <IconChevronUp size={18} />}
        </ActionIcon>
    );
};
`.trim();
export const ColumnFilterTsxCode = `
import React, { useState } from "react";
import { Column } from "@tanstack/react-table";
import { TextInput, Menu, ActionIcon, Stack, Group } from "@mantine/core";
import { IconFilter, IconX, IconCheck } from "@tabler/icons-react";
interface ColumnButtonProps {
    column: Column<any, any>; // eslint-disable-line
}
export const ColumnFilter: React.FC<ColumnButtonProps> = ({ column }) => {
    // eslint-disable-next-line
    const [state, setState] = useState(null as null | { value: any });
    if (!column.getCanFilter()) {
        return null;
    }
    const open = () =>
        setState({
            value: column.getFilterValue(),
        });
    const close = () => setState(null);
    // eslint-disable-next-line
    const change = (value: any) => setState({ value });
    const clear = () => {
        column.setFilterValue(undefined);
        close();
    };
    const save = () => {
        if (!state) return;
        column.setFilterValue(state.value);
        close();
    };
    const renderFilterElement = () => {
        // eslint-disable-next-line
        const FilterComponent = (column.columnDef?.meta as any)?.filterElement;
        if (!FilterComponent && !!state) {
            return (
                <TextInput
                    autoComplete="off"
                    value={state.value}
                    onChange={(e) => change(e.target.value)}
                />
            );
        }
        return <FilterComponent value={state?.value} onChange={change} />;
    };
    return (
        <Menu
            opened={!!state}
            position="bottom"
            withArrow
            transition="scale-y"
            shadow="xl"
            onClose={close}
            width="256px"
            withinPortal
        >
            <Menu.Target>
                <ActionIcon
                    size="xs"
                    onClick={open}
                    variant={column.getIsFiltered() ? "light" : "transparent"}
                    color={column.getIsFiltered() ? "primary" : "gray"}
                >
                    <IconFilter size={18} />
                </ActionIcon>
            </Menu.Target>
            <Menu.Dropdown>
                {!!state && (
                    <Stack p="xs" spacing="xs">
                        {renderFilterElement()}
                        <Group position="right" spacing={6} noWrap>
                            <ActionIcon
                                size="md"
                                color="gray"
                                variant="outline"
                                onClick={clear}
                            >
                                <IconX size={18} />
                            </ActionIcon>
                            <ActionIcon
                                size="md"
                                onClick={save}
                                color="primary"
                                variant="outline"
                            >
                                <IconCheck size={18} />
                            </ActionIcon>
                        </Group>
                    </Stack>
                )}
            </Menu.Dropdown>
        </Menu>
    );
};
`.trim();

================
File: guides-concepts/tables/example/pagination.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function Pagination() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine dataProvider={dataProvider(API_URL)}>
            <ProductTable />
        </Refine>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable } from "@refinedev/core";
export const ProductTable: React.FC = () => {
  const { tableQuery, pageCount, pageSize, current, setCurrent } = useTable<IProduct>({
    resource: "products",
    pagination: {
        current: 1, 
        pageSize: 10,
        mode: "server", // "client" or "server"
    },
  });
  const posts = tableQuery?.data?.data ?? [];
  if (tableQuery?.isLoading) {
    return <div>Loading...</div>;
  }
  return (
    <div>
      <h1>Products</h1>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Price</th>
          </tr>
        </thead>
        <tbody>
          {posts.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.name}</td>
              <td>{post.price}</td>
            </tr>
          ))}
        </tbody>
      </table>
      <hr />
      <p>Current Page: {current}</p>
      <p>Page Size: {pageSize}</p>
      <button
        onClick={() => {
          setCurrent(current - 1);
        }}
        disabled={current < 2}
      >
        Previous Page
      </button>
      <button
        onClick={() => {
          setCurrent(current + 1);
        }}
        disabled={current === pageCount}
      >
        Next Page
      </button>
    </div>
  );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
}
`.trim();

================
File: guides-concepts/tables/example/relationship.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function Relationship() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/home-page.tsx": {
          code: HomePageTsxCode,
          hidden: false,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { HomePage } from "./home-page.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine
          dataProvider={dataProvider(API_URL)}
        >
            <HomePage />
        </Refine>
    );
}
`.trim();
export const HomePageTsxCode = `
import React from "react";
import { useTable, HttpError, useMany } from "@refinedev/core";
export const HomePage: React.FC = () => {
    const { tableQuery } = useTable<IPost, HttpError>({
        resource: "posts",
    });
    const posts = tableQuery?.data?.data ?? [];
    const categoryIds = posts.map((item) => item.category.id);
    const { data: categoriesData, isLoading } = useMany<ICategory>({
        resource: "categories",
        ids: categoryIds,
        queryOptions: {
            enabled: categoryIds.length > 0,
        },
    });
    if (tableQuery?.isLoading) {
        return <div>Loading...</div>;
    }
    return (
        <div>
            <h1>Posts</h1>
            <table>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Title</th>
                        <th>Category</th>
                    </tr>
                </thead>
                <tbody>
                    {posts.map((post) => (
                        <tr key={post.id}>
                            <td>{post.id}</td>
                            <td>{post.title}</td>
                            <td>
                                {isLoading ? (
                                    <div>Loading...</div>
                                ) : (
                                    categoriesData?.data.find(
                                        (item) => item.id === post.category.id,
                                    )?.title
                                )}
                            </td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};
interface IPost {
    id: number;
    title: string;
    category: {
        id: number;
    };
}
interface ICategory {
    id: number;
    title: string;
}
`.trim();

================
File: guides-concepts/tables/example/search-antd.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function SearchAntd() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/antd": "latest",
        antd: "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { ConfigProvider, App as AntdApp } from "antd";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <ConfigProvider>
          <AntdApp>
            <Refine dataProvider={dataProvider(API_URL)}>
                <ProductTable />
            </Refine>
          </AntdApp>
        </ConfigProvider>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { HttpError } from "@refinedev/core";
import { useTable } from "@refinedev/antd";
import { Button, Form, Input, Space, Table } from "antd";
export const ProductTable: React.FC = () => {
    const { tableProps, searchFormProps } = useTable<
        IProduct,
        HttpError,
        IProduct
    >({
        resource: "products",
        onSearch: (values) => {
            return [
                {
                    field: "name",
                    operator: "contains",
                    value: values.name,
                },
            ];
        },
    });
    return (
        <div style={{ padding: "4px" }}>
            <h2>Products</h2>
            <Form {...searchFormProps}>
                <Space>
                    <Form.Item name="name">
                        <Input placeholder="Search by name" />
                    </Form.Item>
                    <Form.Item>
                        <Button htmlType="submit">Search</Button>
                    </Form.Item>
                </Space>
            </Form>
            <Table {...tableProps} rowKey="id">
                <Table.Column dataIndex="id" title="ID" />
                <Table.Column dataIndex="name" title="Name" />
                <Table.Column dataIndex="price" title="Price" />
            </Table>
        </div>
    );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
}
`.trim();

================
File: guides-concepts/tables/example/sorting.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function Sorting() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine dataProvider={dataProvider(API_URL)}>
            <ProductTable />
        </Refine>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable } from "@refinedev/core";
export const ProductTable: React.FC = () => {
    const { tableQuery, sorters, setSorters } = useTable<IProduct>({
        resource: "products",
        sorters: {
            initial: [{ field: "price", order: "asc" }],
        },
    });
    const products = tableQuery?.data?.data ?? [];
    const findSorterByFieldName = (fieldName: string) => {
        return sorters.find((sorter) => sorter.field === fieldName);
    };
    if (tableQuery.isLoading) {
        return <div>Loading...</div>;
    }
    return (
        <div>
            <h1>Products</h1>
            <table>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Name</th>
                        <th>Price</th>
                    </tr>
                </thead>
                <tbody>
                    {products.map((product) => (
                        <tr key={product.id}>
                            <td>{product.id}</td>
                            <td>{product.name}</td>
                            <td>{product.price}</td>
                        </tr>
                    ))}
                </tbody>
            </table>
            <hr />
            <hr />
            Sorting by field:
            <b>
                {findSorterByFieldName("price")?.field}, order{" "}
                {findSorterByFieldName("price")?.order}
            </b>
            <br />
            <button
                onClick={() => {
                    setSorters([
                        {
                            field: "price",
                            order:
                                findSorterByFieldName("price")?.order === "asc"
                                    ? "desc"
                                    : "asc",
                        },
                    ]);
                }}
            >
                Toggle Sort
            </button>
        </div>
    );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
}
`.trim();

================
File: guides-concepts/tables/example/tanstack-table.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BaseTanStackTable() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@tanstack/react-table": "latest",
        "@refinedev/react-table": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine dataProvider={dataProvider(API_URL)}>
            <ProductTable />
        </Refine>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";
export const ProductTable: React.FC = () => {
    const columns = React.useMemo<ColumnDef<IProduct>[]>(
        () => [
            {
                id: "id",
                header: "ID",
                accessorKey: "id",
                meta: {
                    filterOperator: "eq",
                },
            },
            {
                id: "name",
                header: "Name",
                accessorKey: "name",
                meta: {
                    filterOperator: "contains",
                },
            },
            {
                id: "price",
                header: "Price",
                accessorKey: "price",
                meta: {
                    filterOperator: "eq",
                },
            },
        ],
        [],
    );
    const {
        getHeaderGroups,
        getRowModel,
        getState,
        setPageIndex,
        getCanPreviousPage,
        getPageCount,
        getCanNextPage,
        nextPage,
        previousPage,
        setPageSize,
    } = useTable<IProduct>({
        refineCoreProps: {
            resource: "products",
        },
        columns,
    });
    return (
        <div>
            <h1>Products</h1>
            <table>
                <thead>
                    {getHeaderGroups().map((headerGroup) => (
                        <tr key={headerGroup.id}>
                            {headerGroup.headers.map((header) => {
                                return (
                                    <th key={header.id}>
                                        {header.isPlaceholder ? null : (
                                            <>
                                                <div
                                                    onClick={header.column.getToggleSortingHandler()}
                                                >
                                                    {flexRender(
                                                        header.column.columnDef
                                                            .header,
                                                        header.getContext(),
                                                    )}
                                                    {{
                                                        asc: " 🔼",
                                                        desc: " 🔽",
                                                    }[
                                                        header.column.getIsSorted() as string
                                                    ] ?? " ↕️"}
                                                </div>
                                            </>
                                        )}
                                        {header.column.getCanFilter() ? (
                                            <div>
                                                <input
                                                    value={
                                                        (header.column.getFilterValue() as string) ??
                                                        ""
                                                    }
                                                    onChange={(e) =>
                                                        header.column.setFilterValue(
                                                            e.target.value,
                                                        )
                                                    }
                                                />
                                            </div>
                                        ) : null}
                                    </th>
                                );
                            })}
                        </tr>
                    ))}
                </thead>
                <tbody>
                    {getRowModel().rows.map((row) => {
                        return (
                            <tr key={row.id}>
                                {row.getVisibleCells().map((cell) => {
                                    return (
                                        <td key={cell.id}>
                                            {flexRender(
                                                cell.column.columnDef.cell,
                                                cell.getContext(),
                                            )}
                                        </td>
                                    );
                                })}
                            </tr>
                        );
                    })}
                </tbody>
            </table>
            <div>
                <button
                    onClick={() => setPageIndex(0)}
                    disabled={!getCanPreviousPage()}
                >
                    {"<<"}
                </button>
                <button
                    onClick={() => previousPage()}
                    disabled={!getCanPreviousPage()}
                >
                    {"<"}
                </button>
                <button onClick={() => nextPage()} disabled={!getCanNextPage()}>
                    {">"}
                </button>
                <button
                    onClick={() => setPageIndex(getPageCount() - 1)}
                    disabled={!getCanNextPage()}
                >
                    {">>"}
                </button>
                <span>
                    Page
                    <strong>
                        {getState().pagination.pageIndex + 1} of{" "}
                        {getPageCount()}
                    </strong>
                </span>
                <span>
                    | Go to page:
                    <input
                        type="number"
                        defaultValue={getState().pagination.pageIndex + 1}
                        onChange={(e) => {
                            const page = e.target.value
                                ? Number(e.target.value) - 1
                                : 0;
                            setPageIndex(page);
                        }}
                    />
                </span>{" "}
                <select
                    value={getState().pagination.pageSize}
                    onChange={(e) => {
                        setPageSize(Number(e.target.value));
                    }}
                >
                    {[10, 20, 30, 40, 50].map((pageSize) => (
                        <option key={pageSize} value={pageSize}>
                            Show {pageSize}
                        </option>
                    ))}
                </select>
            </div>
        </div>
    );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
}
`.trim();

================
File: guides-concepts/tables/index.md
================
---
title: Tables
---

import BaseAntdTableExample from "./example/antd.tsx";
import BaseTanStackTable from "./example/tanstack-table";
import BaseCoreExample from "./example/core";
import BaseMaterialUITable from "./example/material-ui";
import BaseMantineTable from "./example/mantine";
import BaseChakraUITable from "./example/chakra-ui";
import SearchAntdTableExample from "./example/search-antd.tsx";
import SearchMaterialUI from "./example/search-material-ui.tsx";
import Relationship from "./example/relationship";
import Pagination from "./example/pagination";
import Filtering from "./example/filtering";
import Sorting from "./example/sorting";

Tables are essential in data-intensive applications, serving as the primary way for organizing and displaying data in a readable format using rows and columns. Their integration, however, is complex due to functionalities like sorting, filtering, and pagination. Refine's **tables** integration aims to make this process as simple as possible while providing as many real world features as possible out of the box. This guide will cover the basics of **tables** in Refine and how to use them.

## Handling Data

[`useTable`][use-table-core] allows us to fetch data according to the sorter, filter, and pagination states. Under the hood, it uses [`useList`][use-list] for the fetch. Its designed to be headless, but Refine offers seamless integration with several popular UI libraries, simplifying the use of their table components.

- [TanStack Table](https://react-table.tanstack.com/) (for Headless, Chakra UI, Mantine) - [Documentation](/docs/packages/list-of-packages)) - [Example](/docs/examples/table/tanstack-table/basic-tanstack-table/)
- [Ant Design Table](https://ant.design/components/table/#header) - [Documentation](/docs/ui-integrations/ant-design/hooks/use-table) - [Example](/examples/table/antd/useTable.md)
- [Material UI DataGrid](https://mui.com/x/react-data-grid/) - [Documentation](/docs/ui-integrations/material-ui/hooks/use-data-grid) - [Example](/examples/table/mui/useDataGrid.md)

## Basic Usage

The usage of the `useTable` hooks may slightly differ between UI libraries, however, the core functionality of `useTable` hook in [`@refinedev/core`][use-table-core] stays consistent in all implementations. The `useTable` hook in Refine's core is the foundation of all the other `useTable` implementations.

<Tabs wrapContent={false}>

<TabItem value="core" label="Refine's Core">

<BaseCoreExample />

[Check out Refine's `useTable` reference page to learn more about the usage and see it in action.][use-table-core]

</TabItem>

<TabItem value="tanstack-table" label="TanStack Table">

<BaseTanStackTable />

[Check out TanStack Table's `useTable` reference page to learn more about the usage and see it in action.](/docs/packages/list-of-packages#installation)

</TabItem>

<TabItem value="ant-design" label="Ant Design">

<BaseAntdTableExample />

[Check out Ant Design's `useTable` reference page to learn more about the usage and see it in action.](/docs/ui-integrations/ant-design/hooks/use-table)

</TabItem>

<TabItem value="material-ui" label="Material UI">

<BaseMaterialUITable />

[Check out Material UI's `useDataGrid` reference page to learn more about the usage and see it in action.](/docs/ui-integrations/material-ui/hooks/use-data-grid)

</TabItem>

<TabItem value="mantine" label={(<span><span className="block">Mantine</span><small className="block">TanStack Table</small></span>)}>

<BaseMantineTable />

[Check out TanStack Table's `useTable` reference page to learn more about the usage and see it in action.](/docs/packages/list-of-packages#installation)

</TabItem>

<TabItem value="chakra-ui" label={(<span><span className="block">Chakra UI</span><small className="block">TanStack Table</small></span>)}>

<BaseChakraUITable />

[Check out TanStack Table's `useTable` reference page to learn more about the usage and see it in action.](/docs/packages/list-of-packages#installation)

</TabItem>

</Tabs>

## Pagination <GuideBadge id="guides-concepts/data-fetching/#filters-sorters-and-pagination" />

`useTable` has a pagination feature. The pagination is done by passing the `current`, `pageSize` and, `mode` keys to `pagination` object.

- **current**: The page index.
- **pageSize**: The number of items per page.
- **mode**: Whether to use server side pagination or not.
  - When `server` is selected, the pagination will be handled on the server side.
  - When `client` is selected, the pagination will be handled on the client side. No request will be sent to the server.
  - When `off` is selected, the pagination will be disabled. All data will be fetched from the server.

You can also change the `current` and `pageSize` values by using the `setCurrent` and `setPageSize` functions that are returned by the `useTable` hook. Every change will trigger a new fetch.

<Pagination />

## Filtering <GuideBadge id="guides-concepts/data-fetching/#filters-sorters-and-pagination" />

`useTable` has a filter feature. The filter is done by using the `initial`, `permanent`, `defaultBehavior` and `mode` keys to `filters` object.

These states are a [`CrudFilters`][crudfilters] type for creating complex single or multiple queries.

- **initial**: The initial filter state. It can be changed by the `setFilters` function.
- **permanent**: The default and unchangeable filter state. It can't be changed by the `setFilters` function.
- **defaultBehavior**: The default behavior of the `setFilters` function.
  - When `merge` is selected, the new filters will be merged with the old ones.
  - When `replace` is selected, the new filters will replace the old ones. It means that the old filters will be deleted.
- **mode**: Whether to use server side filter or not.
  - When `server` is selected, the filters will be sent to the server.
  - When `off` is selected, the filters will be applied on the client side.

[`useTable`][use-table-core] will pass these states to [`dataProvider`][data-provider] for making it possible to fetch the data you need. Handling and adapting these states for API requests is the responsibility of the [`dataProvider`][data-provider]

<Filtering />

## Sorting <GuideBadge id="guides-concepts/data-fetching/#filters-sorters-and-pagination" />

[`useTable`][use-table-core] has a sorter feature. The sorter is done by passing the `initial` and `permanent` keys to `sorters` object. These states are a [`CrudSorter`][crudsorting] type for creating single or multiple queries.

- **initial**: The initial sorter state. It can be changed by the `setSorters` function.
- **permanent**: The default and unchangeable sorter state. It can't be changed by the `setSorters` function.

[`useTable`][use-table-core] will pass these states to [`dataProvider`][data-provider] for making it possible to fetch the data you need. Handling and adapting these states for API requests is the responsibility of the [`dataProvider`][data-provider]

You can change the sorters state by using the `setSorters` function. Every change will trigger a new fetch.

<Sorting />

## Search

`useTable` has a search feature with `onSearch`. The search is done by using the `onSearch` function with `searchFormProps`. These feature enables you to easily connect form state to the table filters.

- **onSearch**: function is triggered when the `searchFormProps.onFinish` is called. It receives the form values as the first argument and expects a promise that returns a [`CrudFilters`][crudfilters] type.
- **searchFormProps**: Has necessary props for the `<form>`.

For example we can fetch product with the name that contains the search value.

<Tabs wrapContent={false}>

<TabItem value="ant-design" label="Ant Design">

<SearchAntdTableExample />

[Check out Ant Design's `useTable` reference page to learn more about the usage and see it in action.](/docs/ui-integrations/ant-design/hooks/use-table)

</TabItem>

<TabItem value="material-ui" label="Material UI">

<SearchMaterialUI />

[Check out Material UI's `useDataGrid` reference page to learn more about the usage and see it in action.](/docs/ui-integrations/material-ui/hooks/use-data-grid)

</TabItem>

</Tabs>

## Integrating with Routers

### Resource <RouterBadge id="guides-concepts/routing/#relationship-between-resources-and-routes-"/>

`useTable` can infer current `resource` from the current route based on your resource definitions. This eliminates the need of passing these parameters to the hooks manually.

```tsx
useTable({
  // When the current route is `/products`, the resource prop can be omitted.
  resource: "products",
});
```

### Sync with Location <RouterBadge id="guides-concepts/routing/#usetable" /> <GlobalConfigBadge id="core/refine-component/#syncwithlocation" />

When you use the [`syncWithLocation`](/docs/data/hooks/use-table#syncwithlocation) feature, the `useTable`'s state (e.g., sort order, filters, pagination) is automatically encoded in the query parameters of the URL, and when the URL changes, the `useTable` state is automatically updated to match. This makes it easy to share table state across different routes or pages, and to allow users to bookmark or share links to specific table views.

## Relationships <GuideBadge id="guides-concepts/data-fetching/#relationships" />

Refine handles data relations with data hooks(eg: `useOne`, `useMany`, etc.). This compositional design allows you to flexibly and efficiently manage data relationships to suit your specific requirements.

For example imagine each post has a many category. We can fetch the categories of the post by using the `useMany` hook.

 <Relationship />

[use-table-core]: /docs/data/hooks/use-table
[use-list]: /docs/data/hooks/use-list
[usequery]: https://react-query.tanstack.com/reference/useQuery
[baserecord]: /docs/core/interface-references#baserecord
[crudsorting]: /docs/core/interface-references#crudsorting
[crudfilters]: /docs/core/interface-references#crudfilters
[httperror]: /docs/core/interface-references#httperror
[Refine swl]: /docs/core/refine-component#syncwithlocation
[syncwithlocationparams]: /docs/core/interface-references#syncwithlocationparams
[notification-provider]: /docs/notification/notification-provider
[data-provider]: /docs/data/data-provider

================
File: guides-concepts/ui-libraries/index.md
================
---
title: UI Libraries
---

Refine's UI library integrations enhance the core functionality by exposing hooks and components, offering prebuilt UI elements with minimal additional, library-specific logic. Refine offers seamless integration with popular UI libraries, allowing you to choose the one that suits your needs. These integrations don't constrain your application's logic. While they provide advantages, you can still create, extend, or mix components independently.

The headless architecture offers the freedom to utilize any UI library or create custom UI integrations. It encapsulates application logic within hooks, helpers, and logical components, making them UI-agnostic and highly composable.

## Available Integrations

Refine has out of the box support for the four libraries that are widely used in the React ecosystem. Each of these has their own composition of components and hooks that are designed to be used seamlessly with little to no effort.

These integrations are made to provide solutions for common use cases such as menus, layouts, action buttons, tables, forms and more while providing a consistent design language with the UI library. Rather than a constraint, these integrations are designed as helpers and extensions to the core functionalities of Refine and the UI libraries.

- [Ant Design with `@refinedev/antd`](/docs/ui-integrations/ant-design/introduction)
- [Material UI with `@refinedev/mui`](/docs/ui-integrations/material-ui/introduction)
- [Chakra UI with `@refinedev/chakra-ui`](/docs/ui-integrations/chakra-ui/introduction)
- [Mantine with `@refinedev/mantine`](/docs/ui-integrations/mantine/introduction)

## Prebuilt Components

Refine's UI integration packages exposes prebuilt components that are designed to be used with the UI libraries. These components are compositions of the Refine's functionalities and the UI libraries' components. Since their implementation is based on the UI libraries, they are easy to customize and extend to fit your needs.

### Layouts and Menus

Layouts and menus are one of the common elements of an application, this is why we're providing layout and menu components for the supported UI libraries. While these components are also a composition of the Refine's core functionalities, they fit well with the design language of the UI libraries and provide a seamless integration.

These components are designed to fit the most common needs of an application with a flexibility to customize them to fit your needs. For example, a `<Sider>` component is available in all of the UI integrations which includes a navigation menu with a multi-level support, an authorization check for menu items and a logout button which leverages the `useLogout` hook of refine.

As an addition to the layouts, there is also `<Breadcrumb />` component that is designed to be used with the layouts which offers a breadcrumb navigation for the views.

### Buttons

Refine's UI integrations offer variety of buttons that are built using the appropriate components of the UI libraries and includes many logical functionalities such as authorization checks, confirmation dialogs, loading states, invalidation, navigation and more.

The list of buttons that are available in the UI integrations are:

- `<CreateButton />`
- `<EditButton />`
- `<ListButton />`
- `<ShowButton />`
- `<CloneButton />`
- `<DeleteButton />`
- `<SaveButton />`
- `<RefreshButton />`
- `<ImportButton />`
- `<ExportButton />`

### Views

Views are designed as wrappers around the content of the pages in the application. They are designed to be used within the layouts and provide basic functionalities such as titles based on the resource, breadcrumbs, related actions and authorization checks.

The list of views that are available in the UI integrations are:

- `<List />`
- `<Show />`
- `<Edit />`
- `<Create />`

### Fields

Field components can be used to render values with appropriate design and format of the UI libraries. These components are built on top of respective components of the UI library and also provide logic for formatting of the values. While these components might not always be suitable for your use case, they can be combined or extended to provide the desired functionality.

The list of provided field components are:

- `<BooleanField />`
- `<DateField />`
- `<EmailField />`
- `<FileField />`
- `<ImageField />`
- `<MarkdownField />`
- `<NumberField />`
- `<TagsField />`
- `<TextField />`
- `<UrlField />`

### Auth Pages

Auth pages are designed to be used as the pages of the authentication flow of the application. They offer an out of the box solution for the login, register, forgot password and reset password pages by leveraging the authentication hooks of Refine.

The list of types of auth pages that are available in the UI integrations are:

- `<AuthPage type="login" />`
- `<AuthPage type="register" />`
- `<AuthPage type="forgot-password" />`
- `<AuthPage type="reset-password" />`

### Error Pages

UI integrations of Refine also provides an `<ErrorPage />` component that you can use to render a 404 page in your app. While these components does not offer much functionality, they are provided as an easy way to render an error page with a consistent design language.

## Customization

While the exported components from the UI integrations mostly accept the props of the underlying UI components, there are cases where you might want to customize these components to fit your needs on both logical and visual level. In these cases, you can use couple of different approaches to achieve your goal, from the most simple to the most complex, here are the options you have:

### Using the props

In many of these components, you'll be able to pass props to override or extend the existing styling and logic. While this is the most simple approach, it might not be enough for some cases. For example, if you want to hide the `<EditButton />` instead of disabling it depending on the user's authorization, you can pass the `accessControl` prop to the component.

```tsx title="edit.tsx"
import { EditButton } from "@refinedev/antd";

<EditButton
  accessControl={{
    hideIfUnauthorized: true,
  }}
/>;
```

### Using the Refine options

Refine has the ability to change some configurations of the components and hooks globally through the `<Refine>` component. This will let the user to change the default logical and visual approaches made in the UI components. For example, we can change the buttons' visibility based on the authorization status through `<Refine>` component. This will effect all of the buttons in the application just by changing it in one place.

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";

<Refine
    accessControlProvider={{
        can: async ({ resource, action, params }) => { ... },
        options: {
            buttons: {
                hideIfUnauthorized: true,
            },
        },
    }}
/>
```

[To learn more about the options, check out the `<Refine>` component documentation.](/docs/core/refine-component)

### Using the `swizzle` command

Refine's CLI has this command called `swizzle` which lets you export the components of the UI integrations and use them in your application. This will let you to change the components in a granular level and use them in your application. You can also use this command to export the `<EditButton />` and change its logic to hide instead of disabling it.

```bash
> npm run refine swizzle

Which package do you want to swizzle? (Use arrow keys or type to search)

Data Provider
 ◯ @refinedev/simple-rest
UI Framework
 ◉ @refinedev/antd

Which component do you want to swizzle?

Buttons
 ◯ CreateButton
 ◯ ShowButton
❯◉ EditButton
Pages
 ◯ ErrorPage
 ◯ AuthPage

(Move up and down to reveal more choices)
```

[To learn more about the `swizzle` command, check out the CLI documentation.](/docs/packages/list-of-packages)

> While `swizzle` provides a way to customize the components, it's a one time operation and it may be hard to maintain the changes and keep track of the new features in the future. Swizzling a component will detach it from the related package and it will be your responsibility to keep it up to date.

## Notifications <GuideBadge id="guides-concepts/notifications/" />

One of the most important parts of an application is the notifications and the visual feedbacks. Refine has this built-in notification integration that works automatically when it's needed in cases such as when a request fails or when a form is submitted.

While this integration is not coupled with the UI integrations, it will be a wise choice to use the one that is provided by the UI libraries for a consistent design language. This is why Refine's UI integrations also provides a `notificationProvider` to be used with the notification integration of refine.

Using of the prebuilt notification providers are optional and can be customized, extended or even swapped with a custom implementation if needed.

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";
import { useNotificationProvider } from "@refinedev/mantine";

const App = () => (
  <Refine
    // highlight-next-line
    notificationProvider={useNotificationProvider}
    /* ... */
  >
    {/* ... */}
  </Refine>
);
```

## Custom Implementations

While there are integrations for the popular UI libraries, every app has its own needs and requirements. This is why Refine is designed in a way that it can be used with any UI library or even without one. This is also true for the UI integrations, you can create your own custom UI integration for your needs.

If you've decided to create your own custom UI integration, the source code of the existing UI integrations will be a good starting point for you. You can check out the source code of the UI integrations from the [GitHub repository](https://github.com/refinedev/refine)

================
File: guides-concepts/usage-with-existing-projects/index.md
================
---
title: Usage with Existing Projects
---

Integrating Refine into an existing project is as simple as installing `@refinedev/core` package and importing `Refine` component into your application.

Once imported, `Refine` component provides necessary context to all children components for **Refine** hooks and components to work.

Only required prop for `Refine` component is `dataProvider`. You can read more about data provider [here](/docs/data/data-provider).

## Quickstart

Only needed package for Refine to work is `@refinedev/core`. For demonstration purposes, we will also install `@refinedev/simple-rest` package to use as data provider. You can use one of our data providers or create your own.

<InstallPackagesCommand args="@refinedev/core @refinedev/simple-rest" />

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";

const API_URL = "https://api.fake-rest.refine.dev";

function App() {
  return (
    <ExistingProvider>
      <Refine dataProvider={dataProvider(API_URL)}>
        {/* You can use Refine hooks inside here */}
        <ComponentWithRefineHooks />
        <ExistingComponent1>
      </Refine>
    </ExistingProvider>
  );
}
```

## Headless Examples

The following example shows how to use Refine's `useShow` hook with an existing application.

<Tabs wrapContent={false}>

<TabItem value="vite" label="Vite">

import { ViteHeadless } from './vite/headless';

As you can see in the example below, wrapping `App.tsx` file with `Refine` component is enough to use Refine hooks inside your application.

<ViteHeadless />

</TabItem>

<TabItem value="nextjs-app" label="Next.js App">

import { NextJSAppHeadless } from './nextjs/app/headless'

As you can see in the example below, wrapping `layout.tsx` file with `Refine` component is enough to use Refine hooks & components inside your application.

<NextJSAppHeadless />

</TabItem>

<TabItem value="nextjs-pages" label="Next.js Pages">

import { NextJSPagesHeadless } from './nextjs/pages/headless'

As you can see in the example below, wrapping `_app.tsx` file with `Refine` component is enough to use Refine hooks & components inside your application.

<NextJSPagesHeadless />

</TabItem>

</Tabs>

## Router Examples

In the following examples below, we will integrate Refine into `/refine` route of an existing application.

See the [Routing Guide](/docs/guides-concepts/routing) for more information.

<Tabs wrapContent={false} defaultValue="react-router">

<TabItem value="react-router" label="React Router">

import { ViteRouter } from './vite/router';

First, we need to install necessary packages:

<InstallPackagesCommand args="@refinedev/core @refinedev/react-router @refinedev/simple-rest" />

:::simple

- We start by creating `RefineContext` component in `refine/refine-context.tsx` file.
  This file will be used to wrap `/refine` routes of our application.

- And then in `App.tsx` file, we are adding a new `Route` component with `path="/refine"` and wrapping it with `RefineContext` component.

- Finally, we create `refine/pages/products/list.tsx` file, here we can use Refine features, since it's layout is wrapped with `Refine` component.

:::

<ViteRouter />

</TabItem>

<TabItem value="nextjs-app-router" label="Next.js App">

import { NextJSAppRouter } from './nextjs/app/router';

First, we need to install necessary packages:

<InstallPackagesCommand args="@refinedev/core @refinedev/nextjs-router @refinedev/simple-rest" />

:::simple

- We start by creating `app/refine/layout.tsx` file, this layout will be used by all pages under `/refine` folder.
- Then we create `app/refine/products/page.tsx` file, here we can use Refine features, since it's layout is wrapped with `Refine` component.

:::

<NextJSAppRouter />

</TabItem>

<TabItem value="nextjs-pages-router" label="Next.js Pages">

import { NextJSPagesRouter } from './nextjs/pages/router';

First, we need to install necessary packages:

<InstallPackagesCommand args="@refinedev/core @refinedev/nextjs-router @refinedev/simple-rest" />

:::simple

- We start by creating `src/components/layout.tsx` file, this component will be conditionally rendered by `pages/_app.tsx` file.
- Then we create `pages/_app.tsx` file, here we are checking if the current file has `getLayout` function, if it does, we are rendering it by wrapping it with `getLayout` function.
- Then we create `pages/refine/products.tsx` file, here we are adding `Page.getLayout` to our component, so it will be wrapped with `Refine` context. Then we can use Refine features, since it's layout is wrapped with `Refine` component.

:::

<NextJSPagesRouter />

</TabItem>

</Tabs>

## Adding UI to Router Examples

In the following examples below, as a follow-up from the previous router examples, we will add Ant Design layout from `@refinedev/antd` package.

See the [UI Libraries guide](/docs/guides-concepts/ui-libraries) for more information.

<Tabs wrapContent={false} defaultValue="vite">

<TabItem value="vite" label="Vite">

import { ViteAntdLayout } from './vite/layout/antd';

First, we need to install necessary packages:

<InstallPackagesCommand args="@refinedev/core @refinedev/react-router @refinedev/antd @refinedev/simple-rest" />

:::simple

- We start by modifying `refine-context.tsx` file, adding necessary imports from `@refinedev/antd` package.

- And then in `App.tsx` file, we are updating our `ErrorComponent` import from `@refinedev/core` to `@refinedev/antd`.

- Finally, in `refine/pages/products/list.tsx` file, we are importing `List` component and `useTable` hook from `@refinedev/antd` package.

:::

<ViteAntdLayout />

</TabItem>

<TabItem value="nextjs-app" label="Next.js App">

import { NextJSAppAntdLayout } from './nextjs/app/layout/antd';

First, we need to install necessary packages:

<InstallPackagesCommand args="@refinedev/core @refinedev/nextjs-router @refinedev/antd @refinedev/simple-rest" />

:::simple

- We start by modifying `app/refine/layout.tsx` file, adding necessary imports from `@refinedev/antd` package.
- Then we modify `app/refine/products/page.tsx` file, here we are using `List` component and `useTable` hook from `@refinedev/antd` package.

:::

<NextJSAppAntdLayout />

</TabItem>

<TabItem value="nextjs-pages" label="Next.js Pages">

import { NextJSPagesAntdLayout } from './nextjs/pages/layout/antd';

First, we need to install necessary packages:

<InstallPackagesCommand args="@refinedev/core @refinedev/nextjs-router @refinedev/antd @refinedev/simple-rest" />

:::simple

- We start by updating `src/components/layout.tsx` file, adding necessary imports from `@refinedev/antd` package.
- Then we modify `pages/refine/products.tsx` file, here we are using `List` component and `useTable` hook from `@refinedev/antd` package.

:::

<NextJSPagesAntdLayout />

</TabItem>

</Tabs>

## Authentication

If want to use Refine with your existing application, probably you already have authentication in-place. In this case, in order to enable Authentication features of `Refine`, only thing you need to do is to implement `AuthProvider`'s [check](/docs/authentication/auth-provider#check) method.

:::simple

If you want to handle Authentication with Refine from scratch, check the [Authentication Guide](/docs/guides-concepts/authentication)

:::

### check Method

Once you provide the `check` method, you can use [Authenticated component](/docs/authentication/components/authenticated) and/or [useIsAuthenticated hook](/docs/authentication/hooks/use-is-authenticated) in your application. Refine will redirect user to given login page for unauthenticated users.

```tsx
import { AuthProvider } from "@refinedev/core";

export const authProvider: AuthProvider = {
  check: async () => {
    const isAuthenticated = myCheckLogic();

    if (isAuthenticated) {
      return { authenticated: true };
    }

    return {
      authenticated: false,
      redirectTo: "/my-login-page",
      error: {
        name: "Authentication Failed.",
        message: "User not found.",
      },
    };
  },
  login: async () => {
    throw new Error("Method not implemented.");
  },
  logout: async () => {
    throw new Error("Method not implemented.");
  },
  onError: async () => {
    throw new Error("Method not implemented.");
  },
};
```

### Optional Methods

Following methods are optional, but could be useful for various use-cases.

#### getIdentity Method

[getIdentity method](/docs/authentication/auth-provider/#getidentity) can be used to enable [useGetIdentity hook](/docs/authentication/hooks/use-get-identity).

This hook is also used to rendering current user information in the header of UI Integration layouts.

- [Ant Design Header Docs Header Section](/docs/ui-integrations/ant-design/components/themed-layout#header)
- [Material UI Header Docs Header Section](/docs/ui-integrations/material-ui/components/themed-layout#header)
- [Chakra UI Header Docs Header Section](/docs/ui-integrations/chakra-ui/components/themed-layout#header)
- [Mantine Header Docs Header Section](/docs/ui-integrations/mantine/components/themed-layout#header)

#### onError

See [Error Handling section in Authentication Guide](/docs/guides-concepts/authentication#error-handling) and [AuthProvider's onError documentation](/docs/authentication/auth-provider#onerror)

#### logout

[logout method](/docs/authentication/auth-provider#logout) can be used to enable [useLogout hook](/docs/authentication/hooks/use-logout)

This hook is also used to render `Logout` button in the sider of UI Integration layouts.

- [Ant Design Header Docs Sider Section](/docs/ui-integrations/ant-design/components/themed-layout#sider)
- [Material UI Header Docs Sider Section](/docs/ui-integrations/material-ui/components/themed-layout#sider)
- [Chakra UI Header Docs Sider Section](/docs/ui-integrations/chakra-ui/components/themed-layout#sider)
- [Mantine Header Docs Sider Section](/docs/ui-integrations/mantine/components/themed-layout#sider)

================
File: guides-concepts/usage-with-existing-projects/nextjs/app/headless.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function NextJSAppHeadless() {
  return (
    <Sandpack
      template="nextjs"
      showNavigator
      showFiles
      files={{
        "app/layout.tsx": {
          code: LayoutTsxCode.trim(),
          active: true,
        },
        "app/refine/page.tsx": {
          code: RefinePageTsxCode.trim(),
        },
        "app/page.tsx": {
          code: PageTsxCode.trim(),
        },
        "app/other/page.tsx": {
          code: OtherPageTsxCode.trim(),
        },
      }}
    />
  );
}
const PageTsxCode = /* tsx */ `
import Link from "next/link";
export default function Home({ data }) {
  return (
    <div>
      <h1>Home Page</h1>
      <Link href="/other">Go to other page</Link>
      <br />
      <Link href="/refine">Go to Refine page</Link>
    </div>
  );
}
`;
const LayoutTsxCode = /* tsx */ `
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
const API_URL = "https://api.fake-rest.refine.dev";
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <Refine dataProvider={dataProvider(API_URL)}>{children}</Refine>
      </body>
    </html>
  );
}
`;
const RefinePageTsxCode = /* tsx */ `
import Link from "next/link";
import { useShow } from "@refinedev/core";
export default function RefinePage() {
  const { queryResult } = useShow({ resource: "products", id: 1 });
  return (
    <div>
      Hello From My Refine Component!
      <hr />
      <p>useShow hook queryResult:</p>
      <code>{JSON.stringify(queryResult.data, null, 2)}</code>
      <hr />
      <Link href="/">Go to Home Page</Link>
    </div>
  );
}
`;
const OtherPageTsxCode = /* tsx */ `
import Link from "next/link";
export default function OtherPage() {
  return (
    <div>
      <h1>Hello From Other Page</h1>
      <Link href="/">Go to Home Page</Link>
    </div>
  );
}
`;

================
File: guides-concepts/usage-with-existing-projects/nextjs/app/layout/antd.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function NextJSAppAntdLayout() {
  return (
    <Sandpack
      template="nextjs"
      showFiles
      showNavigator
      dependencies={{
        "@refinedev/antd": "latest",
        antd: "^5.0.5",
      }}
      startRoute="/"
      files={{
        "/app/refine/layout.tsx": {
          code: RefineLayoutTsxCode.trim(),
          active: true,
        },
        "/app/refine/products/page.tsx": {
          code: RefineProductsPageTsxCode.trim(),
        },
        "/app/layout.tsx": {
          code: LayoutTsxCode.trim(),
          hidden: true,
        },
        "/app/page.tsx": {
          code: IndexPageTsxCode.trim(),
        },
        "/app/about/page.tsx": {
          code: AboutPageTsxCode.trim(),
        },
      }}
    />
  );
}
const LayoutTsxCode = /* tsx */ `
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
`;
const IndexPageTsxCode = /* tsx */ `
import Link from "next/link";
export default function Home() {
  return (
    <main>
      <h1>Home Page</h1>
      <Link href="/about">Go to About page</Link>
      <br />
      <Link href="/refine/products">Go to Refine page</Link>
    </main>
  );
}
`;
const AboutPageTsxCode = /* tsx */ `
import Link from "next/link";
export default function AboutPage() {
  return (
    <div>
      <h1>About Page</h1>
      <Link href="/">Go to Home page</Link>
    </div>
  );
}
`;
const RefineLayoutTsxCode = /* tsx */ `
"use client";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/nextjs-router";
import { RefineThemes, ThemedLayoutV2 } from "@refinedev/antd";
import { App as AntdApp, ConfigProvider } from "antd";
import "@refinedev/antd/dist/reset.css";
export default function RefineLayout({ children }: { children: React.ReactNode }) {
  return (
    <ConfigProvider theme={RefineThemes.Blue}>
      <AntdApp>
        <Refine
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          routerProvider={routerProvider}
          resources={[
            {
              name: "products",
              list: "/refine/products",
            },
          ]}
          options={{ syncWithLocation: true }}
        >
          <ThemedLayoutV2>{children}</ThemedLayoutV2>
        </Refine>
      </AntdApp>
    </ConfigProvider>
  );
}
`;
const RefineProductsPageTsxCode = /* tsx */ `
"use client";
import { List, useTable } from "@refinedev/antd";
import { Table } from "antd";
export default function Products() {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
      </Table>
    </List>
  );
}
`;

================
File: guides-concepts/usage-with-existing-projects/nextjs/app/router.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function NextJSAppRouter() {
  return (
    <Sandpack
      template="nextjs"
      showFiles
      files={{
        "/app/refine/layout.tsx": {
          code: RefineLayoutTsxCode.trim(),
          active: true,
        },
        "/app/refine/products/page.tsx": {
          code: RefineProductsPageTsxCode.trim(),
        },
        "/app/layout.tsx": {
          code: LayoutTsxCode.trim(),
          hidden: true,
        },
        "/app/page.tsx": {
          code: IndexPageTsxCode.trim(),
        },
        "/app/about/page.tsx": {
          code: AboutPageTsxCode.trim(),
        },
      }}
    />
  );
}
const LayoutTsxCode = /* tsx */ `
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
`;
const IndexPageTsxCode = /* tsx */ `
import Link from "next/link";
export default function Home() {
  return (
    <main>
      <h1>Home Page</h1>
      <Link href="/about">Go to About page</Link>
      <br />
      <Link href="/refine/products">Go to Refine page</Link>
    </main>
  );
}
`;
const AboutPageTsxCode = /* tsx */ `
import Link from "next/link";
export default function AboutPage() {
  return (
    <div>
      <h1>About Page</h1>
      <Link href="/">Go to Home page</Link>
    </div>
  );
}
`;
const RefineLayoutTsxCode = /* tsx */ `
"use client";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/nextjs-router";
import dataProvider from "@refinedev/simple-rest";
export default function RefineLayout({ children }: { children: React.ReactNode }) {
  return (
    <Refine
      routerProvider={routerProvider}
      dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
      resources={[
        {
          name: "products",
          list: "/refine/products",
        },
      ]}
      options={{ syncWithLocation: true }}
    >
      {children}
    </Refine>
  );
}
`;
const RefineProductsPageTsxCode = /* tsx */ `
"use client";
import { useList } from "@refinedev/core";
export default function Products() {
  const { data: products } = useList();
  return (
    <div>
      <h1>Refine Products Page</h1>
      <ul>
        {products?.data?.map((record) => (
          <li key={record.id}>{record.name}</li>
        ))}
      </ul>
    </div>
  );
}
`;

================
File: guides-concepts/usage-with-existing-projects/nextjs/pages/headless.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function NextJSPagesHeadless() {
  return (
    <Sandpack
      template="nextjs"
      showNavigator
      showFiles
      files={{
        "pages/_app.tsx": {
          code: AppTsxCode.trim(),
          active: true,
        },
        "pages/refine.tsx": {
          code: RefinePageTsxCode.trim(),
        },
        "pages/index.tsx": {
          code: IndexTsxCode.trim(),
        },
        "pages/other.tsx": {
          code: OtherPageTsxCode.trim(),
        },
      }}
    />
  );
}
const IndexTsxCode = /* tsx */ `
import Link from "next/link";
export default function Home({ data }) {
  return (
    <div>
      <h1>Hello From Home</h1>
      <Link href="/other">Go to Other Page</Link>
      <br />
      <Link href="/refine">Go to Refine Page</Link>
    </div>
  );
}
`;
const AppTsxCode = /* tsx */ `
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
const API_URL = "https://api.fake-rest.refine.dev";
export default function MyApp({ Component, pageProps }) {
  return (
    <Refine dataProvider={dataProvider(API_URL)}>
      <Component {...pageProps} />
    </Refine>
  );
}
`;
const RefinePageTsxCode = /* tsx */ `
import Link from "next/link";
import { useShow } from "@refinedev/core";
export default function RefinePage() {
  const { queryResult } = useShow({ resource: "products", id: 1 });
  return (
    <div>
      Hello From My Refine Component!
      <hr />
      <p>useShow hook queryResult:</p>
      <code>{JSON.stringify(queryResult.data, null, 2)}</code>
      <hr />
      <Link href="/">Go to Home Page</Link>
    </div>
  );
}
`;
const OtherPageTsxCode = /* tsx */ `
export default function OtherPage() {
  return (
    <div>
      <h1>Hello From Other Page</h1>
      <Link href="/">Go to Home Page</Link>
    </div>
  );
}
`;

================
File: guides-concepts/usage-with-existing-projects/nextjs/pages/layout/antd.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function NextJSPagesAntdLayout() {
  return (
    <Sandpack
      template="nextjs"
      showNavigator
      showFiles
      dependencies={{
        "@refinedev/antd": "latest",
        antd: "^5.0.5",
      }}
      startRoute="/"
      files={{
        "/src/components/refine-layout.tsx": {
          code: RefineLayoutTsxCode.trim(),
          active: true,
        },
        "/pages/_app.tsx": {
          code: AppTsxCode.trim(),
        },
        "/pages/refine/products.tsx": {
          code: RefineProductsTsxCode.trim(),
        },
        "/pages/about.tsx": {
          code: AboutTsxCode.trim(),
        },
        "/pages/index.tsx": {
          code: IndexTsxCode.trim(),
        },
        "/next.config.js": {
          code: NextConfigJsCode.trim(),
        },
      }}
    />
  );
}
const NextConfigJsCode = /* js */ `
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  transpilePackages: [
    "@ant-design/icons-svg",
    "@refinedev/nextjs-router",
    "@refinedev/antd",
    "antd",
    "@ant-design/pro-components",
    "@ant-design/pro-layout",
    "@ant-design/pro-utils",
    "@ant-design/pro-provider",
    "rc-pagination",
    "rc-picker",
    "rc-util",
  ],
};
module.exports = nextConfig;
`;
const AppTsxCode = /* tsx */ `
import type { ReactElement, ReactNode } from "react";
import type { NextPage } from "next";
import type { AppProps } from "next/app";
export type NextPageWithLayout<P = {}, IP = P> = NextPage<P, IP> & {
  getLayout?: (page: ReactElement) => ReactNode;
};
type AppPropsWithLayout = AppProps & {
  Component: NextPageWithLayout;
};
export default function MyApp({ Component, pageProps }: AppPropsWithLayout) {
  // Use the layout defined at the page level, if available
  const getLayout = Component.getLayout ?? ((page) => page);
  return getLayout(<Component {...pageProps} />);
}
`;
const IndexTsxCode = /* tsx */ `
import Link from "next/link";
export default function Home() {
  return (
    <>
      <h1>Home Page</h1>
      <Link href="/about">Go to About page</Link>
      <br />
      <Link href="/refine/products">Go to Refine page</Link>
    </>
  );
}
`;
const AboutTsxCode = /* tsx */ `
import Link from "next/link";
export default function AboutPage() {
  return (
    <div>
      <h1>About Page</h1>
      <Link href="/">Go to Home page</Link>
    </div>
  );
}
`;
const RefineLayoutTsxCode = /* tsx */ `
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/nextjs-router/pages";
import { RefineThemes, ThemedLayoutV2 } from "@refinedev/antd";
import { App as AntdApp, ConfigProvider } from "antd";
import "@refinedev/antd/dist/reset.css";
export default function RefineLayout({ children }) {
  return (
    <ConfigProvider theme={RefineThemes.Blue}>
      <AntdApp>
        <Refine
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          routerProvider={routerProvider}
          resources={[
            {
              name: "products",
              list: "/refine/products",
            },
          ]}
          options={{ syncWithLocation: true }}
        >
          <ThemedLayoutV2>{children}</ThemedLayoutV2>
        </Refine>
      </AntdApp>
    </ConfigProvider>
  );
}
`;
const RefineProductsTsxCode = /* tsx */ `
import type { ReactElement } from "react";
import { List, useTable } from "@refinedev/antd";
import { Table } from "antd";
import RefineLayout from "../../src/components/refine-layout";
import type { NextPageWithLayout } from "../_app";
const Page: NextPageWithLayout = () => {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
      </Table>
    </List>
  );
};
Page.getLayout = function getLayout(page: ReactElement) {
  return <RefineLayout>{page}</RefineLayout>;
};
export default Page;
`;

================
File: guides-concepts/usage-with-existing-projects/nextjs/pages/router.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function NextJSPagesRouter() {
  return (
    <Sandpack
      template="nextjs"
      showFiles
      files={{
        "/src/components/refine-layout.tsx": {
          code: RefineLayoutTsxCode.trim(),
          active: true,
        },
        "/pages/_app.tsx": {
          code: AppTsxCode.trim(),
        },
        "/pages/refine/products.tsx": {
          code: RefineProductsTsxCode.trim(),
        },
        "/pages/about.tsx": {
          code: AboutTsxCode.trim(),
        },
        "/pages/index.tsx": {
          code: IndexTsxCode.trim(),
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import type { ReactElement, ReactNode } from "react";
import type { NextPage } from "next";
import type { AppProps } from "next/app";
export type NextPageWithLayout<P = {}, IP = P> = NextPage<P, IP> & {
  getLayout?: (page: ReactElement) => ReactNode;
};
type AppPropsWithLayout = AppProps & {
  Component: NextPageWithLayout;
};
export default function MyApp({ Component, pageProps }: AppPropsWithLayout) {
  // Use the layout defined at the page level, if available
  const getLayout = Component.getLayout ?? ((page) => page);
  return getLayout(<Component {...pageProps} />);
}
`;
const IndexTsxCode = /* tsx */ `
import Link from "next/link";
export default function Home() {
  return (
    <>
      <h1>Home Page</h1>
      <Link href="/about">Go to About page</Link>
      <br />
      <Link href="/refine/products">Go to Refine page</Link>
    </>
  );
}
`;
const AboutTsxCode = /* tsx */ `
import Link from "next/link";
export default function AboutPage() {
  return (
    <div>
      <h1>About Page</h1>
      <Link href="/">Go to Home page</Link>
    </div>
  );
}
`;
const RefineLayoutTsxCode = /* tsx */ `
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/nextjs-router/pages";
import dataProvider from "@refinedev/simple-rest";
export default function RefineLayout({ children }) {
  return (
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          resources={[
            {
              name: "products",
              list: "/refine/products",
            },
          ]}
          options={{ syncWithLocation: true }}
        >
         {children}
        </Refine>
      </AntdApp>
    </ConfigProvider>
  );
}
`;
const RefineProductsTsxCode = /* tsx */ `
import type { ReactElement } from "react";
import { useList } from "@refinedev/core";
import RefineLayout from "../../src/components/refine-layout";
import type { NextPageWithLayout } from "../_app";
const Page: NextPageWithLayout = () => {
  const { data: products } = useList();
  return (
    <div>
      <h1>Refine Products Page</h1>
      <ul>
        {products?.data?.map((record) => (
          <li key={record.id}>{record.name}</li>
        ))}
      </ul>
    </div>
  );
};
Page.getLayout = function getLayout(page: ReactElement) {
  return <RefineLayout>{page}</RefineLayout>;
};
export default Page;
`;

================
File: guides-concepts/usage-with-existing-projects/vite/headless.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function ViteHeadless() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
      }}
      showFiles
      files={{
        "/App.tsx": {
          code: AppTsxCode,
        },
        "src/refine-component.tsx": { code: RefineComponentCode.trim() },
        "src/other-component.tsx": {
          code: OtherComponentCode.trim(),
        },
      }}
    />
  );
}
const AppTsxCode = /* tsx */ `
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { OtherComponent } from "./src/other-component";
import { RefineComponent } from "./src/refine-component";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
  return (
    <>
      <Refine dataProvider={dataProvider(API_URL)}>
        {/* You can use Refine hooks here */}
        <OtherComponent />
        <RefineComponent />
      </Refine>
    </>
  );
}
`;
const OtherComponentCode = `
export const OtherComponent = () => {
  return (
    <div>
      <p>Hello From My Existing Component</p>
      <p>This component represents your existing components.</p>
      <hr />
    </div>
  );
};
`;
const RefineComponentCode = /* tsx */ `
import { useShow } from "@refinedev/core";
export const RefineComponent = () => {
  const { queryResult } = useShow({ resource: "products", id: 1 });
  return (
    <div>
      <p>Hello From My Refine Component!</p>
      <code>{\`const { queryResult } = useShow({ resource: "products", id: 1 });\`}</code>
      <p>useShow hook queryResult:</p>
      <code>{JSON.stringify(queryResult.data, null, 2)}</code>
    </div>
  );
};
`;

================
File: guides-concepts/usage-with-existing-projects/vite/layout/antd.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function ViteAntdLayout() {
  return (
    <Sandpack
      showNavigator
      showFiles
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/"
      files={{
        "/refine/refine-context.tsx": {
          code: RefineContextTsxCode.trim(),
          active: true,
        },
        "/App.tsx": {
          code: AppTsxCode.trim(),
        },
        "/refine/pages/products/list.tsx": {
          code: ListTsxCode.trim(),
        },
        "/pages/home.tsx": {
          code: HomeTsxCode.trim(),
        },
        "/pages/about.tsx": {
          code: AboutTsxCode.trim(),
        },
      }}
    />
  );
}
const HomeTsxCode = /* tsx */ `
export const Home = () => {
  return (
    <>
      <h1>Home Page</h1>
      <p>This file represents your existing page.</p>
      <p>This component isn't wrapped with Refine context.</p>
      <a href="/about">Go to About page</a>
      <br />
      <a href="/refine">Go to Refine page</a>
    </>
  );
};
`;
const AboutTsxCode = /* tsx */ `
export const About = () => {
  return (
    <div>
      <h1>About Page</h1>
      <a href="/">Go to Home page</a>
    </div>
  );
};
`;
const RefineContextTsxCode = /* tsx */ `
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";
import { RefineThemes, ThemedLayoutV2 } from "@refinedev/antd";
import { App as AntdApp, ConfigProvider } from "antd";
import "@refinedev/antd/dist/reset.css";
export function RefineContext({ children }) {
  return (
    <ConfigProvider theme={RefineThemes.Blue}>
      <AntdApp>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          resources={[
            {
              name: "products",
              list: "/refine/products",
            },
          ]}
          options={{ syncWithLocation: true }}
        >
          <ThemedLayoutV2>{children}</ThemedLayoutV2>
        </Refine>
      </AntdApp>
    </ConfigProvider>
  );
}
`;
const AppTsxCode = /* tsx */ `
import { BrowserRouter, Route, Routes, Outlet } from "react-router";
import { ErrorComponent } from "@refinedev/antd";
import { NavigateToResource } from "@refinedev/react-router";
import { Home } from "./pages/home.tsx";
import { About } from "./pages/about.tsx";
import { ProductList } from "./refine/pages/products/list.tsx";
import { RefineContext } from "./refine/refine-context.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* Your existing routes */}
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        {/* Refine routes */}
        <Route
          path="/refine"
          element={
            <RefineContext>
              <Outlet />
            </RefineContext>
          }
        >
          <Route index element={<NavigateToResource />} />
          <Route path="products" element={<ProductList />} />
          <Route path="*" element={<ErrorComponent />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
`;
const ListTsxCode = `
import { List, useTable } from "@refinedev/antd";
import { Table } from "antd";
export const ProductList = () => {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
      </Table>
    </List>
  );
};
`;

================
File: guides-concepts/usage-with-existing-projects/vite/router.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export function ViteRouter() {
  return (
    <Sandpack
      showNavigator
      showFiles
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
      }}
      startRoute="/"
      files={{
        "/refine/refine-context.tsx": {
          code: RefineContextTsxCode.trim(),
          active: true,
        },
        "/App.tsx": {
          code: AppTsxCode.trim(),
        },
        "/refine/pages/products/list.tsx": {
          code: ListTsxCode.trim(),
        },
        "/pages/home.tsx": {
          code: HomeTsxCode.trim(),
        },
        "/pages/about.tsx": {
          code: AboutTsxCode.trim(),
        },
      }}
    />
  );
}
const HomeTsxCode = /* tsx */ `
export const Home = () => {
  return (
    <>
      <h1>Home Page</h1>
      <p>This file represents your existing page.</p>
      <p>This component isn't wrapped with Refine context.</p>
      <a href="/about">Go to About page</a>
      <br />
      <a href="/refine">Go to Refine page</a>
    </>
  );
};
`;
const AboutTsxCode = /* tsx */ `
export const About = () => {
  return (
    <div>
      <h1>About Page</h1>
      <a href="/">Go to Home page</a>
    </div>
  );
};
`;
const RefineContextTsxCode = /* tsx */ `
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";
export function RefineContext({ children }) {
  return (
    <Refine
      routerProvider={routerProvider}
      dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
      resources={[
        {
          name: "products",
          list: "/refine/products",
        },
      ]}
      options={{ syncWithLocation: true }}
    >
      {children}
    </Refine>
  );
}
`;
const AppTsxCode = /* tsx */ `
import { BrowserRouter, Route, Routes, Outlet } from "react-router";
import { ErrorComponent } from "@refinedev/core";
import { NavigateToResource } from "@refinedev/react-router";
import { Home } from "./pages/home.tsx";
import { About } from "./pages/about.tsx";
import { ProductList } from "./refine/pages/products/list.tsx";
import { RefineContext } from "./refine/refine-context.tsx";
export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* Your existing routes */}
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        {/* Refine routes */}
        <Route
          path="/refine"
          element={
            <RefineContext>
              <Outlet />
            </RefineContext>
          }
        >
          <Route index element={<NavigateToResource />} />
          <Route path="products" element={<ProductList />} />
          <Route path="*" element={<ErrorComponent />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
`;
const ListTsxCode = `
import { useList } from "@refinedev/core";
export const ProductList = () => {
  const { data: products } = useList();
  return (
    <div>
      <h1>Refine Products Page</h1>
      <ul>
        {products?.data?.map((record) => (
          <li key={record.id}>{record.name}</li>
        ))}
      </ul>
    </div>
  );
};
`;

================
File: i18n/hooks/use-translation/index.md
================
---
title: useTranslation
---

The `useTranslation` hook, allows you to use call `translate`, `changeLocale`, and `getLocale` methods from the [`i18nProvider`](/docs/i18n/i18n-provider) that you provided. It can be used to translate texts, change the locale, and get the current locale in your own components.

## Usage

> This hook can only be used if [`i18nProvider`](/docs/i18n/i18n-provider) is provided.

```tsx
import { useTranslation } from "@refinedev/core";

export const MyComponent = () => {
  const { translate, getLocale, changeLocale } = useTranslation();
  const currentLocale = getLocale();

  return (
    <div>
      <h1>{translate("languages")}</h1>
      <button
        onClick={() => changeLocale("en")}
        disabled={currentLocale === "en"}
      >
        English
      </button>
      <button
        onClick={() => changeLocale("de")}
        disabled={currentLocale === "de"}
      >
        German
      </button>
    </div>
  );
};
```

## translate

If you need to translate the texts in your own components, you can use `translate` method. It calls the `translate` method from [`i18nProvider`](/docs/i18n/i18n-provider) under the hood.

```tsx
import { useTranslate } from "@refinedev/core";

export const MyComponent = () => {
  const { translate } = useTranslate();

  return <button>{translate("my.translate.text")}</button>;
};
```

## changeLocale

If you need to change the locale at runtime, you can use the `changeLocale` method. It calls the `changeLocale` method from [`i18nProvider`](/docs/i18n/i18n-provider) under the hood.

```tsx
import { useSetLocale } from "@refinedev/core";

export const LanguageSwicher = () => {
  const { changeLocale } = useTranslation();

  return (
    <div>
      <span>Languages</span>
      <button onClick={() => changeLanguage("en")}>English</button>
      <button onClick={() => changeLanguage("es")}>Spanish</button>
    </div>
  );
};
```

## getLocale

If you need to know the current locale, you can use the `getLocale` method. It calls the `getLocale` method from [`i18nProvider`](/docs/i18n/i18n-provider) under the hood.

```tsx
import { useSetLocale } from "@refinedev/core";

export const LanguageSwicher = () => {
  const { getLocale } = useTranslation();

  return <h1>Current Locale: {getLocale()}</h1>;
};
```

================
File: i18n/i18n-provider/index.md
================
---
title: i18n Provider
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TranslationFileEN from '../../partials/\_partial-translation-file-en.md';

# i18n Provider <GuideBadge id="guides-concepts/i18n" />

Internationalization (i18n) is a process that allows software applications to be localized for different regions and languages. Refine can work with any i18n framework, but needs an `i18nProvider` to be created based on the chosen library.

Refine expects the `i18nProvider` type as follows:

```ts
import { I18nProvider } from "@refinedev/core";

const i18nProvider: I18nProvider = {
  translate: (key: string, options?: any, defaultMessage?: string) => string,
  changeLocale: (lang: string, options?: any) => Promise,
  getLocale: () => string,
};
```

After creating a `i18nProvider`, you can pass it to the `<Refine />` component:

```tsx title="src/App.tsx"
import { Refine } from "@refinedev/core";

import i18nProvider from "./i18nProvider";

const App: React.FC = () => {
  return (
    <Refine
      // highlight-next-line
      i18nProvider={i18nProvider}
      /* ... */
    >
      {/* ... */}
    </Refine>
  );
};
```

This will allow us to put translation features to the [`useTranslation`][use-translation] hook

## Methods

### translate

`translate` takes parameters and passes them to the provided `i18nProvider` and expects a string as a return value.

It has two [function signatures](https://developer.mozilla.org/en-US/docs/Glossary/Signature/Function) with different parameters, which is known as function overloading.

```ts
function translate(key: string, options?: any, defaultMessage?: string): string;
function translate(key: string, defaultMessage?: string): string;
```

It means that you can use it in two different ways. The first one is to pass the `key`, `options`, and, `defaultMessage` as parameters. The second one is to pass the `key` and `defaultMessage` parameters. The `options` parameter is optional.

- Example of the `key` and `defaultMessage` function signature

```tsx
import { I18nProvider } from "@refinedev/core";
import { useTranslation } from "react-i18next";

// ...

const { t } = useTranslation();

const i18nProvider: I18nProvider = {
  translate: (key: string, defaultMessage?: string) => t(key, defaultMessage),
  // ...
};

// ...
```

```tsx
import { useTranslation } from "@refinedev/core";

// ...

const { translate } = useTranslation();

// ...

translate("posts.fields.title", "Title");

// ...
```

- Example of the `key`, `options` and, `defaultMessage` function signature

```tsx
import { I18nProvider } from "@refinedev/core";
import { useTranslation } from "react-i18next";

// ...

const { t } = useTranslation();

const i18nProvider: I18nProvider = {
  translate: (key: string, options?: any, defaultMessage?: string) =>
    t(key, defaultMessage, options),
  // ...
};

// ...
```

```tsx
import { useTranslation } from "@refinedev/core";

// ...

const { translate } = useTranslation();

// ...

const title = translate("posts.fields.title", { ns: "resources" }, "Title");

// ...
```

You can use the [`useTranslation`][use-translation] hook to call `translate` method.

### changeLocale

`translate` takes parameters and passes them to the provided `i18nProvider` and expects a Promise as a return value.

```ts
changeLocale: (locale: string, options?: any) => Promise<any>;
```

You can use the [`useTranslation`][use-translation] hook to call `changeLocale` method.

### getLocale

`getLocale` expects a string as a return value. It should return the current locale from your `i18nProvider`.

```ts
getLocale: () => string;
```

You can use the [`useTranslation`][use-translation] hook to call `getLocale` method.

## Translation file

All of Refine's components supports `i18n`, meaning that if you want to change their text, you can create your own translation files to override Refine's default texts.

Here is the list of all translation keys that you can override:

<details>
<summary>Show translation file</summary>

<TranslationFileEN />

</details>

## FAQ

### How can I create translation files for other languages in an automated way?

You can use the following community example project as a starting point for incorporating automated translations. The project adds deepl-translate-github-action which uses DeepL, an AI translation service to translate your locales json.

- [refine-i18n-react](https://github.com/lyqht/refine-i18n-react)

## Example

<CodeSandboxExample path="i18n-react" />

[i18nnextjs]: /examples/i18n/i18n-nextjs.md
[react-i18next]: https://react.i18next.com/
[create-refine-app]: /docs/getting-started/quickstart.md
[use-translation]: /docs/i18n/hooks/use-translation

================
File: notification/hooks/use-notification/basic-usage-live-preview.md
================
```tsx live url=http://localhost:3000/products previewHeight=200px hideCode
setInitialRoutes(["/"]);
// visible-block-start
import { useNotification } from "@refinedev/core";
import { Button, Stack } from "@mui/material";

const ExamplePage: React.FC = () => {
  const { open, close } = useNotification();

  return (
    <Stack spacing={2} direction="row">
      <Button
        color="success"
        variant="outlined"
        size="small"
        onClick={() =>
          open?.({
            type: "success",
            message: "Success",
            description: "Success description",
          })
        }
      >
        Success
      </Button>
      <Button
        color="error"
        variant="outlined"
        size="small"
        onClick={() =>
          open?.({
            type: "error",
            message: "Error",
            description: "Error description",
          })
        }
      >
        Error
      </Button>

      <Button
        color="secondary"
        variant="outlined"
        size="small"
        onClick={() =>
          open?.({
            type: "progress",
            message: "Progress",
            undoableTimeout: 5,
            cancelMutation: () => {
              alert("cancelMutation");
            },
          })
        }
      >
        Progress
      </Button>
    </Stack>
  );
};
// visible-block-end
setRefineProps({
  DashboardPage: () => <ExamplePage />,
  resources: [
    {
      name: "post",
      create: () => {},
    },
  ],
});
render(<RefineMuiDemo />);
```

================
File: notification/hooks/use-notification/index.md
================
---
title: useNotification
source: https://github.com/refinedev/refine/blob/main/packages/core/src/hooks/notification/useNotification/index.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import BasicUsageLivePreview from "./\_basic-usage-live-preview.md";

`useNotification` can be used to `open` or `close` notification at any time. It returns the `open` and `close` method from [`notificationProvider`](/docs/notification/notification-provider) under the hood.

## Usage

Here is a basic example of how to use `useNotification` hook.

```tsx
const { open, close } = useNotification();

// open notification
open?.({
  type: "success",
  message: "Success",
  description: "This is a success message",
});

// close notification
close?.("notification-key");
```

## Properties

### open

You can call this method to open a new notification box.

```tsx
const { open } = useNotification();

open?.({
  type: "success",
  message: "Success",
  description: "This is a success message",
});
```

> For more information, refer to the [`Open Notification Params` interface→](/docs/core/interface-references#open-notification-params)

### close

You can close a notification with a `key`.

```tsx
const { close } = useNotification();

close?.("notification-key");
```

You must pass a `key` to the `open` method. This key is used to close the notification.

## FAQ

### How to use a undoable notification?

It should be `type=progress` to show undoable notifications. A function can then be triggered.

```tsx
const { open } = useNotification();

open?.({
  type: "progress",
  message: "Progress",
  undoableTimeout: 5,
  cancelMutation: () => {
    // when undo button is clicked, run this callback
  },
});
```

## API Reference

### Return Values

| Property | Description               | Type                                                                                   |
| -------- | ------------------------- | -------------------------------------------------------------------------------------- |
| open     | Open Notification Params  | [`Open Notification Params`](/docs/core/interface-references#open-notification-params) |
| close    | Close Notification Params | `(key: string) => void;`                                                               |

================
File: notification/notification-provider/index.md
================
---
title: Notification Provider
---

Refine let's you set a notification API by providing the `notificationProvider` property to the `<Refine>` component.

`notificationProvider` is an object with close and open methods. Refine uses these methods to show and hide notifications. These methods can be called from anywhere in the application with [`useNotification`](/docs/notification/hooks/use-notification) hook.

A `notificationProvider` must include following methods:

```tsx
const notificationProvider = {
  show: () => {},
  close: () => {},
};
```

And these methods types like this:

```tsx
interface NotificationProvider {
  open: (params: OpenNotificationParams) => void;
  close: (key: string) => void;
}

interface OpenNotificationParams {
  key?: string;
  message: string;
  type: "success" | "error" | "progress";
  description?: string;
  cancelMutation?: () => void;
  undoableTimeout?: number;
}
```

## Usage

To use `notificationProvider` in Refine, we have to pass the `notificationProvider` to the `<Refine>` component.

```tsx
import { Refine, NotificationProvider } from "@refinedev/core";

//highlight-start
const notificationProvider: NotificationProvider = {
  open: () => {},
  close: () => {},
};
//highlight-end

const App = () => {
  return (
    <Refine
      //highlight-next-line
      notificationProvider={notificationProvider}
      /* ... */
    >
      {/* ... */}
    </Refine>
  );
};
```

By default, Refine doesn't require `notificationProvider` configuration.

If a `notificationProvider` property is not provided, Refine will use the default `notificationProvider`, which lets the app work without a notification.
If your app doesn't require `notification`, no further setup is necessary for the app to work.

## Built-in Notification Providers

If you're looking for a complete notification infrastructure, Refine has out-of-the-box support for the libraries below:

<Tabs
defaultValue="antd"
values={[
{label: 'Ant Design', value: 'antd'},
{label: 'Material UI', value: 'mui'},
{label: 'Mantine', value: 'mantine'},
{label: 'Chakra UI', value: 'chakra'},
]}>

  <TabItem value="antd">

```tsx
import { useNotificationProvider } from "@refinedev/antd";

return (
  <Refine
    //...
    notificationProvider={useNotificationProvider}
  />
);
```

  </TabItem>

  <TabItem value="mui">

```tsx
import {
  useNotificationProvider,
  RefineSnackbarProvider,
} from "@refinedev/mui";

return (
  <RefineSnackbarProvider>
    <Refine
      //...
      notificationProvider={useNotificationProvider}
    />
  </RefineSnackbarProvider>
);
```

  </TabItem>

  <TabItem value="mantine">

```tsx
import { useNotificationProvider } from "@refinedev/mantine";
import { NotificationsProvider } from "@mantine/notifications";

return (
  <NotificationsProvider position="top-right">
    <Refine
      //...
      notificationProvider={useNotificationProvider}
    />
  </NotificationsProvider>
);
```

  </TabItem>

  <TabItem value="chakra">

```tsx
import { useNotificationProvider } from "@refinedev/chakra-ui";

return (
  <Refine
    //...
    notificationProvider={useNotificationProvider()}
  />
);
```

  </TabItem>
</Tabs>

## Creating a `notificationProvider` from scratch

We will now build a simple `notificationProvider` from scratch to show the logic of how `notificationProvider` methods interact with the app. For this, we will use the [`react-toastify`](https://github.com/fkhadra/react-toastify) package, which is very **popular** in the **React Ecosystem**. If you want to use another notification library, you can use the same approach.

Before we start, we need set up the `react-toastify` requirements.

```tsx
import { Refine } from "@refinedev/core";

//highlight-start
import { ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
//highlight-end

const App: React.FC = () => {
  return (
    <Refine
    /* ...*/
    >
      {/* ... */}
      {/* highlight-start */}
      <ToastContainer />
      {/* highlight-end */}
    </Refine>
  );
};

export default App;
```

### open

Refine calls this method when it wants to open a notification. It also helps you to get the right notification by sending some parameters to the Refine open method. For example, `message`, `description`, etc.

Here we open a notification with [`react-toastify`](https://github.com/fkhadra/react-toastify):

```tsx
import { toast } from "react-toastify";

const notificationProvider: NotificationProvider = {
  open: ({ message, key, type }) => {
    toast(message, {
      toastId: key,
      type,
    });
  },
};
```

Let's make it so that the previous notification is updated when the notification is called again with the same `key` instead of creating a new one each time. We can use `toast.isActive(key)` for this since it returns `true` if the notification is still active.

```tsx
import { toast } from "react-toastify";

const notificationProvider: NotificationProvider = {
  open: ({ message, key, type }) => {
    //highlight-start
    if (toast.isActive(key)) {
      toast.update(key, {
        render: message,
        type,
      });
    } else {
      //highlight-end
      toast(message, {
        toastId: key,
        type,
      });
    }
  },
};
```

Now, let's create a custom notification when the mutation mode is `undoable`. In this case, Refine sends the notification's type as `progress` as well as `cancelMutation` and `undoableTimeout`.

`undoableTimeout` decreases by 1 every second until it reaches 0, at which point the notification is closed. The `open` method is called again with the same`key` each countdown. So, the notification should be updated with the new`undoableTimeout` value.

```tsx
import { toast } from "react-toastify";

const notificationProvider: NotificationProvider = {
  open: ({ message, key, type }) => {
    //highlight-start
    if (type === "progress") {
      if (toast.isActive(key)) {
        toast.update(key, {
          progress: undoableTimeout && (undoableTimeout / 10) * 2,
          render: (
            <UndoableNotification
              message={message}
              cancelMutation={cancelMutation}
            />
          ),
          type: "default",
        });
      } else {
        toast(
          <UndoableNotification
            message={message}
            cancelMutation={cancelMutation}
          />,
          {
            toastId: key,
            updateId: key,
            closeOnClick: false,
            closeButton: false,
            autoClose: false,
            progress: undoableTimeout && (undoableTimeout / 10) * 2,
          },
        );
      }
    } else {
      //highlight-end
      if (toast.isActive(key)) {
        toast.update(key, {
          render: message,
          //highlight-start
          closeButton: true,
          autoClose: 5000,
          //highlight-end
          type,
        });
      } else {
        toast(message, {
          toastId: key,
          type,
        });
      }
    }
  },
};
```

<details><summary>See UndoableNotification Component</summary>
<p>

```tsx
type UndoableNotification = {
  message: string;
  cancelMutation?: () => void;
  closeToast?: () => void;
};

export const UndoableNotification: React.FC<UndoableNotification> = ({
  closeToast,
  cancelMutation,
  message,
}) => {
  return (
    <div>
      <p>{message}</p>
      <button
        onClick={() => {
          cancelMutation?.();
          closeToast?.();
        }}
      >
        Undo
      </button>
    </div>
  );
};
```

:::note

We add `closeButton` and `autoClose` for progress notifications, which are not closable by default to allow users to close them when the progress is done.

:::

</p>
</details>

The `open` method then will be accessible via [`useNotification`](/docs/notification/hooks/use-notification) hook.

```tsx
import { useNotification } from "@refinedev/core";

const { open } = useNotification();

open?.({
  type: "success",
  message: "Hey",
  description: "I <3 Refine",
  key: "unique-id",
});
```

### close

Refine calls this method when it wants to close a notification. Refine pass the `key` of the notification to the `close` method. So, we can handle the notification close logic with this `key`.

```tsx
import { toast } from "react-toastify";

const notificationProvider: NotificationProvider = {
  //...
  close: (key) => toast.dismiss(key),
};
```

`close` method then will be accessible via [`useNotification`](/docs/notification/hooks/use-notification) hook.

```tsx
import { useNotification } from "@refinedev/core";

const { close } = useNotification();

close?.("displayed-notification-key");
```

## Example

<CodeSandboxExample path="with-react-toastify" />

================
File: packages/cli/index.md
================
---
title: CLI
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Refine CLI is a command line application that allows you to interact with your Refine project and perform some tasks. This includes [creating a new resource](#create-resource), [managing updates](#update), [swizzle](#swizzle) components, and [runs your project](#dev--start--build) (build, start, dev).

```bash
> npm run refine
Usage: refine <command> [options]

      ___           ___           ___                       ___           ___
     /\  \         /\  \         /\  \          ___        /\__\         /\  \
    /::\  \       /::\  \       /::\  \        /\  \      /::|  |       /::\  \
   /:/\:\  \     /:/\:\  \     /:/\:\  \       \:\  \    /:|:|  |      /:/\:\  \
  /::\~\:\  \   /::\~\:\  \   /::\~\:\  \      /::\__\  /:/|:|  |__   /::\~\:\  \
 /:/\:\ \:\__\ /:/\:\ \:\__\ /:/\:\ \:\__\  __/:/\/__/ /:/ |:| /\__\ /:/\:\ \:\__\
 \/_|::\/:/  / \:\~\:\ \/__/ \/__\:\ \/__/ /\/:/  /    \/__|:|/:/  / \:\~\:\ \/__/
    |:|::/  /   \:\ \:\__\        \:\__\   \::/__/         |:/:/  /   \:\ \:\__\
    |:|\/__/     \:\ \/__/         \/__/    \:\__\         |::/  /     \:\ \/__/
    |:|  |        \:\__\                     \/__/         /:/  /       \:\__\
     \|__|         \/__/                                   \/__/         \/__/

Options:
  -v, --version              Output the current version.
  -h, --help                 Output usage information.

Commands:
  swizzle                    Export a component or a function from refine packages to customize it in your project
  create-resource [options]  Create a new resource files (deprecated, please use "add resource" command)
  update [options]           Interactively select and update all `refine` packages to selected version. To skip the interactive mode, use the `--all` option.
  dev [options] [args...]    It runs: `unknown `. Also accepts all the arguments `unknown` accepts.
  build [options] [args...]  It runs: `unknown `. Also accepts all the arguments `unknown` accepts.
  start [options] [args...]  It runs: `unknown `. Also accepts all the arguments `unknown` accepts.
  run [command] [args...]    Runs a defined package script. If no `command` is provided, it will list the available scripts
  check-updates              Check all installed `refine` packages are up to date
  whoami                     View the details of the development environment
  proxy [options]            Manage proxy settings
  devtools [command]         Start or install refine's devtools server; it starts on port 5001.
  add                        Add new resources, providers, or integrations
  help [command]             display help for command
```

:::simple Installation

CLI is automatically installed in projects created with the `create refine-app` command. You can use the [commands](#commands) immediately 🎉

If you want to add it to your existing project, checkout [how to add to an existing project?](#how-to-add-to-an-existing-project) section.

:::

## Commands

### swizzle

In this command, you can swizzle the components of the Refine. This allows you to customize the components and use your own components.

<details>

<summary>Why is it called swizzling?</summary>

The term comes from Objective-C and Swift-UI: [method swizzling](https://pspdfkit.com/blog/2019/swizzling-in-swift/) is the process of changing the implementation of an existing selector (method).

For Refine, component swizzling means providing an alternative component that will be used instead of the default one.

You can think of it as [Monkey Patching](https://en.wikipedia.org/wiki/Monkey_patch) for React components, which allows you to change the default implementation. Gatsby has a similar feature called [theme shadowing](https://www.gatsbyjs.com/docs/how-to/plugins-and-themes/shadowing/).

**Thanks to the [Docusaurus](https://docusaurus.io) team for inspiring us for this feature.**

</details>

#### Do I need to swizzle?

Refine packages provide data providers, UI frameworks, and components that make it easy to build a project. Most these are customizable and can be used as is. However, sometimes you may want to customize it as if you created it yourself. This is where swizzling comes in. Most of Refine packages provide a swizzle command that ejects the files to your project. You can then customize them as you wish.

#### Usage

Let's create a new component by swizzling the `Layout` components.

```bash
> npm run refine swizzle

? Which package do you want to swizzle? (Use arrow keys or type to search)

Data Provider
 ◯ @refinedev/simple-rest
UI Framework
 ◉ @refinedev/antd
```

First, you need to select the package you want to swizzle. In this example, we will swizzle the `@refinedev/antd` package.

:::simple Good to know

Refine CLI will only show the packages that are installed in your project.

:::

```bash
? Which component do you want to swizzle?

 ◯ TagField
 ◯ TextField
 ◯ UrlField
Other
 ◯ Breadcrumb
❯◉ Layout
Pages
 ◯ ErrorPage
 ◯ AuthPage
(Move up and down to reveal more choices)
```

Then, you need to select the component you want to swizzle. In this example, we will swizzle the `Layout` component.

```bash
Successfully swizzled Layout
Files created:
 - src/components/layout/sider.tsx
 - src/components/layout/header.tsx
 - src/components/layout/title.tsx
 - src/components/layout/index.tsx

Warning:
If you want to change the default layout;
You should wrap your pages with layout/index.tsx inside <Refine>
component.

    ╭ App.tsx ────────────────────────────────────────╮
    │                                                 │
    │   import { Layout } from "components/layout";   │
    │                                                 │
    │   const App = () => {                           │
    │       return (                                  │
    │           <Refine                               │
    │               /* ... */                         │
    │           >                                     │
    │               <Layout>                          │
    │                   {/* ... */}                   │
    │               <Layout>                          │
    │           </Refine>                             │
    │       );                                        │
    │   }                                             │
    │                                                 │
    ╰─────────────────────────────────────────────────╯
```

Finally, the swizzle command will create a new folder in the `src/components/layout` directory and generate the layout components of the `@refinedev/antd` package in it.

:::simple Good to know

- Refine CLI determines the path to create a new folder according to the framework you are using. For example, if you are using the `remix`, the path will be `app/components/layout`.

- If there is already a file with the same name in the directory, the swizzle command will not overwrite it.

:::

### add

Use this command to add a new `resource`, `provider`, or `integration` to your project.

#### resource

CRUD components are created for the selected actions. These components are put on the specified path. The folder name here becomes plural.

```bash
> npm run refine add resource
```

| Argument                | Description                               |
| ----------------------- | ----------------------------------------- |
| resourceName (optional) | The name of the resource you want to add. |

#### provider

Empty Provider methods are created for to easily implement and connect to your data source from your Refine project. These components are put on the specified path.

```bash
> npm run refine add provider

? Which providers do you want to add? (Press <space> to select, <a> to toggle all, <i> to invert selection, and <enter> to proceed)
❯◯ Auth provider - Manage user authentication and authorization
 ◯ Live provider - Enable real-time updates and synchronization
 ◯ Data provider - Communicate with your API
 ◯ Access Control - Manage user permissions & roles
 ◯ Notification provider - Display in-app alerts and messages
 ◯ I18n provider - Support multiple languages and locales
 ◯ Audit Log provider - Display audit logs for your resources
```

```bash
> npm run refine add provider auth
> npm run refine add provider data
> npm run refine add provider live
> npm run refine add provider access-control
> npm run refine add provider audit-log
> npm run refine add provider i18n
> npm run refine add provider notification
```

| Argument                                                                                                               | Description                               |
| ---------------------------------------------------------------------------------------------------------------------- | ----------------------------------------- |
| `auth` &#124 `data` &#124 `live` &#124 `access-control` &#124 `audit-log` &#124 `i18n` &#124 `notification` (required) | The name of the provider you want to add. |

| Alias | Option    | Default                                                                                             | Description                                                                                |
| ----- | --------- | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| -a    | --actions | `list`,`create`,`edit`,`show`                                                                       | Only generate the specified actions for resource. (works only when `add resource`)         |
| -p    | --path    | (when `add resource`): react/vite: `src/pages` next.js: `src/components` remix: `app/components`    | The path to create source files. (It is created automatically according to the framework.) |
| -p    | --path    | (when `add providers`): react/vite: `src/providers` next.js: `src/providers` remix: `app/providers` | The path to create source files. (It is created automatically according to the framework.) |
| -h    | --help    |                                                                                                     | Output usage information                                                                   |

#### integration

You can use this command to add integration to your existing projects.

```bash
> npm run refine add integration

? Which integration do you want to add? (Use arrow keys)
❯ Ant Design - Setup Ant Design with Refine
  React Router - Setup routing with React Router
```

### create-resource <PropTag deprecated />

Use [add](#add) command instead.

### update

Interactively update your outdated Refine packages. To skip interactive mode, use the `--all` flag to update all outdated Refine packages to selected tag.

```bash
> npm run refine update

? Choose packages to update (Press <space> to select, <a> to toggle all, <i> to invert selection, and <enter> to proceed)

   Package                          From      To

Patch Updates
 ◯ @refinedev/cli                1.5.1 -> 1.5.3

Minor Updates
 ◯ @refinedev/airtable           2.1.1 -> 2.7.8
 ◉ @refinedev/core              3.88.1 -> 3.90.4
 ◯ @refinedev/react-hook-form   3.31.0 -> 3.33.2
 ◯ @refinedev/simple-rest        2.6.0 -> 2.7.8
❯◉ @refinedev/strapi            3.18.0 -> 3.37.0

Major Updates
 ◯ @refinedev/airtable           2.1.1 -> 3.33.0
 ◯ @refinedev/simple-rest        2.6.0 -> 3.35.2
```

#### Options

| Option    | Alias | Description                                                                                 | Values           | Default                                                    |
| --------- | ----- | ------------------------------------------------------------------------------------------- | ---------------- | ---------------------------------------------------------- |
| --tag     | -t    | Select version to update to.                                                                | `latest`, `next` | Version ranges in the `package.json` will be installed.    |
| --all     | -a    | Use to skip interactive mode update and update all `Refine` packages to the selected `tag`. |                  | `false` Interactive mode will be open.                     |
| --dry-run | -d    | Use to skip automatic installation. Prints the update command of the packages.              |                  | `false` Selected packages will be installed automatically. |

### check-updates

Show the running versions of the installed Refine packages.

```bash
> npm run refine check-updates
                                    Update Available
                ┌────────────────────────────────┬─────────┬────────┬────────┐
                │ name                           │ current │ wanted │ latest │
                ├────────────────────────────────┼─────────┼────────┼────────┤
                │ @refinedev/airtable        │ 2.1.1   │ 2.7.8  │ 3.33.0 │
                ├────────────────────────────────┼─────────┼────────┼────────┤
                │ @refinedev/cli             │ 1.5.1   │ 1.5.3  │ 1.5.3  │
                ├────────────────────────────────┼─────────┼────────┼────────┤
                │ @refinedev/core            │ 3.88.1  │ 3.90.4 │ 3.90.4 │
                ├────────────────────────────────┼─────────┼────────┼────────┤
                │ @refinedev/react-hook-form │ 3.31.0  │ 3.33.2 │ 3.33.2 │
                ├────────────────────────────────┼─────────┼────────┼────────┤
                │ @refinedev/simple-rest     │ 2.6.0   │ 2.7.8  │ 3.35.2 │
                ├────────────────────────────────┼─────────┼────────┼────────┤
                │ @refinedev/strapi          │ 3.18.0  │ 3.37.0 │ 3.37.0 │
                └────────────────────────────────┴─────────┴────────┴────────┘
                    To update `Refine` packages with the wanted version
                        Run the following command npm run refine update
```

### dev, start, build

When you run `npm run refine [dev | start | build]` It will detect the framework you are using and run the commands accordingly.

Also you can pass environment variables, and all the options that are available in the framework. For example, you can run `npm run refine dev --port 3001` to run the app on port `3001`.

<Tabs
defaultValue="cra"
values={[
{label: 'React', value: 'cra'},
{label: 'Next.js', value: 'nextjs'},
{label: 'Remix', value: 'remix'}
]}>

<TabItem value="cra">

```bash
 # Starts application in development mode. Equivalent to `react-scripts start` or `vite`.
npm run refine dev
```

```bash
# Creates a production build of your app. Equivalent to `react-scripts build` or `vite build`.
npm run refine build
```

[Refer to the Create React App documentation for detailed usage. &#8594](https://create-react-app.dev/docs/available-scripts)

[Refer to the Vite documentation for detailed usage. &#8594](https://vitejs.dev/guide/#command-line-interface)

</TabItem>

<TabItem value="nextjs">

```bash
# Starts application in development mode. Equivalent to `next dev`.
npm run refine dev
```

```bash
# Starts application in production mode. Equivalent to `next start`.
npm run refine start
```

```bash
# Creates a production build of your app. Equivalent to `next build`.
npm run refine build
```

[Refer to the Next.js documentation for detailed usage. &#8594](https://nextjs.org/docs/api-reference/cli)

</TabItem>

<TabItem value="remix">

```bash
# Starts application in development mode. Equivalent to `remix dev`.
npm run refine dev
```

```bash
# Starts application in production mode. Equivalent to `remix-serve start`.
npm run refine start
```

```bash
# Creates a production build of your app. Equivalent to `next build`.
npm run refine build
```

[Refer to the Remix documentation for detailed usage. &#8594](https://remix.run/docs/en/v1/other-api/dev)
</TabItem>
</Tabs>

### run

Runs a custom script in the context of your Refine project. Also It will pass all the arguments to the script.

First it will check `package.json` to see if there is a script with the given name. If there is, it will run that script. Otherwise, it will run in `node_modules/.bin`.

With this way you can run unsupported commands via Refine.

```bash
npm run refine run react-app-rewired start
```

### whoami

View the details of the development environment.

```bash
> npm run refine whoami

## System:
 - OS: macOS 13.0
 - CPU: (8) arm64 Apple M1 Pro
## Binaries:
 - Node: 16.14.0 - ~/.nvm/versions/node/v16.14.0/bin/node
 - Yarn: 1.22.17 - /opt/homebrew/bin/yarn
 - npm: 8.3.1 - ~/.nvm/versions/node/v16.14.0/bin/npm
## Browsers:
 - Chrome: 107.0.5304.121
 - Firefox: 106.0.3
 - Safari: 16.1

## Refine Packages:
 - @refinedev/airtable: 2.1.1
 - @refinedev/antd: 3.62.0
 - @refinedev/cli: 1.5.1
 - @refinedev/core: 3.88.1
 - @refinedev/react-hook-form: 3.31.0
 - @refinedev/simple-rest: 2.6.0
 - @refinedev/strapi: 3.18.0
```

## How to add to an existing project?

If you want to add the [@refinedev/cli](https://github.com/refinedev/refine/tree/main/packages/cli) to your existing project, you have to add it to your project's `dependencies`.

<InstallPackagesCommand args="@refinedev/cli"/>

Then add the `refine` command to your scripts in your `package.json` file

```diff title="package.json"
{
    "scripts": {
+       "refine": "refine"
    }
}
```

Hooray!

```bash
> npm run refine
Usage: refine <command> [options]

      ___           ___           ___                       ___           ___
     /\  \         /\  \         /\  \          ___        /\__\         /\  \
    /::\  \       /::\  \       /::\  \        /\  \      /::|  |       /::\  \
   /:/\:\  \     /:/\:\  \     /:/\:\  \       \:\  \    /:|:|  |      /:/\:\  \
  /::\~\:\  \   /::\~\:\  \   /::\~\:\  \      /::\__\  /:/|:|  |__   /::\~\:\  \
 /:/\:\ \:\__\ /:/\:\ \:\__\ /:/\:\ \:\__\  __/:/\/__/ /:/ |:| /\__\ /:/\:\ \:\__\
 \/_|::\/:/  / \:\~\:\ \/__/ \/__\:\ \/__/ /\/:/  /    \/__|:|/:/  / \:\~\:\ \/__/
    |:|::/  /   \:\ \:\__\        \:\__\   \::/__/         |:/:/  /   \:\ \:\__\
    |:|\/__/     \:\ \/__/         \/__/    \:\__\         |::/  /     \:\ \/__/
    |:|  |        \:\__\                     \/__/         /:/  /       \:\__\
     \|__|         \/__/                                   \/__/         \/__/

Options:
  -v, --version              Output the current version.
  -h, --help                 Output usage information.

Commands:
  create-resource [options]  Create a new resource files
  check-updates              Check all installed `Refine` packages are up to date
  update [options]           Interactively select and update all `Refine` packages to selected version. To skip the interactive mode, use the `--all` option.
  dev [args...]              It runs: `nextjs dev`. Also accepts all the arguments `nextjs` accepts.
  build [args...]            It runs: `nextjs build`. Also accepts all the arguments `nextjs` accepts.
  start [args...]            It runs: `nextjs start`. Also accepts all the arguments `nextjs` accepts.
  run [command] [args...]    Runs a defined package script. If no `command` is provided, it will list the available scripts
  whoami                     View the details of the development environment
  help [command]             display help for command

```

You can optionally modify your scripts in `package.json` with `Refine CLI` [commands](#dev--start--build). The benefit it will provide you is that it gives warnings to keep your `Refine` packages always up to date.

<Tabs
defaultValue="react"
values={[
{label: 'React', value: 'react'},
{label: 'Next.js', value: 'nextjs'},
{label: 'Remix', value: 'remix'}
]}>

<TabItem value="react">

```diff title="package.json"
{
    "scripts": {
-       "dev": "react-scripts start",
-       "build": "react-scripts build",
+       "dev": "refine dev",
+       "build": "refine build",
    }
}
```

</TabItem>
<TabItem value="nextjs">

```diff title="package.json"
{
    "scripts": {
-       "dev": "next dev",
-       "build": "next build",
-       "start": "next start",
+       "dev": "refine dev",
+       "build": "refine build",
+       "start": "refine start",
    }
}
```

</TabItem>
<TabItem value="remix">

```diff title="package.json"
{
    "scripts": {
-       "dev": "remix dev",
-       "build": "remix build",
-       "start": "remix-serve build"
+       "dev": "refine dev",
+       "build": "refine build",
+       "start": "refine start",
    }
}
```

</TabItem>
</Tabs>

================
File: packages/command-palette/index.md
================
---
title: Command Palette
---

```tsx live shared
import {
  useMany as CoreUseMany,
  useShow as RefineCoreUseShow,
  useOne as RefineCoreUseOne,
} from "@refinedev/core";
import {
  List as RefineAntdList,
  TextField as RefineAntdTextField,
  TagField as RefineAntdTagField,
  useTable as RefineAntdUseTable,
  EditButton as RefineAntdEditButton,
  ShowButton as RefineAntdShowButton,
  getDefaultSortOrder as RefineAntdGetDefaultSortOrder,
  useForm as RefineAntdUseForm,
  useSelect as RefineAntdUseSelect,
  Create as RefineAntdCreate,
  Show as RefineAntdShow,
} from "@refinedev/antd";
import {
  Table as AntdTable,
  Space as AntdSpace,
  Form as AntdForm,
  Select as AntdSelect,
  Input as AntdInput,
  Typography as AntdTypography,
} from "antd";

const PostList: React.FC = () => {
  const { tableProps, sorter } = RefineAntdUseTable<IPost>();

  const categoryIds =
    tableProps?.dataSource?.map((item) => item.categoryId) ?? [];
  const { data, isLoading } = CoreUseMany<ICategory>({
    resource: "categories",
    ids: categoryIds,
    queryOptions: {
      enabled: categoryIds.length > 0,
    },
  });

  return (
    <RefineAntdList>
      <AntdTable {...tableProps} rowKey="id">
        <AntdTable.Column dataIndex="id" title="ID" />
        <AntdTable.Column dataIndex="title" title="Title" />
        <AntdTable.Column
          dataIndex={["category", "id"]}
          title="Category"
          render={(value) => {
            if (isLoading) {
              return <RefineAntdTextField value="Loading..." />;
            }

            return (
              <RefineAntdTextField
                value={data?.data.find((item) => item.id === value)?.title}
              />
            );
          }}
        />
        <AntdTable.Column
          dataIndex="status"
          title="Status"
          render={(value: string) => <RefineAntdTagField value={value} />}
        />
        <AntdTable.Column<IPost>
          title="Actions"
          dataIndex="actions"
          render={(_, record) => (
            <AntdSpace>
              <RefineAntdEditButton
                hideText
                size="small"
                recordItemId={record.id}
              />
              <RefineAntdShowButton
                hideText
                size="small"
                recordItemId={record.id}
              />
            </AntdSpace>
          )}
        />
      </AntdTable>
    </RefineAntdList>
  );
};

const PostCreate: React.FC = () => {
  const { formProps, saveButtonProps } = RefineAntdUseForm<IPost>();

  const { selectProps: categorySelectProps } = RefineAntdUseSelect<ICategory>({
    resource: "61bc4afa9ee2c",
    optionLabel: "title",
    optionValue: "id",
  });

  return (
    <RefineAntdCreate saveButtonProps={saveButtonProps}>
      <AntdForm {...formProps} layout="vertical">
        <AntdForm.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
        <AntdForm.Item
          label="Category"
          name="categoryId"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdSelect {...categorySelectProps} />
        </AntdForm.Item>
        <AntdForm.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput.TextArea />
        </AntdForm.Item>
      </AntdForm>
    </RefineAntdCreate>
  );
};

const PostEdit: React.FC = () => {
  const { formProps, saveButtonProps, query } = RefineAntdUseForm<IPost>();
  const postData = query?.data?.data;

  const { selectProps: categorySelectProps } = RefineAntdUseSelect<ICategory>({
    defaultValue: postData?.categoryId,
    resource: "61c43adc284ac",
    optionLabel: "title",
    optionValue: "id",
  });

  return (
    <RefineAntdCreate saveButtonProps={saveButtonProps}>
      <AntdForm {...formProps} layout="vertical">
        <AntdForm.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
        <AntdForm.Item
          label="Category"
          name="categoryId"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdSelect {...categorySelectProps} />
        </AntdForm.Item>
        <AntdForm.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput.TextArea />
        </AntdForm.Item>
      </AntdForm>
    </RefineAntdCreate>
  );
};

const PostShow: React.FC = () => {
  const { queryResult } = RefineCoreUseShow<IPost>();
  const { data, isLoading } = queryResult;
  const record = data?.data;

  const { data: categoryData, isLoading: categoryIsLoading } =
    RefineCoreUseOne<ICategory>({
      resource: "categories",
      id: record?.category?.id || "",
      queryOptions: {
        enabled: !!record,
      },
    });

  return (
    <RefineAntdShow isLoading={isLoading}>
      <AntdTypography.Title level={5}>Id</AntdTypography.Title>
      <AntdTypography.Text>{record?.id}</AntdTypography.Text>

      <AntdTypography.Title level={5}>
        AntdTypography.Title
      </AntdTypography.Title>
      <AntdTypography.Text>{record?.title}</AntdTypography.Text>

      <AntdTypography.Title level={5}>Category</AntdTypography.Title>
      <AntdTypography.Text>
        {categoryIsLoading ? "Loading..." : categoryData?.data.title}
      </AntdTypography.Text>

      <AntdTypography.Title level={5}>Content</AntdTypography.Title>
      <AntdTypography.Text>{record?.content}</AntdTypography.Text>
    </RefineAntdShow>
  );
};
```

Refine supports the command palette feature and use the
[**kbar**][kbar]. **kbar** is a fully extensible `cmd` + `k`(MacOS) or `ctrl` + `k`(Linux/Windows) interface for your site.

## Installation

Install the [@refinedev/kbar][refine-kbar] library.

<InstallPackagesCommand args="@refinedev/kbar"/>

## Usage

First of all, you need to import the `@refinedev/kbar` library and we will use `RefineKbarProvider` to wrap the whole application.

After that, we should mount the `RefineKbar` component inside the `<Refine>` component.

```tsx tile="app.tsx"
// highlight-next-line
import { RefineKbar, RefineKbarProvider } from "@refinedev/kbar";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      // highlight-next-line
      <RefineKbarProvider>
        <Refine
        //...
        >
          {/*...*/}
          {/* highlight-next-line */}
          <RefineKbar />
        </Refine>
        // highlight-next-line
      </RefineKbarProvider>
    </BrowserRouter>
  );
};
```

You can click on the live preview area and test how it works with `cmd` + `k`(MacOS) or `ctrl` + `k`(Linux/Windows).

```tsx live previewOnly url=http://localhost:5173 previewHeight=650px
setInitialRoutes(["/posts"]);
import { Refine, Authenticated } from "@refinedev/core";
import routerProvider, {
  CatchAllNavigate,
  NavigateToResource,
} from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";
import dataProvider from "@refinedev/simple-rest";
import {
  ThemedLayoutV2,
  RefineThemes,
  useNotificationProvider,
  List,
  EditButton,
  ShowButton,
  useTable,
  AuthPage,
  ErrorComponent,
} from "@refinedev/antd";
import { ConfigProvider, Layout, Table, Space } from "antd";
import { RefineKbar, RefineKbarProvider } from "@refinedev/kbar";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <RefineKbarProvider>
          <Refine
            dataProvider={dataProvider(API_URL)}
            routerProvider={routerProvider}
            resources={[
              {
                name: "posts",
                list: "/posts",
                create: "/posts/create",
                edit: "/posts/edit/:id",
                show: "/posts/show/:id",
                meta: {
                  canDelete: true,
                },
              },
            ]}
            notificationProvider={useNotificationProvider}
            options={{
              liveMode: "auto",
              syncWithLocation: true,
              warnWhenUnsavedChanges: true,
            }}
          >
            <Routes>
              <Route
                element={
                  <ThemedLayoutV2>
                    <Outlet />
                  </ThemedLayoutV2>
                }
              >
                <Route index element={<NavigateToResource />} />
                <Route path="/posts">
                  <Route index element={<PostList />} />
                  <Route path="create" element={<PostCreate />} />
                  <Route path="edit/:id" element={<PostEdit />} />
                  <Route path="show/:id" element={<PostShow />} />
                </Route>
              </Route>
            </Routes>
            <RefineKbar />
          </Refine>
        </RefineKbarProvider>
      </ConfigProvider>
    </BrowserRouter>
  );
};
render(<App />);
```

## Access Control

`refine-kbar` respects the access control settings of your App. To learn more about access control, please refer to the [Access Control Provider][access-control] section of the documentation. Also, we can use the `canDelete` in the `resources` to check the delete accessibility of the command palette.

For more information check out the source code of [`refine-kbar`][refine-kbar] package

## Actions

`refine-kbar` uses your resources to create default actions. Which includes; `list`, `create`, `edit`, `show` and `delete`. It will hide the current action of the page you are in.

## Custom Actions

If we want to add custom actions to the command palette, we can use the `createAction` and `useRegisterActions` of the `refine-kbar`.
check the [`refine-finefoods`][refine-finefoods] example.

Also you can find more information about actions in the [`kbar`][kbar-actions] package.

You can use the `createAction` to create a new action and use the `useRegisterActions` to register the action to the command palette.

```tsx title="Custom action example"
import { createAction, useRegisterActions } from "@refinedev/kbar";

const customAction = createAction({
  name: "my custom action",
  section: "custom-actions",
  perform: () => {
    console.log("onSelect my custom action");
  },
  priority: Priority.HIGH,
});

useRegisterActions(customAction);
```

:::simple Good to know

Since `refine-kbar` exports the [`kbar`](https://github.com/timc1/kbar), you use all of its features

:::

## Example

<CodeSandboxExample path="command-palette-kbar" />

[kbar]: https://github.com/timc1/kbar
[kbar-actions]: https://kbar.vercel.app/docs/concepts/actions
[refine-kbar]: https://github.com/refinedev/refine/tree/main/packages/kbar
[access-control]: /docs/authorization/access-control-provider
[usecanwithoutcache]: https://github.com/refinedev/refine/blob/main/packages/core/src/hooks/accessControl/useCanWithoutCache.ts
[refine-finefoods]: https://github.com/refinedev/refine/blob/main/examples/finefoods-material-ui/src/hooks/useOrderCustomKbarActions/index.tsx

================
File: packages/inferencer/index.md
================
---
title: Inferencer
---

`@refinedev/inferencer` is a package that provides a way to automatically generate views for resources based on the data structure. The aim is to reduce the amount of time spent on creating views for resources by generating the code automatically that can be customized easily.

The package exports components for **List**, **Show**, **Create** and **Edit** views inside UI package scopes. For example, `@refinedev/inferencer/antd` exports components for `@refinedev/antd` package.

## Installation

<InstallPackagesCommand args="@refinedev/inferencer"/>

## Available UI Inferencers

- [Ant Design](/docs/ui-integrations/ant-design/components/inferencer)
- [Material UI](/docs/ui-integrations/material-ui/components/inferencer)
- [Mantine](/docs/ui-integrations/mantine/components/inferencer)
- [Chakra UI](/docs/ui-integrations/chakra-ui/components/inferencer)
- [Headless](/docs/core/components/inferencer)

:::simple Good to know

`@refinedev/inferencer` is an experimental package and it is now in the early stages of development. We are working on improving the package and adding new features.

If you have any suggestions or feedback, please let us know in the [**GitHub Discussions**](https://github.com/refinedev/refine/discussions/3046)

`@refinedev/inferencer` components are meant to be used in development environments. They are not meant to be used in production environments.

:::

## How it works?

Simply, `@refinedev/inferencer` generates views and codes based on the data structure of the resource by fetching it using the `dataProvider` of `<Refine/>` component.

### How the data is obtained?

For, `edit` and `show` actions, we send the request with `resource` and `id`. For `list` and `create` actions, we send a list request with `resource` and use one of the items to generate the view. These actions will take place in your app.

### How the fields are inferred?

While inferring the field types, we use a set of functions that each checks the field for a specific type and returns the inferred type. These functions also can return a `priority` field that is used to determine the type of the field. For example, if we have a `created_at` property with a string value, we can infer it as a `date` type and a `text` type. In this case, we use the `priority` field to determine the type of the field. The higher the priority, the more accurate the type of the field.

Properties with multiple values are identified as `array` type but also repeats the same process for their values to determine the type of the values. Same also happens for `object` type properties. Both can have `accessor` field in return value to access the values of the property which is used when creating the view and the code.

If the property is an `object` type, we try to pick a key to represent that property. For example, if we have a `category` field with `{ label: string; id: string; }` type, we pick `label` as the key to represent the property. These `object` fields with keys to represent them have the property `fieldable` set to `true` in the return value.

#### Available field types and functions

```ts
type Types =
  | "relation"
  | "array"
  | "object"
  | "date"
  | "email"
  | "image"
  | "url"
  | "richtext"
  | "text"
  | "number"
  | "boolean"
  | "unknown"
  | `custom_${string}`;
```

`custom_${string}` is used by the inferencer components of UI packages when they have custom representations, for now users can't pass custom types and functions to the inferencer components.

#### Keys to represent `object` type properties

```ts
type PresentationalKeys =
  | "name"
  | "label"
  | "title"
  | "count"
  | "content"
  | "username"
  | "nickname"
  | "login"
  | "firstName"
  | "lastName"
  | "url";
```

### How the relations are determined?

There are some conditions we look for before determining if a field is can be a `relation`. These won't trigger any API calls to the resources.

- If the property name ends with `id` or `ids`. camelCase, PascalCase, snake_case, kebab-case, UPPER_CASE, lower_case are all supported with or without array brackets([]).
- If the property is an object with a single property `id`.
- If the property is an array of objects with a single property `id` or UUID compatible strings or numbers.
- If the property is a string or number and the property name matches with one of the known resources (singular or plural).

If one of these conditions is met, we consider the property as a `relation` type and try to determine the related resource.

To determine the relations;

- First, we try to find a resource that matches with the property name (singular or plural).
- If a resource is found in the `resources` array with a match, we use that resource as the related resource.
- If no resource is found, we send two requests to the `default` `dataProvider` one with singular property name and one with plural property name, both stripped from the `id` suffixes if there are any.
- If a resource is found we use that resource and its `dataProvider` (if specified) and make the API call with the property value.
- If any of these requests succeed with `200` status code, we consider the property as a `relation` type and set the resource as the related resource.
- If none of these requests succeed, we remove the `relation` mark from the property and consider it as a normal field. If it's an `object` type, then we will try to find the best suitable property to represent it.

:::simple Manually setting relations and resources

If your `dataProvider` and `resources` has a different way of work that makes it impossible for Inferencer to find the `relation` resources. You can manually modify the inferred fields by using the `fieldTransformer` function. You can find more information about it in the [**Modifying the inferred fields**](#modifying-the-inferred-fields) section.

:::

### How the components are rendered and the code is generated?

To render the components we use a [fork](https://github.com/aliemir/react-live) of [`react-live`](https://github.com/FormidableLabs/react-live) package with Typescript support.

After the fields are determined, we use the `renderer` functions to create the code for the components and also use the same code to render the components in the view. `renderer` functions are constructed per action type and the UI package. This means, `@refinedev/inferencer/antd` and other UI scopes has different `renderer` functions for `list`, `show`, `edit` and `create` actions.

`renderer` function returns a `string` that includes the code for the component which is presented to user to copy and paste to their project. The same code is also used to render the component in the view.

Component name is determined by the active `resource` element and the active action. If the resource has `option.label` field, it will be used as the part of the component name. Otherwise, the `resource.name` will be used. For example, if the resource name is `categories` and the action is `list`, the component name will be `CategoryList`.

### Usage with GraphQL backends and `meta` values

Refine handles the GraphQL backends by using the `meta` properties in its data hooks. Inferencer lets you define meta values for your resources and methods in a single prop and uses it when generating the code and inferring the fields. Unlike the `meta` property of the data hooks, Inferencer components uses the `meta` property with a nested structure, letting you define the `meta` values per resource and action.

Here's the syntax for defining the `meta` values in Inferencer components:

```tsx
<AntdListInferencer
    meta={{
        [resourceNameOrIdentifier: string]: {
            [methodName: "default" | "getList" | "getMany" | "getOne" | "update"]: Record<string, unknown>,
        }
    }}
/>
```

`default` is the default `meta` value for all the methods. In the absence of a specific `meta` value for a method for a resource, the `default` value will be used.

This structure is designed to let users provide `meta` values for multiple resources and actions at once since the Inferencer might find relations and try to use hooks to fetch the necessary data.

#### Example Usage

```tsx
<AntdListInferencer
  meta={{
    posts: {
      getList: {
        fields: ["id", "title", "content", "category_id", "created_at"],
      },
    },
    categories: {
      default: {
        fields: ["id", "title"],
      },
    },
  }}
/>
```

### Modifying the inferred fields

If you want to customize the output of the Inferencer such as setting a custom `accessor` property for `object` type fields or changing the `type` of a field, or changing the `resource` for a `relation` type, you can use`fieldTransformer` prop in Inferencer components. It is a function that takes the field as an argument and returns the modified field. If `undefined | false | null` is returned, the field will be removed from the output, both for the preview and the code.

### Hiding the Code Viewer and Development Warning

If you want to hide the code viewer and the warning components, you can use the `hideCodeViewerInProduction` prop. This will only work in production mode. In development mode, the code viewer and the information block will always be visible.

Please note that the Inferencer components are not meant to be used in production. They are meant to be used in development mode to help you generate the code for your components.

================
File: packages/list-of-packages/index.md
================
---
title: List of Packages
---

- `@refinedev/core` - Collection of `hooks`, `components` and `providers` for **authentication**, **access control**, **routing**, **networking**, **state management** and **i18n**. Your starting point for headless projects.
- `@refinedev/inferencer` - Provides a way to automatically generate views for resources based on the data structure. The aim is to reduce the amount of time spent on creating views for resources by generating the code automatically that can be customized easily.
- `@refinedev/cli` - It is a tool that allows you to perform important commands while developing with refine.

### UI Framework Packages:

To learn more about UI Libraries and integrations, check out [UI Libraries](/docs/guides-concepts/ui-libraries) guide.

- [`@refinedev/antd`](/docs/ui-integrations/ant-design/introduction) - [Ant Design](https://ant.design/) System UI Framework support. **20+** framework-specific `hooks` and  `components`  incl. Table, Form, Select, Menu, Layout, Notification and CRUD components.
- [`@refinedev/mui`](/docs/ui-integrations/material-ui/introduction) - [Material UI](https://mui.com/material-ui/getting-started/overview/) Framework support. **20+** framework-specific `hooks` and  `components`  incl. DataGrid (+ Pro), AutoComplete, Menu, Layout, Notification and CRUD components.
- [`@refinedev/mantine`](/docs/ui-integrations/mantine/introduction) - [Mantine](https://mantine.dev/) UI Framework support. **20+** framework-specific `hooks` and `components` incl. Table, Form, AutoComplete, Menu, Layout, Notification and CRUD components.
- [`@refinedev/chakra-ui`](/docs/ui-integrations/chakra-ui/introduction) - [Chakra UI](https://chakra-ui.com/) UI Framework support. **20+** framework-specific `components` incl. Menu, Layout, Notification and CRUD components.
- [`@ferdiunal/refine-shadcn`](https://github.com/ferdiunal/refine-shadcn) - ShadCN UI components with Refine.

### Data Provider Packages:

To learn more about Data Providers, check out [Data Provider](/docs/data/data-provider/) docs.

- [`@refinedev/simple-rest`](/docs/data/packages/simple-rest) - Connect any custom **REST API** backend.
- [`@refinedev/graphql`](/docs/data/packages/graphql) - Connect any custom **GraphQL** backend.
- [`@refinedev/nestjsx-crud`](/docs/data/packages/nestjsx-crud) - Consume **REST API**'s built with **NestJs**.
- [`@refinedev/nestjs-query`](/docs/data/packages/nestjs-query) - Consume **GraphQL API**'s built with **Nestjs-Query**.
- [`@refinedev/strapi-v4`](/docs/data/packages/strapi-v4) - [Strapi](https://strapi.io/) connector for **v4 REST API.**
- [`@refinedev/strapi`](/docs/data/packages/strapi-v4) - [Strapi](https://strapi.io/) connector for **legacy REST API.**
- [`@refinedev/supabase`](/docs/data/packages/supabase) -[Supabase](https://supabase.com/) data provider. Supports **Supabase Realtime** for **live/realtime** projects.
- [`@refinedev/hasura`](/docs/data/packages/hasura) - [Hasura GraphQL](https://hasura.io/) data provider. Supports **GraphQL Subscriptions** for **live/realtime** projects.
- [`@refinedev/appwrite`](/docs/data/packages/appwrite) - [Appwrite](https://appwrite.io/) data provider. Supports **Appwrite Realtime** for **live/realtime** projects.
- [`@refinedev/airtable`](/docs/data/packages/airtable) - Use [Airtable](https://airtable.com/) as backend service.
- `@refinedev/medusa` - [Medusa](https://medusajs.com/) connector for your e-commerce projects.

### Router Provider Packages

To learn more about Router Providers, check out [Routing](/docs/guides-concepts/routing) guide.

- [`@refinedev/react-router`](/docs/routing/integrations/react-router) - Router Provider for [React Router](https://reactrouter.com)
- [`@refinedev/nextjs-router`](/docs/routing/integrations/next-js) - Router Provider for [Next.js](https://nextjs.org/docs/api-reference/next/router#userouter)
- [`@refinedev/remix-router`](/docs/routing/integrations/remix) - Router Provider for [Remix](https://remix.run/)
- [`@refinenative/expo-router`](https://www.npmjs.com/package/@refinenative/expo-router) - Router Provider for [Expo](https://docs.expo.dev/)

### Live Provider Packages

To learn more about Live Providers, check out [Realtime](/docs/guides-concepts/realtime) guide.

- `@refinedev/ably` - [Ably](https://ably.com/) integration for realtime applications.
- `@refinedev/graphql` - Realtime support through GraphQL Subscriptions.
- `@refinedev/nestjs-query` - Realtime support through GraphQL Subscriptions for **Nestjs-Query**.
- `@refinedev/supabase` -[Supabase](https://supabase.com/) realtime support.
- `@refinedev/hasura` - [Hasura GraphQL](https://hasura.io/) support with GraphQL Subscriptions.
- `@refinedev/appwrite` - [Appwrite](https://appwrite.io/) realtime support.

### Integrations

- [`@refinedev/kbar`](/docs/packages/command-palette) - [kbar](https://kbar.vercel.app/) integration. Add `command`/`crtrl`+`k` interfaces to your project.
- [`@refinedev/react-table`](/docs/packages/tanstack-table/introduction) - [React Table](https://tanstack.com/table/v8) integration. Powerful tables & datagrids for your headless projects.
- [`@refinedev/react-hook-form`](/docs/packages/react-hook-form/introduction) - [React Hook Form](https://react-hook-form.com/) integration. Extensible forms and validation for your projects.

### React Frameworks

- `NextJS` - SSR and SSG support for your projects.
- `Remix` - SSR support for your projects.
- `React Native` - Mobile support for your projects.

### ❤️ Community Packages:

- [`refine-firebase`](https://github.com/resulturan/refine-firebase) - Support for [Firebase](https://firebase.google.com/) services.
- [`@tspvivek/refine-directus`](https://github.com/tspvivek/refine-directus) - Connector for backends created with [Directus](https://directus.io/)
- [`refine-elide-rest`](https://github.com/chirdeeptomar/refine-elide-rest) - Connector for backends created with [Elide](https://elide.io/)
- [`refine-elide-graphql`](https://github.com/chirdeeptomar/refine-elide-graphql) - Connector for GraphQL backends created with [Elide](https://elide.io/)
- [`ent-refine`](https://github.com/diazoxide/entrefine) - A library that generates fully customizable UI based on [Entgo ORM](https://entgo.io/) and [GraphQL API](https://graphql.org/) with [Refine](https://github.com/refinedev/refine)
- [`refine-use-generated`](https://github.com/usegen/refine-use-generated) - Connector for GraphQL backends created with [useGenerated](https://usegenerated.com/)
- [`refine-hygraph`](https://github.com/acomagu/refine-hygraph) - Connector for [Hygraph](https://hygraph.com/) backends(GraphQL)
- [`refine-sanity`](https://github.com/hirenf14/refine-sanity) - Connector for [Sanity](https://www.sanity.io/) backends
- [`refine-sqlite`](https://github.com/mateusabelli/refine-sqlite) - Connector for [SQLite](https://www.sqlite.org/index.html) backends
- [`refine-jsonapi`](https://github.com/MahirMahdi/refine-jsonapi) - Connector for [JSON:API](https://jsonapi.org/) backends
- [`@refine-auth/kinde-react`](https://github.com/hirenf14/refine-auth-kinde-react) - Support for [Kinde](https://kinde.com) authentication.
- [`refine-pocketbase`](https://github.com/kruschid/refine-pocketbase) - Connector for backends created with [PocketBase](https://pocketbase.io/). Also has auth provider and live provider supports.
- [`refine-postgrest-ts`](https://github.com/ffimnsr/refine-postgrest-ts) - Connector for [PostgREST](https://postgrest.org) backends.
- [`refine-chakra-ui-v3-ts`](https://github.com/ffimnsr/refine-chakra-ui-v3-ts) - Integration for [Chakra UI v3](https://www.chakra-ui.com).

================
File: packages/react-hook-form/introduction/index.md
================
---
title: Introduction
---

# React Hook Form <GuideBadge id="guides-concepts/forms" /> <RouterBadge id="guides-concepts/routing/#useform" />

Refine provides an integration package for [React Hook Form][react-hook-form] library. This package enables you to manage your forms in a headless manner. This adapter supports all of the features of both [React Hook Form][react-hook-form] and [Refine's useForm][use-form-core] hook. Simply, you can use any of the [React Hook Form][react-hook-form] examples as-is by copying and pasting them into your project.

This package exports following hooks to manage your forms:

- [`useForm`][use-form-react-hook-form]
- [`useModalForm`](/docs/packages/list-of-packages)
- [`useStepsForm`](/docs/packages/list-of-packages)

## Installation

Install the [`@refinedev/react-hook-form`][refine-react-hook-form] library.

<InstallPackagesCommand args="@refinedev/react-hook-form"/>

## Usage

Let's see how to edit a post with [useForm][use-form-react-hook-form] hook.

<Tabs wrapContent={false}>

<TabItem value="Headless">

```tsx title="edit.tsx"
import { HttpError } from "@refinedev/core";
import { useForm } from "@refinedev/react-hook-form";

export const PostEdit = () => {
  const {
    refineCore: { onFinish, formLoading, query },
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<IPost, HttpError>({
    refineCoreProps: {
      resource: "posts",
      action: "edit",
      id: 1,
    },
  });

  return (
    <form onSubmit={handleSubmit(onFinish)}>
      <label>Title: </label>
      <input {...register("title", { required: true })} />
      {errors.title && <span>This field is required</span>}
      <br />

      <label>Status: </label>
      <select {...register("status")}>
        <option value="published">published</option>
        <option value="draft">draft</option>
        <option value="rejected">rejected</option>
      </select>
      <br />

      <label>Content: </label>
      <textarea
        {...register("content", { required: true })}
        rows={10}
        cols={50}
      />
      {errors.content && <span>This field is required</span>}
      <br />

      <input type="submit" value="Submit" />
      {formLoading && <p>Loading</p>}
    </form>
  );
};

export type IStatus = "published" | "draft" | "rejected";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: IStatus;
}
```

</TabItem>

<TabItem value="Material UI">

```tsx title="edit.tsx"
import { HttpError } from "@refinedev/core";
import { Edit } from "@refinedev/mui";
import Box from "@mui/material/Box";
import TextField from "@mui/material/TextField";
import Autocomplete from "@mui/material/Autocomplete";
import { useForm } from "@refinedev/react-hook-form";
import { Controller } from "react-hook-form";

export const PostEdit: React.FC = () => {
  const {
    saveButtonProps,
    register,
    control,
    formState: { errors },
  } = useForm<IPost, HttpError>({
    refineCoreProps: {
      resource: "posts",
      action: "edit",
      id: 1,
    },
  });

  return (
    <Edit saveButtonProps={saveButtonProps}>
      <Box
        component="form"
        sx={{ display: "flex", flexDirection: "column" }}
        autoComplete="off"
      >
        <TextField
          id="title"
          {...register("title", {
            required: "This field is required",
          })}
          error={!!errors.title}
          helperText={errors.title?.message}
          margin="normal"
          fullWidth
          label="Title"
          name="title"
          autoFocus
        />

        <Controller
          control={control}
          name="status"
          rules={{ required: "This field is required" }}
          // eslint-disable-next-line
          defaultValue={null as any}
          render={({ field }) => (
            <Autocomplete<IStatus>
              id="status"
              options={["published", "draft", "rejected"]}
              {...field}
              onChange={(_, value) => {
                field.onChange(value);
              }}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label="Status"
                  margin="normal"
                  variant="outlined"
                  error={!!errors.status}
                  helperText={errors.status?.message}
                  required
                />
              )}
            />
          )}
        />

        <TextField
          id="content"
          {...register("content", {
            required: "This field is required",
          })}
          error={!!errors.content}
          helperText={errors.content?.message}
          margin="normal"
          label="Content"
          multiline
          rows={4}
        />
      </Box>
    </Edit>
  );
};

export type IStatus = "published" | "draft" | "rejected";

export interface IPost {
  id: number;
  title: string;
  content: string;
  status: IStatus;
}
```

</TabItem>

<TabItem value="Chakra UI">

```tsx title="edit.tsx"
import { HttpError } from "@refinedev/core";
import { useForm } from "@refinedev/react-hook-form";
import { Edit } from "@refinedev/chakra-ui";
import {
  FormControl,
  FormErrorMessage,
  FormLabel,
  Input,
  Select,
  Textarea,
} from "@chakra-ui/react";

export const PostEdit = () => {
  const {
    refineCore: { formLoading },
    saveButtonProps,
    register,
    formState: { errors },
  } = useForm<IPost, HttpError>({
    refineCoreProps: {
      resource: "posts",
      action: "edit",
      id: 1,
    },
  });

  return (
    <Edit isLoading={formLoading} saveButtonProps={saveButtonProps}>
      <FormControl mb="3" isInvalid={!!errors?.title}>
        <FormLabel>Title</FormLabel>
        <Input
          id="title"
          type="text"
          {...register("title", { required: "Title is required" })}
        />
        <FormErrorMessage>{`${errors.title?.message}`}</FormErrorMessage>
      </FormControl>

      <FormControl mb="3" isInvalid={!!errors?.status}>
        <FormLabel>Status</FormLabel>
        <Select
          id="status"
          placeholder="Select Post Status"
          {...register("status", {
            required: "Status is required",
          })}
        >
          <option>published</option>
          <option>draft</option>
          <option>rejected</option>
        </Select>
        <FormErrorMessage>{`${errors.status?.message}`}</FormErrorMessage>
      </FormControl>

      <FormControl mb="3" isInvalid={!!errors?.content}>
        <FormLabel>Content</FormLabel>
        <Textarea
          id="content"
          {...register("content", {
            required: "content is required",
          })}
        />
        <FormErrorMessage>{`${errors.content?.message}`}</FormErrorMessage>
      </FormControl>
    </Edit>
  );
};

export type IStatus = "published" | "draft" | "rejected";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: IStatus;
}
```

</TabItem>

</Tabs>

[use-form-react-hook-form]: /docs/packages/list-of-packages
[react-hook-form]: https://react-hook-form.com
[refine-react-hook-form]: https://github.com/refinedev/refine/tree/main/packages/react-hook-form
[use-form-core]: /docs/data/hooks/use-form/
[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[notification-provider]: /docs/notification/notification-provider
[get-one]: /docs/data/data-provider#getone-
[create]: /docs/data/data-provider#create-
[update]: /docs/data/data-provider#update-
[data-provider]: /docs/data/data-provider

================
File: packages/react-hook-form/use-form/index.md
================
---
title: useForm
source: packages/react-hook-form/src/useForm/index.ts
---

```tsx live shared
import { useNavigation, useTable } from "@refinedev/core";
import { useForm as ReactHookFormUseForm } from "@refinedev/react-hook-form";
import React from "react";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
}

const Layout: React.FC = ({ children }) => {
  return (
    <div
      style={{
        height: "100vh",
        background: "white",
      }}
    >
      {children}
    </div>
  );
};

const PostList: React.FC = () => {
  const { tableQuery, current, setCurrent, pageSize, pageCount } =
    useTable<IPost>({
      sorters: {
        initial: [
          {
            field: "id",
            order: "desc",
          },
        ],
      },
    });
  const { edit, create, clone } = useNavigation();

  const hasNext = current < pageCount;
  const hasPrev = current > 1;

  return (
    <div>
      <button onClick={() => create("posts")}>Create Post</button>
      <table>
        <thead>
          <td>ID</td>
          <td>Title</td>
          <td>Actions</td>
        </thead>
        <tbody>
          {tableQuery.data?.data.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.title}</td>
              <td>
                <button onClick={() => edit("posts", post.id)}>Edit</button>
                <button onClick={() => clone("posts", post.id)}>Clone</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
      <div>
        <div>
          <button onClick={() => setCurrent(1)} disabled={!hasPrev}>
            First
          </button>
          <button
            onClick={() => setCurrent((prev) => prev - 1)}
            disabled={!hasPrev}
          >
            Previous
          </button>
          <button
            onClick={() => setCurrent((prev) => prev + 1)}
            disabled={!hasNext}
          >
            Next
          </button>
          <button onClick={() => setCurrent(pageCount)} disabled={!hasNext}>
            Last
          </button>
        </div>
        <span>
          Page{" "}
          <strong>
            {current} of {pageCount}
          </strong>
        </span>
        <span>
          Go to page:
          <input
            type="number"
            defaultValue={current}
            onChange={(e) => {
              const value = e.target.value ? Number(e.target.value) : 1;
              setCurrent(value);
            }}
          />
        </span>
      </div>
    </div>
  );
};

const PostEdit: React.FC = () => {
  const {
    refineCore: { onFinish, formLoading },
    register,
    handleSubmit,
    formState: { errors },
  } = ReactHookFormUseForm();

  return (
    <form onSubmit={handleSubmit(onFinish)}>
      <label>Title: </label>
      <input {...register("title", { required: true })} />
      {errors.title && <span>This field is required</span>}
      <br />
      <label>Status: </label>
      <select {...register("status")}>
        <option value="published">published</option>
        <option value="draft">draft</option>
        <option value="rejected">rejected</option>
      </select>
      <br />
      <label>Content: </label>
      <br />
      <textarea
        {...register("content", { required: true })}
        rows={10}
        cols={50}
      />
      {errors.content && <span>This field is required</span>}
      <br />
      <br />
      <input type="submit" disabled={formLoading} value="Submit" />
      {formLoading && <p>Loading</p>}
    </form>
  );
};

const PostCreate: React.FC = () => {
  const {
    refineCore: { onFinish, formLoading },
    register,
    handleSubmit,
    formState: { errors },
  } = ReactHookFormUseForm();

  return (
    <form onSubmit={handleSubmit(onFinish)}>
      <label>Title: </label>
      <input {...register("title", { required: true })} />
      {errors.title && <span>This field is required</span>}
      <br />
      <label>Status: </label>
      <select {...register("status")}>
        <option value="published">published</option>
        <option value="draft">draft</option>
        <option value="rejected">rejected</option>
      </select>
      <br />
      <label>Content: </label>
      <br />
      <textarea
        {...register("content", { required: true })}
        rows={10}
        cols={50}
      />
      {errors.content && <span>This field is required</span>}
      <br />
      <br />
      <input type="submit" disabled={formLoading} value="Submit" />
      {formLoading && <p>Loading</p>}
    </form>
  );
};
```

`useForm` is used to manage forms. It returns the necessary properties and methods to control the `<form>` element. It has been developed by using [`useForm`][use-form-core] imported from the [@refinedev/core](https://github.com/refinedev/refine/tree/main/packages/core) package.

<GeneralConceptsLink />

## Installation

Install the [`@refinedev/react-hook-form`][refine-react-hook-form] library.

<InstallPackagesCommand args="@refinedev/react-hook-form"/>

## Usage

> For more detailed usage examples please refer to the [React Hook Form](https://react-hook-form.com/get-started) documentation.

We'll show the basic usage of `useForm` by adding an editing form.

```tsx title="pages/posts/edit.tsx"
import { useSelect } from "@refinedev/core";
import { useForm } from "@refinedev/react-hook-form";

export const PostEdit: React.FC = () => {
  const {
    refineCore: { onFinish, formLoading, query },
    register,
    handleSubmit,
    resetField,
    formState: { errors },
  } = useForm();

  const { options } = useSelect({
    resource: "categories",
    defaultValue: query?.data?.data.category.id,
  });

  useEffect(() => {
    resetField("category.id");
  }, [options]);

  return (
    <form onSubmit={handleSubmit(onFinish)}>
      <label>Title: </label>
      <input {...register("title", { required: true })} />
      {errors.title && <span>This field is required</span>}
      <br />
      <label>Status: </label>
      <select {...register("status")}>
        <option value="published">published</option>
        <option value="draft">draft</option>
        <option value="rejected">rejected</option>
      </select>
      <br />
      <label>Category: </label>
      <select
        {...register("category.id", {
          required: true,
        })}
        defaultValue={query?.data?.data.category.id}
      >
        {options?.map((category) => (
          <option key={category.value} value={category.value}>
            {category.label}
          </option>
        ))}
      </select>
      {errors.category && <span>This field is required</span>}
      <br />
      <label>Content: </label>
      <br />
      <textarea
        {...register("content", { required: true })}
        rows={10}
        cols={50}
      />
      {errors.content && <span>This field is required</span>}
      <br />

      {query?.data?.data?.thumbnail && (
        <>
          <br />
          <label>Image: </label>
          <br />

          <img src={query?.data?.data?.thumbnail} width={200} height={200} />
          <br />
          <br />
        </>
      )}

      <input type="submit" value="Submit" />
      {formLoading && <p>Loading</p>}
    </form>
  );
};
```

If you want to show a form in a modal or drawer where necessary route params might not be there you can use the [useModalForm](/docs/packages/list-of-packages).

## Properties

### action

`useForm` can handle `edit`, `create` and `clone` actions.

By default, it determines the `action` from route. The action is inferred by matching the resource's action path with the current route.

It can be overridden by passing the `action` prop where it isn't possible to determine the action from the route (e.g. when using form in a modal or using a custom route).

<Tabs
defaultValue="create"
values={[
{label: 'create', value: 'create'},
{label: 'edit', value: 'edit'},
{label: 'clone', value: 'clone'}
]}>
<TabItem value="create">

`action: "create"` is used for creating a new record that didn't exist before.

`useForm` uses [`useCreate`](/docs/data/hooks/use-create) under the hood for mutations on create mode.

In the following example, we'll show how to use `useForm` with `action: "create"`.

```tsx live url=http://localhost:3000/posts/create previewHeight=420px
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { useForm } from "@refinedev/react-hook-form";

const PostCreatePage: React.FC = () => {
  const {
    refineCore: { onFinish, formLoading },
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();

  return (
    <form onSubmit={handleSubmit(onFinish)}>
      <label>Title: </label>
      <input {...register("title", { required: true })} />
      {errors.title && <span>This field is required</span>}
      <br />
      <label>Status: </label>
      <select {...register("status")}>
        <option value="published">published</option>
        <option value="draft">draft</option>
        <option value="rejected">rejected</option>
      </select>
      <br />
      <label>Content: </label>
      <br />
      <textarea
        {...register("content", { required: true })}
        rows={10}
        cols={50}
      />
      {errors.content && <span>This field is required</span>}
      <br />
      <br />
      <input type="submit" disabled={formLoading} value="Submit" />
      {formLoading && <p>Loading</p>}
    </form>
  );
};
// visible-block-end

setRefineProps({
  Layout: (props) => <Layout {...props} />,
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreatePage,
      edit: PostEdit,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

</TabItem>

<TabItem value="edit">

`action: "edit"` is used for editing an existing record. It requires the `id` for determining the record to edit. By default, it uses the `id` from the route. It can be changed with the `setId` function or `id` property.

It fetches the record data according to the `id` with [`useOne`](/docs/data/hooks/use-one) and returns the `query` for you to fill the form. After the form is submitted, it updates the record with [`useUpdate`](/docs/data/hooks/use-update).

In the following example, we'll show how to use `useForm` with `action: "edit"`.

```tsx live url=http://localhost:3000/edit/123 previewHeight=420px
setInitialRoutes(["/posts/edit/123"]);

// visible-block-start
import { useForm } from "@refinedev/react-hook-form";

const PostEditPage: React.FC = () => {
  const {
    refineCore: { onFinish, formLoading },
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();

  return (
    <form onSubmit={handleSubmit(onFinish)}>
      <label>Title: </label>
      <input {...register("title", { required: true })} />
      {errors.title && <span>This field is required</span>}
      <br />
      <label>Content: </label>
      <br />
      <label>Status: </label>
      <select {...register("status")}>
        <option value="published">published</option>
        <option value="draft">draft</option>
        <option value="rejected">rejected</option>
      </select>
      <br />
      <textarea
        {...register("content", { required: true })}
        rows={10}
        cols={50}
      />
      {errors.content && <span>This field is required</span>}
      <br />
      <input type="submit" value="Submit" />
      {formLoading && <p>Loading</p>}
    </form>
  );
};
// visible-block-end

setRefineProps({
  Layout: (props) => <Layout {...props} />,
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreate,
      edit: PostEditPage,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

</TabItem>

<TabItem value="clone">

`action: "clone"` is used for cloning an existing record. It requires the `id` for determining the record to clone. By default, it uses the `id` from the route. It can be changed with the `setId` function.

You can think `action:clone` like save as. It's similar to `action:edit` but it creates a new record instead of updating the existing one.

It fetches the record data according to the `id` with [`useOne`](/docs/data/hooks/use-one) and returns the `query` for you to fill the form. After the form is submitted, it creates a new record with [`useCreate`](/docs/data/hooks/use-create).

In the following example, we'll show how to use `useForm` with `action: "clone"`.

```tsx live url=http://localhost:3000/clone/123 previewHeight=420px
setInitialRoutes(["/posts/clone/123"]);

// visible-block-start
import { useForm } from "@refinedev/react-hook-form";

const PostCreatePage: React.FC = () => {
  const {
    refineCore: { onFinish, formLoading },
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();

  return (
    <form onSubmit={handleSubmit(onFinish)}>
      <label>Title: </label>
      <input {...register("title", { required: true })} />
      {errors.title && <span>This field is required</span>}
      <br />
      <label>Status: </label>
      <select {...register("status")}>
        <option value="published">published</option>
        <option value="draft">draft</option>
        <option value="rejected">rejected</option>
      </select>
      <br />
      <label>Content: </label>
      <br />
      <textarea
        {...register("content", { required: true })}
        rows={10}
        cols={50}
      />
      {errors.content && <span>This field is required</span>}
      <br />
      <br />
      <input type="submit" disabled={formLoading} value="Submit" />
      {formLoading && <p>Loading</p>}
    </form>
  );
};
// visible-block-end

setRefineProps({
  Layout: (props) => <Layout {...props} />,
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreatePage,
      edit: PostEdit,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

</TabItem>

</Tabs>

### resource

It will be passed to the [`dataProvider`][data-provider]'s method as a params. This parameter is usually used to as a API endpoint path. It all depends on how to handle the `resource` in your [`dataProvider`][data-provider]. See the [`creating a data provider`](/docs/data/data-provider#creating-a-data-provider) section for an example of how `resource` are handled.

By default it reads the `resource` value from the current URL.

- When `action` is `"create"`, it will be passed to the [`create`][create] method from the [`dataProvider`][data-provider].
- When `action` is `"edit"`, it will be passed to the [`update`][update] and the [`getOne`][get-one] method from the [`dataProvider`][data-provider].
- When `action` is `"clone"`, it will be passed to the [`create`][create] and the [`getOne`][get-one] method from the [`dataProvider`][data-provider].

```tsx
useForm({
  refineCoreProps: {
    resource: "categories",
  },
});
```

If the `resource` is passed, the `id` from the current URL will be ignored because it may belong to a different resource. To retrieve the `id` value from the current URL, use the `useParsed` hook and pass the `id` value to the `useForm` hook.

```tsx
import { useParsed } from "@refinedev/core";
import { useForm } from "@refinedev/react-hook-form";

const { id } = useParsed();

useForm({
  refineCoreProps: {
    resource: "custom-resource",
    id,
  },
});
```

Or you can use the `setId` function to set the `id` value.

```tsx
import { useForm } from "@refinedev/react-hook-form";

const {
  refineCore: { setId },
} = useForm({
  refineCoreProps: {
    resource: "custom-resource",
  },
});

setId("123");
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### id

`id` is used for determining the record to `edit` or `clone`. By default, it uses the `id` from the route. It can be changed with the `setId` function or `id` property.

It is useful when you want to `edit` or `clone` a `resource` from a different page. Keep in mind that `id` is required when `action: "edit"` or `action: "clone"`.

```tsx
useForm({
  refineCoreProps: {
    action: "edit", // or clone
    resource: "categories",
    id: 1, // <BASE_URL_FROM_DATA_PROVIDER>/categories/1
  },
});
```

### redirect

`redirect` is used for determining the page to redirect after the form is submitted. By default, it uses the `list`. It can be changed with the `redirect` property.

It can be set to `"show" | "edit" | "list" | "create"` or `false` to prevent the page from redirecting to the list page after the form is submitted.

```tsx
useForm({
  refineCoreProps: {
    redirect: false,
  },
});
```

### onMutationSuccess

It's a callback function that will be called after the mutation is successful.

It receives the following parameters:

- `data`: Returned value from [`useCreate`](/docs/data/hooks/use-create) or [`useUpdate`](/docs/data/hooks/use-update) depending on the `action`.
- `variables`: The variables passed to the mutation.
- `context`: react-query context.
- `isAutoSave`: It's a boolean value that indicates whether the mutation is triggered by the [`autoSave`](#autoSave) feature or not.

```tsx
useForm({
  refineCoreProps: {
    onMutationSuccess: (data, variables, context, isAutoSave) => {
      console.log({ data, variables, context, isAutoSave });
    },
  },
});
```

### onMutationError

It's a callback function that will be called after the mutation is failed.

It receives the following parameters:

- `data`: Returned value from [`useCreate`](/docs/data/hooks/use-create) or [`useUpdate`](/docs/data/hooks/use-update) depending on the `action`.
- `variables`: The variables passed to the mutation.
- `context`: react-query context.
- `isAutoSave`: It's a boolean value that indicates whether the mutation is triggered by the [`autoSave`](#autoSave) feature or not.

```tsx
useForm({
  refineCoreProps: {
    onMutationError: (data, variables, context, isAutoSave) => {
      console.log({ data, variables, context, isAutoSave });
    },
  },
});
```

### invalidates

You can use it to manage the invalidations that will occur at the end of the mutation.

By default it's invalidates following queries from the current `resource`:

- on `create` or `clone` mode: `"list"` and `"many"`
- on `edit` mode: `"list`", `"many"` and `"detail"`

```tsx
useForm({
  refineCoreProps: {
    invalidates: ["list", "many", "detail"],
  },
});
```

### dataProviderName

If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use.
It is useful when you want to use a different `dataProvider` for a specific resource.

If you want to use a different `dataProvider` on all resource pages, you can use the [`dataProvider` prop ](/docs/core/refine-component#dataprovidername) of the `<Refine>` component.

```tsx
useForm({
  refineCoreProps: {
    dataProviderName: "second-data-provider",
  },
});
```

### mutationMode

Mutation mode determines which mode the mutation runs with. Mutations can run under three different modes: `pessimistic`, `optimistic` and `undoable`. Default mode is `pessimistic`.
Each mode corresponds to a different type of user experience.

> For more information about mutation modes, please check [Mutation Mode documentation](/docs/advanced-tutorials/mutation-mode) page.

```tsx
useForm({
  refineCoreProps: {
    mutationMode: "undoable", // "pessimistic" | "optimistic" | "undoable",
  },
});
```

### successNotification

> [`NotificationProvider`][notification-provider] is required for this prop to work.

After form is submitted successfully, `useForm` will call `open` function from [`NotificationProvider`][notification-provider] to show a success notification. With this prop, you can customize the success notification.

```tsx
useForm({
  refineCoreProps: {
    successNotification: (data, values, resource) => {
      return {
        message: `Post Successfully created with ${data.title}`,
        description: "Success with no errors",
        type: "success",
      };
    },
  },
});
```

### errorNotification

> [`NotificationProvider`][notification-provider] is required for this prop to work.

After form is submit is failed, `Refine` will show a error notification. With this prop, you can customize the error notification.

```tsx
useForm({
  refineCoreProps: {
    action: "create",
    resource: "post",
    errorNotification: (data, values, resource) => {
      return {
        message: `Something went wrong when deleting ${data.id}`,
        description: "Error",
        type: "error",
      };
    },
  },
});
```

```json title="Default values"
{
    "message": "Error when updating <resource-name> (status code: ${err.statusCode})" or "Error when creating <resource-name> (status code: ${err.statusCode})",
    "description": "Error",
    "type": "error",
}
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).
- Providing additional parameters to the redirection path after the form is submitted.

[Refer to the `meta` section of the General Concepts documentation for more information &#8594](/docs/guides-concepts/general-concepts/#meta-concept)

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useForm({
  refineCoreProps: {
    meta: {
      headers: { "x-meta-data": "true" },
    },
  },
});

const myDataProvider = {
  //...
  // highlight-start
  create: async ({ resource, variables, meta }) => {
    const headers = meta?.headers ?? {};
    // highlight-end
    const url = `${apiUrl}/${resource}`;

    // highlight-next-line
    const { data } = await httpClient.post(url, variables, { headers });

    return {
      data,
    };
  },
  //...
};
```

### queryMeta

In addition to the [`meta`](#meta) property, you can also pass the `queryMeta` property to the `useForm` hook. This property is used to pass additional information to the `useOne` hook that is used to fetch the data in the `edit` and `clone` modes. This is useful when you have to apply different values to the `useOne` hook from the `useCreate` or `useUpdate` hook mutations.

```tsx
useForm({
  queryMeta: {
    querySpecificValue: "someValue",
  },
});
```

If you have overlapping properties in both `meta` and `queryMeta`, the `queryMeta` property will be used.

### mutationMeta

In addition to the [`meta`](#meta) property, you can also pass the `mutationMeta` property to the `useForm` hook. This property is used to pass additional information to the `useCreate` or `useUpdate` hook mutations. This is useful when you have to apply different values to the `useCreate` or `useUpdate` hooks from the `useOne` hook query.

```tsx
useForm({
  mutationMeta: {
    mutationSpecificValue: "someValue",
  },
});
```

If you have overlapping properties in both `meta` and `mutationMeta`, the `mutationMeta` property will be used.

### queryOptions

> Works only in `action: "edit"` or `action: "clone"` mode.

in `edit` or `clone` mode, Refine uses [`useOne`](/docs/data/hooks/use-one) hook to fetch data. You can pass [`queryOptions`](https://tanstack.com/query/v4/docs/react/reference/useQuery) options by passing `queryOptions` property.

```tsx
useForm({
  refineCoreProps: {
    queryOptions: {
      retry: 3,
    },
  },
});
```

### createMutationOptions

> This option is only available when `action: "create"` or `action: "clone"`.

In `create` or `clone` mode, Refine uses [`useCreate`](/docs/data/hooks/use-create) hook to create data. You can pass [`mutationOptions`](https://tanstack.com/query/v4/docs/react/reference/useMutation) by passing `createMutationOptions` property.

```tsx
useForm({
  refineCoreProps: {
    queryOptions: {
      retry: 3,
    },
  },
});
```

### updateMutationOptions

> This option is only available when `action: "edit"`.

In `edit` mode, Refine uses [`useUpdate`](/docs/data/hooks/use-update) hook to update data. You can pass [`mutationOptions`](https://tanstack.com/query/v4/docs/react/reference/useMutation) by passing `updateMutationOptions` property.

```tsx
useForm({
  refineCoreProps: {
    queryOptions: {
      retry: 3,
    },
  },
});
```

### warnWhenUnsavedChanges

When it's true, Shows a warning when the user tries to leave the page with unsaved changes. It can be used to prevent the user from accidentally leaving the page. Default value is `false`.

It can be set globally in [`Refine config`](/docs/core/refine-component#warnwhenunsavedchanges).

```tsx
useForm({
  refineCoreProps: {
    warnWhenUnsavedChanges: true,
  },
});
```

### liveMode

Whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.
For more information about live mode, please check [Live / Realtime](/docs/realtime/live-provider#livemode) page.

```tsx
useForm({
  refineCoreProps: {
    liveMode: "auto",
  },
});
```

### onLiveEvent

The callback function that is executed when new events from a subscription are arrived.

```tsx
useForm({
  refineCoreProps: {
    onLiveEvent: (event) => {
      console.log(event);
    },
  },
});
```

### liveParams

Params to pass to [liveProvider's](/docs/realtime/live-provider#subscribe) subscribe method.

### autoSave

If you want to save the form automatically after some delay when user edits the form, you can pass true to `autoSave.enabled` prop.

By default the `autoSave` feature does not invalidate queries. However, you can use the `invalidateOnUnmount` prop to invalidate queries upon unmount.

It also supports [`onMutationSuccess`](#onmutationsuccess) and [`onMutationError`](#onmutationerror) callback functions. You can use `isAutoSave` parameter to determine whether the mutation is triggered by `autoSave` or not.

`autoSave` feature operates exclusively in `edit` mode. Users can take advantage of this feature while editing data, as changes are automatically saved in editing mode. However, when creating new data, manual saving is still required.

`onMutationSuccess` and `onMutationError` callbacks will be called after the mutation is successful or failed.

#### enabled

To enable the `autoSave` feature, set the `enabled` parameter to `true`. By default, it is disabled.

```tsx
useForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
    },
  },
});
```

#### debounce

Set the debounce time for the `autoSave` prop. Default value is `1000` milliseconds.

```tsx
useForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
      // highlight-next-line
      debounce: 2000,
    },
  },
});
```

#### onFinish

If you want to modify the data before sending it to the server, you can use `onFinish` callback function.

```tsx
useForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
      // highlight-start
      onFinish: (values) => {
        return {
          foo: "bar",
          ...values,
        };
      },
      // highlight-end
    },
  },
});
```

#### invalidateOnUnmount

This prop is useful when you want to invalidate the `list`, `many` and `detail` queries from the current resource when hook is unmounted. By default, it invalidates the `list`, `many` and `detail` queries associated with the current resource. Also, You can use the `invalidates` prop to select which queries to invalidate.

By default, the `invalidateOnUnmount` prop is set to `false`.

```tsx
useForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
      // highlight-next-line
      invalidateOnUnmount: true,
    },
  },
});
```

## Return Values

### query

If the `action` is set to `"edit"` or `"clone"` or if a `resource` with an `id` is provided, `useForm` will call [`useOne`](/docs/data/hooks/use-one) and set the returned values as the `query` property.

```tsx
const {
  refineCore: { query },
} = useForm();

const { data } = query;
```

### mutation

When in `"create"` or `"clone"` mode, `useForm` will call [`useCreate`](/docs/data/hooks/use-create). When in `"edit"` mode, it will call [`useUpdate`](/docs/data/hooks/use-update) and set the resulting values as the `mutation` property."

```tsx
const {
  refineCore: { mutation },
} = useForm();

const { data } = mutation;
```

### setId

`useForm` determine `id` from the router. If you want to change the `id` dynamically, you can use `setId` function.

```tsx
const {
  refineCore: { id, setId },
} = useForm();

const handleIdChange = (id: string) => {
  setId(id);
};

return (
  <div>
    <input value={id} onChange={(e) => handleIdChange(e.target.value)} />
  </div>
);
```

### redirect

"By default, after a successful mutation, `useForm` will `redirect` to the `"list"` page. To redirect to a different page, you can either use the `redirect` function to programmatically specify the destination, or set the redirect [property](/docs/data/hooks/use-form/#redirect) in the hook's options.

In the following example we will redirect to the `"show"` page after a successful mutation.

```tsx
const {
  refineCore: { onFinish, redirect },
} = useForm();

// --

const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  const data = await onFinish(formValues);
  redirect("show", data?.data?.id);
};

// --
```

### onFinish

`onFinish` is a function that is called when the form is submitted. It will call the appropriate mutation based on the `action` property.
You can override the default behavior by passing an `onFinish` function in the hook's options.

For example you can [change values before sending to the API](/docs/packages/react-hook-form/use-form/#how-can-i-change-the-form-data-before-submitting-it-to-the-api).

### saveButtonProps

It contains all the props needed by the "submit" button within the form (disabled, onClick etc.). When `saveButtonProps.onClick` is called, it triggers `handleSubmit`function with `onFinish`. You can manually pass these props to your custom button.

### formLoading

Loading state of a modal. It's `true` when `useForm` is currently being submitted or data is being fetched for the `"edit"` or `"clone"` mode.

### autoSaveProps

If `autoSave` is enabled, this hook returns `autoSaveProps` object with `data`, `error`, and `status` properties from mutation.

### ~~mutationResult~~ <PropTag deprecated />

This prop is deprecated and will be removed in the future versions. Use [`mutation`](#mutation) instead.

### ~~queryResult~~ <PropTag deprecated />

This prop is deprecated and will be removed in the future versions. Use [`query`](#query) instead.

## FAQ

### How can Invalidate other resources?

You can invalidate other resources with help of [`useInvalidate`](/docs/data/hooks/use-invalidate) hook.

It is useful when you want to `invalidate` other resources don't have relation with the current resource.

```tsx
import { useInvalidate } from "@refinedev/core";
import { useForm } from "@refinedev/react-hook-form";

const PostEdit = () => {
  const invalidate = useInvalidate();

  useForm({
    refineCoreProps: {
      onMutationSuccess: (data, variables, context) => {
        invalidate({
          resource: "users",
          invalidates: ["resourceAll"],
        });
      },
    },
  });

  // ---
};
```

### How can I change the form data before submitting it to the API?

You may need to modify the form data before it is sent to the API.

For example, Let's send the values we received from the user in two separate inputs, `name` and `surname`, to the API as `fullName`.

```tsx title="pages/user/create.tsx"
import { useForm } from "@refinedev/react-hook-form";
import React from "react";
import { FieldValues } from "react-hook-form";

export const UserCreate: React.FC = () => {
  const {
    refineCore: { onFinish },
    register,
    handleSubmit,
  } = useForm();

  const onFinishHandler = (data: FieldValues) => {
    onFinish({
      fullName: `${data.name} ${data.surname}`,
    });
  };

  return (
    <form onSubmit={handleSubmit(onFinishHandler)}>
      <label>Name: </label>
      <input {...register("name")} />
      <br />

      <label>Surname: </label>
      <input {...register("surname")} />
      <br />

      <button type="submit">Submit</button>
    </form>
  );
};
```

### How to pass `meta` values only for the mutation or query?

You can use `meta` property to pass common values to the mutation and the query. But in some cases, you may want to pass different values to the mutation and the query. To do this, you can use `mutationMeta` and `queryMeta` properties.

## API

### Properties

<PropsTable module="@refinedev/react-hook-form/useForm" />

> `*`: These properties have default values in `RefineContext` and can also be set on the **<[Refine](/docs/core/refine-component)>** component.

:::simple External Props

It also accepts all props of [useForm](https://react-hook-form.com/api/useform) hook available in the [React Hook Form](https://react-hook-form.com/).

:::

> For example, we can define the `refineCoreProps` property in the `useForm` hook as:

```tsx
import { useForm } from "@refinedev/react-hook-form";

const { ... } = useForm({
    ...,
    refineCoreProps: {
        resource: "posts",
        redirect: false,
        // You can define all properties provided by Refine useForm
    },
});
```

### Return values

Returns all the properties returned by [React Hook Form][react-hook-form] of the `useForm` hook. Also, we added the following return values:

`refineCore`: Returns all values returned by [`useForm`][use-form-core]. You can see all of them in [here](/docs/data/hooks/use-form/##return-values).

> For example, we can access the `refineCore` return value in the `useForm` hook as:

```tsx
import { useForm } from "@refinedev/react-hook-form";

const {
    refineCore: { query, ... },
} = useForm({ ... });
```

| Property        | Description               | Type                                                                                                                                    |
| --------------- | ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| saveButtonProps | Props for a submit button | `{ disabled: boolean; onClick: (e: React.BaseSyntheticEvent) => void; }`                                                                |
| autoSaveProps   | Auto save props           | `{ data: UpdateResponse<TData>` \| `undefined, error: HttpError` \| `null, status: "loading"` \| `"error"` \| `"idle"` \| `"success" }` |

### Type Parameters

| Property       | Description                                                                                                                                                         | Type                       | Default                    |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData   | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError         | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TVariables     | Field Values for mutation function                                                                                                                                  | `{}`                       | `{}`                       |
| TContext       | Second generic type of the `useForm` of the React Hook Form.                                                                                                        | `{}`                       | `{}`                       |
| TData          | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |
| TResponse      | Result data returned by the mutation function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TData` will be used as the default value.        | [`BaseRecord`][baserecord] | `TData`                    |
| TResponseError | Custom error object that extends [`HttpError`][httperror]. If not specified, the value of `TError` will be used as the default value.                               | [`HttpError`][httperror]   | `TError`                   |

## Example

<CodeSandboxExample path="form-react-hook-form-use-form" />

[react-hook-form]: https://react-hook-form.com
[refine-react-hook-form]: https://github.com/refinedev/refine/tree/main/packages/react-hook-form
[use-form-core]: /docs/data/hooks/use-form/
[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[notification-provider]: /docs/notification/notification-provider
[get-one]: /docs/data/data-provider#getone-
[create]: /docs/data/data-provider#create-
[update]: /docs/data/data-provider#update-
[data-provider]: /docs/data/data-provider

================
File: packages/react-hook-form/use-modal-form/index.md
================
---
title: useModalForm
---

```tsx live shared
type ModalPropsType = {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
};

const Modal: React.FC<ModalPropsType> = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null;
  return (
    <>
      <div className="overlay" onClick={onClose}></div>
      <div className="modal">
        <div className="modal-title">
          <button className="close-button" onClick={onClose}>
            &times;
          </button>
        </div>
        <div className="modal-content">{children}</div>
      </div>
    </>
  );
};
```

```css live shared
html,
body {
  background: white;
}

* {
  box-sizing: border-box;
}

.overlay {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background-color: rgba(0, 0, 0, 0.7);
  z-index: 1000;
}

.modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #fff;
  z-index: 1000;
  width: 500px;
  overflow-y: auto;
}

.modal .modal-title {
  display: flex;
  justify-content: flex-end;
  padding: 4px;
}

.modal .modal-content {
  padding: 0px 16px 16px 16px;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.form .form-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.form input,
select,
textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
```

`useModalForm` hook allows you to manage a form within a modal. It provides some useful methods to handle the form modal.

`useModalForm` hook is extended from [`useForm`][refine-react-hook-form-use-form] from the [`@refinedev/react-hook-form`][@refinedev/react-hook-form] package. This means that you can use all the features of [`useForm`][refine-react-hook-form-use-form] hook.

## Usage

We'll show three examples, `"create"`, `"edit"` and `"clone"`. Let's see how `useModalForm` is used in all.

<Tabs
defaultValue="create"
values={[
{label: 'create', value: 'create'},
{label: 'edit', value: 'edit'},
{label: 'clone', value: 'clone'},
]}>

<TabItem value="create">

```tsx live url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { HttpError, useTable } from "@refinedev/core";
import { useModalForm } from "@refinedev/react-hook-form";

import { Modal } from "@components";

const PostList = () => {
  const { tableQuery } = useTable<IPost>({
    sorters: {
      initial: [
        {
          field: "id",
          order: "desc",
        },
      ],
    },
  });

  // highlight-start
  const {
    formState: { errors },
    refineCore: { onFinish, formLoading },
    modal: { visible, close, show },
    register,
    handleSubmit,
    saveButtonProps,
  } = useModalForm<IPost, HttpError, IPost>({
    refineCoreProps: { action: "create" },
  });
  // highlight-end

  const loading = tableQuery?.isLoading;

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      {/* highlight-start */}
      <Modal isOpen={visible} onClose={close}>
        <form className="form" onSubmit={handleSubmit(onFinish)}>
          <div className="form-group">
            <label>Title: </label>
            <input
              {...register("title", {
                required: "This field is required",
              })}
            />
            {errors.title && <span>{errors.title.message}</span>}
          </div>
          <div className="form-group">
            <label>Status: </label>
            <select {...register("status")}>
              <option value="published">published</option>
              <option value="draft">draft</option>
              <option value="rejected">rejected</option>
            </select>
          </div>
          <button type="submit" {...saveButtonProps}>
            {formLoading ? "Loading" : "Save"}
          </button>
        </form>
      </Modal>
      <button onClick={() => show()}>Create Post</button>
      {/* highlight-end */}
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          {tableQuery.data?.data.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.title}</td>
              <td>{post.status}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

</TabItem>

<TabItem value="edit">

```tsx live url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { HttpError, useTable } from "@refinedev/core";
import { useModalForm } from "@refinedev/react-hook-form";

import { Modal } from "@components";

const PostList = () => {
  const { tableQuery } = useTable<IPost>({
    sorters: {
      initial: [
        {
          field: "id",
          order: "desc",
        },
      ],
    },
  });

  // highlight-start
  const {
    formState: { errors },
    refineCore: { onFinish, formLoading },
    modal: { visible, close, show },
    register,
    handleSubmit,
    saveButtonProps,
  } = useModalForm<IPost, HttpError, IPost>({
    refineCoreProps: { action: "edit" },
  });
  // highlight-end

  const loading = tableQuery?.isLoading;

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      {/* highlight-start */}
      <Modal isOpen={visible} onClose={close}>
        <form className="form" onSubmit={handleSubmit(onFinish)}>
          <div className="form-group">
            <label>Title: </label>
            <input
              {...register("title", {
                required: "This field is required",
              })}
            />
            {errors.title && <span>{errors.title.message}</span>}
          </div>
          <div className="form-group">
            <label>Status: </label>
            <select {...register("status")}>
              <option value="published">published</option>
              <option value="draft">draft</option>
              <option value="rejected">rejected</option>
            </select>
          </div>
          <button type="submit" {...saveButtonProps}>
            {formLoading ? "Loading" : "Save"}
          </button>
        </form>
      </Modal>
      {/* highlight-end */}
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {tableQuery.data?.data.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.title}</td>
              <td>{post.status}</td>
              <td>
                {/* highlight-start */}
                <button onClick={() => show(post.id)}>Edit</button>
                {/* highlight-end */}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

:::simple Implementation Tips

Refine doesn't automatically add a `<EditButton/>` to the each record in `<PostList>` which opens edit form in `<Modal>` when clicked.

So, we have to put the `<EditButton/>` on our list. In that way, `<Edit>` form in `<Modal>` can fetch data by the record `id`.

```tsx
<td>
  {/* highlight-start */}
  <button onClick={() => show(post.id)}>Edit</button>
  {/* highlight-end */}
</td>
```

Don't forget to pass the record `"id"` to `show` to fetch the record data. This is necessary for both `"edit"` and `"clone"` forms.

:::

</TabItem>

<TabItem value="clone">

```tsx live url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { HttpError, useTable } from "@refinedev/core";
import { useModalForm } from "@refinedev/react-hook-form";

import { Modal } from "@components";

const PostList = () => {
  const { tableQuery } = useTable<IPost>({
    initialSorter: [
      {
        field: "id",
        order: "desc",
      },
    ],
  });

  // highlight-start
  const {
    formState: { errors },
    refineCore: { onFinish, formLoading },
    modal: { visible, close, show },
    register,
    handleSubmit,
    saveButtonProps,
  } = useModalForm<IPost, HttpError, IPost>({
    refineCoreProps: { action: "clone" },
  });
  // highlight-end

  const loading = tableQuery?.isLoading;

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      {/* highlight-start */}
      <Modal isOpen={visible} onClose={close}>
        <form className="form" onSubmit={handleSubmit(onFinish)}>
          <div className="form-group">
            <label>Title: </label>
            <input
              {...register("title", {
                required: "This field is required",
              })}
            />
            {errors.title && <span>{errors.title.message}</span>}
          </div>
          <div className="form-group">
            <label>Status: </label>
            <select {...register("status")}>
              <option value="published">published</option>
              <option value="draft">draft</option>
              <option value="rejected">rejected</option>
            </select>
          </div>
          <button type="submit" {...saveButtonProps}>
            {formLoading ? "Loading" : "Save"}
          </button>
        </form>
      </Modal>
      {/* highlight-end */}
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {tableQuery.data?.data.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.title}</td>
              <td>{post.status}</td>
              <td>
                {/* highlight-start */}
                <button onClick={() => show(post.id)}>Clone</button>
                {/* highlight-end */}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

:::simple Implementation Tips

Refine doesn't automatically add a `<CloneButton/>` to the each record in `<PostList>` which opens edit form in `<Modal>` when clicked.

So, we have to put the `<CloneButton/>` on our list. In that way, `<Clone>` form in `<Modal>` can fetch data by the record `id`.

```tsx
<td>
  {/* highlight-start */}
  <button onClick={() => show(post.id)}>clone</button>
  {/* highlight-end */}
</td>
```

Don't forget to pass the record `"id"` to `show` to fetch the record data. This is necessary for both `"edit"` and `"clone"` forms.

:::

</TabItem>

</Tabs>

<details>
  <summary>See Modal component</summary>
  <div>

```tsx title="src/components/Modal/index.tsx"
type ModalPropsType = {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
};

const Modal: React.FC<ModalPropsType> = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null;
  return (
    <>
      <div className="overlay" onClick={onClose}></div>
      <div className="modal">
        <div className="modal-title">
          <button className="close-button" onClick={onClose}>
            &times;
          </button>
        </div>
        <div className="modal-content">{children}</div>
      </div>
    </>
  );
};
```

  </div>
</details>

<details>
  <summary>See styles</summary>
  <div>

```css title="src/styles.css"
* {
  box-sizing: border-box;
}

.overlay {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background-color: rgba(0, 0, 0, 0.7);
  z-index: 1000;
}

.modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #fff;
  z-index: 1000;
  width: 500px;
  overflow-y: auto;
}

.modal .modal-title {
  display: flex;
  justify-content: flex-end;
  padding: 4px;
}

.modal .modal-content {
  padding: 0px 16px 16px 16px;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.form .form-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.form input,
select,
textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
```

  </div>
</details>

## Properties

All [`useForm`][refine-react-hook-form-use-form] props also available in `useModalForm`. You can find descriptions on [`useForm`](/docs/packages/list-of-packages#properties) docs.

All [`React Hook Form useForm`][react-hook-form-use-form] props also available in `useModalForm`. You can find descriptions on [`React Hook Form`][react-hook-form-use-form] docs.

### defaultValues

Default values for the form. Use this to pre-populate the form with data that needs to be displayed. This property is only available with `"create"` action.

```tsx
const modalForm = useModalForm({
  defaultValues: {
    title: "Hello World",
  },
});
```

### defaultVisible

When `true`, modal will be visible by default. Defaults to `false`.

```tsx
const modalForm = useModalForm({
  modalProps: {
    defaultVisible: true,
  },
});
```

### autoSubmitClose

When `true`, modal will be closed after successful submit. Defaults to `true`.

```tsx
const modalForm = useModalForm({
  modalProps: {
    autoSubmitClose: false,
  },
});
```

### autoResetForm

When `true`, form will be reset after successful submit. Defaults to `true`.

```tsx
const modalForm = useModalForm({
  modalProps: {
    autoResetForm: false,
  },
});
```

### warnWhenUnsavedChanges

When you have unsaved changes and try to leave the current page, Refine shows a confirmation modal box. To activate this feature. By default, this feature is disabled.

You can also set this value in [`<Refine>`](/docs/core/refine-component#warnwhenunsavedchanges) component.

```tsx
const modalForm = useModalForm({
  warnWhenUnsavedChanges: true,
});
```

### syncWithLocation

When `true`, the modals visibility state and the `id` of the record will be synced with the URL. By default, this feature is disabled.

This property can also be set as an object `{ key: string; syncId?: boolean }` to customize the key of the URL query parameter. `id` will be synced with the URL only if `syncId` is `true`.

```tsx
const modalForm = useModalForm({
  syncWithLocation: { key: "my-modal", syncId: true },
});
```

### autoSave

If you want to save the form automatically after some delay when user edits the form, you can pass true to `autoSave.enabled` prop.

By default the `autoSave` feature does not invalidate queries. However, you can use the `invalidateOnUnmount` and `invalidateOnClose` props to invalidate queries upon unmount or close.

It also supports `onMutationSuccess` and `onMutationError` callback functions. You can use `isAutoSave` parameter to determine whether the mutation is triggered by `autoSave` or not.

`autoSave` feature operates exclusively in `edit` mode. Users can take advantage of this feature while editing data, as changes are automatically saved in editing mode. However, when creating new data, manual saving is still required.

`onMutationSuccess` and `onMutationError` callbacks will be called after the mutation is successful or failed.

#### enabled

To enable the `autoSave` feature, set the `enabled` parameter to `true`. By default, it is set to `false`.

```tsx
useModalForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
    },
  },
});
```

#### debounce

Set the debounce time for the `autoSave` prop. Default value is `1000` milliseconds.

```tsx
useModalForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
      // highlight-next-line
      debounce: 2000,
    },
  },
});
```

#### onFinish

If you want to modify the data before sending it to the server, you can use `onFinish` callback function.

```tsx
useModalForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
      // highlight-start
      onFinish: (values) => {
        return {
          foo: "bar",
          ...values,
        };
      },
      // highlight-end
    },
  },
});
```

#### invalidateOnUnmount

This prop is useful when you want to invalidate the `list`, `many` and `detail` queries from the current resource when the hook is unmounted. By default, it invalidates the `list`, `many` and `detail` queries associated with the current resource. Also, You can use the `invalidates` prop to select which queries to invalidate. By default it is set to `false`.

```tsx
useDrawerForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
      // highlight-next-line
      invalidateOnUnmount: true,
    },
  },
});
```

#### invalidateOnClose

This prop is useful when you want to invalidate the `list`, `many` and `detail` queries from the current resource when the modal is closed. By default, it invalidates the `list`, `many` and `detail` queries associated with the current resource. Also, You can use the `invalidates` prop to select which queries to invalidate. By default it is set to `false`.

```tsx
useDrawerForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
      // highlight-next-line
      invalidateOnClose: true,
    },
  },
});
```

## Return Values

All [`useForm`][refine-react-hook-form-use-form] return values also available in `useModalForm`. You can find descriptions on [`useForm`](/docs/packages/list-of-packages#return-values) docs.

All [`React Hook Form useForm`][react-hook-form-use-form] return values also available in `useModalForm`. You can find descriptions on [`useForm`](/docs/packages/list-of-packages#return-values) docs.

### visible

Current visibility state of the modal.

```tsx
const modalForm = useModalForm({
  defaultVisible: true,
});

console.log(modalForm.modal.visible); // true
```

### title

Title of the modal. Based on resource and action values

```tsx
const {
  modal: { title },
} = useModalForm({
  refineCoreProps: {
    resource: "posts",
    action: "create",
  },
});

console.log(title); // "Create Post"
```

### close

A function that can close the modal. It's useful when you want to close the modal manually.

```tsx
const {
  getInputProps,
  handleSubmit,
  register,
  modal,
  refineCore: { onFinish },
} = useModalForm();

return (
  <>
    <button onClick={show}>Show Modal</button>
    <Modal {...modal}>
      <form onSubmit={handleSubmit(onFinish)}>
        <div>
          <label>Title: </label>
          <input {...register("title")} />
        </div>
        <div>
          <button type="submit" onClick={modal.close}>
            Cancel
          </button>
          <button type="submit" onClick={modal.submit}>
            Save
          </button>
        </div>
      </form>
    </Modal>
  </>
);
```

### submit

A function that can submit the form. It's useful when you want to submit the form manually.

```tsx
const {
  getInputProps,
  handleSubmit,
  register,
  modal,
  refineCore: { onFinish },
} = useModalForm();

// ---

return (
  <>
    <button onClick={show}>Show Modal</button>
    <Modal {...modal}>
      <form onSubmit={handleSubmit(onFinish)}>
        <div>
          <label>Title: </label>
          <input {...register("title")} />
        </div>
        <div>
          <button type="submit" onClick={modal.submit}>
            Save
          </button>
        </div>
      </form>
    </Modal>
  </>
);
```

### show

A function that can show the modal.

```tsx
const {
  saveButtonProps,
  handleSubmit,
  register,
  modal,
  refineCore: { onFinish, formLoading },
} = useModalForm();

return (
  <>
    <button onClick={show}>Show Modal</button>
    <Modal {...modal}>
      <form onSubmit={handleSubmit(onFinish)}>
        <div>
          <label>Title: </label>
          <input {...register("title")} />
        </div>
        <div>
          <button type="submit" {...saveButtonProps}>
            Save
          </button>
        </div>
      </form>
    </Modal>
  </>
);
```

### saveButtonProps

It contains all the props needed by the "submit" button within the modal (disabled,loading etc.). You can manually pass these props to your custom button.

```tsx
const {
  saveButtonProps,
  handleSubmit,
  register,
  modal,
  refineCore: { onFinish, formLoading },
} = useModalForm();

return (
  <>
    <button onClick={show}>Show Modal</button>
    <Modal {...modal}>
      <form onSubmit={handleSubmit(onFinish)}>
        <div>
          <label>Title: </label>
          <input {...register("title")} />
        </div>
        <div>
          <button
            type="submit"
            disabled={saveButtonProps.disabled}
            onClick={(e) => {
              // -- your custom logic
              saveButtonProps.onClick(e);
            }}
          >
            Save
          </button>
        </div>
      </form>
    </Modal>
  </>
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/react-hook-form/useModalForm" />

:::simple External Props

It also accepts all props of [useForm](https://react-hook-form.com/api/useform) hook available in the [React Hook Form](https://react-hook-form.com/).

:::

### Type Parameters

| Property       | Description                                                                                                                                                         | Type                       | Default                    |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData   | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError         | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TVariables     | Field Values for mutation function                                                                                                                                  | `{}`                       | `{}`                       |
| TContext       | Second generic type of the `useForm` of the React Hook Form.                                                                                                        | `{}`                       | `{}`                       |
| TData          | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |
| TResponse      | Result data returned by the mutation function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TData` will be used as the default value.        | [`BaseRecord`][baserecord] | `TData`                    |
| TResponseError | Custom error object that extends [`HttpError`][httperror]. If not specified, the value of `TError` will be used as the default value.                               | [`HttpError`][httperror]   | `TError`                   |

### Return values

| Property                      | Description                                                     | Type                                                              |
| ----------------------------- | --------------------------------------------------------------- | ----------------------------------------------------------------- |
| modal                         | Relevant states and methods to control the modal                | [`ModalReturnValues`](#modalreturnvalues)                         |
| refineCore                    | The return values of the [`useForm`][use-form-core] in the core | [`UseFormReturnValues`](/docs/data/hooks/use-form/#return-values) |
| React Hook Form Return Values | See [React Hook Form][react-hook-form-use-form] documentation   |

#### ModalReturnValues

| Property        | Description                                    | Type                                                                     |
| --------------- | ---------------------------------------------- | ------------------------------------------------------------------------ |
| visible         | State of modal visibility                      | `boolean`                                                                |
| show            | Sets the visible state to true                 | `(id?: BaseKey) => void`                                                 |
| close           | Sets the visible state to false                | `() => void`                                                             |
| submit          | Submits the form                               | `(values: TVariables) => void`                                           |
| title           | Modal title based on resource and action value | `string`                                                                 |
| saveButtonProps | Props for a submit button                      | `{ disabled: boolean, onClick: (e: React.BaseSyntheticEvent) => void; }` |

## Example

<CodeSandboxExample path="form-react-hook-form-use-modal-form" />

[@refinedev/react-hook-form]: https://github.com/refinedev/refine/tree/main/packages/react-hook-form
[refine-react-hook-form-use-form]: /docs/packages/list-of-packages
[react-hook-form-use-form]: https://react-hook-form.com/api/useform
[use-form-core]: /docs/data/hooks/use-form/
[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: packages/react-hook-form/use-steps-form/index.md
================
---
title: useStepsForm
---

```css live shared
body {
  background: white;
}
```

```tsx live shared
import {
  useMany,
  useNavigation,
  useSelect as useSelectShared,
  useTable,
} from "@refinedev/core";
import { useStepsForm as useStepsFormShared } from "@refinedev/react-hook-form";

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: {
    id: ICategory["id"];
  };
}

const stepTitlesShared = ["Title", "Status", "Category and content"];

const PostList: React.FC = () => {
  const { tableQuery } = useTable<IPost>({
    sorters: {
      initial: [
        {
          field: "id",
          order: "desc",
        },
      ],
    },
  });
  const { edit, create } = useNavigation();

  const categoryIds =
    tableQuery?.data?.data.map((item) => item.category.id) ?? [];
  const { data, isLoading } = useMany<ICategory>({
    resource: "categories",
    ids: categoryIds,
    queryOptions: {
      enabled: categoryIds.length > 0,
    },
  });

  return (
    <div>
      <button onClick={() => create("posts")}>Create Post</button>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Title</th>
            <th>Category</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {tableQuery.data?.data.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>{post.title}</td>
              <td>
                {isLoading
                  ? "Loading"
                  : data?.data.find((item) => item.id == post.category.id)
                      ?.title}
              </td>
              <td>{post.status}</td>
              <td>
                <button onClick={() => edit("posts", post.id)}>Edit</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

const PostCreate: React.FC = () => {
  const {
    refineCore: { onFinish, formLoading },
    register,
    handleSubmit,
    formState: { errors },
    steps: { currentStep, gotoStep },
  } = useStepsFormShared<IPost, HttpError, IPost>();

  const { options } = useSelectShared({
    resource: "categories",
  });

  const renderFormByStep = (step: number) => {
    switch (step) {
      case 0:
        return (
          <>
            <label>Title: </label>
            <input
              {...register("title", {
                required: "This field is required",
              })}
            />
            {errors.title && <span>{errors.title.message}</span>}
          </>
        );
      case 1:
        return (
          <>
            <label>Status: </label>
            <select {...register("status")}>
              <option value="published">published</option>
              <option value="draft">draft</option>
              <option value="rejected">rejected</option>
            </select>
          </>
        );
      case 2:
        return (
          <>
            <label>Category: </label>
            <select
              {...register("category.id", {
                required: "This field is required",
              })}
            >
              {options?.map((category) => (
                <option key={category.value} value={category.value}>
                  {category.label}
                </option>
              ))}
            </select>
            {errors.category && <span>{errors.category.message}</span>}
            <br />
            <br />
            <label>Content: </label>
            <textarea
              {...register("content", {
                required: "This field is required",
              })}
              rows={10}
              cols={50}
            />
            {errors.content && <span>{errors.content.message}</span>}
          </>
        );
    }
  };

  if (formLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 16 }}>
      <div style={{ display: "flex", gap: 36 }}>
        {stepTitlesShared.map((title, index) => (
          <button
            key={index}
            onClick={() => gotoStep(index)}
            style={{
              backgroundColor: currentStep === index ? "lightgray" : "initial",
            }}
          >
            {index + 1} - {title}
          </button>
        ))}
      </div>
      <form autoComplete="off">{renderFormByStep(currentStep)}</form>
      <div style={{ display: "flex", gap: 8 }}>
        {currentStep > 0 && (
          <button
            onClick={() => {
              gotoStep(currentStep - 1);
            }}
          >
            Previous
          </button>
        )}
        {currentStep < stepTitlesShared.length - 1 && (
          <button
            onClick={() => {
              gotoStep(currentStep + 1);
            }}
          >
            Next
          </button>
        )}
        {currentStep === stepTitlesShared.length - 1 && (
          <button onClick={handleSubmit(onFinish)}>Save</button>
        )}
      </div>
    </div>
  );
};

const PostEdit: React.FC = () => {
  const {
    refineCore: { onFinish, formLoading, query },
    register,
    handleSubmit,
    formState: { errors },
    steps: { currentStep, gotoStep },
  } = useStepsFormShared<IPost, HttpError, IPost>();

  const { options } = useSelectShared({
    resource: "categories",
    defaultValue: query?.data?.data.category.id,
  });

  const renderFormByStep = (step: number) => {
    switch (step) {
      case 0:
        return (
          <>
            <label>Title: </label>
            <input
              {...register("title", {
                required: "This field is required",
              })}
            />
            {errors.title && <span>{errors.title.message}</span>}
          </>
        );
      case 1:
        return (
          <>
            <label>Status: </label>
            <select {...register("status")}>
              <option value="published">published</option>
              <option value="draft">draft</option>
              <option value="rejected">rejected</option>
            </select>
          </>
        );
      case 2:
        return (
          <>
            <label>Category: </label>
            <select
              {...register("category.id", {
                required: "This field is required",
              })}
              defaultValue={query?.data?.data.category.id}
            >
              {options?.map((category) => (
                <option key={category.value} value={category.value}>
                  {category.label}
                </option>
              ))}
            </select>
            {errors.category && <span>{errors.category.message}</span>}
            <br />
            <br />
            <label>Content: </label>
            <textarea
              {...register("content", {
                required: "This field is required",
              })}
              rows={10}
              cols={50}
            />
            {errors.content && <span>{errors.content.message}</span>}
          </>
        );
    }
  };

  if (formLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 16 }}>
      <div style={{ display: "flex", gap: 36 }}>
        {stepTitlesShared.map((title, index) => (
          <button
            key={index}
            onClick={() => gotoStep(index)}
            style={{
              backgroundColor: currentStep === index ? "lightgray" : "initial",
            }}
          >
            {index + 1} - {title}
          </button>
        ))}
      </div>
      <form autoComplete="off">{renderFormByStep(currentStep)}</form>
      <div style={{ display: "flex", gap: 8 }}>
        {currentStep > 0 && (
          <button
            onClick={() => {
              gotoStep(currentStep - 1);
            }}
          >
            Previous
          </button>
        )}
        {currentStep < stepTitlesShared.length - 1 && (
          <button
            onClick={() => {
              gotoStep(currentStep + 1);
            }}
          >
            Next
          </button>
        )}
        {currentStep === stepTitlesShared.length - 1 && (
          <button onClick={handleSubmit(onFinish)}>Save</button>
        )}
      </div>
    </div>
  );
};
```

`useStepsForm` allows you to manage a form with multiple steps. It provides features such as which step is currently active, the ability to go to a specific step and validation when changing steps etc.

`useStepsForm` hook is extended from [`useForm`][refine-react-hook-form-use-form] from the [`@refinedev/react-hook-form`][@refinedev/react-hook-form] package. This means you can use all the features of [`useForm`][refine-react-hook-form-use-form].

## Usage

We'll show two examples, one for creating and one for editing a post. Let's see how `useStepsForm` is used in both.

<Tabs
defaultValue="create"
values={[
{label: 'create', value: 'create'},
{label: 'edit', value: 'edit'},
]}>

<TabItem value="create">

Here is the final result of the form: We will explain the code in following sections.

```tsx live url=http://localhost:3000/posts/create previewHeight=420px hideCode
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { HttpError, useSelect } from "@refinedev/core";
import { useStepsForm } from "@refinedev/react-hook-form";

const stepTitles = ["Title", "Status", "Category and content"];

const PostCreatePage: React.FC = () => {
  const {
    refineCore: { onFinish, formLoading },
    register,
    handleSubmit,
    formState: { errors },
    steps: { currentStep, gotoStep },
  } = useStepsForm<IPost, HttpError, IPost>();

  const { options } = useSelect<ICategory, HttpError>({
    resource: "categories",
  });

  const renderFormByStep = (step: number) => {
    switch (step) {
      case 0:
        return (
          <>
            <label>Title: </label>
            <input
              {...register("title", {
                required: "This field is required",
              })}
            />
            {errors.title && <span>{errors.title.message}</span>}
          </>
        );
      case 1:
        return (
          <>
            <label>Status: </label>
            <select {...register("status")}>
              <option value="published">published</option>
              <option value="draft">draft</option>
              <option value="rejected">rejected</option>
            </select>
          </>
        );
      case 2:
        return (
          <>
            <label>Category: </label>
            <select
              {...register("category.id", {
                required: "This field is required",
              })}
            >
              {options?.map((category) => (
                <option key={category.value} value={category.value}>
                  {category.label}
                </option>
              ))}
            </select>
            {errors.category && <span>{errors.category.message}</span>}
            <br />
            <br />
            <label>Content: </label>
            <textarea
              {...register("content", {
                required: "This field is required",
              })}
              rows={10}
              cols={50}
            />
            {errors.content && <span>{errors.content.message}</span>}
          </>
        );
    }
  };

  if (formLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 16 }}>
      <div style={{ display: "flex", gap: 36 }}>
        {stepTitles.map((title, index) => (
          <button
            key={index}
            onClick={() => gotoStep(index)}
            style={{
              backgroundColor: currentStep === index ? "lightgray" : "initial",
            }}
          >
            {index + 1} - {title}
          </button>
        ))}
      </div>
      <form autoComplete="off">{renderFormByStep(currentStep)}</form>
      <div style={{ display: "flex", gap: 8 }}>
        {currentStep > 0 && (
          <button
            onClick={() => {
              gotoStep(currentStep - 1);
            }}
          >
            Previous
          </button>
        )}
        {currentStep < stepTitles.length - 1 && (
          <button
            onClick={() => {
              gotoStep(currentStep + 1);
            }}
          >
            Next
          </button>
        )}
        {currentStep === stepTitles.length - 1 && (
          <button onClick={handleSubmit(onFinish)}>Save</button>
        )}
      </div>
    </div>
  );
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: {
    id: ICategory["id"];
  };
}
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreatePage,
      edit: PostEdit,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

</TabItem>

<TabItem value="edit">

Here is the final result of the form: We will explain the code in following sections.

```tsx live url=http://localhost:3000/posts/edit/123 previewHeight=420px hideCode
setInitialRoutes(["/posts/edit/123"]);

// visible-block-start
import { HttpError, useSelect } from "@refinedev/core";
import { useStepsForm } from "@refinedev/react-hook-form";

const stepTitles = ["Title", "Status", "Category and content"];

const PostEditPage: React.FC = () => {
  const {
    refineCore: { onFinish, formLoading, query },
    register,
    handleSubmit,
    formState: { errors },
    steps: { currentStep, gotoStep },
  } = useStepsForm<IPost, HttpError, IPost>();

  const { options } = useSelect<ICategory, HttpError>({
    resource: "categories",
    defaultValue: query?.data?.data.category.id,
  });

  const renderFormByStep = (step: number) => {
    switch (step) {
      case 0:
        return (
          <>
            <label>Title: </label>
            <input
              {...register("title", {
                required: "This field is required",
              })}
            />
            {errors.title && <span>{errors.title.message}</span>}
          </>
        );
      case 1:
        return (
          <>
            <label>Status: </label>
            <select {...register("status")}>
              <option value="published">published</option>
              <option value="draft">draft</option>
              <option value="rejected">rejected</option>
            </select>
          </>
        );
      case 2:
        return (
          <>
            <label>Category: </label>
            <select
              {...register("category.id", {
                required: "This field is required",
              })}
              defaultValue={query?.data?.data.category.id}
            >
              {options?.map((category) => (
                <option key={category.value} value={category.value}>
                  {category.label}
                </option>
              ))}
            </select>
            {errors.category && <span>{errors.category.message}</span>}
            <br />
            <br />
            <label>Content: </label>
            <textarea
              {...register("content", {
                required: "This field is required",
              })}
              rows={10}
              cols={50}
            />
            {errors.content && <span>{errors.content.message}</span>}
          </>
        );
    }
  };

  if (formLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 16 }}>
      <div style={{ display: "flex", gap: 36 }}>
        {stepTitles.map((title, index) => (
          <button
            key={index}
            onClick={() => gotoStep(index)}
            style={{
              backgroundColor: currentStep === index ? "lightgray" : "initial",
            }}
          >
            {index + 1} - {title}
          </button>
        ))}
      </div>
      <form autoComplete="off">{renderFormByStep(currentStep)}</form>
      <div style={{ display: "flex", gap: 8 }}>
        {currentStep > 0 && (
          <button
            onClick={() => {
              gotoStep(currentStep - 1);
            }}
          >
            Previous
          </button>
        )}
        {currentStep < stepTitles.length - 1 && (
          <button
            onClick={() => {
              gotoStep(currentStep + 1);
            }}
          >
            Next
          </button>
        )}
        {currentStep === stepTitles.length - 1 && (
          <button onClick={handleSubmit(onFinish)}>Save</button>
        )}
      </div>
    </div>
  );
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: {
    id: ICategory["id"];
  };
}
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreate,
      edit: PostEditPage,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

</TabItem>

</Tabs>

In this example we're going to build a Post `"create"` form. We also added a relational category field to expand our example.

To split your `<input/>` components under a `<form/>` component, first import and use `useStepsForm` hook in your page:

```tsx
import { HttpError } from "@refinedev/core";
import { useStepsForm } from "@refinedev/react-hook-form";

const PostCreate = () => {
  const {
    refineCore: { onFinish, formLoading },
    register,
    handleSubmit,
    formState: { errors },
    steps: { currentStep, gotoStep },
  } = useStepsForm<IPost, HttpError, IPost>();

  return <div>...</div>;
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: {
    id: ICategory["id"];
  };
}
```

`useStepsForm` is generic over the type form data to help you type check your code.

This hook returns a set of useful values to render steps form. Given current value, you should have a way to render your form items conditionally with this index value.

Here, we're going to use a `switch` statement to render the form items based on the `currentStep`.

```tsx
import { HttpError, useSelect } from "@refinedev/core";
import { useStepsForm } from "@refinedev/react-hook-form";

const PostCreate = () => {
  const {
    refineCore: { onFinish, formLoading },
    register,
    handleSubmit,
    formState: { errors },
    steps: { currentStep, gotoStep },
  } = useStepsForm<IPost, HttpError, IPost>();

  const { options } = useSelect<ICategory, HttpError>({
    resource: "categories",
  });

  // highlight-start
  const renderFormByStep = (step: number) => {
    switch (step) {
      case 0:
        return (
          <>
            <label>Title: </label>
            <input
              {...register("title", {
                required: "This field is required",
              })}
            />
            {errors.title && <span>{errors.title.message}</span>}
          </>
        );
      case 1:
        return (
          <>
            <label>Status: </label>
            <select {...register("status")}>
              <option value="published">published</option>
              <option value="draft">draft</option>
              <option value="rejected">rejected</option>
            </select>
          </>
        );
      case 2:
        return (
          <>
            <label>Category: </label>
            <select
              {...register("category.id", {
                required: "This field is required",
              })}
            >
              {options?.map((category) => (
                <option key={category.value} value={category.value}>
                  {category.label}
                </option>
              ))}
            </select>
            {errors.category && <span>{errors.category.message}</span>}
            <br />
            <br />
            <label>Content: </label>
            <textarea
              {...register("content", {
                required: "This field is required",
              })}
              rows={10}
              cols={50}
            />
            {errors.content && <span>{errors.content.message}</span>}
          </>
        );
    }
  };
  // highlight-end

  return <div>...</div>;
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: {
    id: ICategory["id"];
  };
}
```

:::simple Relational Data

Since `category` is a relational data, we use `useSelect` to fetch its data.

[Refer to `useSelect` documentation for detailed usage. &#8594](/docs/ui-integrations/ant-design/hooks/use-select)

:::

Now, we can use `renderFormByStep` function to render the form items based on the `currentStep` and `gotoStep` function to navigate between steps.

```tsx
import { HttpError, useSelect } from "@refinedev/core";
import { useStepsForm } from "@refinedev/react-hook-form";

const PostCreate = () => {
  const {
    refineCore: { onFinish, formLoading },
    register,
    handleSubmit,
    formState: { errors },
    steps: { currentStep, gotoStep },
  } = useStepsForm<IPost, HttpError, IPost>();

  const { options } = useSelect<ICategory, HttpError>({
    resource: "categories",
  });

  const renderFormByStep = (step: number) => {
    switch (step) {
      case 0:
        return (
          <>
            <label>Title: </label>
            <input
              {...register("title", {
                required: "This field is required",
              })}
            />
            {errors.title && <span>{errors.title.message}</span>}
          </>
        );
      case 1:
        return (
          <>
            <label>Status: </label>
            <select {...register("status")}>
              <option value="published">published</option>
              <option value="draft">draft</option>
              <option value="rejected">rejected</option>
            </select>
          </>
        );
      case 2:
        return (
          <>
            <label>Category: </label>
            <select
              {...register("category.id", {
                required: "This field is required",
              })}
            >
              {options?.map((category) => (
                <option key={category.value} value={category.value}>
                  {category.label}
                </option>
              ))}
            </select>
            {errors.category && <span>{errors.category.message}</span>}
            <br />
            <br />
            <label>Content: </label>
            <textarea
              {...register("content", {
                required: "This field is required",
              })}
              rows={10}
              cols={50}
            />
            {errors.content && <span>{errors.content.message}</span>}
          </>
        );
    }
  };

  // highlight-start
  if (formLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 16 }}>
      <div style={{ display: "flex", gap: 36 }}>
        {stepTitles.map((title, index) => (
          <button
            key={index}
            onClick={() => gotoStep(index)}
            style={{
              backgroundColor: currentStep === index ? "lightgray" : "initial",
            }}
          >
            {index + 1} - {title}
          </button>
        ))}
      </div>
      <form autoComplete="off">{renderFormByStep(currentStep)}</form>
      <div style={{ display: "flex", gap: 8 }}>
        {currentStep > 0 && (
          <button
            onClick={() => {
              gotoStep(currentStep - 1);
            }}
          >
            Previous
          </button>
        )}
        {currentStep < stepTitles.length - 1 && (
          <button
            onClick={() => {
              gotoStep(currentStep + 1);
            }}
          >
            Next
          </button>
        )}
        {currentStep === stepTitles.length - 1 && (
          <button onClick={handleSubmit(onFinish)}>Save</button>
        )}
      </div>
    </div>
  );
  // highlight-end
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: {
    id: ICategory["id"];
  };
}
```

## Properties

### refineCoreProps

All [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form) properties also available in `useStepsForm`. You can find descriptions on [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form#return-values) docs.

```tsx
const stepsForm = useStepsForm({
  refineCoreProps: {
    action: "edit",
    resource: "posts",
    id: "1",
  },
});
```

### stepsProps

The props needed by the manage state steps.

#### defaultStep

Sets the default starting step number. Counting starts from `0`.

```tsx
const stepsForm = useStepsForm({
  stepsProps: {
    defaultStep: 0,
  },
});
```

#### isBackValidate

When is `true`, validates a form fields when the user navigates to a previous step. Default is `false`.

```tsx
const stepsForm = useStepsForm({
  stepsProps: {
    isBackValidate: true,
  },
});
```

### autoSave

If you want to save the form automatically after some delay when user edits the form, you can pass true to `autoSave.enabled` prop.

By default the `autoSave` feature does not invalidate queries. However, you can use the `invalidateOnUnmount` prop to invalidate queries upon unmount.

It also supports `onMutationSuccess` and `onMutationError` callback functions. You can use `isAutoSave` parameter to determine whether the mutation is triggered by `autoSave` or not.

`autoSave` feature operates exclusively in `edit` mode. Users can take advantage of this feature while editing data, as changes are automatically saved in editing mode. However, when creating new data, manual saving is still required.

`onMutationSuccess` and `onMutationError` callbacks will be called after the mutation is successful or failed.

#### enabled

To enable the `autoSave` feature, set the `enabled` parameter to `true`. By default, it is set to `false`.

```tsx
useStepsForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
    },
  },
});
```

#### debounce

Set the debounce time for the `autoSave` prop. By default, it is set to `1000` milliseconds.

```tsx
useStepsForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
      // highlight-next-line
      debounce: 2000,
    },
  },
});
```

#### onFinish

If you want to modify the data before sending it to the server, you can use `onFinish` callback function.

```tsx
useStepsForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
      // highlight-start
      onFinish: (values) => {
        return {
          foo: "bar",
          ...values,
        };
      },
      // highlight-end
    },
  },
});
```

#### invalidateOnUnmount

This prop is useful when you want to invalidate the `list`, `many` and `detail` queries from the current resource when the hook is unmounted. By default, it invalidates the `list`, `many` and `detail` queries associated with the current resource. Also, You can use the `invalidates` prop to select which queries to invalidate. By default, it is set to `false`.

```tsx
useStepsForm({
  refineCoreProps: {
    autoSave: {
      enabled: true,
      // highlight-next-line
      invalidateOnUnmount: true,
    },
  },
});
```

## Return Values

All [`useForm`](/docs/packages/list-of-packages) return values also available in `useStepsForm`. You can find descriptions on [`useForm`](/docs/packages/list-of-packages#return-values) docs.

### steps

The return values needed by the manage state steps.

#### currentStep

Current step, counting from `0`.

#### gotoStep

Is a function that allows you to programmatically change the current step of a form.
It takes in one argument, step, which is a number representing the index of the step you want to navigate to.

## API Reference

### Properties

<PropsTable module="@refinedev/react-hook-form/useStepsForm" />

:::simple External Props

It also accepts all props of [useForm](https://react-hook-form.com/api/useform) hook available in the [React Hook Form](https://react-hook-form.com/).

:::

### Type Parameters

| Property       | Description                                                                                                                                                         | Type                       | Default                    |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData   | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError         | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TVariables     | Field Values for mutation function                                                                                                                                  | `{}`                       | `{}`                       |
| TContext       | Second generic type of the `useForm` of the React Hook Form.                                                                                                        | `{}`                       | `{}`                       |
| TData          | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |
| TResponse      | Result data returned by the mutation function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TData` will be used as the default value.        | [`BaseRecord`][baserecord] | `TData`                    |
| TResponseError | Custom error object that extends [`HttpError`][httperror]. If not specified, the value of `TError` will be used as the default value.                               | [`HttpError`][httperror]   | `TError`                   |

### Return values

| Property                      | Description                                                     | Type                                                              |
| ----------------------------- | --------------------------------------------------------------- | ----------------------------------------------------------------- |
| steps                         | Relevant state and method to control the steps                  | [`StepsReturnValues`](#steps)                                     |
| refineCore                    | The return values of the [`useForm`][use-form-core] in the core | [`UseFormReturnValues`](/docs/data/hooks/use-form/#return-values) |
| React Hook Form Return Values | See [React Hook Form][react-hook-form-use-form] documentation   |

## Example

<CodeSandboxExample path="form-react-hook-form-use-steps-form" />

[@refinedev/react-hook-form]: https://github.com/refinedev/refine/tree/main/packages/react-hook-form
[refine-react-hook-form-use-form]: /docs/packages/list-of-packages
[react-hook-form-use-form]: https://react-hook-form.com/api/useform
[use-form-core]: /docs/data/hooks/use-form/
[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: packages/tanstack-table/examples/_partial-basic-usage-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
}

const PostList: React.FC = () => {
  const columns = React.useMemo<ColumnDef<IPost>[]>(
    () => [
      {
        id: "id",
        header: "ID",
        accessorKey: "id",
      },
      {
        id: "title",
        header: "Title",
        accessorKey: "title",
      },
      {
        id: "status",
        header: "Status",
        accessorKey: "status",
      },
      {
        id: "createdAt",
        header: "CreatedAt",
        accessorKey: "createdAt",
      },
    ],
    [],
  );

  const { getHeaderGroups, getRowModel } = useTable({
    columns,
  });

  return (
    <table>
      <thead>
        {getHeaderGroups().map((headerGroup) => (
          <tr key={headerGroup.id}>
            {headerGroup.headers.map((header) => {
              return (
                <th key={header.id}>
                  {flexRender(
                    header.column.columnDef.header,
                    header.getContext(),
                  )}
                </th>
              );
            })}
          </tr>
        ))}
      </thead>
      <tbody>
        {getRowModel().rows.map((row) => {
          return (
            <tr key={row.id}>
              {row.getVisibleCells().map((cell) => {
                return (
                  <td key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </td>
                );
              })}
            </tr>
          );
        })}
      </tbody>
    </table>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

================
File: packages/tanstack-table/examples/_partial-filtering-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
}

const PostList: React.FC = () => {
  const columns = React.useMemo<ColumnDef<IPost>[]>(
    () => [
      {
        id: "id",
        header: "ID",
        accessorKey: "id",
        //highlight-next-line
        enableColumnFilter: false,
      },
      {
        id: "title",
        header: "Title",
        accessorKey: "title",
        //highlight-start
        meta: {
          filterOperator: "contains",
        },
        //highlight-end
      },
      {
        id: "status",
        header: "Status",
        accessorKey: "status",
        //highlight-start
        meta: {
          filterOperator: "contains",
        },
        //highlight-end
      },
      {
        id: "createdAt",
        header: "CreatedAt",
        accessorKey: "createdAt",
        //highlight-start
        meta: {
          filterOperator: "gte",
        },
        //highlight-end
      },
    ],
    [],
  );

  const { getHeaderGroups, getRowModel } = useTable({
    columns,
  });

  return (
    <table>
      <thead>
        {getHeaderGroups().map((headerGroup) => (
          <tr key={headerGroup.id}>
            {headerGroup.headers.map((header) => {
              return (
                <th key={header.id}>
                  {header.isPlaceholder ? null : (
                    <>
                      {flexRender(
                        header.column.columnDef.header,
                        header.getContext(),
                      )}
                      {/* highlight-start */}
                      {header.column.getCanFilter() ? (
                        <div>
                          <input
                            value={
                              (header.column.getFilterValue() as string) ?? ""
                            }
                            onChange={(e) =>
                              header.column.setFilterValue(e.target.value)
                            }
                          />
                        </div>
                      ) : null}
                      {/* highlight-end */}
                    </>
                  )}
                </th>
              );
            })}
          </tr>
        ))}
      </thead>
      <tbody>
        {getRowModel().rows.map((row) => {
          return (
            <tr key={row.id}>
              {row.getVisibleCells().map((cell) => {
                return (
                  <td key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </td>
                );
              })}
            </tr>
          );
        })}
      </tbody>
    </table>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

================
File: packages/tanstack-table/examples/_partial-pagination-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
}

const PostList: React.FC = () => {
  const columns = React.useMemo<ColumnDef<IPost>[]>(
    () => [
      {
        id: "id",
        header: "ID",
        accessorKey: "id",
      },
      {
        id: "title",
        header: "Title",
        accessorKey: "title",
      },
      {
        id: "status",
        header: "Status",
        accessorKey: "status",
      },
      {
        id: "createdAt",
        header: "CreatedAt",
        accessorKey: "createdAt",
      },
    ],
    [],
  );

  const {
    getHeaderGroups,
    getRowModel,
    // highlight-start
    getState,
    setPageIndex,
    getCanPreviousPage,
    getPageCount,
    getCanNextPage,
    nextPage,
    previousPage,
    setPageSize,
    getPrePaginationRowModel,
    // highlight-end
  } = useTable({
    columns,
  });

  return (
    <div>
      <table>
        <thead>
          {getHeaderGroups().map((headerGroup) => (
            <tr key={headerGroup.id}>
              {headerGroup.headers.map((header) => {
                return (
                  <th key={header.id}>
                    {header.isPlaceholder ? null : (
                      <>
                        {flexRender(
                          header.column.columnDef.header,
                          header.getContext(),
                        )}
                      </>
                    )}
                  </th>
                );
              })}
            </tr>
          ))}
        </thead>
        <tbody>
          {getRowModel().rows.map((row) => {
            return (
              <tr key={row.id}>
                {row.getVisibleCells().map((cell) => {
                  return (
                    <td key={cell.id}>
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext(),
                      )}
                    </td>
                  );
                })}
              </tr>
            );
          })}
        </tbody>
      </table>
      {/* Pagination can be built however you'd like. */}
      {/* This is just a very basic UI implementation: */}
      {/* highlight-start */}
      <div>
        <button
          onClick={() => setPageIndex(0)}
          disabled={!getCanPreviousPage()}
        >
          {"<<"}
        </button>
        <button onClick={() => previousPage()} disabled={!getCanPreviousPage()}>
          {"<"}
        </button>
        <button onClick={() => nextPage()} disabled={!getCanNextPage()}>
          {">"}
        </button>
        <button
          onClick={() => setPageIndex(getPageCount() - 1)}
          disabled={!getCanNextPage()}
        >
          {">>"}
        </button>
        <span>
          <div>Page</div>
          <strong>
            {getState().pagination.pageIndex + 1} of {getPageCount()}
          </strong>
        </span>
        <span>
          | Go to page:
          <input
            type="number"
            defaultValue={getState().pagination.pageIndex + 1}
            onChange={(e) => {
              const page = e.target.value ? Number(e.target.value) - 1 : 0;
              setPageIndex(page);
            }}
          />
        </span>
        <select
          value={getState().pagination.pageSize}
          onChange={(e) => {
            setPageSize(Number(e.target.value));
          }}
        >
          {[10, 20, 30, 40, 50].map((pageSize) => (
            <option key={pageSize} value={pageSize}>
              Show {pageSize}
            </option>
          ))}
        </select>
      </div>
      <div>{getPrePaginationRowModel().rows.length} Rows</div>
      {/* highlight-end */}
    </div>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

================
File: packages/tanstack-table/examples/_partial-relational-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";
import { GetManyResponse, HttpError, useMany } from "@refinedev/core";

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: {
    id: number;
  };
}

const PostList: React.FC = () => {
  const columns = React.useMemo<ColumnDef<IPost>[]>(
    () => [
      {
        id: "id",
        header: "ID",
        accessorKey: "id",
      },
      {
        id: "title",
        header: "Title",
        accessorKey: "title",
      },
      {
        id: "status",
        header: "Status",
        accessorKey: "status",
      },
      {
        id: "createdAt",
        header: "CreatedAt",
        accessorKey: "createdAt",
      },
      // highlight-start
      {
        id: "category",
        header: "Category",
        accessorKey: "category.id",
        cell: function render({ getValue, table }) {
          const meta = table.options.meta as {
            categoryData: GetManyResponse<ICategory>;
          };
          // Gets the  category from the meta.categoryData object, which is the result of the useMany hook We pass this data to meta with the setOptions function.
          const category = meta.categoryData?.data?.find(
            (item) => item.id === getValue(),
          );

          return category?.title ?? "Loading...";
        },
      },
      // highlight-end
    ],
    [],
  );

  const {
    getHeaderGroups,
    getRowModel,
    setOptions,
    refineCore: {
      tableQuery: { data: tableData },
    },
  } = useTable<IPost, HttpError>({
    columns,
  });

  // highlight-start
  // Fetches the category of each post. It uses the useMany hook to fetch the category data from the API.
  const { data: categoryData } = useMany<ICategory, HttpError>({
    resource: "categories",
    // Creates the array of ids. This will filter and fetch the category data for the relevant posts.
    ids: tableData?.data?.map((item) => item?.category?.id) ?? [],
    queryOptions: {
      // Set to true only if the posts array is not empty.
      enabled: !!tableData?.data,
    },
  });
  // highlight-end

  // highlight-start
  // set meta data to table options. We will use this data in cell render.
  setOptions((prev) => ({
    ...prev,
    meta: {
      ...prev.meta,
      categoryData,
    },
  }));
  // highlight-end

  return (
    <table>
      <thead>
        {getHeaderGroups().map((headerGroup) => (
          <tr key={headerGroup.id}>
            {headerGroup.headers.map((header) => {
              return (
                <th key={header.id}>
                  {flexRender(
                    header.column.columnDef.header,
                    header.getContext(),
                  )}
                </th>
              );
            })}
          </tr>
        ))}
      </thead>
      <tbody>
        {getRowModel().rows.map((row) => {
          return (
            <tr key={row.id}>
              {row.getVisibleCells().map((cell) => {
                return (
                  <td key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </td>
                );
              })}
            </tr>
          );
        })}
      </tbody>
    </table>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

================
File: packages/tanstack-table/examples/_partial-sorting-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
}

const PostList: React.FC = () => {
  const columns = React.useMemo<ColumnDef<IPost>[]>(
    () => [
      {
        id: "id",
        header: "ID",
        accessorKey: "id",
      },
      {
        id: "title",
        header: "Title",
        accessorKey: "title",
      },
      {
        id: "status",
        header: "Status",
        accessorKey: "status",
      },
      {
        id: "createdAt",
        header: "CreatedAt",
        accessorKey: "createdAt",
      },
    ],
    [],
  );

  const { getHeaderGroups, getRowModel } = useTable({
    columns,
  });

  return (
    <table>
      <thead>
        {getHeaderGroups().map((headerGroup) => (
          <tr key={headerGroup.id}>
            {headerGroup.headers.map((header) => {
              return (
                <th key={header.id}>
                  {header.isPlaceholder ? null : (
                    // highlight-start
                    <>
                      <div onClick={header.column.getToggleSortingHandler()}>
                        {flexRender(
                          header.column.columnDef.header,
                          header.getContext(),
                        )}
                        {{
                          asc: " 🔼",
                          desc: " 🔽",
                        }[header.column.getIsSorted() as string] ?? null}
                      </div>
                    </>
                    // highlight-end
                  )}
                </th>
              );
            })}
          </tr>
        ))}
      </thead>
      <tbody>
        {getRowModel().rows.map((row) => {
          return (
            <tr key={row.id}>
              {row.getVisibleCells().map((cell) => {
                return (
                  <td key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </td>
                );
              })}
            </tr>
          );
        })}
      </tbody>
    </table>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineHeadlessDemo />);
```

================
File: packages/tanstack-table/examples/chakra-ui.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BaseCoreTable() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-table": "latest",
        "@tanstack/react-table": "latest",
        "@refinedev/chakra-ui": "latest",
        "@chakra-ui/react": "^2.5.1",
        "@tabler/icons-react": "^3.1.0",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
        "/pagination.tsx": {
          code: PaginationTsxCode,
          hidden: false,
        },
        "/column-sorter.tsx": {
          code: ColumnSorterTsxCode,
          hidden: false,
        },
        "/column-filter.tsx": {
          code: ColumnFilterTsxCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { ChakraProvider } from "@chakra-ui/react";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <ChakraProvider>
            <Refine dataProvider={dataProvider(API_URL)}>
                <ProductTable />
            </Refine>
        </ChakraProvider>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";
import {
    Table,
    Thead,
    Tbody,
    Tr,
    Th,
    Td,
    TableContainer,
    HStack,
    Text,
} from "@chakra-ui/react";
import { Pagination } from "./pagination";
import { ColumnSorter } from "./column-sorter";
import { ColumnFilter } from "./column-filter";
export const ProductTable: React.FC = () => {
    const columns = React.useMemo<ColumnDef<IProduct>[]>(
        () => [
            {
                id: "id",
                header: "ID",
                accessorKey: "id",
                meta: {
                    filterOperator: "eq",
                },
            },
            {
                id: "name",
                header: "Name",
                accessorKey: "name",
                meta: {
                    filterOperator: "contains",
                },
            },
            {
                id: "price",
                header: "Price",
                accessorKey: "price",
                meta: {
                    filterOperator: "eq",
                },
            },
        ],
        [],
    );
    const {
        getHeaderGroups,
        getRowModel,
        refineCore: { setCurrent, pageCount, current },
    } = useTable({
        refineCoreProps: {
            resource: "products",
        },
        columns,
    });
    return (
        <div style={{ padding:"8px" }}>
            <Text fontSize='3xl'>Products</Text>
            <TableContainer whiteSpace="pre-line">
                <Table variant="simple">
                    <Thead>
                        {getHeaderGroups().map((headerGroup) => (
                            <Tr key={headerGroup.id}>
                                {headerGroup.headers.map((header) => (
                                    <Th key={header.id}>
                                        {!header.isPlaceholder && (
                                            <HStack spacing="2">
                                                <Text>
                                                    {flexRender(
                                                        header.column.columnDef
                                                            .header,
                                                        header.getContext(),
                                                    )}
                                                </Text>
                                                <HStack spacing="2">
                                                    <ColumnSorter
                                                        column={header.column}
                                                    />
                                                    <ColumnFilter
                                                        column={header.column}
                                                    />
                                                </HStack>
                                            </HStack>
                                        )}
                                    </Th>
                                ))}
                            </Tr>
                        ))}
                    </Thead>
                    <Tbody>
                        {getRowModel().rows.map((row) => (
                            <Tr key={row.id}>
                                {row.getVisibleCells().map((cell) => (
                                    <Td key={cell.id}>
                                        {flexRender(
                                            cell.column.columnDef.cell,
                                            cell.getContext(),
                                        )}
                                    </Td>
                                ))}
                            </Tr>
                        ))}
                    </Tbody>
                </Table>
            </TableContainer>
            <Pagination
                current={current}
                pageCount={pageCount}
                setCurrent={setCurrent}
            />
        </div>
    );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
}
`.trim();
export const PaginationTsxCode = `
import { FC } from "react";
import { HStack, Button, Box } from "@chakra-ui/react";
import { usePagination } from "@refinedev/chakra-ui";
export const Pagination: FC<PaginationProps> = ({
    current,
    pageCount,
    setCurrent,
}) => {
    const pagination = usePagination({
        current,
        pageCount,
    });
    return (
        <Box display="flex" justifyContent="flex-end">
            <HStack my="3" spacing="1">
                {pagination?.prev && (
                    <Button
                        aria-label="previous page"
                        onClick={() => setCurrent(current - 1)}
                        disabled={!pagination?.prev}
                        variant="outline"
                    >
                        Prev
                    </Button>
                )}
                {pagination?.items.map((page) => {
                    if (typeof page === "string")
                        return <span key={page}>...</span>;
                    return (
                        <Button
                            key={page}
                            onClick={() => setCurrent(page)}
                            variant={page === current ? "solid" : "outline"}
                        >
                            {page}
                        </Button>
                    );
                })}
                {pagination?.next && (
                    <Button
                        aria-label="next page"
                        onClick={() => setCurrent(current + 1)}
                        variant="outline"
                    >
                        Next
                    </Button>
                )}
            </HStack>
        </Box>
    );
};
type PaginationProps = {
    current: number;
    pageCount: number;
    setCurrent: (page: number) => void;
};
`.trim();
export const ColumnSorterTsxCode = `
import React, { useState } from "react";
import { IconButton } from "@chakra-ui/react";
import { IconChevronDown, IconChevronUp, IconSelector } from "@tabler/icons-react";
import type { SortDirection } from "@tanstack/react-table";
export interface ColumnButtonProps {
    column: Column<any, any>; // eslint-disable-line
}
export const ColumnSorter: React.FC<ColumnButtonProps> = ({ column }) => {
    if (!column.getCanSort()) {
        return null;
    }
    const sorted = column.getIsSorted();
    return (
        <IconButton
            aria-label="Sort"
            size="xs"
            onClick={column.getToggleSortingHandler()}
            icon={<ColumnSorterIcon sorted={sorted} />}
            variant={sorted ? "light" : "transparent"}
            color={sorted ? "primary" : "gray"}
        />
    );
};
const ColumnSorterIcon = ({ sorted }: { sorted: false | SortDirection }) => {
    if (sorted === "asc") return <IconChevronDown size={18} />;
    if (sorted === "desc") return <IconChevronUp size={18} />;
    return <IconSelector size={18} />;
};
`.trim();
export const ColumnFilterTsxCode = `
import React, { useState } from "react";
import {
    Input,
    Menu,
    IconButton,
    MenuButton,
    MenuList,
    VStack,
    HStack,
} from "@chakra-ui/react";
import { IconFilter, IconX, IconCheck } from "@tabler/icons-react";
interface ColumnButtonProps {
    column: Column<any, any>; // eslint-disable-line
}
export const ColumnFilter: React.FC<ColumnButtonProps> = ({ column }) => {
    // eslint-disable-next-line
    const [state, setState] = useState(null as null | { value: any });
    if (!column.getCanFilter()) {
        return null;
    }
    const open = () =>
        setState({
            value: column.getFilterValue(),
        });
    const close = () => setState(null);
    // eslint-disable-next-line
    const change = (value: any) => setState({ value });
    const clear = () => {
        column.setFilterValue(undefined);
        close();
    };
    const save = () => {
        if (!state) return;
        column.setFilterValue(state.value);
        close();
    };
    const renderFilterElement = () => {
        // eslint-disable-next-line
        const FilterComponent = (column.columnDef?.meta as any)?.filterElement;
        if (!FilterComponent && !!state) {
            return (
                <Input
                    borderRadius="md"
                    size="sm"
                    autoComplete="off"
                    value={state.value}
                    onChange={(e) => change(e.target.value)}
                />
            );
        }
        return (
            <FilterComponent
                value={state?.value}
                onChange={(e: any) => change(e.target.value)}
            />
        );
    };
    return (
        <Menu isOpen={!!state} onClose={close}>
            <MenuButton
                onClick={open}
                as={IconButton}
                aria-label="Options"
                icon={<IconFilter size="16" />}
                variant="ghost"
                size="xs"
            />
            <MenuList p="2">
                {!!state && (
                    <VStack align="flex-start">
                        {renderFilterElement()}
                        <HStack spacing="1">
                            <IconButton
                                aria-label="Clear"
                                size="sm"
                                colorScheme="red"
                                onClick={clear}
                            >
                                <IconX size={18} />
                            </IconButton>
                            <IconButton
                                aria-label="Save"
                                size="sm"
                                onClick={save}
                                colorScheme="green"
                            >
                                <IconCheck size={18} />
                            </IconButton>
                        </HStack>
                    </VStack>
                )}
            </MenuList>
        </Menu>
    );
};
`.trim();

================
File: packages/tanstack-table/examples/headless.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BaseTanStackTable() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@tanstack/react-table": "latest",
        "@refinedev/react-table": "latest",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <Refine dataProvider={dataProvider(API_URL)}>
            <ProductTable />
        </Refine>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";
export const ProductTable: React.FC = () => {
    const columns = React.useMemo<ColumnDef<IProduct>[]>(
        () => [
            {
                id: "id",
                header: "ID",
                accessorKey: "id",
                meta: {
                    filterOperator: "eq",
                },
            },
            {
                id: "name",
                header: "Name",
                accessorKey: "name",
                meta: {
                    filterOperator: "contains",
                },
            },
            {
                id: "price",
                header: "Price",
                accessorKey: "price",
                meta: {
                    filterOperator: "eq",
                },
            },
        ],
        [],
    );
    const {
        getHeaderGroups,
        getRowModel,
        getState,
        setPageIndex,
        getCanPreviousPage,
        getPageCount,
        getCanNextPage,
        nextPage,
        previousPage,
        setPageSize,
    } = useTable<IProduct>({
        refineCoreProps: {
            resource: "products",
        },
        columns,
    });
    return (
        <div>
            <h1>Products</h1>
            <table>
                <thead>
                    {getHeaderGroups().map((headerGroup) => (
                        <tr key={headerGroup.id}>
                            {headerGroup.headers.map((header) => {
                                return (
                                    <th key={header.id}>
                                        {header.isPlaceholder ? null : (
                                            <>
                                                <div
                                                    onClick={header.column.getToggleSortingHandler()}
                                                >
                                                    {flexRender(
                                                        header.column.columnDef
                                                            .header,
                                                        header.getContext(),
                                                    )}
                                                    {{
                                                        asc: " 🔼",
                                                        desc: " 🔽",
                                                    }[
                                                        header.column.getIsSorted() as string
                                                    ] ?? " ↕️"}
                                                </div>
                                            </>
                                        )}
                                        {header.column.getCanFilter() ? (
                                            <div>
                                                <input
                                                    value={
                                                        (header.column.getFilterValue() as string) ??
                                                        ""
                                                    }
                                                    onChange={(e) =>
                                                        header.column.setFilterValue(
                                                            e.target.value,
                                                        )
                                                    }
                                                />
                                            </div>
                                        ) : null}
                                    </th>
                                );
                            })}
                        </tr>
                    ))}
                </thead>
                <tbody>
                    {getRowModel().rows.map((row) => {
                        return (
                            <tr key={row.id}>
                                {row.getVisibleCells().map((cell) => {
                                    return (
                                        <td key={cell.id}>
                                            {flexRender(
                                                cell.column.columnDef.cell,
                                                cell.getContext(),
                                            )}
                                        </td>
                                    );
                                })}
                            </tr>
                        );
                    })}
                </tbody>
            </table>
            <div>
                <button
                    onClick={() => setPageIndex(0)}
                    disabled={!getCanPreviousPage()}
                >
                    {"<<"}
                </button>
                <button
                    onClick={() => previousPage()}
                    disabled={!getCanPreviousPage()}
                >
                    {"<"}
                </button>
                <button onClick={() => nextPage()} disabled={!getCanNextPage()}>
                    {">"}
                </button>
                <button
                    onClick={() => setPageIndex(getPageCount() - 1)}
                    disabled={!getCanNextPage()}
                >
                    {">>"}
                </button>
                <span>
                    Page
                    <strong>
                        {getState().pagination.pageIndex + 1} of{" "}
                        {getPageCount()}
                    </strong>
                </span>
                <span>
                    | Go to page:
                    <input
                        type="number"
                        defaultValue={getState().pagination.pageIndex + 1}
                        onChange={(e) => {
                            const page = e.target.value
                                ? Number(e.target.value) - 1
                                : 0;
                            setPageIndex(page);
                        }}
                    />
                </span>{" "}
                <select
                    value={getState().pagination.pageSize}
                    onChange={(e) => {
                        setPageSize(Number(e.target.value));
                    }}
                >
                    {[10, 20, 30, 40, 50].map((pageSize) => (
                        <option key={pageSize} value={pageSize}>
                            Show {pageSize}
                        </option>
                    ))}
                </select>
            </div>
        </div>
    );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
}
`.trim();

================
File: packages/tanstack-table/examples/mantine.tsx
================
import { Sandpack } from "@site/src/components/sandpack";
import React from "react";
export default function BaseCoreTable() {
  return (
    <Sandpack
      dependencies={{
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/mantine": "latest",
        "@refinedev/react-table": "latest",
        "@tanstack/react-table": "latest",
        "@mantine/core": "^5.10.4",
        "@tabler/icons-react": "^3.1.0",
      }}
      startRoute="/"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: false,
        },
        "/product-table.tsx": {
          code: ProductTableTsxCode,
          hidden: false,
          active: true,
        },
        "/column-sorter.tsx": {
          code: ColumnSorterTsxCode,
          hidden: false,
        },
        "/column-filter.tsx": {
          code: ColumnFilterTsxCode,
          hidden: false,
        },
      }}
    />
  );
}
const AppTsxCode = `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { MantineProvider, Global } from "@mantine/core";
import { ProductTable } from "./product-table.tsx";
const API_URL = "https://api.fake-rest.refine.dev";
export default function App() {
    return (
        <MantineProvider
                withNormalizeCSS
                withGlobalStyles
        >
            <Global styles={{ body: { WebkitFontSmoothing: "auto" } }} />
            <Refine dataProvider={dataProvider(API_URL)}>
                <ProductTable />
            </Refine>
        </MantineProvider>
    );
}
`.trim();
export const ProductTableTsxCode = `
import React from "react";
import { useTable } from "@refinedev/react-table";
import { ColumnDef, flexRender } from "@tanstack/react-table";
import { Box, Group, Table, Pagination } from "@mantine/core";
import { ColumnSorter } from "./column-sorter.tsx";
import { ColumnFilter } from "./column-filter.tsx";
export const ProductTable: React.FC = () => {
    const columns = React.useMemo<ColumnDef<IProduct>[]>(
        () => [
            {
                id: "id",
                header: "ID",
                accessorKey: "id",
                meta: {
                    filterOperator: "eq",
                },
            },
            {
                id: "name",
                header: "Name",
                accessorKey: "name",
                meta: {
                    filterOperator: "contains",
                },
            },
            {
                id: "price",
                header: "Price",
                accessorKey: "price",
                meta: {
                    filterOperator: "eq",
                },
            },
        ],
        [],
    );
    const {
        getHeaderGroups,
        getRowModel,
        refineCore: { setCurrent, pageCount, current },
    } = useTable({
        refineCoreProps: {
            resource: "products",
        },
        columns,
    });
    return (
        <div style={{ padding: "4px" }}>
            <h2>Products</h2>
            <Table highlightOnHover>
                <thead>
                    {getHeaderGroups().map((headerGroup) => (
                        <tr key={headerGroup.id}>
                            {headerGroup.headers.map((header) => {
                                return (
                                    <th key={header.id}>
                                        {!header.isPlaceholder && (
                                            <Group spacing="xs" noWrap>
                                                <Box>
                                                    {flexRender(
                                                        header.column.columnDef
                                                            .header,
                                                        header.getContext(),
                                                    )}
                                                </Box>
                                                <Group spacing="xs" noWrap>
                                                    <ColumnSorter
                                                        column={header.column}
                                                    />
                                                    <ColumnFilter
                                                        column={header.column}
                                                    />
                                                </Group>
                                            </Group>
                                        )}
                                    </th>
                                );
                            })}
                        </tr>
                    ))}
                </thead>
                <tbody>
                    {getRowModel().rows.map((row) => {
                        return (
                            <tr key={row.id}>
                                {row.getVisibleCells().map((cell) => {
                                    return (
                                        <td key={cell.id}>
                                            {flexRender(
                                                cell.column.columnDef.cell,
                                                cell.getContext(),
                                            )}
                                        </td>
                                    );
                                })}
                            </tr>
                        );
                    })}
                </tbody>
            </Table>
            <br />
            <Pagination
                position="right"
                total={pageCount}
                page={current}
                onChange={setCurrent}
            />
        </div>
    );
};
interface IProduct {
    id: number;
    name: string;
    price: string;
}
`.trim();
export const ColumnSorterTsxCode = `
import { ActionIcon } from "@mantine/core";
import { IconChevronDown, IconSelector, IconChevronUp } from "@tabler/icons-react";
export interface ColumnButtonProps {
    column: Column<any, any>; // eslint-disable-line
}
export const ColumnSorter: React.FC<ColumnButtonProps> = ({ column }) => {
    if (!column.getCanSort()) {
        return null;
    }
    const sorted = column.getIsSorted();
    return (
        <ActionIcon
            size="xs"
            onClick={column.getToggleSortingHandler()}
            style={{
                transition: "transform 0.25s",
                transform: \`rotate(\${sorted === "asc" ? "180" : "0"}deg)\`,
            }}
            variant={sorted ? "light" : "transparent"}
            color={sorted ? "primary" : "gray"}
        >
            {!sorted && <IconSelector size={18} />}
            {sorted === "asc" && <IconChevronDown size={18} />}
            {sorted === "desc" && <IconChevronUp size={18} />}
        </ActionIcon>
    );
};
`.trim();
export const ColumnFilterTsxCode = `
import React, { useState } from "react";
import { Column } from "@tanstack/react-table";
import { TextInput, Menu, ActionIcon, Stack, Group } from "@mantine/core";
import { IconFilter, IconX, IconCheck } from "@tabler/icons-react";
interface ColumnButtonProps {
    column: Column<any, any>; // eslint-disable-line
}
export const ColumnFilter: React.FC<ColumnButtonProps> = ({ column }) => {
    // eslint-disable-next-line
    const [state, setState] = useState(null as null | { value: any });
    if (!column.getCanFilter()) {
        return null;
    }
    const open = () =>
        setState({
            value: column.getFilterValue(),
        });
    const close = () => setState(null);
    // eslint-disable-next-line
    const change = (value: any) => setState({ value });
    const clear = () => {
        column.setFilterValue(undefined);
        close();
    };
    const save = () => {
        if (!state) return;
        column.setFilterValue(state.value);
        close();
    };
    const renderFilterElement = () => {
        // eslint-disable-next-line
        const FilterComponent = (column.columnDef?.meta as any)?.filterElement;
        if (!FilterComponent && !!state) {
            return (
                <TextInput
                    autoComplete="off"
                    value={state.value}
                    onChange={(e) => change(e.target.value)}
                />
            );
        }
        return <FilterComponent value={state?.value} onChange={change} />;
    };
    return (
        <Menu
            opened={!!state}
            position="bottom"
            withArrow
            transition="scale-y"
            shadow="xl"
            onClose={close}
            width="256px"
            withinPortal
        >
            <Menu.Target>
                <ActionIcon
                    size="xs"
                    onClick={open}
                    variant={column.getIsFiltered() ? "light" : "transparent"}
                    color={column.getIsFiltered() ? "primary" : "gray"}
                >
                    <IconFilter size={18} />
                </ActionIcon>
            </Menu.Target>
            <Menu.Dropdown>
                {!!state && (
                    <Stack p="xs" spacing="xs">
                        {renderFilterElement()}
                        <Group position="right" spacing={6} noWrap>
                            <ActionIcon
                                size="md"
                                color="gray"
                                variant="outline"
                                onClick={clear}
                            >
                                <IconX size={18} />
                            </ActionIcon>
                            <ActionIcon
                                size="md"
                                onClick={save}
                                color="primary"
                                variant="outline"
                            >
                                <IconCheck size={18} />
                            </ActionIcon>
                        </Group>
                    </Stack>
                )}
            </Menu.Dropdown>
        </Menu>
    );
};
`.trim();

================
File: packages/tanstack-table/introduction/index.md
================
---
title: Introduction
source: /packages/react-table/src/useTable
---

import BaseHeadlessTable from "../examples/headless";
import BaseMantineTable from "../examples/mantine";
import BaseChakraUiTable from "../examples/chakra-ui";

# TanStack Table <GuideBadge id="guides-concepts/tables" /> <RouterBadge id="guides-concepts/routing/#usetable" />

Refine provides an integration package for [TanStack Table][tanstack-table] library. This package enables you to manage your tables in a headless manner. This adapter supports all of the features of both [TanStack Table][tanstack-table] and [Refine's useTable][use-table-core] hook (sorting, filtering pagination etc). Simply, you can use any of the [TanStack Table][tanstack-table] examples as-is by copying and pasting them into your project.

## Installation

Install the [`@refinedev/react-table`][refine-react-table] library.

<InstallPackagesCommand args="@refinedev/react-table"/>

## Usage

Let's see how to display a table with [useTable][use-table-tanstack] hook.

We provide implementation examples for the Mantine and Chakra UI. If you using a different ui library, you can use the headless example as a starting point.

<Tabs wrapContent={false}>

<TabItem value="headless" label="Headless">

<BaseHeadlessTable />

</TabItem>

<TabItem value="mantine" label={(<span><span className="block">Mantine</span><small className="block">TanStack Table</small></span>)}>

<BaseMantineTable />

</TabItem>

<TabItem value="chakra-ui" label={(<span><span className="block">Chakra UI</span><small className="block">TanStack Table</small></span>)}>

<BaseChakraUiTable />

</TabItem>

</Tabs>

[tanstack-table]: https://tanstack.com/table/v8
[refine-react-table]: https://github.com/refinedev/refine/tree/main/packages/react-table
[use-table-core]: /docs/data/hooks/use-table
[use-table-tanstack]: /docs/packages/list-of-packages
[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[syncwithlocationparams]: /docs/core/interface-references#syncwithlocationparams
[notification-provider]: /docs/notification/notification-provider
[crudsorting]: /docs/core/interface-references#crudsorting
[crudfilters]: /docs/core/interface-references#crudfilters
[Refine swl]: /docs/core/refine-component#syncwithlocation

================
File: packages/tanstack-table/use-table/index.md
================
---
title: useTable
source: /packages/react-table/src/useTable
---

import BasicUsageLivePreview from "../examples/\_partial-basic-usage-live-preview.md";
import PaginationLivePreview from "../examples/\_partial-pagination-live-preview.md";
import SortingLivePreview from "../examples/\_partial-sorting-live-preview.md";
import FilteringLivePreview from "../examples/\_partial-filtering-live-preview.md";
import RelationalLivePreview from "../examples/\_partial-relational-live-preview.md";
import PropResource from "@site/src/partials/prop-resource";

Refine offers a [TanStack Table][tanstack-table] adapter with [@refinedev/react-table][refine-react-table] that allows you to use the TanStack Table library with Refine. All features such as sorting, filtering, and pagination come out of the box. Under the hood it uses [`useList`](/docs/data/hooks/use-list) for the fetch. Since it is designed as headless, It expects you to handle the UI.

All of [TanStack Table's][tanstack-table] features are supported and you can use all of the [TanStack Table's][tanstack-table] examples with no changes just copy and paste them into your project.

`useTable` hook is extended from [`useTable`][use-table-core] hook from the [`@refinedev/core`](https://github.com/refinedev/refine/tree/main/packages/core) package. This means that you can use all the features of [`useTable`][use-table-core] hook.

## Installation

Install the [`@refinedev/react-table`][refine-react-table] library.

<InstallPackagesCommand args="@refinedev/react-table"/>

## Usage

In basic usage, `useTable` returns the data as it comes from the endpoint. By default, it reads [`resource`](#resource) from the url.

<BasicUsageLivePreview/>

## Pagination

[TanStack Table][tanstack-table] provides a bunch of methods that we can use to control the pagination. For example, we can use the `setPageSize` method to set the current `pageSize`. Every change in the `pageSize` and `pageIndex` will trigger a new request to the data provider.

It also syncs the pagination state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

By default, pagination happens on the server side. If you want to do pagination handling on the client side, you can pass the pagination.mode property and set it to "client". Also, you can disable the pagination by setting the "off".

<PaginationLivePreview/>

## Sorting

[TanStack Table][tanstack-table] provides a bunch of methods that we can use to control the sorting. For example, we can use the `setColumnOrder` method to set the current `sorting` value. Every change in the `sorting` state will trigger a new request to the data provider.

It also syncs the sorting state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

<SortingLivePreview/>

## Filtering

[TanStack Table][tanstack-table] provides a bunch of methods that we can use to control the filtering. For example, we can use the `setColumnFilters` method to set the current `columnFilters` value. Every change in the `filter` will trigger a new request to the data provider.

It also syncs the filtering state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

By default, filter operators are set to "eq" for all fields. You can specify which field will be filtered with which filter operator with the `filterOperator` property in the `meta` object. Just be aware that the `filterOperator` must be a [`CrudOperators`](/docs/core/interface-references#crudoperators) type.

If you're going to use [logical filters](/docs/core/interface-references#logicalfilter) (`and`, `or`), you can set `filterOperator` to `and` or `or` in the `meta` object. By design, logical filters do not have `field` property, instead they have `key` property to differentiate between filters if there are multiple filters with the same operator.

By default, `id` field of the column is used as the `key` property. If you want to use a different field as the `key`, you can set the `filterKey` property in the `meta` object.

:::simple Finding the filter value

Refine provides the [`getDefaultFilter`](https://github.com/refinedev/refine/blob/716656d9ad3deb169c32685cdebbfd46bac44beb/packages/core/src/definitions/table/index.ts#L166) function, You can use this function to find the filter value for the specific field.

```tsx
import { getDefaultFilter } from "@refinedev/core";
import { useTable } from "@refinedev/react-table";

const MyComponent = () => {
  const {
    refineCore: { filters },
  } = useTable({
    refineCoreProps: {
      filters: {
        initial: [
          {
            field: "name",
            operator: "contains",
            value: "John Doe",
          },
        ],
      },
    },
  });

  const nameFilterValue = getDefaultFilter("name", filters, "contains");
  console.log(nameFilterValue); // "John Doe"

  return {
    /** ... */
  };
};
```

:::

<FilteringLivePreview/>

## Realtime Updates

> This feature is only available if you use a [Live Provider](/docs/realtime/live-provider).

When the `useTable` hook is mounted, it will call the `subscribe` method from the `liveProvider` with some parameters such as `channel`, `resource` etc. It is useful when you want to subscribe to live updates.

## Properties

It also accepts all props of [TanStack Table](https://tanstack.com/table/v8/docs/api/core/table#options).

### resource

<PropResource
hook={{
    name:"useList",
    URL:"/docs/data/hooks/use-list/"
}}
method={{
    name:"getList",
    URL:"/docs/data/data-provider/#getlist"
}}
hasDefault={false}
/>

By default, it reads the resource from the current route.

```tsx
useTable({
  refineCoreProps: {
    resource: "categories",
  },
});
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### dataProviderName

If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use. It is useful when you want to use a different `dataProvider` for a specific resource.

```tsx
useTable({
  refineCoreProps: {
    dataProviderName: "second-data-provider",
  },
});
```

### pagination.current

Sets the initial value of the page index. Default value is `1`.

```tsx
useTable({
  refineCoreProps: {
    pagination: {
      current: 2,
    },
  },
});
```

### pagination.pageSize

Sets the initial value of the page size. Default value is `10`.

```tsx
useTable({
  refineCoreProps: {
    pagination: {
      pageSize: 10,
    },
  },
});
```

### pagination.mode

It can be `"off"`, `"server"` or `"client"`. Default value is `"server"`.

- **"off":** Pagination is disabled. All records will be fetched.
- **"client":** Pagination is done on the client side. All records will be fetched and then the records will be paginated on the client side.
- **"server":**: Pagination is done on the server side. Records will be fetched by using the `current` and `pageSize` values.

```tsx
useTable({
  refineCoreProps: {
    pagination: {
      mode: "client",
    },
  },
});
```

### sorters.initial

Sets the initial value of the sorter. The `initial` is not permanent. It will be cleared when the user changes the sorter. If you want to set a permanent value, use the `sorters.permanent` prop.

[Refer to the `CrudSorting` interface for more information &#8594](/docs/core/interface-references#crudsorting)

```tsx
useTable({
  refineCoreProps: {
    sorters: {
      initial: [
        {
          field: "name",
          order: "asc",
        },
      ],
    },
  },
});
```

### sorters.permanent

Sets the permanent value of the sorter. The `permanent` is permanent and unchangeable. It will not be cleared when the user changes the sorter. If you want to set a temporary value, use the `sorters.initial` prop.

[Refer to the `CrudSorting` interface for more information &#8594](/docs/core/interface-references#crudsorting)

```tsx
useTable({
  refineCoreProps: {
    sorters: {
      permanent: [
        {
          field: "name",
          order: "asc",
        },
      ],
    },
  },
});
```

### sorters.mode

It can be `"off"` or `"server"`. Default value is `"server"`.

- **"off":** Sorting are disabled. All records will be fetched.
- **"server":**: Sorting are done on the server side. Records will be fetched by using the `sorters` value.

```tsx
useTable({
  refineCoreProps: {
    sorters: {
      mode: "off",
    },
  },
});
```

### filters.initial

Sets the initial value of the filter. The `initial` is not permanent. It will be cleared when the user changes the filter. If you want to set a permanent value, use the `filters.permanent` prop.

[Refer to the `CrudFilters` interface for more information &#8594](/docs/core/interface-references#crudfilters)

```tsx
useTable({
  refineCoreProps: {
    filters: {
      initial: [
        {
          field: "name",
          operator: "contains",
          value: "Foo",
        },
      ],
    },
  },
});
```

### filters.permanent

Sets the permanent value of the filter. The `permanent` is permanent and unchangeable. It will not be cleared when the user changes the filter. If you want to set a temporary value, use the `filters.initial` prop.

[Refer to the `CrudFilters` interface for more information &#8594](/docs/core/interface-references#crudfilters)

```tsx
useTable({
  refineCoreProps: {
    filters: {
      permanent: [
        {
          field: "name",
          operator: "contains",
          value: "Foo",
        },
      ],
    },
  },
});
```

### filters.defaultBehavior

The filtering behavior can be set to either `"merge"` or `"replace"`. Default value is `"replace"`.

- When the filter behavior is set to `"merge"`, it will merge the new filter with the existing filters. This means that if the new filter has the same column as an existing filter, the new filter will replace the existing filter for that column. If the new filter has a different column than the existing filters, it will be added to the existing filters.

- When the filter behavior is set to `"replace"`, it will replace all existing filters with the new filter. This means that any existing filters will be removed and only the new filter will be applied to the table.

You can also override the default value by using the second parameter of the [`setFilters`](#setfilters) function.

```tsx
useTable({
  refineCoreProps: {
    filters: {
      defaultBehavior: "merge",
    },
  },
});
```

### filters.mode

It can be `"off"` or `"server"`. Default value is `"server"`.

- **"off":** `filters` are not sent to the server. You can use the `filters` value to filter the records on the client side.
- **"server":**: Filters are done on the server side. Records will be fetched by using the `filters` value.

```tsx
useTable({
  refineCoreProps: {
    filters: {
      mode: "off",
    },
  },
});
```

### syncWithLocation <GlobalConfigBadge id="core/refine-component/#syncwithlocation" />

When you use the syncWithLocation feature, the `useTable`'s state (e.g. sort order, filters, pagination) is automatically encoded in the query parameters of the URL, and when the URL changes, the `useTable` state is automatically updated to match. This makes it easy to share table state across different routes or pages and to allow users to bookmark or share links to specific table views.

By default, it reads the `syncWithLocation` from the `<Refine>` component.

```tsx
useTable({
  refineCoreProps: {
    syncWithLocation: true,
  },
});
```

### queryOptions

`useTable` uses [`useList`](/docs/data/hooks/use-list) hook to fetch data. You can pass [`queryOptions`](https://tanstack.com/query/v4/docs/react/reference/useQuery).

```tsx
useTable({
  refineCoreProps: {
    queryOptions: {
      retry: 3,
    },
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

[Refer to the `meta` section of the General Concepts documentation for more information &#8594](/docs/guides-concepts/general-concepts/#meta-concept)

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useTable({
  refineCoreProps: {
    metaData: {
      headers: { "x-meta-data": "true" },
    },
  },
});

const myDataProvider = {
  //...
  getList: async ({
    resource,
    pagination,
    sorters,
    filters,
    // highlight-next-line
    metaData,
  }) => {
    // highlight-next-line
    const headers = metaData?.headers ?? {};
    const url = `${apiUrl}/${resource}`;

    //...
    //...

    // highlight-next-line
    const { data, headers } = await httpClient.get(`${url}`, { headers });

    return {
      data,
    };
  },
  //...
};
```

### successNotification

> [`NotificationProvider`][notification-provider] is required for this prop to work.

After data is fetched successfully, `useTable` can call `open` function from [`NotificationProvider`][notification-provider] to show a success notification. With this prop, you can customize the success notification.

```tsx
useTable({
  refineCoreProps: {
    successNotification: (data, values, resource) => {
      return {
        message: `${data.title} Successfully fetched.`,
        description: "Success with no errors",
        type: "success",
      };
    },
  },
});
```

### errorNotification

> [`NotificationProvider`][notification-provider] is required for this prop to work.

After data fetching is failed, `useTable` will call `open` function from [`NotificationProvider`][notification-provider] to show an error notification. With this prop, you can customize the error notification.

```tsx
useTable({
  refineCoreProps: {
    errorNotification: (data, values, resource) => {
      return {
        message: `Something went wrong when getting ${data.id}`,
        description: "Error",
        type: "error",
      };
    },
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required.

Determines whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.
For more information about live mode, please check [Live / Realtime](/docs/realtime/live-provider#livemode) page.

```tsx
useTable({
  refineCoreProps: {
    liveMode: "auto",
  },
});
```

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required.

The callback function is executed when new events from a subscription have arrived.

```tsx
useTable({
  refineCoreProps: {
    onLiveEvent: (event) => {
      console.log(event);
    },
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### ~~initialCurrent~~ <PropTag deprecated />

Use `pagination.current` instead.

### ~~initialPageSize~~ <PropTag deprecated />

Use `pagination.pageSize` instead.

### ~~hasPagination~~ <PropTag deprecated />

Use `pagination.mode` instead.

### ~~initialSorter~~ <PropTag deprecated />

Use `sorters.initial` instead.

### ~~permanentSorter~~ <PropTag deprecated />

Use `sorters.permanent` instead.

### ~~initialFilter~~ <PropTag deprecated />

Use `filters.initial` instead.

### ~~permanentFilter~~ <PropTag deprecated />

Use `filters.permanent` instead.

### ~~defaultSetFilterBehavior~~ <PropTag deprecated />

Use `filters.defaultBehavior` instead.

## Return Values

It also have all return values of [TanStack Table](https://tanstack.com/table/v8/docs/api/core/table#options).

### refineCore

#### tableQuery

Returned values from [`useList`](/docs/data/hooks/use-list) hook.

### sorters

Current [sorters state][crudsorting].

### setSorters

A function to set current [sorters state][crudsorting].

```tsx
 (sorters: CrudSorting) => void;
```

A function to set current [sorters state][crudsorting].

#### filters

Current [filters state][crudfilters].

#### setFilters

```tsx
((filters: CrudFilters, behavior?: SetFilterBehavior) => void) & ((setter: (prevFilters: CrudFilters) => CrudFilters) => void)
```

A function to set current [filters state][crudfilters].

#### current

Current page index state. If pagination is disabled, it will be `undefined`.

#### setCurrent

```tsx
React.Dispatch<React.SetStateAction<number>> | undefined;
```

A function to set the current page index state. If pagination is disabled, it will be `undefined`.

#### pageSize

Current page size state. If pagination is disabled, it will be `undefined`.

#### setPageSize

```tsx
React.Dispatch<React.SetStateAction<number>> | undefined;
```

A function to set the current page size state. If pagination is disabled, it will be `undefined`.

#### pageCount

Total page count state. If pagination is disabled, it will be `undefined`.

#### createLinkForSyncWithLocation

```tsx
(params: SyncWithLocationParams) => string;
```

A function creates accessible links for `syncWithLocation`. It takes [SyncWithLocationParams][syncwithlocationparams] as parameters.

### ~~sorter~~ <PropTag deprecated />

Use `sorters` instead.

Current [sorters state][crudsorting].

### ~~setSorter~~ <PropTag deprecated />

Use `setSorters` instead.

## FAQ

### How can I handle relational data?

You can use [`useMany`](/docs/data/hooks/use-many) hook to fetch relational data.

<RelationalLivePreview/>

### How can I handle client side filtering?

You can set the [`filters.mode: "off"`](#filtersmode) in order to disable server-side filtering. `useTable` is fully compatible with [`TanStack Table`](https://tanstack.com/table/v8/docs/api/features/filters) filtering feature.

```tsx
useTable({
  refineCoreProps: {
    filters: {
      mode: "off",
    },
  },
});
```

### How can I handle client side sorting?

You can set the [`sorters.mode: "off"`](#sortersmode) in order to disable server-side sorting. `useTable` is fully compatible with [`TanStack Table`](https://tanstack.com/table/v8/docs/api/features/sorting) sorting feature.

```tsx
useTable({
  refineCoreProps: {
    sorters: {
      mode: "off",
    },
  },
});
```

## API Reference

### Properties

<PropsTable module="@refinedev/react-table/useTable" />

### Type Parameters

| Property     | Description                                                                                                                                                | Type                       | Default                    |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data of the query. Extends [`BaseRecord`][baserecord]                                                                                               | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                  | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data of the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Property                     | Description                                                                                     | Type                                                               |
| ---------------------------- | ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| refineCore                   | The return values of the [`useTable`][use-table-core] in the core                               | [`UseTableReturnValues`](/docs/data/hooks/use-table#return-values) |
| Tanstack Table Return Values | See [TanStack Table](https://tanstack.com/table/v8/docs/api/core/table#table-api) documentation |

## Example

<CodeSandboxExample path="table-react-table-basic" />

[tanstack-table]: https://tanstack.com/table/v8
[refine-react-table]: https://github.com/refinedev/refine/tree/main/packages/react-table
[use-table-core]: /docs/data/hooks/use-table
[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[syncwithlocationparams]: /docs/core/interface-references#syncwithlocationparams
[notification-provider]: /docs/notification/notification-provider
[crudsorting]: /docs/core/interface-references#crudsorting
[crudfilters]: /docs/core/interface-references#crudfilters
[Refine swl]: /docs/core/refine-component#syncwithlocation

================
File: partials/_partial-translation-file-de.md
================
```json title="/locales/de/common.json"
{
  "pages": {
    "login": {
      "title": "Melden Sie sich bei Ihrem Konto an",
      "signin": "Einloggen",
      "signup": "Anmelden",
      "divider": "oder",
      "fields": {
        "email": "Email",
        "password": "Passwort"
      },
      "errors": {
        "validEmail": "Ungültige E-Mail-Adresse",
        "requiredEmail": "E-Mail ist erforderlich",
        "requiredPassword": "Passwort wird benötigt"
      },
      "buttons": {
        "submit": "Anmeldung",
        "forgotPassword": "Passwort vergessen?",
        "noAccount": "Sie haben kein Konto?",
        "rememberMe": "Erinnere dich an mich"
      }
    },
    "forgotPassword": {
      "title": "Haben Sie Ihr Passwort vergessen?",
      "fields": {
        "email": "Email"
      },
      "errors": {
        "validEmail": "Ungültige E-Mail-Adresse",
        "requiredEmail": "E-Mail ist erforderlich"
      },
      "buttons": {
        "submit": "Anweisungen zum Zurücksetzen senden"
      }
    },
    "register": {
      "title": "Registrieren Sie sich für Ihr Konto",
      "fields": {
        "email": "Email",
        "password": "Passwort"
      },
      "errors": {
        "validEmail": "Ungültige E-Mail-Adresse",
        "requiredEmail": "E-Mail ist erforderlich",
        "requiredPassword": "Passwort wird benötigt"
      },
      "buttons": {
        "submit": "Registrieren",
        "haveAccount": "Ein Konto haben?"
      }
    },
    "updatePassword": {
      "title": "Kennwort aktualisieren",
      "fields": {
        "password": "Neues Passwort",
        "confirmPassword": "Bestätige neues Passwort"
      },
      "errors": {
        "confirmPasswordNotMatch": "Passwörter stimmen nicht überein",
        "requiredPassword": "Passwort wird benötigt",
        "requiredConfirmPassword": "Das Feld „Passwort bestätigen“ ist erforderlich"
      },
      "buttons": {
        "submit": "Aktualisieren"
      }
    },
    "error": {
      "info": "Sie haben vergessen, {{action}} component zu {{resource}} hinzufügen.",
      "404": "Leider existiert diese Seite nicht.",
      "resource404": "Haben Sie die {{resource}} resource erstellt?",
      "backHome": "Zurück"
    }
  },
  "actions": {
    "list": "Aufführen",
    "create": "Erstellen",
    "edit": "Bearbeiten",
    "show": "Zeigen"
  },
  "buttons": {
    "create": "Erstellen",
    "save": "Speichern",
    "logout": "Abmelden",
    "delete": "Löschen",
    "edit": "Bearbeiten",
    "cancel": "Abbrechen",
    "confirm": "Sicher?",
    "filter": "Filter",
    "clear": "Löschen",
    "refresh": "Erneuern",
    "show": "Zeigen",
    "undo": "Undo",
    "import": "Importieren",
    "clone": "Klon",
    "notAccessTitle": "Sie haben keine zugriffsberechtigung"
  },
  "warnWhenUnsavedChanges": "Nicht gespeicherte Änderungen werden nicht übernommen.",
  "notifications": {
    "success": "Erfolg",
    "error": "Fehler (status code: {{statusCode}})",
    "undoable": "Sie haben {{seconds}} Sekunden Zeit für Undo.",
    "createSuccess": "{{resource}} erfolgreich erstellt.",
    "createError": "Fehler beim Erstellen {{resource}} (status code: {{statusCode}})",
    "deleteSuccess": "{{resource}} erfolgreich gelöscht.",
    "deleteError": "Fehler beim Löschen {{resource}} (status code: {{statusCode}})",
    "editSuccess": "{{resource}} erfolgreich bearbeitet.",
    "editError": "Fehler beim Bearbeiten {{resource}} (status code: {{statusCode}})",
    "importProgress": "{{processed}}/{{total}} importiert"
  },
  "loading": "Wird geladen",
  "tags": {
    "clone": "Klon"
  },
  "dashboard": {
    "title": "Dashboard"
  },
  "posts": {
    "posts": "Einträge",
    "fields": {
      "id": "Id",
      "title": "Titel",
      "category": "Kategorie",
      "status": {
        "title": "Status",
        "published": "Veröffentlicht",
        "draft": "Draft",
        "rejected": "Abgelehnt"
      },
      "content": "Inhalh",
      "createdAt": "Erstellt am"
    },
    "titles": {
      "create": "Erstellen",
      "edit": "Bearbeiten",
      "list": "Einträge",
      "show": "Eintrag zeigen"
    }
  },
  "table": {
    "actions": "Aktionen"
  },
  "documentTitle": {
    "default": "refine",
    "suffix": " | Refine",
    "post": {
      "list": "Beiträge | Refine",
      "show": "#{{id}} Beitrag anzeigen | Refine",
      "edit": "#{{id}} Beitrag bearbeiten | Refine",
      "create": "Neuen Beitrag erstellen | Refine",
      "clone": "#{{id}} Beitrag klonen | Refine"
    }
  },
  "autoSave": {
    "success": "gespeichert",
    "error": "fehler beim automatischen speichern",
    "loading": "speichern...",
    "idle": "warten auf anderungen"
  }
}
```

================
File: partials/_partial-translation-file-en.md
================
```json title="/locales/en/common.json"
{
  "pages": {
    "login": {
      "title": "Sign in to your account",
      "signin": "Sign in",
      "signup": "Sign up",
      "divider": "or",
      "fields": {
        "email": "Email",
        "password": "Password"
      },
      "errors": {
        "validEmail": "Invalid email address",
        "requiredEmail": "Email is required",
        "requiredPassword": "Password is required"
      },
      "buttons": {
        "submit": "Login",
        "forgotPassword": "Forgot password?",
        "noAccount": "Don’t have an account?",
        "rememberMe": "Remember me"
      }
    },
    "forgotPassword": {
      "title": "Forgot your password?",
      "fields": {
        "email": "Email"
      },
      "errors": {
        "validEmail": "Invalid email address",
        "requiredEmail": "Email is required"
      },
      "buttons": {
        "submit": "Send reset instructions"
      }
    },
    "register": {
      "title": "Sign up for your account",
      "fields": {
        "email": "Email",
        "password": "Password"
      },
      "errors": {
        "validEmail": "Invalid email address",
        "requiredEmail": "Email is required",
        "requiredPassword": "Password is required"
      },
      "buttons": {
        "submit": "Register",
        "haveAccount": "Have an account?"
      }
    },
    "updatePassword": {
      "title": "Update password",
      "fields": {
        "password": "New Password",
        "confirmPassword": "Confirm new password"
      },
      "errors": {
        "confirmPasswordNotMatch": "Passwords do not match",
        "requiredPassword": "Password required",
        "requiredConfirmPassword": "Confirm password is required"
      },
      "buttons": {
        "submit": "Update"
      }
    },
    "error": {
      "info": "You may have forgotten to add the {{action}} component to {{resource}} resource.",
      "404": "Sorry, the page you visited does not exist.",
      "resource404": "Are you sure you have created the {{resource}} resource.",
      "backHome": "Back Home"
    }
  },
  "actions": {
    "list": "List",
    "create": "Create",
    "edit": "Edit",
    "show": "Show"
  },
  "buttons": {
    "create": "Create",
    "save": "Save",
    "logout": "Logout",
    "delete": "Delete",
    "edit": "Edit",
    "cancel": "Cancel",
    "confirm": "Are you sure?",
    "filter": "Filter",
    "clear": "Clear",
    "refresh": "Refresh",
    "show": "Show",
    "undo": "Undo",
    "import": "Import",
    "clone": "Clone",
    "notAccessTitle": "You don't have permission to access"
  },
  "warnWhenUnsavedChanges": "Are you sure you want to leave? You have unsaved changes.",
  "notifications": {
    "success": "Successful",
    "error": "Error (status code: {{statusCode}})",
    "undoable": "You have {{seconds}} seconds to undo",
    "createSuccess": "Successfully created {{resource}}",
    "createError": "There was an error creating {{resource}} (status code: {{statusCode}})",
    "deleteSuccess": "Successfully deleted {{resource}}",
    "deleteError": "Error when deleting {{resource}} (status code: {{statusCode}})",
    "editSuccess": "Successfully edited {{resource}}",
    "editError": "Error when editing {{resource}} (status code: {{statusCode}})",
    "importProgress": "Importing: {{processed}}/{{total}}"
  },
  "loading": "Loading",
  "tags": {
    "clone": "Clone"
  },
  "dashboard": {
    "title": "Dashboard"
  },
  "posts": {
    "posts": "Posts",
    "fields": {
      "id": "Id",
      "title": "Title",
      "category": "Category",
      "status": {
        "title": "Status",
        "published": "Published",
        "draft": "Draft",
        "rejected": "Rejected"
      },
      "content": "Content",
      "createdAt": "Created At"
    },
    "titles": {
      "create": "Create Post",
      "edit": "Edit Post",
      "list": "Posts",
      "show": "Show Post"
    }
  },
  "table": {
    "actions": "Actions"
  },
  "documentTitle": {
    "default": "refine",
    "suffix": " | Refine",
    "post": {
      "list": "Posts | Refine",
      "show": "#{{id}} Show Post | Refine",
      "edit": "#{{id}} Edit Post | Refine",
      "create": "Create new Post | Refine",
      "clone": "#{{id}} Clone Post | Refine"
    }
  },
  "autoSave": {
    "success": "saved",
    "error": "auto save failure",
    "loading": "saving...",
    "idle": "waiting for changes"
  }
}
```

================
File: partials/tutorial/headless-layout.md
================
```css live shared
body {
  margin: 0px;
}

table {
  border-spacing: 0;
  border: 1px solid black;
}

table th,
td {
  margin: 0;
  padding: 0.5rem;
  border-bottom: 1px solid black;
  border-right: 1px solid black;
}

table tr:last-child td {
  border-bottom: 0;
}

table th,
td {
  margin: 0;
  padding: 0.5rem;
  border-bottom: 1px solid black;
  border-right: 1px solid black;
}

table th:last-child,
td:last-child {
  border-right: 0;
}

.layout {
  display: flex;
  gap: 16px;
}

@media screen and (max-width: 751px) {
  .layout {
    display: block;
  }
}

.layout .content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
}

.breadcrumb {
  display: flex;
  gap: 24px;
  list-style-type: "/  ";
  padding: 8px 16px;
  border-bottom: 1px solid lightgray;
}

.breadcrumb a {
  color: blue;
  text-decoration: none;
}

.menu {
  flex-shrink: 0;
  padding: 8px 16px;
  border-right: 1px solid lightgray;
}

.menu a {
  color: black;
}

.menu .active {
  font-weight: bold;
}

@media screen and (max-width: 751px) {
  .menu {
    border-right: none;
    border-bottom: 1px solid lightgray;
  }
}

.menu ul {
  padding-left: 16px;
}
```

```tsx live shared
import { PropsWithChildren } from "react";
import { useMenu, useBreadcrumb } from "@refinedev/core";
import { NavLink, Link } from "react-router";

const Breadcrumb = () => {
  const { breadcrumbs } = useBreadcrumb();

  return (
    <ul className="breadcrumb">
      {breadcrumbs.map((breadcrumb) => (
        <li key={`breadcrumb-${breadcrumb.label}`}>
          {breadcrumb.href ? (
            <Link to={breadcrumb.href}>{breadcrumb.label}</Link>
          ) : (
            <span>{breadcrumb.label}</span>
          )}
        </li>
      ))}
    </ul>
  );
};

const Menu = () => {
  const { menuItems } = useMenu();

  return (
    <nav className="menu">
      <ul>
        {menuItems.map((item) => (
          <li key={item.key}>
            <NavLink to={item.route ?? "/"}>{item.label}</NavLink>
          </li>
        ))}
      </ul>
    </nav>
  );
};

const Layout: React.FC<PropsWithChildren> = ({ children }) => {
  return (
    <div className="layout">
      <Menu />
      <div className="content">
        <Breadcrumb />
        <div>{children}</div>
      </div>
    </div>
  );
};
```

================
File: realtime/hooks/use-publish/index.md
================
---
title: usePublish
source: packages/core/src/hooks/live/usePublish/index.ts
---

`usePublish` returns the [`publish`][live-provider-publish] method from [`liveProvider`][live-provider]. It is useful when you want to publish a custom event.

Refine uses this hook internally in mutation hooks to `publish` events after successful mutations. You can refer to the `liveProvider`'s [Publish Events from Hooks](/docs/realtime/live-provider#publish-events-from-hooks) section for more information.

## Usage

```tsx
import { usePublish } from "@refinedev/core";

const publish = usePublish();

publish({
  channel: "custom-channel-name",
  type: "custom-event-name",
  payload: {
    ids: [1, 2, 3],
    "custom-property": "custom-property-value",
  },
  date: new Date(),
});
```

:::caution

This method is used to publish an event on the client side. Beware that publishing events on the client side is not recommended and the best practice is to publish events from the server side. You can refer [Publish Events from API](/docs/realtime/live-provider#publish-events-from-api) to see which events should be published from the server.

:::

## Publish Properties

`usePublish` will be passed to the [publish][live-provider-publish] method from the [liveProvider][live-provider] as a parameter. Following properties of this method can be used when publishing an event.

> For more information, refer to the [LiveEvent interface&#8594][live-event]

### channel <PropTag required/>

The channel name to publish the event.

### type <PropTag required/>

The event name to publish.

### payload <PropTag required/>

The payload to publish.

### date <PropTag required/>

The date of the event.

[live-provider]: /docs/realtime/live-provider
[live-provider-publish]: /docs/realtime/live-provider#publish
[live-event]: /docs/core/interface-references#liveevent

================
File: realtime/hooks/use-subscription/index.md
================
---
title: useSubscription
source: packages/core/src/hooks/live/useSubscription/index.ts
---

`useSubscription` calls the [`subscribe`][live-provider-subscribe] method from [`liveProvider`][live-provider] when mounted. It is useful when you want to subscribe to a Realtime channel.

Refine uses this hook internally in data hooks to `subscribe` Realtime data. You can refer liveProvider's [Integrated Hooks][integrated-hooks] section for more information.

## Usage

```tsx
import { useSubscription } from "@refinedev/core";

useSubscription({
    channel: "channel-name",
    types: ["event-name", "another-event-name"]
    onLiveEvent: (event) => {},
    dataProviderName: "default",
});

```

### Properties

`useSubscription` will be passed to the [subscribe][live-provider-subscribe] method from the [liveProvider][live-provider] as a parameter. You can use the following properties of this method while subscribing to a channel.

### channel <PropTag required/>

Channel name to subscribe to.

### onLiveEvent <PropTag required/>

Callback that is run when new events from the subscription arrive.

### types

Type of events to subscribe. `"\*"` means all events. By default, it subscribes to all events.

### enabled

You can disable the subscription by setting this prop to `false` and vice versa. By default, it is enabled.

### params

You can pass any additional parameters to the [`liveProvider`][live-provider]'s [`subscribe`][live-provider-subscribe] method.

Hooks that use `useSubscription` internally send the query's parameters' (pagination, meta, sort, filters, etc.) information along with this prop.

> For more information on which hooks use `useSubscription` internally, refer to the [LiveProvider's "Integrated Hooks" section&#8594][integrated-hooks]

### dataProviderName

You can pass the name of the data provider to use for the subscription. By default, it uses the `"default"` data provider.

## API Reference

### Properties

<PropsTable module="@refinedev/core/useSubscription"  />

[live-provider]: /docs/realtime/live-provider
[live-provider-subscribe]: /docs/realtime/live-provider#subscribe
[integrated-hooks]: /docs/realtime/live-provider#integrated-hooks

================
File: realtime/live-provider/index.md
================
---
title: Live Provider
---

**Live Provider** is Refine's built-in provider that enables real-time updates and interactions between the server and the client. Refine being agnostic as always allows you to integrate any solution of your choice

A live provider must include the following methods:

```ts
const liveProvider = {
    subscribe: ({ channel, params: { ids }, types, callback, meta }) => any,
    unsubscribe: (subscription) => void,
    publish?: ({ channel, type, payload, date, meta }) => void,
};
```

## Built-in Integrations

We have the following built-in integrations which you can use out-of-the-box.

Refine includes some out-of-the-box live providers to use in your projects such as:

- **Ably** &#8594 [Source Code](https://github.com/refinedev/refine/blob/main/packages/ably/src/index.ts) - [Demo](https://codesandbox.io/embed/github/refinedev/refine/tree/main/examples/live-provider-ably/?view=preview&theme=dark&codemirror=1)
- **Supabase** &#8594 [Source Code](https://github.com/refinedev/refine/blob/main/packages/supabase/src/index.ts#L187)
- **Appwrite** &#8594 [Source Code](https://github.com/refinedev/refine/blob/main/packages/appwrite/src/index.ts#L252)
- **Hasura** &#8594 [Source Code](https://github.com/refinedev/refine/blob/main/packages/hasura/src/liveProvider/index.ts#L16)

## Live Mode Options

To activate live features in Refine, you need to use the `liveMode` option.

**Global Configuration**: Add liveMode to the options prop of the `<Refine>` component. This sets it up for your entire application, and all hooks will automatically use this by default.

```tsx
<Refine
  liveProvider={liveProvider}
  options={
    // highlight-next-line
    { liveMode: "auto" }
  }
/>
```

**Hook-Specific Configuration**: Alternatively, you can apply liveMode directly to [integrated hooks](#integrated-hooks) individually for more precise control. This is useful if you don't want to apply live mode globally.

```tsx
useList({ liveMode: "auto" });
// or
useOne({ liveMode: "auto" });
```

**Priority Handling**: If you provide `liveMode` in both the `<Refine>` component and hooks, the config in the hook will take priority over the global `<Refine>` configuration.

### auto

Queries of related resources **will be invalidated** and **re-fetched** as new events from subscriptions are published.

For example, `posts` data of `useList` hook will be re-fetched when a new event is published for `posts` resource.

```tsx
const { data } = useList({ resource: "posts", liveMode: "auto" });
```

### manual

In `manual` mode, queries of the related resources **won't be invalidated**. Instead, the `onLiveEvent` function will be called when new events are published from the subscriptions.

`manual` mode can be used to prevent those

```tsx
const { data } = useList({
  liveMode: "manual",
  onLiveEvent: (event) => {
    console.log(event); // { channel: "resources/posts", type: "created", payload: { ids: ["1"] }, date: new Date() }
  },
});
```

### off

Disables live mode entirely.

## onLiveEvent

`onLiveEvent` is called when the new event(s) are published from the subscriptions.

```tsx
const { data } = useList({
  resource: "products",
  liveMode: "manual",
  // Called when new event(s) are published for `products` resource.
  onLiveEvent: (event) => {
    console.log(event); // { channel: "resources/posts", type: "created", payload: { ids: ["1"] }, date: new Date() }
  },
});
```

### With `<Refine>` component

When passed to the `<Refine>` component, `onLiveEvent` will be called for **every event** from any resource. It can be used for actions that are generally applicable to all events from active subscriptions.

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";

import { liveProvider } from "./liveProvider";

const App: React.FC = () => {
  return (
    <Refine
      liveProvider={liveProvider}
      options={{ liveMode: "auto" }}
      onLiveEvent={(event) => {
        // Put your own logic based on event
      }}
    />
  );
};
```

## Integrated Hooks

Following hooks are supported by the **Live Provider** and will subscribe to their resource channels automatically.

### useList

```ts
useList({ resource: "posts" });

// Calls LiveProvider's `subscribe` method with following parameters:
{
    types: ["*"],
    channel: "resources/posts"
}
```

Since the following hooks are derivative of `useList` hook, they will subscribe to the same events.

| Package                | Hooks                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| @refinedev/core        | [useTable](/docs/data/hooks/use-table), [useSelect](/docs/data/hooks/use-select)                                                                                                                                                                                                                                                                                                                                                             |
| @refinedev/antd        | [useTable](/docs/ui-integrations/ant-design/hooks/use-table), [useEditableTable](/docs/ui-integrations/ant-design/hooks/use-editable-table), [useSelect](/docs/ui-integrations/ant-design/hooks/use-select), [useSimpleList](/docs/ui-integrations/ant-design/hooks/use-simple-list), [useCheckboxGroup](/docs/ui-integrations/ant-design/hooks/use-checkbox-group), [useRadioGroup](/docs/ui-integrations/ant-design/hooks/use-radio-group) |
| @refinedev/react-table | [useTable](/docs/packages/list-of-packages)                                                                                                                                                                                                                                                                                                                                                                                                  |
| @refinedev/mui         | [useDataGrid](/docs/ui-integrations/material-ui/hooks/use-data-grid), [useAutoComplete](/docs/ui-integrations/material-ui/hooks/use-auto-complete)                                                                                                                                                                                                                                                                                           |
| @refinedev/mantine     | [useSelect](/docs/ui-integrations/mantine/hooks/use-select)                                                                                                                                                                                                                                                                                                                                                                                  |

### useOne

```ts
useOne({ resource: "posts", id: "1" });


// Calls LiveProvider's `subscribe` method with following parameters:
{
    types: ["*"],
    channel: "resources/posts",
    params: { ids: ["1"] }
}
```

Since the following hooks are derivative of `useOne` hook, they will subscribe to the same events.

| Package            | Hooks                                                                                                                                                                                                                                                                             |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| @refinedev/core    | [useShow](/docs/data/hooks/use-show), [useForm](/docs/data/hooks/use-form/)                                                                                                                                                                                                       |
| @refinedev/antd    | [useForm](/docs/ui-integrations/ant-design/hooks/use-form), [useModalForm](/docs/ui-integrations/ant-design/hooks/use-modal-form), [useDrawerForm](/docs/ui-integrations/ant-design/hooks/use-drawer-form), [useStepsForm](/docs/ui-integrations/ant-design/hooks/use-steps-form) |
| @refinedev/mantine | [useForm](/docs/ui-integrations/mantine/hooks/use-form), [useDrawerForm](/docs/ui-integrations/mantine/hooks/use-drawer-form), [useModalForm](/docs/ui-integrations/mantine/hooks/use-modal-form), [useStepsForm](/docs/ui-integrations/mantine/hooks/use-steps-form)             |

### useMany

```ts
useMany({ resource: "posts", ids: ["1", "2"] });

// Calls LiveProvider's `subscribe` method with following parameters:
{
    types: ["*"],
    channel: "resources/posts"
    params: { ids: ["1", "2"] }
}
```

Since the following hooks are using `useMany` hook, they will subscribe to the same events.

| Package         | Hooks                                    |
| --------------- | ---------------------------------------- |
| @refinedev/core | [useSelect](/docs/data/hooks/use-select) |

## Publish Events from Hooks

Refine publishes these events in the hooks. Let's see the usage of hooks and what kind of events are published:

### useCreate

```ts
const { mutate } = useCreate();

mutate({
  resource: "posts",
  values: {
    title: "New Post",
  },
});

// Calls Live Provider's publish method with following parameters:
{
    channel: `resources/posts`,
    type: "created",
    payload: {
        ids: ["id-of-created-post"]
    },
    date: new Date(),
}
```

### useCreateMany

```ts
const { mutate } = useCreateMany();

mutate({
  resource: "posts",
  values: [
    {
      title: "New Post",
    },
    {
      title: "Another New Post",
    },
  ],
});

// Calls Live Provider's publish method with following parameters:
{
    channel: `resources/posts`,
    type: "created",
    payload: {
        ids: ["id-of-new-post", "id-of-another-new-post"]
    },
    date: new Date(),
}
```

### useDelete

```ts
const { mutate } = useDelete();

mutate({
  resource: "posts",
  id: "1",
});

// Calls Live Provider's publish method with following parameters:
{
    channel: `resources/posts`,
    type: "deleted",
    payload: {
        ids: ["1"]
    },
    date: new Date(),
}
```

### useDeleteMany

```ts
const { mutate } = useDeleteMany();

mutate({
  resource: "posts",
  ids: ["1", "2"],
});

// Calls Live Provider's publish method with following parameters:
{
    channel: `resources/posts`,
    type: "deleted",
    payload: {
        ids: ["1", "2"]
    },
    date: new Date(),
}
```

### useUpdate

```ts
const { mutate } = useUpdate();

mutate({
  resource: "posts",
  id: "2",
  values: { title: "New Post Title" },
});

// Calls Live Provider's publish method with following parameters:
{
    channel: `resources/posts`,
    type: "updated",
    payload: {
        ids: ["1"]
    },
    date: new Date(),
}
```

### useUpdateMany

```ts
const { mutate } = useUpdateMany();

mutate({
  resource: "posts",
  ids: ["1", "2"],
  values: { title: "New Post Title" },
});

// Calls Live Provider's publish method with following parameters:
{
    channel: `resources/posts`,
    type: "updated",
    payload: {
        ids: ["1", "2"]
    },
    date: new Date(),
}
```

## Publishing Events from the Client Side

Publishing on the client side must be avoided generally. It's recommended to handle it on the server side.

Events published from the server must be in the following ways:

- When creating a record:

```ts
{
    channel: `resources/${resource}`,
    type: "created",
    payload: {
        ids: [id]
    },
    date: new Date(),
}
```

- When deleting a record:

```ts
{
    channel: `resources/${resource}`,
    type: "deleted",
    payload: {
        ids: [id]
    },
    date: new Date(),
}
```

- When updating a record:

```ts
{
    channel: `resources/${resource}`,
    type: "updated",
    payload: {
        ids: [id]
    },
    date: new Date(),
}
```

================
File: repomix.config.json
================
{
  "output": {
    "filePath": "C:\\git\\cizzle-app-starters\\repomixes\\refine-docs.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": true,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: routing/components/link/index.md
================
---
title: <Link />
source: packages/core/src/components/link/index.tsx
---

`<Link />` is a component that is used to navigate to different pages in your application.

It uses [`routerProvider.Link`](/docs/routing/router-provider/#link) under the hood, if [`routerProvider`](/docs/routing/router-provider) is not provided, it will be use [`<a>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a) HTML element.

## Usage

```tsx
import { Link } from "@refinedev/core";

const MyComponent = () => {
  return (
    <>
      {/* simple usage, navigates to `/posts` */}
      <Link to="/posts">Posts</Link>
      {/* complex usage with more control, navigates to `/posts` with query filters */}
      <Link
        go={{
          query: {
            // `useTable` or `useDataGrid` automatically uses these filters to fetch data if `syncWithLocation` is true.
            filters: [
              {
                operator: "eq",
                value: "published",
                field: "status",
              },
            ],
          },
          to: {
            resource: "posts",
            action: "list",
          },
        }}
      >
        Posts
      </Link>
    </>
  );
};
```

## Props

The `<Link />` component takes all the props from the [`routerProvider.Link`](/docs/routing/router-provider/#link) and the props that an `<a>` HTML element uses. In addition to these props, it also accepts the `go`
and `to` props to navigate to a specific `resource` defined in the `<Refine />` component.

### go

When `go` prop is provided, this component will use [`useGo`](/docs/routing/hooks/use-go/) to create the URL to navigate to. It's accepts all the props that `useGo.go` accepts.

It's useful to use this prop when you want to navigate to a resource with a specific action.

:::caution

- `routerProvider` is required to use this prop.
- When `to` prop is provided, `go` will be ignored.

:::

### to

The URL to navigate to.

## Type support with generics

`<Link />` works with any routing library because it uses [`routerProvider.Link`](/docs/routing/router-provider/#link) internally. However, when importing it from `@refinedev/core`, it doesn't provide type support for your specific routing library. To enable full type support, you can use generics.

```tsx
import type { LinkProps } from "react-router";
import { Link } from "@refinedev/core";

const MyComponent = () => {
  return (
    // Omit 'to' prop from LinkProps (required by react-router) since we use the 'go' prop
    <Link<Omit<LinkProps, "to">>
      // Props from "react-router"
      // highlight-start
      replace={true}
      unstable_viewTransition={true}
      preventScrollReset={true}
      // highlight-end
      // Props from "@refinedev/core"
      go={{
        to: {
          resource: "posts",
          action: "list",
        },
      }}
    >
      Posts
    </Link>
  );
};
```

================
File: routing/hooks/use-back/index.md
================
---
title: useBack
---

`useBack` is a hook that leverages the `back` method of the [`routerProvider`][routerprovider] to perform the "go back" operation in the history stack.

## Usage

```tsx
import { useBack } from "@refinedev/core";

const MyComponent = () => {
  const back = useBack();

  return <Button onClick={() => back()}>Go Back</Button>;
};
```

[routerprovider]: /docs/routing/router-provider

================
File: routing/hooks/use-get-to-path/index.md
================
---
title: useGetToPath
---

`useGetToPath` is a hook that returns a function that composes the URL for the given `resource` and the `action` by using the URL parameters and the `meta` property if provided.

This is useful when you want to navigate to a specific action of a resource and you want to have the URL to be composed automatically.

## Usage

```tsx
import { useGetToPath, useGo } from "@refinedev/core";

// Let's assume that we have a resource named `posts` and the `edit` action path is `/:authorId/posts/:id/edit`

const MyComponent = () => {
  const getToPath = useGetToPath();

  const go = useGo();

  return (
    <Button
      onClick={() => {
        go({
          to: getToPath({
            resource: "posts",
            action: "edit",
            meta: {
              id: 1,
              authorId: 2,
            },
          }),
        });
      }}
    >
      Go To Edit Post
    </Button>
  );

  /* ... */
};
```

:::tip

The `authorId` and `id` parameters will be inferred from the route if they are present in the URL. If you want to explicitly set the value of a parameter, you can use the `meta` property.

:::

## Parameters

### resource

This is the name of the resource that you want to navigate to.

### action

This is the name of the action that you want to navigate to.

### meta

This is the meta object that you want to use to compose the URL. It will be merged with the `params` object that is parsed from the URL.

### legacy

This is a boolean value that indicates whether the legacy URL format should be used or not. If it is set to `true`, the URL will be composed for the legacy routers. Default value is `false`.

================
File: routing/hooks/use-go/index.md
================
---
title: useGo
---

`useGo` is a hook that leverages the `go` method of the [`routerProvider`][routerprovider] to perform navigation operations.

## Usage

### With path

```tsx
import { useGo } from "@refinedev/core";

const MyComponent = () => {
  const go = useGo();

  return (
    <Button
      onClick={() => {
        go({
          to: "/posts",
          query: {
            filters: [
              {
                field: "title",
                operator: "contains",
                value: "Refine",
              },
            ],
          },
          type: "push",
        });
      }}
    >
      Go Posts With Default Filters
    </Button>
  );
};
```

### With resource

`to` accepts an object with the following shape to navigate to a resource:

```tsx
type ToWithResource = {
  resource: string; // resource name or identifier
  id?: BaseKey; // required when `action` is `"edit"`, `"show"`, or `"clone"`.
  action: "list" | "create" | "edit" | "show" | "clone"; // action name
  meta?: Record<string, unknown>; // meta data to be used when composing the path (use if you have additional path parameters)
};
```

`useGo` will convert the resource object into the path defined in the resources array within the `<Refine />` component.

```tsx
import { useGo } from "@refinedev/core";

const MyComponent = () => {
    const go = useGo();

    return (
        <Button
            onClick={() => {
                go({
                    to:  {
                        resource: "posts", // resource name or identifier
                        action: "edit",
                        id: "1",
                    }
                    query: {
                         foo: "bar",
                    },
                    type: "push",
                });
            }}
        >
            Go Posts With Default Filters
        </Button>
    );
};
```

## Parameters

### to

The `to` parameter is the path you want to navigate to. If left empty, it will navigate to the current path, which is useful for updating the query parameters.

Also, you can pass a `resource` object to the `to` parameter. The `routerProvider` will convert the resource object to the path.

### query

The `query` parameter is the query parameters you want to add to the path. It is an object which the `routerProvider` will convert to the query string.

### type

The `type` parameter is the type of navigation you want to perform. It can be one of the following:

- `push`: It adds a new entry to the history stack.
- `replace`: It replaces the current entry on the history stack.
- `path`: Returns the navigation path for the given config. Doesn't mutate the history stack.

### hash

The `hash` parameter is the hash you want to add to the path.

### options.keepQuery

The `options.keepQuery` parameter is a boolean that determines whether the current query parameters should be kept or not. If it is `true`, the current query parameters will be merged with the new query parameters. If it is `false`, the current query parameters will be ignored.

### options.keepHash

The `options.keepHash` parameter is a boolean that determines whether the current hash should be kept or not. If it is `true`, the current hash will be kept in the URL. If it is `false`, the current hash will be ignored.

## Return Value

`useGo` does not return any value except for the `path` type, which returns the navigation path for the given config without mutating the history stack.

[routerprovider]: /docs/routing/router-provider
[basekey]: /docs/core/interface-references#basekey

================
File: routing/hooks/use-link/index.md
================
---
title: useLink
---

`useLink` is a hook that returns [`<Link />`](/docs/routing/components/link/) component. It is used to navigate to different pages in your application.

:::simple Good to know

- It's recommended to use the `<Link />` component from the `@refinedev/core` package instead of this hook. This hook is used mostly for internal purposes and is only exposed for customization needs.

:::

## Usage

```tsx
import { useLink } from "@refinedev/core";

const MyComponent = () => {
  const Link = useLink();

  return (
    <>
      <Link to="/posts">Posts</Link>
      {/* or */}
      <Link
        go={{
          to: {
            resource: "posts",
            action: "list",
          },
        }}
      >
        Posts
      </Link>
    </>
  );
};
```

================
File: routing/hooks/use-navigation/index.md
================
---
title: useNavigation
---

`useNavigation` is a hook that provides methods to navigate the app. Internally, it uses the `go` method of the [`routerProvider`][routerprovider].

This hook is a legacy hook and is not recommended, despite not being deprecated. You should use your router libraries' hooks and methods instead when dealing with the custom navigations.

If you're in need of a navigation hook to use to navigate between your actions and resources, we recommend using the [`useGo`](/docs/routing/hooks/use-go) and [`useGetToPath`](/docs/routing/hooks/use-get-to-path) hooks.

```tsx
import { useNavigation } from "@refinedev/core";

const {
  list,
  create,
  edit,
  show,
  clone,
  push,
  replace,
  goBack,
  listUrl,
  createUrl,
  editUrl,
  showUrl,
  cloneUrl,
} = useNavigation();
```

## Return Values

All functions the `useNavigation` hook returns, except `push`, `replace` and `goBack`, accept a `meta` parameter. This is an optional parameter that can be used to pass additional parameters to the routes if they contain multiple parameters other than `id`.

### list

This method navigates to the list page of the given resource.

```tsx
import { useNavigation } from "@refinedev/core";

const { list } = useNavigation();

list("posts"); // It navigates to the `/posts` page
```

You can also give a `type` property as a second parameter to the `list` method.

### create

This method navigates to the create page of the given resource.

```tsx
import { useNavigation } from "@refinedev/core";

const { create } = useNavigation();

create("posts"); // It navigates to the `/posts/create` page
```

You can also give a `type` property as a second parameter to the `create` method.

### edit

This method navigates to the edit page of the given `resource` and `id`. When you use this method, you need to give it the `id` of the record you want to edit.

```tsx
import { useNavigation } from "@refinedev/core";

const { edit } = useNavigation();

edit("posts", "1"); // It navigates to the `/posts/edit/1` page
```

You can also give a `type` property as a third parameter to the `edit` method.

### show

This method navigates to the show page of the given `resource` and `id`. When you use this method, you need to give the `id` of the record you want to show.

```tsx
import { useNavigation } from "@refinedev/core";

const { show } = useNavigation();

show("posts", "1"); // It navigates to the `/posts/show/1` page
```

You can also give a `type` property as a third parameter to the `show` method.

### clone

This method navigates to the clone page of the given `resource` and `id`. When you use this method, you need to give the `id` of the record you want to clone.

```tsx
import { useNavigation } from "@refinedev/core";

const { clone } = useNavigation();

clone("posts", "1"); // It navigates to the `/posts/clone/1` page
```

You can also give a `type` property as a third parameter to the `clone` method.

### push

This method pushes a new entry onto the history stack. It uses the `push` method of the `useHistory` from the [`routerProvider`][routerprovider].

```tsx
import { useNavigation } from "@refinedev/core";

const { push } = useNavigation();

push("custom-page"); // It navigates to the `/custom-page` page
```

`push` method parameters are dependent on your router provider.

### replace

This method replaces the current entry on the history stack. It uses the `replace` method of the `useHistory` from the [`routerProvider`][routerprovider].

```tsx
import { useNavigation } from "@refinedev/core";

const { replace } = useNavigation();

replace("custom-page"); // It navigates to the `/custom-page` page
```

`replace` method parameters are dependent on your router provider.

### goBack

This method navigates to the previous page. It uses the `goBack` method of the `useHistory` from the [`routerProvider`][routerprovider].

```tsx
import { useNavigation } from "@refinedev/core";

const { goBack } = useNavigation();

goBack(); // It navigates to the previous page
```

`goBack` method parameters are dependent on your router provider.

### listUrl

This method returns the list page URL of the given resource.

```tsx
import { useNavigation } from "@refinedev/core";

const { listUrl } = useNavigation();

listUrl("posts"); // It returns the `/posts` URL
```

### createUrl

This method returns the create page URL of the given resource.

```tsx
import { useNavigation } from "@refinedev/core";

const { createUrl } = useNavigation();

createUrl("posts"); // It returns the `/posts/create` URL
```

### editUrl

This method returns the edit page URL of the given resource and id.

```tsx
import { useNavigation } from "@refinedev/core";

const { editUrl } = useNavigation();

editUrl("posts", "1"); // It returns the `/posts/edit/1` URL
```

### showUrl

This method returns the show page URL of the given resource and id.

```tsx
import { useNavigation } from "@refinedev/core";

const { showUrl } = useNavigation();

showUrl("posts", "1"); // It returns the `/posts/show/1` URL
```

### cloneUrl

This method returns the clone page URL of the given resource and id.

```tsx
import { useNavigation } from "@refinedev/core";

const { cloneUrl } = useNavigation();

cloneUrl("posts", "1"); // It returns the `/posts/clone/1` URL
```

## API Reference

### Return values

| Property  | Description                                                 | Type                                                                                     |
| --------- | ----------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| list      | Method that navigates to the list page                      | `(resource: string, type: HistoryType, meta?: Record<string, any>) => void`              |
| create    | Method that navigates to the create page                    | `(resource: string, type: HistoryType, meta?: Record<string, any>) => void`              |
| edit      | Method that navigates to the edit page                      | `(resource: string, id: BaseKey, type: HistoryType, meta?: Record<string, any>) => void` |
| show      | Method that navigates to the show page                      | `(resource: string, id: BaseKey, type: HistoryType, meta?: Record<string, any>) => void` |
| clone     | Method that navigates to the clone page                     | `(resource: string, id: BaseKey, type: HistoryType, meta?: Record<string, any>) => void` |
| push      | Method that pushes the given path to the history stack      | `(path: string, ...rest: unknown[]) => void`                                             |
| replace   | Method that replaces the current entry on the history stack | `(path: string, ...rest: unknown[]) => void`                                             |
| goBack    | Method that navigates to the previous page                  | `() => void`                                                                             |
| listUrl   | Method that returns the list page URL                       | `(resource: string, meta?: Record<string, any>) => string`                               |
| createUrl | Method that returns the create page URL                     | `(resource: string, meta?: Record<string, any>) => string`                               |
| editUrl   | Method that returns the edit page URL                       | `(resource: string, id: BaseKey, meta?: Record<string, any>) => string`                  |
| showUrl   | Method that returns the show page URL                       | `(resource: string, id: BaseKey, meta?: Record<string, any>) => string`                  |
| cloneUrl  | Method that returns the clone page URL                      | `(resource: string, id: BaseKey, meta?: Record<string, any>) => string`                  |

#### Interfaces

- [`type BaseKey`][basekey]
- `type HistoryType = "push" | "replace";`

[routerprovider]: /docs/routing/router-provider
[basekey]: /docs/core/interface-references#basekey

================
File: routing/hooks/use-parsed/index.md
================
---
title: useParsed
---

`useParsed` is a hook that leverages the `parse` method of the [`routerProvider`][routerprovider] to access the URL and query parameters along with the inferred `resource`, `action` and `id` from the URL.

## Usage

```tsx
import { useParsed } from "@refinedev/core";

type MyParams = {
  someParam: string;
};

const MyComponent = () => {
  const {
    resource,
    action,
    id,
    pathname,
    params: {
      filters,
      sorters,
      current,
      pageSize,
      ...restParams // TParams - Any other parameters are also parsed and available in `params`
    },
  } = useParsed<MyParams>();

  /* ... */
};
```

## Return Values

### resource

This is the active resource that is matched by the current route and the action definitions in the `resources` array of the `Refine` component. It will be `undefined` if there is no match.

### action

This is the active action that is matched by the current route and the action definitions in the `resources` array of the `Refine` component. It will be `undefined` if there is no match.

### id

This is the main parameter used by the Refine in API interactions. It will also be available in the `params` object but it is also available as a separate value for convenience. It will be `undefined` if there is no `id` parameter in the URL.

### pathname

This is the current pathname of the URL.

### params.filters

This is the filters that are parsed from the URL. It will be `undefined` if there is no `filters` parameter in the URL. This property is used in the `syncWithLocation` feature of the `useTable`.

### params.sorters

This is the sorters that are parsed from the URL. It will be `undefined` if there is no `sorters` parameter in the URL. This property is used in the `syncWithLocation` feature of the `useTable`.

### params.current

This is the current page that is parsed from the URL. It will be `undefined` if there is no `current` parameter in the URL. This property is used in the `syncWithLocation` feature of the `useTable`.

### params.pageSize

This is the page size that is parsed from the URL. It will be `undefined` if there is no `pageSize` parameter in the URL. This property is used in the `syncWithLocation` feature of the `useTable`.

### params

This is the object that contains all the parameters that are parsed from the URL. It will be an empty object if there is no parameter in the URL. `params` object contains both the URL parameters and the query parameters.

[routerprovider]: /docs/routing/router-provider

================
File: routing/hooks/use-resource-params/index.md
================
---
title: useResourceParams
source: packages/core/src/hooks/use-resource-params
---

`useResourceParams` is used to get the related parameters of the current resource such as `resource`, `id` and `action`. It also provides `formAction` to determine the action of the form and `setId` to set the `id` programmatically without having to use a separate state for it.

## Usage

```tsx
const {
  id?, // ID of the record
  setId, // Function to set the ID
  resource?, // Resource object
  action?, // Passed action or inferred from the route
  identifier?, // Identifier value of the resource
  formAction?, // Form action derived from the action
} = useResourceParams({
  id?, // ID to set explicitly. Inferred from the route if not provided
  action?, // Action to set explicitly. Inferred from the route if not provided
  resource?, // Resource object to set explicitly. Inferred from the route if not provided
});
```

### Inferring the `id` from the route

When the `id` is not explicitly passed, it can be inferred from the route. Inference from the route is only possible under certain conditions:

- If there's no explicitly set `resource` value.
- If there's an explicitly set `resource` value and it's the same as the current route.

This check is necessary to prevent the `id` from being inferred from a different resource.

If there's no explicit `id` value, no `id` from the route or there's a mismatch between the `resource` and the route, the `id` will be set to `undefined`.

### Inferring the `formAction` from the route

The `formAction` is inferred from the `action` value.

- If the `action` is a valid form action (`create`, `edit` or `clone`), the `formAction` will be set to the `action`.
- Otherwise, the `formAction` will be set to `create`.

This is done to provide a more convenient way to determine the action of the form.

## Return Values

### resource

The `resource` object.

### identifier

Identifier value for the current resource, this can either be the `identifier` property or the `name` property of the resource.

### id

`id` parameter to be used in the actions.

### setId

Function to set the `id` programmatically.

### action

Current action to be performed. This can be explicitly passed via the `action` parameter or inferred from the route.

### formAction

Apart from the `action` value, `formAction` can only be `create`, `edit` or `clone`. If the `action` is not one of these, `formAction` will be set to `create` for convenience.

## API Reference

### Properties

<PropsTable module="@refinedev/core/useResourceParams"  />

### Return value

| Description | Type                                                                       |
| ----------- | -------------------------------------------------------------------------- |
| resource    | `IResourceItem` \| `undefined`                                             |
| identifier  | `string` \| `undefined`                                                    |
| id          | [`BaseKey` \| `undefined`](/docs/core/interface-references#basekey)        |
| setId       | `(id: BaseKey) => void`                                                    |
| action      | `undefined` \| `"list"` \| `"create"` \| `"edit"` \| `"show"` \| `"clone"` |
| formAction  | `"create"` \| `"edit"` \| `"clone"`                                        |

================
File: routing/hooks/use-resource/index.md
================
---
title: useResource
---

`useResource` is used to get the resources array that you defined in `<Refine>`. It also returns the `resource` object. You can pass a resource name or identifier to match a resource or it will return the resource object that matches the current route.

If you pass a resource name or identifier to `useResource`, it will return the `resource` object that matches the name or identifier. If there is no match, a temporary `resource` will be created with the provided name or identifier.

## Usage

### Without parameters

If you don't pass any parameter to `useResource`, it will return the resource object that matches the current route by default. If there is no match, the `resource` will be `undefined`.

```ts
import { useResource } from "@refinedev/core";

const { resources, resource, action, id } = useResource();
```

### With a resource name or identifier

If you pass a resource name or identifier to `useResource`, it will return the resource object that matches the name or identifier. If there is no match, a temporary `resource` will be created with the provided name or identifier.

```ts
import { useResource } from "@refinedev/core";

const { resource } = useResource("posts");
```

## Return Values

### resources

An array of resources that you defined in `<Refine>`.

### resource

The `resource` object.

### resourceName

Resource name of the `resource` object.

### ~~id~~ <PropTag deprecated />

> Use [`useResourceParams`](/docs/routing/hooks/use-resource-params) instead.

`id` parameter of the current route.

### ~~action~~ <PropTag deprecated />

> Use [`useResourceParams`](/docs/routing/hooks/use-resource-params) instead.

`action` from the current route if there is a match.

### select

The function allows you to retrieve a `resource` object and matched `identifier` by providing either a resource `name` or `identifier`. By default, if there is no match for the given `name` or `identifier`, the function will return the `resource` object and `identifier` associated with the provided value.

If you don't pass any parameter to `useResource`, it will try to infer the `resource` from the current route. If there is no match, the `resource` and `identifier` will be `undefined`.

The function also accepts a second parameter `force` which is `true` by default. If you set it to `false`, it will not return a `resource` object and `identifier` if there is no match.

### identifier

Identifier value for the current resource, this can either be the `identifier` property or the `name` property of the resource.

## API Reference

### Properties

<PropsTable module="@refinedev/core/useResource"  />

### Return value

| Description  | Type                                                                                                                      |
| ------------ | ------------------------------------------------------------------------------------------------------------------------- |
| resources    | [`IResourceItem[]`](#interfaces)                                                                                          |
| resource     | [`IResourceItem` \| `undefined`](#interfaces)                                                                             |
| resourceName | `string` \| `undefined`                                                                                                   |
| id           | [`BaseKey`](/docs/core/interface-references#basekey)                                                                      |
| action       | `undefined` \| `"list"` \| `"create"` \| `"edit"` \| `"show"` \| `"clone"`                                                |
| select       | `(resourceName: string, force?: boolean) => { resource: IResourceItem` \| `undefined, identifier: string` \| `undefined}` |
| identifier   | `string` \| `undefined`                                                                                                   |

#### Interfaces

```ts
interface IResourceComponents {
  list?:
    | string
    | React.ComponentType<any>
    | { component: React.ComponentType<any>; path: string };
  create?:
    | string
    | React.ComponentType<any>
    | { component: React.ComponentType<any>; path: string };
  edit?:
    | string
    | React.ComponentType<any>
    | { component: React.ComponentType<any>; path: string };
  show?:
    | string
    | React.ComponentType<any>
    | { component: React.ComponentType<any>; path: string };
}

interface IResourceItem extends IResourceComponents {
  name: string;
  identifier?: string;
  meta?: MetaProps;
}
```

================
File: routing/integrations/react-router/index.md
================
---
title: React Router
---

Refine provides router bindings and utilities for [React Router](https://reactrouter.com/). It is built on top of the `react-router` package. This package will provide easy integration between Refine and **react-router** for both existing projects and new projects.

<InstallPackagesCommand args="@refinedev/react-router react-router"/>

We recommend using `create refine-app` to initialize your Refine projects. It gives you a good boilerplate to start with using React Router.

<CreateRefineAppCommand args="-p refine-react my-refine-app" />

[Refer to the Router Provider documentation for detailed information. &#8594][routerprovider]

## Usage

`@refinedev/react-router` is not restricting you to use the router in a specific way and it is up to you to decide how you want to use it.

You can define your routes the way you want, then pass the `routerProvider` prop to the `Refine` component and use the `resources` prop to define the resources and their action paths. From basic to advanced use cases and enterprise applications, you will have full control over your routes. In our examples, we've used this approach to demonstrate the flexibility of the router provider and the route handling process.

### Basic Usage

We'll pass the `routerProvider` prop to the `Refine` component to instruct Refine on how to communicate with the router. We'll also define our resources and their action paths, this will inform Refine to use these paths when generating the breadcrumbs, menus, handling redirections and inferring the current resource and action.

<Tabs
defaultValue="browser-router"
values={[
{label: 'Using <BrowserRouter>', value: 'browser-router'},
{label: 'Using <RouterProvider>', value: 'router-provider'},
]}>
<TabItem value="browser-router">

This example uses the [`<BrowserRouter>`](https://reactrouter.com/en/main/router-components/browser-router) router component.

```tsx title=App.tsx
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
// highlight-start
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route } from "react-router";
// highlight-end

import { PostList, PostCreate } from "pages/posts";
import { CategoryList, CategoryShow } from "pages/categories";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider}
        // highlight-next-line
        routerProvider={routerProvider}
        resources={[
          {
            name: "posts",
            // highlight-start
            list: "/posts",
            create: "/posts/create",
            // highlight-end
          },
          {
            name: "categories",
            // highlight-start
            list: "/categories",
            show: "/categories/show/:id",
            // highlight-end
          },
        ]}
      >
        <Routes>
          {/* highlight-start */}
          <Route path="posts">
            <Route index element={<PostList />} />
            <Route path="create" element={<PostCreate />} />
          </Route>
          <Route path="categories">
            <Route index element={<CategoryList />} />
            <Route path="show/:id" element={<CategoryShow />} />
          </Route>
          {/* highlight-end */}
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
```

</TabItem>
<TabItem value="router-provider">

In their v6.4, React Router introduced Data APIs Router. It uses [`<RouterProvider>`](https://reactrouter.com/en/main/routers/router-provider) component coupled with a [`createBrowserRouter()`](https://reactrouter.com/en/main/routers/create-browser-router) function that live outside the DOM.

The example below start from the `<BrowserRouter>` example and follow their [migration guide](https://reactrouter.com/en/main/upgrading/v6-data) to the `<RouterProvider>` component.

:::caution Use cases

While the basic usage of routing works out of the box, more advanced use cases of the Data APIs are not tested.

You are welcome to [contribute][contributing] to help test and support the advanced use cases of the Data APIs.

:::

```tsx title=App.tsx
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";
import { createBrowserRouter, RouterProvider, Outlet } from "react-router";

import { PostList, PostCreate } from "pages/posts";
import { CategoryList, CategoryShow } from "pages/categories";

const router = createBrowserRouter([
  {
    Component: RefineProvider,
    children: [
      // highlight-start
      {
        path: "posts",
        children: [
          { index: true, Component: PostList },
          { path: "create", Component: PostCreate },
        ],
      },
      {
        path: "categories",
        children: [
          { index: true, Component: CategoryList },
          { path: "show/:id", Component: CategoryShow },
        ],
      },
      // highlight-end
    ],
  },
]);

const App = () => {
  /* highlight-next-line */
  return <RouterProvider router={router} />;
};

const RefineProvider = () => {
  return (
    <Refine
      dataProvider={dataProvider}
      // highlight-next-line
      routerProvider={routerProvider}
      resources={[
        {
          name: "posts",
          // highlight-start
          list: "/posts",
          create: "/posts/create",
          // highlight-end
        },
        {
          name: "categories",
          // highlight-start
          list: "/categories",
          show: "/categories/show/:id",
          // highlight-end
        },
      ]}
    >
      <Outlet />
    </Refine>
  );
};
```

</TabItem>
</Tabs>

### Usage with Authentication

When handling authenticated routes, we can use [`<Authenticated>`](/docs/authentication/components/authenticated) to check if the user is authenticated or not. Internally, it uses the `useIsAuthenticated` hook and handles the redirection or showing the appropriate elements based on the authentication status by the `children` and `fallback` props.

Additionally, we'll use the [`<Outlet>`](https://reactrouter.com/en/main/components/outlet) component from `react-router` to render our routes inside the `<Authenticated>` component. This will allow us to create protected routes and render the routes only when the user is authenticated.

We will also need to create a `/login` route to handle the redirection when the user is not authenticated. We can use the `AuthPage` components from Refine's UI packages with `type="login"` prop to render the login page.

```tsx title=App.tsx
// highlight-next-line
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";
// highlight-next-line
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

// highlight-next-line
import { authProvider } from "src/authProvider";

// highlight-next-line
import { AuthPage } from "@refinedev/antd";

import { PostList, PostCreate } from "pages/posts";
import { CategoryList, CategoryShow } from "pages/categories";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider}
        routerProvider={routerProvider}
        // highlight-next-line
        authProvider={authProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
            create: "/posts/create",
          },
          {
            name: "categories",
            list: "/categories",
            show: "/categories/show/:id",
          },
        ]}
      >
        <Routes>
          <Route
            // highlight-start
            element={
              <Authenticated fallback={<Outlet />}>
                <NavigateToResource resource="posts" />
              </Authenticated>
            }
            // highlight-end
          >
            {/* highlight-next-line */}
            <Route path="/login" element={<AuthPage type="login" />} />
          </Route>
          <Route
            // highlight-start
            element={
              <Authenticated redirectOnFail="/login">
                <Outlet />
              </Authenticated>
            }
            // highlight-end
          >
            <Route path="posts">
              <Route index element={<PostList />} />
              <Route path="create" element={<PostCreate />} />
            </Route>
            <Route path="categories">
              <Route index element={<CategoryList />} />
              <Route path="show/:id" element={<CategoryShow />} />
            </Route>
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
```

Notice that we've used the `fallback` property to render the `<Outlet>` component inside the wrapper `Route` of the `/login` page. This allows us to render the login page when the user is not authenticated and redirect the user to the `/posts` page when the user is authenticated.

We've also used the `<Outlet>` component inside the children of the `<Authenticated>` component in the wrapper `Route` of the resource routes. This will allow us to render the resource routes only when the user is authenticated and redirect the user to the `/login` page when the user is not authenticated.

### Usage with Layouts

When using layouts in your application, you can use the same approach as the authentication example. We'll use the [`<ThemedLayoutV2>`](/docs/advanced-tutorials/custom-layout/#layout) component to wrap our routes and the [`<Outlet>`](https://reactrouter.com/en/main/components/outlet) component from `react-router` to render our routes inside the `<ThemedLayoutV2>` component. This will allow us to define the common layout for our routes.

In the below example, we'll wrap our resource routes with the `Layout` component from `@refinedev/antd` and render the routes inside the `<Outlet>` component.

```tsx title=App.tsx
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "src/authProvider";

// highlight-next-line
import { AuthPage, ThemedLayoutV2 } from "@refinedev/antd";

import { PostList, PostCreate } from "pages/posts";
import { CategoryList, CategoryShow } from "pages/categories";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider}
        routerProvider={routerProvider}
        authProvider={authProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
            create: "/posts/create",
          },
          {
            name: "categories",
            list: "/categories",
            show: "/categories/show/:id",
          },
        ]}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<Outlet />}>
                <NavigateToResource resource="posts" />
              </Authenticated>
            }
          >
            <Route path="/login" element={<AuthPage type="login" />} />
          </Route>
          <Route
            element={
              <Authenticated redirectOnFail="/login">
                {/* highlight-start */}
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
                {/* highlight-end */}
              </Authenticated>
            }
          >
            <Route path="posts">
              <Route index element={<PostList />} />
              <Route path="create" element={<PostCreate />} />
            </Route>
            <Route path="categories">
              <Route index element={<CategoryList />} />
              <Route path="show/:id" element={<CategoryShow />} />
            </Route>
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
```

Notice that we've wrapped the `<Outlet>` with `<ThemedLayoutV2>` component. This way, we don't need to define the layout for each route and wrap the each route inside it with the `<ThemedLayoutV2>` component.

### Usage with Access Control providers

If you want to protect your routes with [Access Control Provider](/docs/authorization/access-control-provider), all you have to do is to wrap `Outlet` with `CanAccess` component.

`CanAccess` component will infer resource name and action based on the current route and handle the **access control** from your Access Control Provider for you.

```tsx title=App.tsx
// highlight-next-line
import { Refine, Authenticated, CanAccess } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "src/authProvider";

import { AuthPage, ThemedLayoutV2 } from "@refinedev/antd";

import { PostList, PostCreate } from "pages/posts";
import { CategoryList, CategoryShow } from "pages/categories";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider}
        routerProvider={routerProvider}
        authProvider={authProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
            create: "/posts/create",
          },
          {
            name: "categories",
            list: "/categories",
            show: "/categories/show/:id",
          },
        ]}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<Outlet />}>
                <NavigateToResource resource="posts" />
              </Authenticated>
            }
          >
            <Route path="/login" element={<AuthPage type="login" />} />
          </Route>
          <Route
            element={
              <Authenticated redirectOnFail="/login">
                <ThemedLayoutV2>
                  {/* highlight-start */}
                  <CanAccess fallback={<div>Unauthorized!</div>}>
                    <Outlet />
                  </CanAccess>
                  {/* highlight-end */}
                </ThemedLayoutV2>
              </Authenticated>
            }
          >
            <Route path="posts">
              <Route index element={<PostList />} />
              <Route path="create" element={<PostCreate />} />
            </Route>
            <Route path="categories">
              <Route index element={<CategoryList />} />
              <Route path="show/:id" element={<CategoryShow />} />
            </Route>
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
```

If you don't want to wrap your whole application with `CanAccess`, it's also possible to wrap certain routes individually.

```tsx title=App.tsx
<Routes>
  <Route
    element={
      <Authenticated fallback={<Outlet />}>
        <NavigateToResource resource="posts" />
      </Authenticated>
    }
  >
    <Route path="/login" element={<AuthPage type="login" />} />
  </Route>
  <Route
    element={
      <Authenticated redirectOnFail="/login">
        <ThemedLayoutV2>
          <Outlet />
        </ThemedLayoutV2>
      </Authenticated>
    }
  >
    <Route path="posts">
      <Route index element={<PostList />} />
      <Route
        path="create"
        element={
          // highlight-start
          <CanAccess fallback={<div>Unauthorized!</div>}>
            <PostCreate />
          </CanAccess>
          // highlight-end
        }
      />
    </Route>
    <Route path="categories">
      <Route index element={<CategoryList />} />
      <Route path="show/:id" element={<CategoryShow />} />
    </Route>
  </Route>
</Routes>
```

### Usage with an Error Page

You may also want to render an error page when the user tries to access a route that doesn't exist. To do this, we'll define a `*` route that will render the error page when there's no other route that matches the current path.

We'll place this inside the authenticated routes so that the unauthorized users will be redirected to the login page when they try to access a route that doesn't exist.

```tsx title=App.tsx
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "src/authProvider";

// highlight-next-line
import { AuthPage, ThemedLayoutV2, ErrorComponent } from "@refinedev/antd";

import { PostList, PostCreate } from "pages/posts";
import { CategoryList, CategoryShow } from "pages/categories";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider}
        routerProvider={routerProvider}
        authProvider={authProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
            create: "/posts/create",
          },
          {
            name: "categories",
            list: "/categories",
            show: "/categories/show/:id",
          },
        ]}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<Outlet />}>
                <NavigateToResource resource="posts" />
              </Authenticated>
            }
          >
            <Route path="/login" element={<AuthPage type="login" />} />
          </Route>
          <Route
            element={
              <Authenticated redirectOnFail="/login">
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              </Authenticated>
            }
          >
            <Route path="posts">
              <Route index element={<PostList />} />
              <Route path="create" element={<PostCreate />} />
            </Route>
            <Route path="categories">
              <Route index element={<CategoryList />} />
              <Route path="show/:id" element={<CategoryShow />} />
            </Route>
            {/* highlight-next-line */}
            <Route path="*" element={<ErrorComponent />} />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
```

### Usage with a Root Route

You may notice that we didn't define an index route for our application yet. We can defina a root route that will redirect the user to the `posts` resource when they visit the root of our application.

We can achieve this by using the [`<NavigateToResource>`](#navigatetoresource) component. This component will redirect the user to the `list` page of the given resource.

We also want this route to be rendered only when the user is authenticated. We can achieve this by placing our `Route` inside the authenticated routes.

```tsx title=App.tsx
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
// highlight-next-line
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "src/authProvider";

import { AuthPage, ThemedLayoutV2, ErrorComponent } from "@refinedev/antd";

import { PostList, PostCreate } from "pages/posts";
import { CategoryList, CategoryShow } from "pages/categories";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider}
        routerProvider={routerProvider}
        authProvider={authProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
            create: "/posts/create",
          },
          {
            name: "categories",
            list: "/categories",
            show: "/categories/show/:id",
          },
        ]}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<Outlet />}>
                <NavigateToResource resource="posts" />
              </Authenticated>
            }
          >
            <Route path="/login" element={<AuthPage type="login" />} />
          </Route>
          <Route
            element={
              <Authenticated redirectOnFail="/login">
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              </Authenticated>
            }
          >
            {/* highlight-next-line */}
            <Route index element={<NavigateToResource resource="posts" />} />
            <Route path="posts">
              <Route index element={<PostList />} />
              <Route path="create" element={<PostCreate />} />
            </Route>
            <Route path="categories">
              <Route index element={<CategoryList />} />
              <Route path="show/:id" element={<CategoryShow />} />
            </Route>
            <Route path="*" element={<ErrorComponent />} />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
```

Your action definitions in the resources can contain additional parameters and nested routes. Passing these parameters when navigating to the pages are handled by the current available parameters and the `meta` props of the related hooks and components.

Refine supports route parameters defined with `:param` syntax. You can use these parameters in your action definitions and create your routes accordingly. For example, if you have a `posts` resource and you want to create a route for the `show` action of a specific post, you can define the `show` action as `/posts/show/:id` and use the `id` parameter in your component.

## Additional Components

`@refinedev/react-router` package also includes some additional components that can be useful in some cases.

### NavigateToResource

A basic component that extends the `Navigate` component from **react-router** to navigate to a resource page. It is useful when you want to navigate to a resource page at the index route of your app.

```tsx

const App = () => {
    return (
        <BrowserRouter>
            <Refine
                /* ... */
                resources={[
                    {
                        name: "posts"
                        list: "/posts",
                    },
                ]}
            >
                <Routes>
                    {/* highlight-next-line */}
                    <Route path="/" element={<NavigateToResource resource="posts" />} />
                    <Route path="/posts" element={<PostList />} />
                </Routes>
            </Refine>
        </BrowserRouter>
    )
}

```

#### Properties

`resource` (optional) - The name of the resource to navigate to. It will redirect to the first `list` route in the `resources` array if not provided.

`meta` (optional) - The meta object to use if the route has parameters in it. The parameters in the current location will also be used to compose the route but `meta` will take precedence.

### UnsavedChangesNotifier

This component enables the `warnWhenUnsavedChanges` feature of Refine. It will show a warning message when user tries to navigate away from the current page without saving the changes. Also checks for `beforeunload` event to warn the user when they try to close the browser tab or window.

Place this component inside the `<Refine>` components children to enable this feature.

```tsx
const App = () => {
  return (
    <BrowserRouter>
      <Refine
        /* ... */
        options={{
          /* ... */
          warnWhenUnsavedChanges: true,
        }}
      >
        {/* ... */}
        {/* highlight-next-line */}
        <UnsavedChangesNotifier />
      </Refine>
    </BrowserRouter>
  );
};
```

#### Properties

`translationKey` (optional) - The translation key for the warning message. Default value is `warnWhenUnsavedChanges`. Useful when you use an i18n provider.

`message` (optional) - The warning message. Default value is `Are you sure you want to leave? You have unsaved changes.` Useful when you don't use an i18n provider.

### CatchAllNavigate

It will redirect to the given path and keep the current location in `to` query parameter to redirect back when needed. In some cases you may not want to use the `<Authenticated>` component's `redirectOnFail` prop to redirect and have a catch-all route to redirect to the desired page. This is useful when handling the 404 pages with authentication.

```tsx
import { Refine } from "@refinedev/core";
import routerProvider, { CatchAllNavigate } from "@refinedev/react-router";
import { AuthPage } from "@refinedev/antd";

import { BrowserRouter, Routes, Route } from "react-router";

import authProvider from "src/authProvider";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        authProvider={authProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
          },
        ]}
      >
        <Routes>
          <Route path="/login" element={<AuthPage type="login" />} />
          {/* ... */}
          {/* highlight-next-line */}
          <Route path="*" element={<CatchAllNavigate to="/login" />} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
```

#### Properties

`to` (required) - The path to redirect to.

### DocumentTitleHandler

This component will generate the document title for the current page.By default, it follows a set of predefined rules to generate titles based on the provided props. However, it also offers the flexibility to customize the title generation process by providing a custom `handler` function.
The default title generation rules are as follows:

- list : `Posts | Refine`
- edit : `#{id} Edit Post | Refine`
- show : `#{id} Show Post | Refine`
- create : `Create new Post | Refine`
- clone : `#{id} Clone Post | Refine`
- default : `Refine`

```tsx
const App = () => {
  return (
    <BrowserRouter>
      <Refine
      /* ... */
      >
        {/* ... */}
        {/* highlight-next-line */}
        <DocumentTitleHandler />
      </Refine>
    </BrowserRouter>
  );
};
```

#### Properties

`handler` (optional) - The function that will get invoked in every location change. It will receive an object with the following properties:

- `pathname`: The current URL pathname.
- `resource`: The resource being displayed (e.g., "posts").
- `action`: The action being performed (e.g., "edit", "show", "create").
- `autoGeneratedTitle`: The default auto-generated title based on the predefined rules.
- `params`: An object containing URL parameters, including the `id` parameter if present.

Inside the handler function, you can dynamically generate the document title based on the provided properties and any additional logic required. The function should return the generated title.

```tsx
const customTitleHandler = ({ resource, action, params }) => {
  let title = "Custom default"; // Default title

  if (resource && action) {
    title = `${resource} ${action} ${params.id}`;
  }

  return title;
};

// Usage
<DocumentTitleHandler handler={customTitleHandler} />;
```

## Hooks

### useDocumentTitle

This hook allows you to set the document title for the current page. It can be used in any component that is a child of the `<Refine>` component.

```tsx
import { useDocumentTitle } from "@refinedev/react-router";

const PostList = () => {
  // highlight-next-line
  useDocumentTitle("Posts | Refine");

  return <List>{/* ... */}</List>;
};
```

This hook can take an object as an argument with `i18nKey`. This key will be used to translate the title using the i18n provider.

```tsx
import { useDocumentTitle } from "@refinedev/react-router";

const PostList = () => {
  // highlight-next-line
  useDocumentTitle({ i18nKey: "documentTitle.posts.list" });

  return <List>{/* ... */}</List>;
};
```

This hook also returns a function that can be used to set the document title dynamically.

```tsx
import { useDocumentTitle } from "@refinedev/react-router";

const PostList = () => {
  const setTitle = useDocumentTitle();

  useEffect(() => {
    setTitle("Posts | Refine");
  }, []);

  return <List>{/* ... */}</List>;
};
```

## FAQ

### How to handle optional authentication, redirects and layouts with authentication?

In the below example, you'll find different cases for route definitions, we've used `Authenticated` component to handle authentication and redirects. You can always choose to use a different approach, Refine will allow you to handle the routes however you like.

For optional authentication, in our `authProvider` implementation's `check` method, we can pass `authentication: false` and `redirectTo: undefined` to indicate that the current user is not authenticated but we don't want to redirect them to the login page. This is useful, when some pages in our app are public and don't require authentication and some pages are private and require authentication.

```tsx title=authProvider.ts
import { AuthProvider } from "@refinedev/core";

export const authProvider: AuthProvider = {
  check: async () => {
    const isAuthenticated = await yourMethodToCheckIfUserIsAuthenticated();

    return {
      // highlight-next-line
      authentication: isAuthenticated,
      // notice that we omit the `redirectTo` property
    };
  },
  // ...
};
```

In our `App.tsx`, while defining the routes, we'll leverage the `Outlet` component from `react-router` and `Authenticated` component from `@refinedev/core`.

**Initialization of `<Refine>` component**

Let's start with initializing our `<Refine>` component with inside `<BrowserRouter>` component. We'll pass our `dataProvider` `routerProvider` and `authProvider` to the `<Refine>` component. We'll also pass our `resources` and define our action paths for each resource in `<Refine>` component.

```tsx title=App.tsx
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";

import { BrowserRouter, Routes } from "react-router";

import { authProvider } from "src/authProvider";

export const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider}
        routerProvider={routerProvider}
        authProvider={authProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
            create: "/posts/create",
          },
        ]}
      >
        {/* ... */}
      </Refine>
    </BrowserRouter>
  );
};
```

**Defining routes**

Then, let's start adding our routes. We'll start with the `LandingPage` component at the `/` path. This will be visible for both authenticated and unauthenticated users. We need to wrap our `Route` elements with a `Routes` component.

```diff title=App.tsx
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";

+ import { BrowserRouter, Routes, Route } from "react-router";

import { authProvider } from "src/authProvider";

+ import { LandingPage } from "pages/landing";

export const App = () => {
    return (
        <BrowserRouter>
            <Refine
                dataProvider={dataProvider}
                routerProvider={routerProvider}
                authProvider={authProvider}
                resources={[
                    {
                        name: "posts",
                        list: "/posts",
                        create: "/posts/create",
                    },
                ]}
            >
+               <Routes>
+                   <Route index element={<LandingPage />} />
+               </Routes>
            </Refine>
        </BrowserRouter>
    )
}
```

**Defining authenticated routes**

Now, let's create our resource actions. They will be wrapped with the `Layout` component and only visible for authenticated users. We'll use the `Authenticated` component to handle authentication and redirects. We'll also use the `Outlet` component to properly wrap and handle the authenticated routes.

```diff title=App.tsx
+ import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";

+ import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "src/authProvider";

import { LandingPage } from "pages/landing";
+ import { PostList, PostCreate } from "pages/posts";

+ import { Layout } from "components/layout";

export const App = () => {
    return (
        <BrowserRouter>
            <Refine
                dataProvider={dataProvider}
                routerProvider={routerProvider}
                authProvider={authProvider}
                resources={[
                    {
                        name: "posts",
                        list: "/posts",
                        create: "/posts/create",
                    },
                ]}
            >
                <Routes>
                    <Route index element={<LandingPage />} />
+                   <Route
+                       element={(
+                           <Authenticated redirectOnFail="/login">
+                               <Layout>
+                                   <Outlet />
+                               </Layout>
+                           </Authenticated>
+                       )}
+                   >
+                       <Route path="posts">
+                           <Route index element={<PostList />} />
+                           <Route path="create" element={<PostCreate />} />
+                       </Route>
+                   </Route>
                </Routes>
            </Refine>
        </BrowserRouter>
    )
}
```

Now, when we navigate to the `/posts` page we should either see the `PostList` component or be redirected to the `/login` page. If we're already authenticated, we should see the `PostList` component.

**Defining auth pages**

We can now add our `/login` and `/register` pages. We'll use the `AuthPage` component for both pages. We'll also navigate to the `/posts` page if the user is already authenticated.

```diff title=App.tsx
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
+ import routerProvider, { NavigateToResource } from "@refinedev/react-router";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "src/authProvider";

import { LandingPage } from "pages/landing";
import { PostList, PostCreate } from "pages/posts";
+ import { AuthPage } from "pages/auth";

import { Layout } from "components/layout";

export const App = () => {
    return (
        <BrowserRouter>
            <Refine
                dataProvider={dataProvider}
                routerProvider={routerProvider}
                authProvider={authProvider}
                resources={[
                    {
                        name: "posts",
                        list: "/posts",
                        create: "/posts/create",
                    },
                ]}
            >
                <Routes>
                    <Route index element={<LandingPage />} />
                    <Route
                        element={(
                            <Authenticated redirectOnFail="/login">
                                <Layout>
                                    <Outlet />
                                </Layout>
                            </Authenticated>
                        )}
                    >
                        <Route path="posts">
                            <Route index element={<PostList />} />
                            <Route path="create" element={<PostCreate />} />
                        </Route>
                    </Route>
+                   <Route
+                       element={(
+                           <Authenticated fallback={<Outlet />}>
+                               <NavigateToResource resource="posts" />
+                           </Authenticated>
+                       )}
+                   >
+                       <Route path="/login" element={<AuthPage type="login" />} />
+                       <Route path="/register" element={<AuthPage type="register" />} />
+                   </Route>
                </Routes>
            </Refine>
        </BrowserRouter>
    )
}
```

Now, when we navigate to the `/login` or `/register` pages, we should either see the `AuthPage` component or be redirected to the `/posts` page. If we're already authenticated, we should be redirected to the `/posts` page.

**Defining error page**

Finally, we'll add our `ErrorComponent` component to show when user navigates to a non-existing page.

```diff title=App.tsx
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "src/authProvider";

+ import { ErrorComponent } from "components/error";
import { LandingPage } from "pages/landing";
import { PostList, PostCreate } from "pages/posts";
import { AuthPage } from "pages/auth";

import { Layout } from "components/layout";

export const App = () => {
    return (
        <BrowserRouter>
            <Refine
                dataProvider={dataProvider}
                routerProvider={routerProvider}
                authProvider={authProvider}
                resources={[
                    {
                        name: "posts",
                        list: "/posts",
                        create: "/posts/create",
                    },
                ]}
            >
                <Routes>
                    <Route index element={<LandingPage />} />
                    <Route
                        element={(
                            <Authenticated redirectOnFail="/login">
                                <Layout>
                                    <Outlet />
                                </Layout>
                            </Authenticated>
                        )}
                    >
                        <Route path="posts">
                            <Route index element={<PostList />} />
                            <Route path="create" element={<PostCreate />} />
                        </Route>
                    </Route>
                    <Route
                        element={(
                            <Authenticated fallback={<Outlet />}>
                                <NavigateToResource resource="posts" />
                            </Authenticated>
                        )}
                    >
                        <Route path="/login" element={<AuthPage type="login" />} />
                        <Route path="/register" element={<AuthPage type="register" />} />
                    </Route>
+                   <Route path="*" element={<ErrorComponent />} />
                </Routes>
            </Refine>
        </BrowserRouter>
    );
};
```

**Result**

We've now added our `AuthPage` and `ErrorComponent` components to our app. We've also used the `Authenticated` component to our routes to redirect the users to the `/login` page if they're not authenticated. The index page is available for all users because we didn't wrap it with the `Authenticated` component.

### Handling 404s

In the earlier versions of Refine, if `authProvider` was defined, we've redirected the users to the `/login` route even with the 404s and 404 pages were only available to the authenticated users. Now, the routes are handled by the users, so you can handle the 404s however you like.

#### 404 Pages for both authenticated and not authenticated users

Here's an example for rendering the `ErrorComponent` for undefined routes for both authenticated and not authenticated users.

Let's start with defining the `Refine` component.

```tsx title=App.tsx
import { Refine, Authenticated } from "@refinedev/core";
import routerProvider, { CatchAllNavigate } from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "providers/authProvider";

import { ErrorPage } from "pages/error";
import { AuthPage } from "pages/auth";
import { PostList, CategoryList } from "pages/posts";
import { Layout } from "components/Layout";

export const App = () => {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        authProvider={authProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
          },
          {
            name: "categories",
            list: "/categories",
          },
        ]}
      >
        <Routes>{/* ... */}</Routes>
      </Refine>
    </BrowserRouter>
  );
};
```

Now, we can add the routes with authentication control. We should place them inside the `Routes` component.

```tsx
<Route
  element={
    <Authenticated fallback={<CatchAllNavigate to="/login" />}>
      <Layout>
        <Outlet />
      </Layout>
    </Authenticated>
  }
>
  <Route path="/posts" element={<PostList />} />
  <Route path="/categories" element={<CategoryList />} />
</Route>
```

This will render the `/posts` and `/categories` routes for authenticated users and apply the `Layout` when rendering. If the current visitor is not authenticated, it will redirect them to the `/login` route.

Let's add the `/login` route.

```tsx
<Route
  element={
    <Authenticated fallback={<Outlet />}>
      <NavigateToResource />
    </Authenticated>
  }
>
  <Route path="/login" element={<AuthPage type="login" />} />
</Route>
```

This will render the `/login` route for not authenticated users and redirect the authenticated users to the `/posts` route.

And finally, we will add a catch-all route (`*`) and render the `ErrorPage` component.

```tsx
<Route
  element={
    <Authenticated fallback={<Outlet />}>
      <Layout>
        <Outlet />
      </Layout>
    </Authenticated>
  }
>
  <Route path="*" element={<ErrorPage />} />
</Route>
```

We will render the `ErrorPage` component for both authenticated and not authenticated users. Only authenticated users will be able to use the sider component we have in the layout.

#### 404 Pages for authenticated users only

The difference from the previous example is in the wrapper of the `*` route. Now we will redirect the unauthenticated users to the `/login` route and show the `ErrorPage` component for authenticated users only.

```tsx
<Route
  element={
    <Authenticated fallback={<CatchAllNavigate to="/login" />}>
      <Layout>
        <Outlet />
      </Layout>
    </Authenticated>
  }
>
  <Route path="*" element={<ErrorPage />} />
</Route>
```

We can also omit the `fallback` property and let the default redirect flow handle the unauthenticated users.

```tsx
<Route
  element={
    <Authenticated>
      <Layout>
        <Outlet />
      </Layout>
    </Authenticated>
  }
>
  <Route path="*" element={<ErrorPage />} />
</Route>
```

This means we will look for the `redirectTo` property in the `authProvider`'s `check` method. If it's defined, `<Authenticated>` component will redirect the user to the `redirectTo` route.

### `RefineRoutes` Component

This component is available but not recommended to use. While this works for the simple cases, we encourage you to define your routes using the `Route` components to have more control and flexibility over them.

This component can be used to create routes for your resources by using the `resources` prop. It will only take effect if the action properties in the resource definitions are assigned to components or objects with `component` property.

It will create the routes and pass it as a `JSX.Element[]` to the `children` function. You can use this to wrap your routes with other components like `Authenticated` or `Layout`.

```tsx title=App.tsx
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
// highlight-start
import routerProvider, { RefineRoutes } from "@refinedev/react-router";
import { BrowserRouter, Routes, Route } from "react-router";
// highlight-end

import { PostList, PostCreate } from "pages/posts";
import { CategoryList, CategoryShow } from "pages/categories";

import { Layout } from "components/Layout";
import { ErrorComponent } from "components/Error";

const App = () => {
    return (
        <BrowserRouter>
            <Refine
                dataProvider={dataProvider}
                // highlight-next-line
                routerProvider={routerProvider}
                resources={[
                    {
                        name: "posts",
                        // highlight-start
                        list: PostList,
                        create: PostCreate,
                        // highlight-end
                    },
                    {
                        name: "categories",
                        // highlight-start
                        list: CategoryList,
                        show: {
                            component: CategoryShow,
                            path: "/categories/:id/details", // Notice that we can also define the path here
                        },
                        // highlight-end
                    }
                ]}
            >
                {/* highlight-start */}
                <RefineRoutes>
                    {(routes) => (
                        <Routes>
                            <Route
                                element={(
                                    <Layout>
                                        <Outlet />
                                    </Layout>
                                )}
                            >
                                <Route index element={<NavigateToResource />} />
                                {routes}
                                <Route path="*" element={<ErrorComponent />} />
                            </Route>
                        </Routes>
                    )}
                </RefineRoutes>
                {/* highlight-end */}
        </BrowserRouter>
    )
}
```

We've defined our resource actions using components to let the `RefineRoutes` render them. We can also define the path for each action. If we don't define the path, the `RefineRoutes` will use the default paths for the actions.

[Refer to "Understanding the Resources" section of our tutorial for detailed information. &#8594][resources]

💡 We also defined the `show` action's path as `/categories/:id/details` which will override the default path.

The `index` route is defined with the `NavigateToResource` component which will redirect the user to the list page of the first defined resource.

We also added a catch-all route which will render the `ErrorComponent` for the routes that are not defined.

When components are used to define the resource actions, default paths will be used. You can override the default paths by assigning an object with `component` and `path` properties to the action properties.

Default paths are:

- `list`: `/resources`
- `create`: `/resources/create`
- `edit`: `/resources/edit/:id`
- `show`: `/resources/show/:id`

[routerprovider]: /docs/routing/router-provider
[resources]: /docs/guides-concepts/general-concepts/#resource-concept

### How to change the document title?

By default [`<DocumentTitleHandler/>`](#documenttitlehandler) component will generate the document title based on current resource and action with the "Refine" suffix. You can customize the title generation process by providing a custom `handler` function.

```tsx
import { BrowserRouter, DocumentTitleHandler } from "@refinedev/react-router";
import { Refine } from "@refinedev/core";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
      /* ... */
      >
        {/* ... */}
        <DocumentTitleHandler
          handler={({ action, params, resource }) => {
            const id = params?.id ?? "";

            const actionPrefixMatcher = {
              create: "Create new ",
              clone: `#${id} Clone ${resource?.meta?.label}`,
              edit: `#${id} Edit ${resource?.meta?.label}`,
              show: `#${id} Show ${resource?.meta?.label}`,
              list: `${resource?.meta?.label}`,
            };

            const suffix = " | <Company Name>";
            const title = actionPrefixMatcher[action || "list"] + suffix;

            return title;
          }}
        />
      </Refine>
    </BrowserRouter>
  );
};
```

================
File: routing/integrations/react-router/migration-guide-v6-to-v7.md
================
---
title: Migration Guide from v6 to v7
sidebar_label: v6 to v7
---

In this guide, we will cover the breaking changes of `@refinedev/react-router-v6` and how to migrate your project to `@refinedev/react-router` with `react-router` v7.

> 🚨 Refine doesn't introduce any breaking changes besides the package name changes. However, we recommend you to read the [React Router v7 migration guide](https://reactrouter.com/upgrading/v6) for more detailed information about React Router v7 changes.

## Package Changes

We changed the package name from `@refinedev/react-router-v6` to `@refinedev/react-router` for consistency and to avoid confusion. Also `react-router-dom` is replaced with `react-router` in [version 7](https://reactrouter.com/upgrading/v6#upgrade-to-v7).

First, we need to uninstall old packages.

```bash
npm uninstall @refinedev/react-router-v6 react-router-dom react-router
```

Then, we need to install the new packages.

Note that `react-router-dom` is no longer needed, all react-router v7 components are imported from `react-router` package.

```bash
npm install @refinedev/react-router react-router
```

```diff

- "@refinedev/react-router-v6": "^4.6.0"
+ "@refinedev/react-router": "^1.0.1"

- "react-router-dom": "^6.8.1"
- "react-router": "^6.8.1"
+ "react-router": "^7.0.2"
```

Then is all set! You can start using `@refinedev/react-router` with `react-router` v7.

### Updating imports

Package imports are changed as follows:

```diff
 import routerProvider, { NavigateToResource, UnsavedChangesNotifier, DocumentTitleHandler }
- from "@refinedev/react-router-v6";
 import routerProvider, { NavigateToResource, UnsavedChangesNotifier, DocumentTitleHandler }
+ from "@refinedev/react-router";

-import { RouterProvider } from "react-router-dom";
+import { RouterProvider } from "react-router";
```

### 🪄 Updating imports automatically with refine-codemod ✨ (recommended)

Instead of manually updating the imports, you can use the `refine-codemod` to automatically update the imports in your project. Make sure your git working tree is clean though so you can revert if it doesn't work as expected.

For `@refinedev/react-router-v6` to `@refinedev/react-router`:

```bash
npx @refinedev/codemod@latest refine-react-router-v6-to-refine-react-router
```

For `react-router-dom` to `react-router`:

```bash
npx @refinedev/codemod@latest react-router-dom-to-react-router
```

================
File: routing/integrations/remix/index.md
================
---
title: Remix
---

Refine provides router bindings and utilities for [Remix](https://remix.run). This package will provide easy integration between Refine and **Remix** for both existing projects and new projects without giving up the benefits of **Remix**.

import { CodeBlock } from "@site/src/theme/CodeBlock/base";

<InstallPackagesCommand args="@refinedev/remix-router"/>

You can use one of our remix examples to start your project.

<Tabs wrapContent={false}>
  <TabItem value="npm" label="npm" default>
    <Tabs>
      <TabItem value="vite" label="Vite Headless">
        <CodeBlock className="language-bash">npm create refine-app@latest -- --example with-remix-vite-headless my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="antd" label="Ant Design">
        <CodeBlock className="language-bash">npm create refine-app@latest -- --example with-remix-antd my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="mui" label="MUI">
        <CodeBlock className="language-bash">npm create refine-app@latest -- --example with-remix-mui my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="auth" label="Ant Design and Auth">
        <CodeBlock className="language-bash">npm create refine-app@latest -- --example with-remix-auth my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="headless" label="Headless">
        <CodeBlock className="language-bash">npm create refine-app@latest -- --example with-remix-headless my-refine-remix-app</CodeBlock>
      </TabItem>
    </Tabs>
  </TabItem>
  <TabItem value="pnpm" label="pnpm">
    <Tabs>
      <TabItem value="vite" label="Vite Headless">
        <CodeBlock className="language-bash">pnpm create refine-app@latest --example with-remix-vite-headless my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="antd" label="Ant Design">
        <CodeBlock className="language-bash">pnpm create refine-app@latest --example with-remix-antd my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="mui" label="MUI">
        <CodeBlock className="language-bash">pnpm create refine-app@latest --example with-remix-mui my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="auth" label="Ant Design and Auth">
        <CodeBlock className="language-bash">pnpm create refine-app@latest --example with-remix-auth my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="headless" label="Headless">
        <CodeBlock className="language-bash">pnpm create refine-app@latest --example with-remix-headless my-refine-remix-app</CodeBlock>
      </TabItem>
    </Tabs>
  </TabItem>
  <TabItem value="yarn" label="yarn">
    <Tabs>
      <TabItem value="vite" label="Vite Headless">
        <CodeBlock className="language-bash">yarn create refine-app@latest --example with-remix-vite-headless my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="antd" label="Ant Design">
        <CodeBlock className="language-bash">yarn create refine-app@latest --example with-remix-antd my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="mui" label="MUI">
        <CodeBlock className="language-bash">yarn create refine-app@latest --example with-remix-mui my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="auth" label="Ant Design and Auth">
        <CodeBlock className="language-bash">yarn create refine-app@latest --example with-remix-auth my-refine-remix-app</CodeBlock>
      </TabItem>
      <TabItem value="headless" label="Headless">
        <CodeBlock className="language-bash">yarn create refine-app@latest --example with-remix-headless my-refine-remix-app</CodeBlock>
      </TabItem>
    </Tabs>
    <ReactMarkdown>{"> Only supports yarn@1 version."}</ReactMarkdown>
  </TabItem>
</Tabs>

[Refer to the Router Provider documentation for detailed information. &#8594][routerprovider]

:::simple Legacy Router

`@refinedev/remix-router` also exports the legacy router provider and it will be available until the next major version of Refine. It is recommended to use the new router provider instead of the legacy one.

If you are using the legacy router provider, it can be imported from `@refinedev/remix-router/legacy` and passed to the `legacyRouterProvider` prop of the `Refine` component.

:::

## Usage

We'll use the `routerProvider` from `@refinedev/remix-router` to set up the router bindings for Refine. We'll define the action routes for our resources in the `resources` array and define our routes in `app/routes` directory.

We'll create four pages for our resources:

- `app/routes/posts._index.tsx` - List page for posts
- `app/routes/posts.show.$id.tsx` - Detail page for posts
- `app/routes/categories._index.tsx` - List page for categories
- `app/routes/categories.show.$id.tsx` - Detail page for categories

And we'll create one page for the index route and use it to redirect to the `posts` resource:

- `app/routes/_index.tsx` - Index page

Notice that we're using the V2 for route file naming convention for our routes. You can find more information about it in the [Remix documentation](https://remix.run/docs/en/main/file-conventions/route-files-v2).

Currently, to enable that you need to add the following line to your `remix.config.js` file:

```node title=remix.config.js
module.exports = {
  future: {
    v2_routeConvention: true,
  },
};
```

Let's start with the initialization of the Refine app in the `app/root.tsx` file:

```tsx title=app/root.tsx
import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/remix-router";

import { Layout } from "components/Layout";

export default function App(): JSX.Element {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Refine
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          // highlight-next-line
          routerProvider={routerProvider}
          resources={[
            {
              name: "posts",
              list: "/posts",
              show: "/posts/show/:id",
            },
            {
              name: "categories",
              list: "/categories",
              show: "/categories/show/:id",
            },
          ]}
        >
          <Layout>
            <Outlet />
          </Layout>
        </Refine>
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}
```

:::simple Good to know

Remix uses the `$` symbol to indicate parameters but Refine uses the colon syntax (`:param`) for route parameters. This won't cause any problems since Refine only uses the colon syntax as an indicator for route parameters and the communication between Refine and the router is handled by the `routerProvider` prop.

:::

Your action definitions in the resources can contain additional parameters and nested routes. Passing these parameters when navigating to the pages are handled by the current available parameters and the `meta` props of the related hooks and components.

Refine supports route parameters defined with `:param` syntax. You can use these parameters in your action definitions and create your routes accordingly. For example, if you have a `posts` resource and you want to create a route for the `show` action of a specific post, you can define the `show` action as `/posts/show/:id` and use the `id` parameter in your component.

Now we can create our pages in the `routes` directory:

```tsx title=app/routes/posts._index.tsx
import { useTable } from "@refinedev/core";
import { NavLink } from "@remix-run/react";

type IPost = {
  id: string;
  title: string;
  description: string;
};

export default function PostList() {
  // `posts` resource will be inferred from the route.
  // Because we've defined `/posts` as the `list` action of the `posts` resource.
  const {
    tableQuery: { data, isLoading },
  } = useTable<IPost>();

  const getToPath = useGetToPath();

  const tableData = data?.data;

  return (
    <div>
      {isLoading && <p>Loading...</p>}
      {!isLoading && (
        <ul>
          {tableData?.map((post) => (
            <li key={post.id}>
              <NavLink
                to={getToPath({
                  resource: "categories",
                  action: "show",
                  meta: { id: category.id },
                })}
              >
                {post.title}
              </NavLink>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

```tsx title=app/routes/posts.show.$id.tsx
import { useShow } from "@refinedev/core";

type IPost = {
    id: string;
    title: string;
    description: string;
}

export default function PostShow() {
    // `posts` resource and the `id` will be inferred from the route.
    // Because we've defined `/posts/show/:id` as the `show` action of the `posts` resource.
    const { queryResult: { data, isLoading } } = useShow<IPost>();

    const postData = data?.data;

    return (
        <div>
            {isLoading && <p>Loading...</p>}
            {!isLoading && (
                <h1>{postData?.title}</h1>
                <p>{postData?.description}</p>
            )}
        </div>
    );
}
```

```tsx title=app/routes/categories._index.tsx
import { useTable, getToPath } from "@refinedev/core";
import { NavLink } from "@remix-run/react";

type ICategory = {
  id: string;
  label: string;
};

export default function CategoryList() {
  // `categories` resource will be inferred from the route.
  // Because we've defined `/categories` as the `list` action of the `categories` resource.
  const {
    tableQuery: { data, isLoading },
  } = useTable<ICategory>();

  const getToPath = useGetToPath();

  const tableData = data?.data;

  return (
    <div>
      {isLoading && <p>Loading...</p>}
      {!isLoading && (
        <ul>
          {tableData?.map((category) => (
            <li key={category.id}>
              <NavLink
                to={getToPath({
                  resource: "categories",
                  action: "show",
                  meta: { id: category.id },
                })}
              >
                {category.label}
              </NavLink>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

```tsx title=app/routes/categories.show.$id.tsx
import { useShow } from "@refinedev/core";

type ICategory = {
  id: string;
  label: string;
};

export default function CategoryShow() {
  // `categories` resource and the `id` will be inferred from the route.
  // Because we've defined `/categories/show/:id` as the `show` action of the `categories` resource.
  const {
    queryResult: { data, isLoading },
  } = useShow<ICategory>();

  const categoryData = data?.data;

  return (
    <div>
      <h1>{categoryData?.label}</h1>
    </div>
  );
}
```

Now, we'll use [`NavigateToResource`](#navigatetoresource) component to redirect to the `posts` resource when the user visits the home page.

Even though we're using the `NavigateToResource` component, when using Remix it's better to handle such redirect operations in the server side rather than the client side. You can use the `loader` function to redirect the user to the `/posts`.

```tsx title=app/routes/_index.tsx
import { NavigateToResource } from "@refinedev/remix-router";

export default function Index() {
  return <NavigateToResource />;
}
```

## Additional Components

`@refinedev/remix-router` package also includes some additional components that can be useful in some cases.

### NavigateToResource

A basic component to navigate to a resource page. It is useful when you want to navigate to a resource page at the index route of your app.

```tsx title=app/routes/index.tsx
import { NavigateToResource } from "@refinedev/remix-router";

export default function IndexPage() {
  return <NavigateToResource />;
}
```

#### Properties

`resource` (optional) - The name of the resource to navigate to. It will redirect to the first `list` route in the `resources` array if not provided.

`meta` (optional) - The meta object to use if the route has parameters in it. The parameters in the current location will also be used to compose the route but `meta` will take precedence.

### UnsavedChangesNotifier

This component enables the `warnWhenUnsavedChanges` feature of Refine. It will show a warning message when user tries to navigate away from the current page without saving the changes. Also checks for `beforeunload` event to warn the user when they try to close the browser tab or window.

Place this component inside the `<Refine>` components children to enable this feature.

```tsx title=app/root.tsx
import { Refine } from "@refinedev/core";
import { UnsavedChangesNotifier } from "@refinedev/remix-router";

export default function App(): JSX.Element {
  return (
    <Refine
    /* ... */
    >
      <Outlet />
      {/* highlight-next-line */}
      <UnsavedChangesNotifier />
    </Refine>
  );
}
```

#### Properties

`translationKey` (optional) - The translation key for the warning message. Default value is `warnWhenUnsavedChanges`. Useful when you use an i18n provider.

`message` (optional) - The warning message. Default value is `Are you sure you want to leave? You have unsaved changes.` Useful when you don't use an i18n provider.

### parseTableParams

This function can be used to parse the query parameters of a table page. It can be useful when you want to use the query parameters in your server side functions (`loader`) to fetch the data such as [persisting the table state](#how-to-persist-syncwithlocation-in-ssr)

## Authentication

In Remix you can achieve authentication control in multiple ways;

On the client-side [`Authenticated`](/docs/authentication/components/authenticated) component from `@refinedev/core` can be used to protect your pages from unauthenticated access.

On the server-side `authProvider`'s `check` function inside server side functions (`loader`) to redirect unauthorized users to other pages using `redirect` from `@remix-run/node`.

:::simple Implementation Tips

For page level access control, server-side approach is recommended.

:::

### Server Side Authentication with `createCookieSessionStorage`

First, let's create our `AuthProvider`. For more information on `AuthProvider`, visit our [AuthProvider documentation][authprovider].

```tsx title="app/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const mockUsers = [
  {
    username: "admin",
    roles: ["admin"],
  },
  {
    username: "editor",
    roles: ["editor"],
  },
];

export const authProvider: AuthProvider = {
  login: async ({ username, password, remember }) => {
    // Suppose we actually send a request to the back end here.
    const user = mockUsers.find((item) => item.username === username);

    if (user) {
      return {
        success: true,
        redirectTo: "/",
      };
    }

    return {
      success: false,
      error: {
        message: "Login failed",
        name: "Invalid email or password",
      },
    };
  },
  logout: async () => {
    return {
      success: true,
      redirectTo: "/",
    };
  },
  onError: async (error) => {
    if (error && error.statusCode === 401) {
      return {
        logout: true,
        redirectTo: "/login",
      };
    }

    return {};
  },
  check: async ({ request, storage }) => {
    const session = await storage.getSession(request.headers.get("Cookie"));

    const user = session.get("user");

    if (!user) {
      return {
        authenticated: false,
        logout: true,
        redirectTo: "/login",
      };
    }
    return {
      authenticated: true,
    };
  },
  getPermissions: async () => {
    return null;
  },
  getIdentity: async () => {
    return null;
  },
};
```

Next, let's create the `app/session.server.ts` file as mentioned in the [`Jokes App`][jokesapp] tutorial

```tsx title="app/session.server.ts"
import { createCookieSessionStorage, redirect } from "@remix-run/node";
import { authProvider } from "./authProvider";

type LoginForm = {
  username: string;
  password: string;
};

// normally you want this to be env variable
const sessionSecret = "SUPER_SECRET_SESSION"; //process.env.SESSION_SECRET;

if (!sessionSecret) {
  throw new Error("SESSION_SECRET must be set");
}

const storage = createCookieSessionStorage({
  cookie: {
    name: "RJ_session",
    // normally you want this to be `secure: true`
    // but that doesn't work on localhost for Safari
    // https://web.dev/when-to-use-local-https/
    secure: process.env.NODE_ENV === "production",
    secrets: [sessionSecret],
    sameSite: "lax",
    path: "/",
    maxAge: 60 * 60 * 24 * 30,
    httpOnly: true,
  },
});

export async function login({ username, password }: LoginForm) {
  try {
    const user = await authProvider.login({ username, password });
    if (user) {
      return { user };
    }
  } catch (error) {
    return error;
  }
}

export async function requireUserId(
  request: Request,
  redirectTo: string = new URL(request.url).pathname,
) {
  try {
    const user = await authProvider.check?.({ request, storage });
    return user;
  } catch (error) {
    const searchParams = new URLSearchParams([["to", redirectTo]]);
    throw redirect(`/login?${searchParams}`);
  }
}

export async function createUserSession(user: object, redirectTo: string) {
  const session = await storage.getSession();
  session.set("user", { ...user });
  return redirect(redirectTo, {
    headers: {
      "Set-Cookie": await storage.commitSession(session),
    },
  });
}

export async function logout(request: Request) {
  const session = await storage.getSession(request.headers.get("Cookie"));
  return redirect("/login", {
    headers: {
      "Set-Cookie": await storage.destroySession(session),
    },
  });
}
```

In the `login` and `requireUserId` functions, we call the corresponding functions of our `AuthProvider`.

Now let's create our login page

```tsx title="app/routes/login.tsx"
import React from "react";
import { useTranslate } from "@refinedev/core";

import { login, createUserSession } from "~/session.server";
import { ActionFunction } from "@remix-run/node";
import { useSearchParams } from "@remix-run/react";

export interface ILoginForm {
  username: string;
  password: string;
}

const LoginPage: React.FC = () => {
  const translate = useTranslate();
  const [searchParams] = useSearchParams();

  return (
    <>
      <h1>{translate("pages.login.title", "Sign in your account")}</h1>
      <form method="post">
        <input
          type="hidden"
          name="redirectTo"
          value={searchParams.get("to") ?? undefined}
        />
        <table>
          <tbody>
            <tr>
              <td>
                {translate("pages.login.username", undefined, "username")}:
              </td>
              <td>
                <input
                  name="username"
                  type="text"
                  size={20}
                  autoCorrect="off"
                  spellCheck={false}
                  autoCapitalize="off"
                  autoFocus
                  required
                />
              </td>
            </tr>
            <tr>
              <td>
                {translate("pages.login.password", undefined, "password")}:
              </td>
              <td>
                <input type="password" name="password" required size={20} />
              </td>
            </tr>
          </tbody>
        </table>
        <br />
        <input type="submit" value="login" />
      </form>
    </>
  );
};

export const action: ActionFunction = async ({ request }) => {
  const form = await request.formData();
  const username = form.get("username") as string;
  const password = form.get("password") as string;
  const redirectTo = form.get("redirectTo") || "/";
  // highlight-start
  const user = await login({ username, password });
  if (!user) {
    return null;
  }

  return createUserSession(user as any, redirectTo as string);
  // highlight-end
};

export default LoginPage;
```

Yeeyy! Now our users can login! 🎉

Remember, actions and loaders run on the server, so console.log calls you put in those you can't see in the browser console. Those will show up in the terminal window you're running your server in.

We can call the `requireUserId` function on our routes where we want the authentication check done.

```tsx
import { json, LoaderFunction } from "@remix-run/node";
//highlight-next-line
import { requireUserId } from "~/session.server";

export const loader: LoaderFunction = async ({ params, request, context }) => {
  //highlight-next-line
  await requireUserId(request);

  return json({});
};
```

Finally, let's make sure our users can log out. For this, we create a routes for `/logout`.

```tsx title="/app/routes/logout.tsx"
import type { LoaderFunction } from "@remix-run/node";

import { logout } from "~/session.server";

export const loader: LoaderFunction = async ({ request }) => {
  return await logout(request);
};
```

### Server Side Authentication with Self service Cookie

First, let's install the `js-cookie` and `cookie` packages in our project.

<InstallPackagesCommand args="js-cookie cookie"/>

<InstallPackagesCommand args="-D @types/js-cookie"/>

We will set/destroy cookies in the `login`, `logout` and `check` functions of our `AuthProvider`.

```tsx title="app/authProvider.ts"
import { AuthProvider } from "@refinedev/core";
// highlight-start
import Cookies from "js-cookie";
import * as cookie from "cookie";
// highlight-end

const mockUsers = [
  {
    username: "admin",
    roles: ["admin"],
  },
  {
    username: "editor",
    roles: ["editor"],
  },
];

// highlight-next-line
const COOKIE_NAME = "user";

export const authProvider: AuthProvider = {
  login: ({ username, password, remember }) => {
    // Suppose we actually send a request to the back end here.
    const user = mockUsers.find((item) => item.username === username);

    if (user) {
      // highlight-next-line
      Cookies.set(COOKIE_NAME, JSON.stringify(user));
      return {
        success: true,
      };
    }

    return {
      success: false,
    };
  },
  logout: () => {
    // highlight-next-line
    Cookies.remove(COOKIE_NAME);

    return {
      success: true,
      redirectTo: "/login",
    };
  },
  onError: (error) => {
    if (error && error.statusCode === 401) {
      return {
        error: new Error("Unauthorized"),
        logout: true,
        redirectTo: "/login",
      };
    }

    return {};
  },
  check: async (context) => {
    // highlight-start
    let user = undefined;
    if (context) {
      // for SSR
      const { request } = context;
      const parsedCookie = cookie.parse(request.headers.get("Cookie"));
      user = parsedCookie[COOKIE_NAME];
    } else {
      // for CSR
      const parsedCookie = Cookies.get(COOKIE_NAME);
      user = parsedCookie ? JSON.parse(parsedCookie) : undefined;
    }
    // highlight-end

    if (!user) {
      return {
        authenticated: false,
        error: {
          message: "Check failed",
          name: "Unauthorized",
        },
        logout: true,
        redirectTo: "/login",
      };
    }

    return {
      authenticated: true,
    };
  },
  getPermissions: async () => {
    return null;
  },
  getIdentity: async () => {
    return null;
  },
};
```

Tadaa! that's all! 🎉

Now, we can check the authentication in loaders of our routes.

```tsx title="app/routes/_index.tsx"
import { json, LoaderFunction } from "@remix-run/node";
import { authProvider } from "~/authProvider";

export const loader: LoaderFunction = async ({ params, request, context }) => {
  // We've handled the SSR case in our `check` function by sending the `request` as parameter.
  const { authenticated } = await authProvider.check(request);

  if (!authenticated) {
    return json({}, { status: 401 });
  }

  return null;
};
```

This needs to be done for all the routes that we want to protect.

## Access Control

There are two ways to do Server Side Authentication with Remix. You can choose one of the two methods according to your use case.

### Server Side

On the server-side `accessControlProvider`'s `can` function inside server side functions (`loader`) to redirect unauthorized users to other pages using `redirect` from `@remix-run/node`.

First, let's build our [AccessControlProvider](/docs/authorization/access-control-provider)

```tsx title="app/acccessControlProvider.ts"
export const accessControlProvider = {
  can: async ({ resource, action, params }) => {
    if (resource === "posts" && action === "edit") {
      return {
        can: false,
        reason: "Unauthorized",
      };
    }

    return { can: true };
  },
};
```

You can also access resource object directly.

```tsx
const resourceName = params?.resource?.name;
const anyUsefulMeta = params?.resource?.meta?.yourUsefulMeta;

export const accessControlProvider = {
  can: async ({ resource, action, params }) => {
    if (
      resourceName === "posts" &&
      anyUsefulMeta === true &&
      action === "edit"
    ) {
      return {
        can: false,
        reason: "Unauthorized",
      };
    }
  },
};
```

Then, let's create our posts route.

```tsx title="app/routes/_protected.posts._index.tsx"
import { useLoaderData } from "@remix-run/react";
import { json, LoaderFunctionArgs } from "@remix-run/node";
import dataProvider from "@refinedev/simple-rest";

import { IPost } from "../interfaces";
import { API_URL } from "~/constants";
import { accessControlProvider } from "../accessControlProvider";

const PostList: React.FC = () => {
  const { initialData } = useLoaderData<typeof loader>();

  return <>{/* ... */}</>;
};

export default PostList;

export async function loader({ request }: LoaderFunctionArgs) {
  const can = accessControlProvider.can({
    resource: "posts",
    action: "list",
  });

  if (!can) {
    return json({}, { status: 403 });
  }

  const data = await dataProvider(API_URL).getList<IPost>({
    resource: "posts",
  });

  return json({ initialData: data });
}
```

Tadaa! that's all! 🎉

### Client Side

For client-side, you can wrap your pages with [`CanAccess`](/docs/authorization/components/can-access) component from `@refinedev/core` to protect your pages from unauthorized access.

```tsx
import { CanAccess } from "@refinedev/core";

export const MyPage = () => (
  <CanAccess>
    <div>{/* ... */}</div>
  </CanAccess>
);
```

## FAQ

### Can I use nested routes?

Yes, you can use nested routes in your app. Refine will match the routes depending on how you define the action paths in your resources. Additional parameters and nesting is supported. Refine will not limit you and your router in route configuration, all you need to do is to pass the appropriate path to the related resource and the action in the `resources` array (This is also optional but recommended due to the features it provides).

You can use `:param` syntax to define parameters in your routes.

### How to make SSR work?

You can always use the methods provided from the `dataProvider` to fetch data in your pages. To do this, you can use `loader` function and pass the data to your page as a prop.

All you need to do is to pass the data as the `initialData` to your data hooks using the `queryOptions` prop.

```tsx
import { useList } from "@refinedev/core";
import { useLoaderData } from "@remix-run/react";

import { dataProvider } from "src/providers";

type IPost = {
  id: number;
  title: string;
  description: string;
};

export async function loader() {
  const { data } = await dataProvider.getList<IPost>("posts", {
    pagination: {
      page: 1,
      perPage: 10,
    },
  });

  return json(data);
}

export default function Posts() {
  const initialPosts = useLoaderData<typeof loader>();

  const {
    tableQuery: { data },
  } = useTable<IPost>({
    queryOptions: {
      initialData: initialPosts,
    },
  });

  return <>{/* ... */}</>;
}
```

### How to persist `syncWithLocation` in SSR?

If `syncWithLocation` is enabled, query parameters must be handled while doing SSR.

```tsx
import { json, LoaderFunction } from "@remix-run/node";
// highlight-next-line
import { parseTableParams } from "@refinedev/remix-router";
import dataProvider from "@refinedev/simple-rest";

const API_URL = "https://api.fake-rest.refine.dev";

export const loader: LoaderFunction = async ({ params, request }) => {
  const { resource } = params;
  const url = new URL(request.url);

  // highlight-next-line
  const tableParams = parseTableParams(url.search);

  try {
    const data = await dataProvider(API_URL).getList({
      resource: resource as string,
      ...tableParams, // this includes `filters`, `sorters` and `pagination`
    });

    return json({ initialData: data });
  } catch (error) {
    return json({});
  }
};

export default function MyListRoute() {
  return <>{/* ... */}</>;
}
```

`parseTableParams` parses the query string and returns query parameters([refer here for their interfaces][interfaces]). They can be directly used for `dataProvider` methods that accept them.

### Handling 404s

In the earlier versions of Refine, if `authProvider` was defined, we've redirected the users to the `/login` route even with the 404s and 404 pages were only available to the authenticated users. Now, the routes are handled by the users, so you can handle the 404s however you like.

In remix, you can use a splat ($) route to handle the 404s. Check out the [remix docs](https://remix.run/docs/en/main/guides/routing#md-splats) for more information.

**Using `loader`**

```tsx title="app/routes/$.tsx"
import { json, LoaderFunction } from "@remix-run/node";

export const loader: LoaderFunction = async ({ params, request, context }) => {
  return json({}, { status: 404 });
};
```

**Using `Authenticated`**

```tsx title="app/routes/$.tsx"
import { Authenticated } from "@refinedev/core";

export default function NotFound() {
  return (
    <Authenticated>
      <div>I'm the 404 page for the authenticated users.</div>
    </Authenticated>
  );
}
```

### RefineRoutes

While this may work for the simple cases, it is not recommended to use this component. Defining your routes separately will give you more control over your routes and will allow you to use the full potential of your router.

This component can be used to render the matching route in your resources by using the `resources` prop. It will only take effect if the action properties in the resource definitions are assigned to components or objects with `component` property.

It will render the component for the matching route and pass it as a `JSX.Element` to the `children` function. You can use this to render your components in a single catch-all route. If there's no matching route `undefined` will be passed to the `children` function. In this case, you can render an error page or redirect the user to another page.

We'll define our resources in the `<Refine>` component:

```tsx title=app/root.tsx
return (
  <Refine
    resources={[
      {
        name: "posts",
        list: "/posts",
        show: "/posts/show/:id",
      },
      {
        name: "categories",
        list: "/categories",
      },
    ]}
  >
    {/* ... */}
  </Refine>
);
```

Then, we'll create a catch-all route to render the matching route in our resources:

```tsx title=app/routes/$.tsx
import { RefineRoutes } from "@refinedev/remix-router";

import { ErrorPage } from "components/error";

export default function CatchAll() {
  return (
    <RefineRoutes>
      {(matchingRoute) => {
        if (matchingRoute) {
          return { matchingRoute };
        }

        return <ErrorPage />;
      }}
    </RefineRoutes>
  );
}
```

When components are used to define the resource actions, default paths will be used. You can override the default paths by assigning an object with `component` and `path` properties to the action properties.

Default paths are:

- `list`: `/resources`
- `create`: `/resources/create`
- `edit`: `/resources/edit/:id`
- `show`: `/resources/show/:id`

## Example

<CodeSandboxExample path="with-remix-antd" />

<CodeSandboxExample path="with-remix-headless" hideSandbox />

[routerprovider]: /docs/routing/router-provider
[remix]: https://remix.run/
[remixrouter]: https://www.npmjs.com/package/@refinedev/remix-router
[Refine]: /docs/core/refine-component
[remixroutes]: https://remix.run/docs/en/v1/api/conventions#routes
[usetable]: /docs/data/hooks/use-table
[reactqueryssr]: https://react-query.tanstack.com/guides/ssr#using-initialdata
[reactquery]: https://react-query.tanstack.com/
[getlist]: /docs/data/data-provider#getlist-
[dataprovider]: /docs/data/data-provider
[usetable]: /docs/data/hooks/use-table
[interfaces]: /docs/core/interface-references/#crudfilters
[loaderfunction]: https://remix.run/docs/en/v1/api/conventions#loader
[jokesapp]: https://remix.run/docs/en/v1/tutorials/jokes#authentication
[authprovider]: /docs/authentication/auth-provider

================
File: routing/router-provider/index.md
================
---
title: Router Provider
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Refine provides a simple interface from the `routerProvider` prop to infer the resource from route, pass, parse and sync the query parameters and handle navigation operations. This provider and its properties are optional but recommended to get the most out of Refine.

Rather than restricting and limiting our users to specific routing libraries or practices, we have designed the `routerProvider` interface to communicate with the router libraries rather than managing them.

:::simple Out of the Box Router Providers

- [React Router][react-router]
- [Next.js Router][nextjs-router]
- [Remix Router][remix-router]
- [Expo Router (Community)][expo-router]

:::

A router provider may contain the following methods:

```tsx
const routerProvider: {
    go?: () => ({
        to?: string;
        query?: Record<string, unknown>;
        hash?: string;
        options?: {
            keepQuery?: boolean;
            keepHash?: boolean;
        };
        type?: "push" | "replace" | "path";
    }) => void | string;
    back?: () => () => void;
    parse?: () => () => {
        resource?: IResourceItem;
        id?: BaseKey;
        action?: Action;
        pathname?: string;
        params?: {
            filters?: CrudFilters;
            sorters?: CrudSorting;
            current?: number;
            pageSize?: number;
            [key: string]: any;
        }
    };
    Link?: React.ComponentType<{ to: string; children?: React.ReactNode; }>;
};
```

You can create your own router provider or easily customize the existing ones to suit your needs. The existing implementations are pretty simple and straightforward. Do not hesitate to check the source code of the existing router providers when creating your own.

## Usage

To activate router provider in Refine, we have to pass the `routerProvider` to the `<Refine />` component:

<Tabs
defaultValue="react-router-v6"
values={[
{label: 'React Router', value: 'react-router-v6'},
{label: 'Next.js Router', value: 'nextjs'},
{label: 'Remix Router', value: 'remix'},
{label: 'React Router V5 (Legacy)', value: 'react-router'},
{label: 'React Location (Legacy)', value: 'react-location'}
]}>
<TabItem value="react-router-v6">

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/react-router";

import { BrowserRouter } from "react-router";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <Refine
        // highlight-next-line
        routerProvider={routerProvider}
        /* ... */
      >
        {/* ... */}
      </Refine>
    </BrowserRouter>
  );
};
```

</TabItem>
<TabItem value="react-router">

```tsx title="App.tsx"
import { Refine } from "@refinedev/core";
import routerProvider from "@pankod/refine-react-router";

const App: React.FC = () => {
  return <Refine legacyRouterProvider={routerProvider} />;
};
```

</TabItem>
<TabItem value="nextjs">

```tsx title="pages/_app.tsx"
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/nextjs-router/pages";
import { AppProps } from "next/app";

function MyApp({ Component, pageProps }: AppProps): JSX.Element {
  return (
    <Refine routerProvider={routerProvider}>
      <Component {...pageProps} />
    </Refine>
  );
}
```

  </TabItem>
<TabItem value="remix">

```tsx title="app/root.tsx"
import type { MetaFunction } from "@remix-run/node";
import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/remix-router";

export const meta: MetaFunction = () => ({
  charset: "utf-8",
  title: "New Remix + Refine App",
  viewport: "width=device-width,initial-scale=1",
});

export default function App() {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Refine routerProvider={routerProvider}>
          <Outlet />
        </Refine>
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}
```

</TabItem>
</Tabs>

## Creating a router provider

The `routerProvider` methods are designed to be as simple as possible and to be compatible with any router library. Refine also exports some helper functions to make it easier to create a customized `routerProvider`.

### go

The `go` method is used to navigate to a specific page. It accepts a `to` parameter, which is the path of the page to navigate to; the `query`, `hash`, and `options` parameters to customize the navigation; and the `type` parameter is used to specify the type of navigation, which can be either `push`, `replace` or `path`.

The `path` type returns the path to navigate, which can be used in links or redirects. The `push` and `replace` types navigate to the path.

The `to` parameter is `undefined` by default. In this case, we expect the `go` function to use the current path and add the `query` and `hash` parameters to it.

The `query` parameter is passed as an object to let the router library handle the query string. In our implementations, we use the `qs` library to stringify the query object, which supports nested objects. The `query` is also parsed in the `parse` method of the `routerProvider`, which allows us to implement custom ways of stringifying and parsing the queries.

### back

The `back` method is used to navigate back to the previous page. It has no parameters and has no return value.

### parse

The `parse` method is used to parse the current path and return the current `resource`, `id` and `action` of the page as well as the `pathname` and the `params`.

`params` is an object that contains both the URL parameters and the query parameters. We use the `qs` library to parse the query string and return the query parameters as an object, but you can use any other library or implement your own way of parsing the query string.

`resource` is the name of the resource that is used in the current page and also defined in the `resources` prop of the `<Refine />` component. This can be `undefined` if there's no matching resource route.

Matching the resource route can be done with the help of the `matchResourceFromRoute` function from the `@refinedev/core` package.

`id` is the id of the record that is used in the current page. This can be `undefined` if there's no matching parameter.

`action` is the name of the action that is used in the current page. This can be `undefined` if there's no matching route for a resource action.

### Link

The `Link` component is used to create links to other pages. It accepts a `to` parameter which is the path of the page to navigate to. It's meant to be used internally in UI packages and other parts of Refine to complement the router library. It's not meant to be used directly in the application.

### Source Code for the Existing Router Providers

- [React Router](https://github.com/refinedev/refine/blob/main/packages/react-router/src/bindings.tsx)
- [Next.js Router](https://github.com/refinedev/refine/blob/main/packages/nextjs-router/src/pages/bindings.tsx)
- [Remix Router](https://github.com/refinedev/refine/blob/main/packages/remix-router/src/bindings.tsx)

## Legacy Router Provider

Refine's v4 release is backward compatible and supports the legacy router provider implementations until v5 comes out. The legacy router provider implementations are still available at `/legacy` paths in the router provider packages. For example, the legacy router provider implementation for React Router is available at `@refinedev/react-router-v6/legacy`.

If you want to use a legacy router provider, you can pass them to the `<Refine />` component using the `legacyRouterProvider` prop.

[expo-router]: https://www.npmjs.com/package/@refinenative/expo-router
[react-router]: https://github.com/refinedev/refine/tree/main/packages/react-router
[nextjs-router]: https://github.com/refinedev/refine/tree/main/packages/nextjs-router
[remix-router]: https://github.com/refinedev/refine/tree/main/packages/remix-router

================
File: ui-integrations/ant-design/components/auth-page/index.md
================
---
title: <AuthPage />
description: <AuthPage> component from Refine is an authentication page that can be used to login, register, forgot password, and update password.
swizzle: true
source: packages/antd/src/components/pages/auth/index.tsx
---

`<AuthPage>` component from Refine for **Ant Design** contains authentication pages that can be used for the login, register, forgot password, and update password actions.

Before using `<AuthPage>` component you need to add [authProvider](/docs/authentication/auth-provider) that will be used to handle authentication.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

```tsx live  shared
const { useNavigation: useNavigationShared, useLogout: useLogoutShared } =
  RefineCore;
const {
  Typography: { Title: SharedTitle },
  Button,
} = AntdCore;

window.__refineAuthStatus = false;

const authProvider = {
  login: () => {
    window.__refineAuthStatus = true;
    return {
      success: true,
      redirectTo: "/",
    };
  },
  register: async () => {
    return {
      success: true,
    };
  },
  forgotPassword: async () => {
    return {
      success: true,
    };
  },
  updatePassword: async () => {
    return {
      success: true,
    };
  },
  logout: async () => {
    window.__refineAuthStatus = false;
    return {
      success: true,
      redirectTo: "/",
    };
  },
  check: async () => {
    return {
      authenticated: window.__refineAuthStatus ? true : false,
      redirectTo: window.__refineAuthStatus ? undefined : "/login",
    };
  },
  onError: async (error) => {
    console.error(error);
    return { error };
  },
  getPermissions: async () => null,
  getIdentity: async () => null,
};

const DashboardPage = () => {
  const { mutate } = useLogoutShared();

  return (
    <div
      style={{
        width: "100%",
        maxWidth: "400px",
        margin: "0 auto",
        textAlign: "center",
      }}
    >
      <SharedTitle level={2}>Home Page</SharedTitle>
      <br />
      <button
        onClick={() => {
          mutate();
        }}
      >
        Logout
      </button>
    </div>
  );
};

const GoogleIcon = (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      fill="#fff"
      d="m23.7 12.3-.1-2.3H12.3v4.5h6.4a5.6 5.6 0 0 1-2.4 3.6v3h3.9c2.2-2.1 3.5-5.2 3.5-8.8Z M12.3 24c3.2 0 6-1 7.9-3l-3.9-3a7.2 7.2 0 0 1-10.8-3.7h-4v3c2 4 6 6.7 10.8 6.7Z M5.5 14.3a7 7 0 0 1 0-4.6v-3h-4a11.9 11.9 0 0 0 0 10.7l4-3.1Z M12.3 4.8c1.7 0 3.3.6 4.6 1.8L20.3 3A12 12 0 0 0 1.6 6.6l4 3.1c.9-2.8 3.5-5 6.7-5Z"
    />
  </svg>
);

const GithubIcon = (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      fill="#fff"
      d="M12 0a12 12 0 0 0-3.8 23.4c.6.1.8-.3.8-.6v-2.2c-3.3.7-4-1.4-4-1.4-.6-1.4-1.4-1.8-1.4-1.8-1-.7.1-.7.1-.7 1.2 0 1.9 1.2 1.9 1.2 1 1.8 2.8 1.3 3.4 1 .2-.8.5-1.3.8-1.6-2.7-.3-5.5-1.3-5.5-6 0-1.2.5-2.3 1.3-3.1-.1-.4-.6-1.6.1-3.2 0 0 1-.3 3.3 1.2a11.5 11.5 0 0 1 6 0C17.3 4.7 18.3 5 18.3 5c.7 1.6.2 2.9.1 3.2.8.8 1.3 1.9 1.3 3.2 0 4.6-2.9 5.6-5.5 5.9.4.4.8 1.1.8 2.2v3.3c0 .3.2.7.8.6A12 12 0 0 0 12 0z"
    />
  </svg>
);
```

## Usage

The `<AuthPage>` component can be used like this:

```tsx live url=http://localhost:3000/login previewHeight=600px
setInitialRoutes(["/login"]);
setRefineProps({ Sider: () => null });

// visible-block-start
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import { AuthPage, ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import routerProvider, {
  CatchAllNavigate,
  NavigateToResource,
} from "@refinedev/react-router";

import { ConfigProvider } from "antd";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "./authProvider";
import { DashboardPage } from "./pages/dashboard";

const App = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          routerProvider={routerProvider}
          authProvider={authProvider}
        >
          <Routes>
            <Route
              element={
                <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                  <ThemedLayoutV2>
                    <Outlet />
                  </ThemedLayoutV2>
                </Authenticated>
              }
            >
              <Route index element={<DashboardPage />} />
            </Route>
            <Route
              element={
                <Authenticated fallback={<Outlet />}>
                  <NavigateToResource />
                </Authenticated>
              }
            >
              {/* highlight-start */}
              <Route path="/login" element={<AuthPage type="login" />} />
              {/* highlight-end */}
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};
// visible-block-end
render(<App />);
```

## Types

The `<AuthPage>` component has the following types:

- [`login`](#login) - a type of login page and default type.
- [`register`](#register) - a type of registration page.
- [`forgotPassword`](#forgotpassword) - a type of forgot password page.
- [`updatePassword`](#updatepassword) - a type of update password page.

### Login

`login` will be used as the default type of the `<AuthPage>` component. The login page will be used to log in to the system.

```tsx live hideCode url=http://localhost:3000/login previewHeight=600px
setInitialRoutes(["/login"]);
setRefineProps({ Sider: () => null });

// visible-block-start
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, {
  CatchAllNavigate,
  NavigateToResource,
} from "@refinedev/react-router";

import { AuthPage, ThemedLayoutV2, RefineThemes } from "@refinedev/antd";

import { ConfigProvider } from "antd";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "./authProvider";

import { DashboardPage } from "pages/dashboard";

const App = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          routerProvider={routerProvider}
          authProvider={authProvider}
        >
          <Routes>
            <Route
              element={
                <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                  <ThemedLayoutV2>
                    <Outlet />
                  </ThemedLayoutV2>
                </Authenticated>
              }
            >
              <Route index element={<DashboardPage />} />
            </Route>
            <Route
              element={
                <Authenticated fallback={<Outlet />}>
                  <NavigateToResource />
                </Authenticated>
              }
            >
              {/* highlight-next-line */}
              <Route path="/login" element={<AuthPage />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};
// visible-block-end
render(<App />);
```

After form submission, the [`login`][login] method of the [`authProvider`][auth-provider] will be called with the form values.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // --
  login: async ({ email, password, remember, providerName }) => {
    // You can handle the login process according to your needs.

    // If the process is successful.
    return {
      success: true,
    };

    return {
      success: false,
      error: {
        name: "Login Error",
        message: "Invalid email or password",
      },
    };
  },
  // --
};
```

### Register

The register page will be used to register new users. You can use the following props for the `<AuthPage>` component when the type is `"register"`:

```tsx live hideCode url=http://localhost:3000/register previewHeight=600px
setInitialRoutes(["/register"]);
setRefineProps({ Sider: () => null });

// visible-block-start
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, {
  CatchAllNavigate,
  NavigateToResource,
} from "@refinedev/react-router";

import { AuthPage, ThemedLayoutV2, RefineThemes } from "@refinedev/antd";

import { ConfigProvider } from "antd";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "./authProvider";

import { DashboardPage } from "pages/dashboard";

const App = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
          routerProvider={routerProvider}
          authProvider={authProvider}
        >
          <Routes>
            <Route
              element={
                <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                  <ThemedLayoutV2>
                    <Outlet />
                  </ThemedLayoutV2>
                </Authenticated>
              }
            >
              <Route index element={<DashboardPage />} />
            </Route>
            <Route
              element={
                <Authenticated fallback={<Outlet />}>
                  <NavigateToResource />
                </Authenticated>
              }
            >
              <Route path="/login" element={<AuthPage />} />
              {/* highlight-next-line */}
              <Route path="/register" element={<AuthPage type="register" />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};
// visible-block-end
render(<App />);
```

After form submission, the [`register`][register] method of the [`authProvider`][auth-provider] will be called with the form values.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // --
  register: async ({ email, password, providerName }) => {
    // You can handle the register process according to your needs.

    // If the process is successful.
    return {
      success: true,
    };

    return {
      success: false,
      error: {
        name: "Register Error",
        message: "Invalid email or password",
      },
    };
  },
  // --
};
```

### ForgotPassword

The `forgotPassword` type is a page that allows users to reset their passwords. You can use this page to reset your password.

```tsx live hideCode url=http://localhost:3000/forgot-password previewHeight=600px
setInitialRoutes(["/forgot-password"]);
setRefineProps({ Sider: () => null });

// visible-block-start
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, {
  CatchAllNavigate,
  NavigateToResource,
} from "@refinedev/react-router";

import { AuthPage, ThemedLayoutV2, RefineThemes } from "@refinedev/antd";

import { ConfigProvider } from "antd";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "./authProvider";

import { DashboardPage } from "pages/dashboard";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        routerProvider={routerProvider}
        authProvider={authProvider}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              </Authenticated>
            }
          >
            <Route index element={<DashboardPage />} />
          </Route>
          <Route
            element={
              <Authenticated fallback={<Outlet />}>
                <NavigateToResource />
              </Authenticated>
            }
          >
            <Route path="/login" element={<AuthPage />} />
            <Route path="/register" element={<AuthPage type="register" />} />
            {/* highlight-next-line */}
            <Route
              path="/forgot-password"
              element={<AuthPage type="forgotPassword" />}
            />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
// visible-block-end
render(<App />);
```

After form submission, the [`forgotPassword`][forgot-password] method of the [`authProvider`][auth-provider] will be called with the form values.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // --
  forgotPassword: async ({ email }) => {
    // You can handle the reset password process according to your needs.

    // If the process is successful.
    return {
      success: true,
    };

    return {
      success: false,
      error: {
        name: "Register Error",
        message: "Invalid email",
      },
    };
  },
  // --
};
```

### UpdatePassword

The `updatePassword` type is the page used to update the password of the user.

```tsx live hideCode url=http://localhost:3000/update-password previewHeight=600px
setInitialRoutes(["/update-password"]);
setRefineProps({ Sider: () => null });

// visible-block-start
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, {
  CatchAllNavigate,
  NavigateToResource,
} from "@refinedev/react-router";

import { AuthPage, ThemedLayoutV2, RefineThemes } from "@refinedev/antd";

import { ConfigProvider } from "antd";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import { authProvider } from "./authProvider";

import { DashboardPage } from "pages/dashboard";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
        routerProvider={routerProvider}
        authProvider={authProvider}
      >
        <Routes>
          <Route
            element={
              <Authenticated fallback={<CatchAllNavigate to="/login" />}>
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              </Authenticated>
            }
          >
            <Route index element={<DashboardPage />} />
          </Route>
          <Route
            element={
              <Authenticated fallback={<Outlet />}>
                <NavigateToResource />
              </Authenticated>
            }
          >
            <Route path="/login" element={<AuthPage />} />
            <Route path="/register" element={<AuthPage type="register" />} />
            <Route
              path="/forgot-password"
              element={<AuthPage type="forgotPassword" />}
            />
            {/* highlight-next-line */}
            <Route
              path="/update-password"
              element={<AuthPage type="updatePassword" />}
            />
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
// visible-block-end
render(<App />);
```

After form submission, the [`updatePassword`][update-password] method of the [`authProvider`][auth-provider] will be called with the form values.

```tsx title="src/authProvider.ts"
import { AuthProvider } from "@refinedev/core";

const authProvider: AuthProvider = {
  // --
  updatePassword: async ({ password, confirmPassword }) => {
    // You can handle the update password process according to your needs.

    // If the process is successful.
    return {
      success: true,
    };

    return {
      success: false,
      error: {
        name: "Login Error",
        message: "Invalid email or password",
      },
    };
  },
  // --
};
```

## Props

### hideForm

When you set `hideForm` to `true`, the form will be hidden. You can use this property to show only providers.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login" // or "register"
      hideForm={true}
      providers={[
        {
          name: "google",
          icon: GoogleIcon,
          label: "Sign in with Google",
        },
        {
          name: "github",
          icon: GithubIcon,
          label: "Sign in with GitHub",
        },
      ]}
    />
  );
};
```

### providers

The `providers` property defines the list of providers used to handle login authentication. `providers` accepts an array of `Provider` type. This property is only available for types `login` and `register`.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      providers={[
        {
          name: "google",
          icon: GoogleIcon,
          label: "Sign in with Google",
        },
        {
          name: "github",
          icon: GithubIcon,
          label: "Sign in with GitHub",
        },
      ]}
    />
  );
};
```

> For more information, refer to the [Interface section &#8594](#interface)

### rememberMe

The `rememberMe` property defines to render your custom `<RememberMe>` component or you can pass `false` to don't render it. This property is only available for type `login`.

You have to wrap your custom `<RememberMe>` component with the `Form.Item` component from **Ant Design** and pass the `name` prop to it then you can access its value from the `formProps` `onFinish` function with `formValues`.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      rememberMe={
        <div
          style={{
            border: "1px dashed cornflowerblue",
            padding: 3,
          }}
        >
          <Form.Item name="remember" valuePropName="checked" noStyle>
            <Checkbox>Custom remember me</Checkbox>
          </Form.Item>
        </div>
      }
      // highlight-end
    />
  );
};
```

### loginLink

The `loginLink` property defines the link to the login page and also you can give a node to render. The default value is `"/login"`. This property is only available for type `register` and `forgotPassword`.

```tsx
const MyRegisterPage = () => {
  return (
    <AuthPage
      type="register"
      // highlight-start
      loginLink={
        <div
          style={{
            border: "1px dashed cornflowerblue",
            padding: 3,
          }}
        >
          <Link to="/login">Login</Link>
        </div>
      }
      // highlight-end
    />
  );
};
```

### registerLink

The `registerLink` property defines the link to the registration page and also you can give a node to render. The default value is `"/register"`. This property is only available for type `login`.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      registerLink={
        <div
          style={{
            border: "1px dashed cornflowerblue",
            marginTop: 5,
            padding: 5,
          }}
        >
          <Link to="/register">Register</Link>
        </div>
      }
      // highlight-end
    />
  );
};
```

### forgotPasswordLink

The `forgotPasswordLink` property defines the link to the forgot password page and also you can give a node to render. Its default value is `"/forgot-password"`. This property is only available for type `login`.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      forgotPasswordLink={
        <div
          style={{
            border: "1px dashed cornflowerblue",
            marginTop: 5,
            padding: 5,
          }}
        >
          <Link to="/forgot-password">Forgot Password</Link>
        </div>
      }
      // highlight-end
    />
  );
};
```

### wrapperProps

The `wrapperProps` is used for passing props to the wrapper component. In the example below you can see that the background color is changed with `wrapperProps`

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      wrapperProps={{
        style: {
          background: "#331049",
        },
      }}
      // highlight-end
    />
  );
};
```

### contentProps

The `contentProps` is used for passing props to the content component which is the card component. In the example below, you can see that the title, header, and content styles are changed with `contentProps`.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      contentProps={{
        title: "Login",
        headStyle: {
          background: "cornflowerblue",
          color: "white",
        },
        bodyStyle: {
          background: "#673ab742",
        },
      }}
      // highlight-end
    />
  );
};
```

### formProps

The `formProps` is used for passing props to the form component. In the example below you can see that the `initialValues` are changed with `formProps` and also the `onFinish` function is changed.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      formProps={{
        initialValues: {
          email: "demo@refine.dev",
          password: "demo",
        },
        onFinish: (formValues) => alert(JSON.stringify(formValues, null, 2)),
      }}
      // highlight-end
    />
  );
};
```

### title

By default, `AuthPage` uses text with icon on top of page. You can use this property to change the default title.

- Default text is: Refine Project
- Default icon is: Refine Logo

```tsx
import { AuthPage, ThemedTitle } from "@refinedev/antd";

const MyLoginPage = () => {
  return <AuthPage type="login" title={<h1>My Title</h1>} />;
};
```

Or you can customize the title with the `ThemedTitle` component.

```tsx
import { AuthPage } from "@refinedev/antd";

const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      title={
        <ThemedTitleV2
          title="My Title"
          icon={<img src="https://refine.dev/img/logo.png" />}
        />
      }
    />
  );
};
```

### renderContent

`renderContent` is used to render the form content and the [title](#title). You can use this property to render your own content, or change the default content and title that it gives you.

```tsx
import { AuthPage } from "@refinedev/antd";

const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      renderContent={(content: React.ReactNode, title: React.ReactNode) => {
        return (
          <div
            style={{
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              alignItems: "center",
            }}
          >
            {title}
            <h1 style={{ color: "white" }}>Extra Header</h1>
            {content}
            <h1 style={{ color: "white" }}>Extra Footer</h1>
          </div>
        );
      }}
      // highlight-end
    />
  );
};
```

### mutationVariables

`mutationVariables` is used to pass additional variables to the `authProvider` methods.

```tsx
const MyLoginPage = () => {
  return (
    <AuthPage
      type="login" // all other types are also supported.
      // highlight-start
      mutationVariables={{
        foo: "bar",
        xyz: "abc",
      }}
      // highlight-end
    />
  );
};

// all mutation methods are supported.
const authProvider = {
  login: async ({ foo, xyz, ...otherProps }) => {
    console.log(foo); // bar
    console.log(xyz); // abc
    // ...
  },
  register: async ({ foo, xyz, ...otherProps }) => {
    console.log(foo); // bar
    console.log(xyz); // abc
    // ...
  },
  // ...
};
```

## FAQ

### How can I remove the default title and logo ?

You can use the `renderContent` property to remove the default title and logo.

```tsx
import { AuthPage } from "@refinedev/antd";

const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      renderContent={(
        content: React.ReactNode,
        title: React.ReactNode, // not return
      ) => {
        return content;
      }}
      // highlight-end
    />
  );
};
```

Or you can give `false` to the `title` property to remove the default title.

```tsx
import { AuthPage } from "@refinedev/antd";

const MyLoginPage = () => {
  return (
    <AuthPage
      type="login"
      // highlight-start
      title={false}
      // highlight-end
    />
  );
};
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/AuthPage"
formProps-type="[`FormProps`](https://ant.design/components/form/#API)"
wrapperProps-type="[`WrapperProps`](https://ant.design/components/layout/#API)"
contentProps-type="[`CardProps`](https://ant.design/components/card/#API)"
rememberMe-default="[`<Checkbox>Remember me</Checkbox>`](/docs/ui-integrations/ant-design/components/auth-page#rememberme)"
/>

### Interface

```tsx
interface OAuthProvider {
  name: string;
  icon?: React.ReactNode;
  label?: string;
}
```

[auth-provider]: /docs/authentication/auth-provider
[login]: /docs/authentication/auth-provider#login-
[register]: /docs/authentication/auth-provider#register
[forgot-password]: /docs/authentication/auth-provider#forgotpassword
[update-password]: /docs/authentication/auth-provider#updatepassword

================
File: ui-integrations/ant-design/components/auto-save-indicator/index.md
================
---
title: <AutoSaveIndicator />
description: <AutoSaveIndicator> component shows `autoSave` status on edit actions.
source: packages/antd/src/components/autoSaveIndicator/index.tsx
---

`<AutoSaveIndicator>` component from Refine for **Ant Design** can be used to communicate auto-save status to the user.

:::simple Good to know

This component is an extended version of the [`<AutoSaveIndicator>`](/docs/core/components/auto-save-indicator) component from Refine's core package. It provides a set of elements which align with Ant Design's components and styling.

:::

## Usage

```tsx
import { AutoSaveIndicator, useForm } from "@refinedev/antd";

const MyComponent = () => {
  const { autoSaveProps } = useForm({
    refineCoreProps: {
      autoSave: {
        enabled: true,
      },
    },
  });

  console.log(autoSaveProps);
  /*
    {
      status: "success",  // "loading" | "error" | "idle" | "success"
      error: null,        // HttpError | null
      data: { ... },      // UpdateResponse | undefined,
    }
  */

  return <AutoSaveIndicator {...autoSaveProps} />;
};
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/AutoSaveIndicator" />

================
File: ui-integrations/ant-design/components/basic-views/create/index.md
================
---
title: Create
swizzle: true
---

`<Create>` provides us a layout to display the page. It does not contain any logic but adds extra functionalities like action buttons and giving titles to the page.

We will show what `<Create>` does using properties with examples.

```tsx live hideCode url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}

// visible-block-start
import { Create, useForm, useSelect } from "@refinedev/antd";
import { Form, Input, Select } from "antd";

const PostCreate: React.FC = () => {
  const { formProps, saveButtonProps } = useForm<IPost>();

  const { selectProps: categorySelectProps } = useSelect<ICategory>({
    resource: "categories",
  });

  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input />
        </Form.Item>
        <Form.Item
          label="Category"
          name={["category", "id"]}
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Select {...categorySelectProps} />
        </Form.Item>
        <Form.Item
          label="Status"
          name="status"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Select
            options={[
              {
                label: "Published",
                value: "published",
              },
              {
                label: "Draft",
                value: "draft",
              },
              {
                label: "Rejected",
                value: "rejected",
              },
            ]}
          />
        </Form.Item>
      </Form>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Properties

### title

`title` allows you to add a title inside the `<Create>` component. If you don't pass the title props, it uses the "Create" prefix and the singular resource name by default. For example, for the `/posts/create` resource, it would be "Create post".

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";

const PostCreate: React.FC = () => {
  return (
    /* highlight-next-line */
    <Create title="Custom Title">
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### saveButtonProps

The `<Create>` component has a save button that submits the form by default. If you want to customize this button you can use the `saveButtonProps` property:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";

const PostCreate: React.FC = () => {
  return (
    /* highlight-next-line */
    <Create saveButtonProps={{ size: "small" }}>
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`<SaveButton>` documentation &#8594](/docs/ui-integrations/ant-design/components/buttons/save-button)

### resource

The `<Create>` component reads the `resource` information from the route by default. If you want to use a custom resource for the `<Create>` component, you can use the `resource` prop:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";

// visible-block-start
import { Create } from "@refinedev/antd";

const CustomPage: React.FC = () => {
  return (
    /* highlight-next-line */
    <Create resource="posts">
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<CustomPage />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### goBack

To customize the back button or to disable it, you can use the `goBack` property:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";
import { Button } from "antd";

const PostCreate: React.FC = () => {
  const BackButton = () => <Button>←</Button>;
  return (
    /* highlight-next-line */
    <Create goBack={<BackButton />}>
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

If your route has no `:action` parameter or your action is `list`, the back button will _not_ be shown even if you pass a `goBack` property. You can override this behavior by using the `headerProps` property:

```tsx
/* highlight-next-line */
import { useBack } from "@refinedev/core";
import { Create } from "@refinedev/antd";
import { Button } from "antd";

const PostCreate: React.FC = () => {
  /* highlight-next-line */
  const back = useBack();
  const BackButton = () => <Button>←</Button>;

  return (
    /* highlight-next-line */
    <Create goBack={<BackButton />} headerProps={{ onBack: back }}>
      <p>Rest of your page here</p>
    </Create>
  );
};
```

### isLoading

To toggle the loading state of the `<Create/>` component, you can use the `isLoading` property:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";

const PostCreate: React.FC = () => {
  return (
    /* highlight-next-line */
    <Create isLoading={true}>
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### breadcrumb <GlobalConfigBadge id="core/refine-component/#breadcrumb" />

To customize or disable the breadcrumb, you can use the `breadcrumb` property. By default the `Breadcrumb` component from the `@refinedev/antd` package is used for breadcrumbs.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create, Breadcrumb } from "@refinedev/antd";

const PostCreate: React.FC = () => {
  return (
    <Create
      // highlight-start
      breadcrumb={
        <div
          style={{
            padding: "3px 6px",
            border: "2px dashed cornflowerblue",
          }}
        >
          <Breadcrumb />
        </div>
      }
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Breadcrumb` documentation &#8594](/docs/ui-integrations/ant-design/components/breadcrumb)

### wrapperProps

You can use the `wrapperProps` property if you want to customize the wrapper of the `<Create/>` component. The `@refinedev/antd` wrapper elements are simply `<div/>`s and `wrapperProps` and can get every attribute that `<div/>` can get.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";

const PostCreate: React.FC = () => {
  return (
    <Create
      // highlight-start
      wrapperProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### headerProps

You can use the `headerProps` property to customize the header of the `<Create/>` component:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";

const PostCreate: React.FC = () => {
  return (
    <Create
      // highlight-start
      headerProps={{
        subTitle: "This is a subtitle",
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`PageHeader` documentation &#8594](https://procomponents.ant.design/en-US/components/page-header)

### contentProps

You can use the `contentProps` property to customize the content of the `<Create/>` component:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";

const PostCreate: React.FC = () => {
  return (
    <Create
      // highlight-start
      contentProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Card` documentation &#8594](https://ant.design/components/card/)

### headerButtons

You can customize the buttons at the header by using the `headerButtons` property. It accepts `React.ReactNode` or a render function `({ defaultButtons }) => React.ReactNode` which you can use to keep the existing buttons and add your own.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";
import { Button } from "antd";

const PostCreate: React.FC = () => {
  return (
    <Create
      // highlight-start
      headerButtons={({ defaultButtons }) => (
        <>
          {defaultButtons}
          <Button type="primary">Custom Button</Button>
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### headerButtonProps

You can use the `headerButtonProps` property to customize the wrapper element of the buttons at the header:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";
import { Button } from "antd";

const PostCreate: React.FC = () => {
  return (
    <Create
      // highlight-start
      headerButtonProps={{
        style: {
          // hide-start
          float: "right",
          marginRight: 24,
          // hide-end
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
      headerButtons={<Button type="primary">Custom Button</Button>}
    >
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Space` documentation &#8594](https://ant.design/components/space/)

### footerButtons

By default, the `<Create/>` component has a [`<SaveButton>`][save-button] at the footer.

You can customize the buttons at the footer by using the `footerButtons` property. It accepts `React.ReactNode` or a render function `({ defaultButtons, saveButtonProps }) => React.ReactNode` which you can use to keep the existing buttons and add your own.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";
import { Button } from "antd";

const PostCreate: React.FC = () => {
  return (
    <Create
      // highlight-start
      footerButtons={({ defaultButtons }) => (
        <>
          {defaultButtons}
          <Button type="primary">Custom Button</Button>
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Or, instead of using the `defaultButtons`, you can create your own buttons. If you want, you can use `saveButtonProps` to utilize the default values of the [`<SaveButton>`][save-button] component.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create, SaveButton } from "@refinedev/antd";
import { Button } from "antd";

const PostCreate: React.FC = () => {
  return (
    <Create
      // highlight-start
      footerButtons={({ saveButtonProps }) => (
        <>
          <SaveButton
            {...saveButtonProps}
            type="primary"
            style={{ marginRight: 8 }}
          >
            Save
          </SaveButton>
          <Button type="primary">Custom Button</Button>
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### footerButtonProps

You can customize the wrapper element of the buttons at the footer by using the `footerButtonProps` property.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/create
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { Create } from "@refinedev/antd";
import { Button } from "antd";

const PostCreate: React.FC = () => {
  return (
    <Create
      // highlight-start
      footerButtonProps={{
        style: {
          // hide-start
          float: "right",
          marginRight: 24,
          // hide-end
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.CreateButton />
              </div>
            }
          />
          <ReactRouter.Route path="create" element={<PostCreate />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Space` documentation &#8594](https://ant.design/components/space/)

## API Reference

### Properties

<PropsTable module="@refinedev/antd/Create" goBack-default="`<ArrowLeft />`" headerProps-type="[`PageHeaderProps`](https://procomponents.ant.design/en-US/components/page-header)" />

[save-button]: /docs/ui-integrations/ant-design/components/buttons/save-button

</rewritten_file>

================
File: ui-integrations/ant-design/components/basic-views/edit/index.md
================
---
title: Edit
swizzle: true
---

`<Edit>` provides us a layout for displaying the page. It does not contain any logic but adds extra functionalities like a refresh button.

We will show what `<Edit>` does using properties with examples.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/custom/123
setInitialRoutes(["/custom/123"]);

// visible-block-start
import { Edit } from "@refinedev/antd";

const CustomPage: React.FC = () => {
  return (
    /* highlight-next-line */
    <Edit resource="posts">
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/custom/:id"
          element={
            <div style={{ padding: 16 }}>
              <CustomPage />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::tip
The example above shows how to use the `resource` prop when the component is rendered on a custom page with a different route than the resource route.
:::

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Properties

### title

`title` allows you to add a title inside the `<Edit>` component. If you don't pass title props, it uses the "Edit" prefix and the singular resource name by default. For example, for the "posts" resource, it will be "Edit post".

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

// visible-block-start
import { Edit } from "@refinedev/antd";

const PostEdit: React.FC = () => {
  return (
    /* highlight-next-line */
    <Edit title="Custom Title">
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### saveButtonProps

The `<Edit>` component has a save button that submits the form by default. If you want to customize this button you can use the `saveButtonProps` property:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

// visible-block-start
import { Edit } from "@refinedev/antd";

const PostEdit: React.FC = () => {
  return (
    /* highlight-next-line */
    <Edit saveButtonProps={{ size: "small" }}>
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`<SaveButton>` documentation &#8594](/docs/ui-integrations/ant-design/components/buttons/save-button)

### canDelete and deleteButtonProps

`canDelete` allows you to add a delete button inside the `<Edit>` component. This button uses the `useDelete` method provided by the `dataProvider`

If you want to customize this button you can use the `deleteButtonProps` property like the code below.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}

import { Edit } from "@refinedev/antd";
import { usePermissions } from "@refinedev/core";

// visible-block-start
const PostEdit: React.FC = () => {
  const { data: permissionsData } = usePermissions();
  return (
    <Edit
      /* highlight-start */
      canDelete={permissionsData?.includes("admin")}
      deleteButtonProps={{ size: "small" }}
      /* highlight-end */
      saveButtonProps={{ size: "small" }}
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`<DeleteButton>` documentation &#8594](/docs/ui-integrations/ant-design/components/buttons/delete-button)

> For more information, refer to the [`usePermission` documentation &#8594](/docs/authentication/hooks/use-permissions)

### resource

The `<Edit>` component reads the `resource` information from the route by default. If you want to use a custom resource for the `<Edit>` component, you can use the `resource` prop:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/custom/123
setInitialRoutes(["/custom/123"]);

// visible-block-start
import { Edit } from "@refinedev/antd";

const CustomPage: React.FC = () => {
  return (
    /* highlight-next-line */
    <Edit resource="posts">
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/custom/:id"
          element={
            <div style={{ padding: 16 }}>
              <CustomPage />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::tip
The example above shows how to use the `resource` prop when the component is rendered on a custom page with a different route than the resource route.
:::

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### recordItemId

The `<Edit>` component reads the `id` information from the route by default. When it cannot be read from the URL, which happens when it's used on a custom page, modal or drawer, `recordItemId` is used.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit, useModalForm } from "@refinedev/antd";
import { Modal, Button } from "antd";

// visible-block-start
const PostEdit: React.FC = () => {
  const { modalProps, id, show } = useModalForm({
    action: "edit",
  });

  return (
    <div>
      <Button onClick={() => show()}>Edit Button</Button>
      <Modal {...modalProps}>
        {/* highlight-next-line */}
        <Edit recordItemId={id}>
          <p>Rest of your page here</p>
        </Edit>
      </Modal>
    </div>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

The `<Edit>` component needs the `id` information for the `<RefreshButton>` to work properly.

### mutationMode

Determines which mode mutation will have while executing `<DeleteButton>` .

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit } from "@refinedev/antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit mutationMode="undoable" saveButtonProps={{ size: "small" }}>
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [mutation mode documentation &#8594](/docs/advanced-tutorials/mutation-mode)

### dataProviderName

If not specified, Refine will use the default data provider. If you have multiple data providers, you can use the `dataProviderName` property to specify which one you want to use:

```tsx
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";

import { Edit } from "@refinedev/antd";

// highlight-start
const PostEdit = () => {
  return <Edit dataProviderName="other">...</Edit>;
};
// highlight-end

export const App: React.FC = () => {
  return (
    <Refine
      // highlight-start
      dataProvider={{
        default: dataProvider("https://api.fake-rest.refine.dev/"),
        other: dataProvider("https://other-api.fake-rest.refine.dev/"),
      }}
      // highlight-end
    >
      {/* ... */}
    </Refine>
  );
};
```

### goBack

To customize the back button or to disable it, you can use the `goBack` property:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit } from "@refinedev/antd";
import { Button } from "antd";

// visible-block-start
const PostEdit: React.FC = () => {
  const BackButton = () => <Button>←</Button>;
  return (
    /* highlight-next-line */
    <Edit goBack={<BackButton />}>
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

If your route has no `:action` parameter or your action is `list`, the back button will not be shown even if you pass a `goBack` property. You can override this behavior by using the `headerProps` property:

```tsx
import { useBack } from "@refinedev/core";
import { Edit } from "@refinedev/antd";
import { Button } from "antd";

const PostEdit: React.FC = () => {
  const back = useBack();
  const BackButton = () => <Button>←</Button>;

  return (
    <Edit goBack={<BackButton />} headerProps={{ onBack: back }}>
      <p>Rest of your page here</p>
    </Edit>
  );
};
```

### isLoading

To toggle the loading state of the `<Edit/>` component, you can use the `isLoading` property:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit } from "@refinedev/antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    /* highlight-next-line */
    <Edit isLoading={true}>
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### breadcrumb <GlobalConfigBadge id="core/refine-component/#breadcrumb" />

To customize or disable the breadcrumb, you can use the `breadcrumb` property. By default the `Breadcrumb` component from the `@refinedev/antd` package is used for breadcrumbs.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit, Breadcrumb } from "@refinedev/antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit
      // highlight-start
      breadcrumb={
        <div
          style={{
            padding: "3px 6px",
            border: "2px dashed cornflowerblue",
          }}
        >
          <Breadcrumb />
        </div>
      }
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Breadcrumb` documentation &#8594](/docs/ui-integrations/ant-design/components/breadcrumb)

### wrapperProps

You can use the `wrapperProps` property if you want to customize the wrapper of the `<Edit/>` component. The `@refinedev/antd` wrapper elements are simply `<div/>`s and `wrapperProps` and can get every attribute that `<div/>` can get.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit } from "@refinedev/antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit
      // highlight-start
      wrapperProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### headerProps

You can use the `headerProps` property to customize the header of the `<Edit/>` component:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit } from "@refinedev/antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit
      // highlight-start
      headerProps={{
        subTitle: "This is a subtitle",
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`PageHeader` documentation &#8594](https://procomponents.ant.design/en-US/components/page-header)

### contentProps

You can use the `contentProps` property to customize the content of the `<Edit/>` component:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit } from "@refinedev/antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit
      // highlight-start
      contentProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Card` documentation &#8594](https://ant.design/components/card/)

### headerButtons

By default, the `<Edit/>` component has a [`<ListButton>`][list-button] and a [`<RefreshButton>`][refresh-button] at the header.

You can customize the buttons at the header by using the `headerButtons` property. It accepts `React.ReactNode` or a render function `({ defaultButtons, refreshButtonProps, listButtonProps }) => React.ReactNode` which you can use to keep the existing buttons and add your own.

If the "list" resource is not defined, the [`<ListButton>`][list-button] will not render and `listButtonProps` will be `undefined`.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit } from "@refinedev/antd";
import { Button } from "antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit
      // highlight-start
      headerButtons={({ defaultButtons }) => (
        <>
          {defaultButtons}
          <Button type="primary">Custom Button</Button>
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Or, instead of using the `defaultButtons`, you can create your own buttons. If you want, you can use `refreshButtonProps` and `listButtonProps` to utilize the default values of the `<ListButton>`[list-button] and `<RefreshButton>`[refresh-button] components.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit, ListButton, RefreshButton } from "@refinedev/antd";
import { Button } from "antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit
      // highlight-start
      headerButtons={({ refreshButtonProps, listButtonProps }) => (
        <>
          <Button type="primary">Custom Button</Button>
          <RefreshButton {...refreshButtonProps} meta={{ foo: "bar" }} />
          {listButtonProps && (
            <ListButton {...listButtonProps} meta={{ foo: "bar" }} />
          )}
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### headerButtonProps

You can use the `headerButtonProps` property to customize the wrapper element of the buttons at the header:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit } from "@refinedev/antd";
import { Button } from "antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit
      // highlight-start
      headerButtonProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
      headerButtons={<Button type="primary">Custom Button</Button>}
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### footerButtons

By default, the `<Edit/>` component has a [`<SaveButton>`][save-button] and a [`<DeleteButton>`][delete-button] at the footer.

You can customize the buttons at the footer by using the `footerButtons` property. It accepts `React.ReactNode` or a render function `({ defaultButtons, saveButtonProps, deleteButtonProps }) => React.ReactNode` which you can use to keep the existing buttons and add your own.

If [`canDelete`](#candelete-and-deletebuttonprops) is `false`, the [`<DeleteButton>`][delete-button] will not render and `deleteButtonProps` will be `undefined`.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit } from "@refinedev/antd";
import { Button } from "antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit
      // highlight-start
      footerButtons={({ defaultButtons }) => (
        <>
          {defaultButtons}
          <Button type="primary">Custom Button</Button>
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Or, instead of using the `defaultButtons`, you can create your own buttons. If you want, you can use `saveButtonProps` and `deleteButtonProps` to utilize the default values of the [`<SaveButton>`][save-button] and [`<DeleteButton>`][delete-button] components.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit, SaveButton, DeleteButton } from "@refinedev/antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit
      // highlight-start
      footerButtons={({ saveButtonProps, deleteButtonProps }) => (
        <>
          <SaveButton {...saveButtonProps} hideText />
          {deleteButtonProps && (
            <DeleteButton {...deleteButtonProps} hideText />
          )}
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### footerButtonProps

You can customize the wrapper element of the buttons at the footer by using the `footerButtonProps` property.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

import { Edit } from "@refinedev/antd";

// visible-block-start
const PostEdit: React.FC = () => {
  return (
    <Edit
      // highlight-start
      footerButtonProps={{
        style: {
          float: "right",
          marginRight: 24,
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### autoSaveProps

You can use the auto save feature of the `<Edit/>` component by using the `autoSaveProps` property.

```tsx live url=http://localhost:3000/posts/edit/123
setInitialRoutes(["/posts/edit/123"]);

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}

import { Edit, useForm, useSelect } from "@refinedev/antd";
import { Form, Input, Select } from "antd";

// visible-block-start
const PostEdit: React.FC = () => {
  const { current, gotoStep, stepsProps, formProps, saveButtonProps, query } =
    useStepsForm<IPost>({
      stepsProps: {
        items: [
          {
            title: "First Step",
          },
          {
            title: "Second Step",
          },
        ],
      },
    });

  return (
    <Edit saveButtonProps={saveButtonProps}>
      <Steps {...stepsProps} />
      <Form {...formProps} layout="vertical">
        {current === 0 && (
          <Form.Item
            label="Title"
            name="title"
            rules={[
              {
                required: true,
              },
            ]}
          >
            <Input />
          </Form.Item>
        )}
        {current === 1 && (
          <Form.Item
            label="Content"
            name="content"
            rules={[
              {
                required: true,
              },
            ]}
          >
            <Input.TextArea />
          </Form.Item>
        )}
      </Form>
    </Edit>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.EditButton recordItemId="123">
                  Edit Item 123
                </RefineAntd.EditButton>
              </div>
            }
          />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::tip
The `query` object from the `useForm` hook contains the query result from the data provider. You can use it to access the data returned from the API.

```tsx
const { query } = useForm();
const record = query?.data?.data;
```

The `data.data` structure shown above is the default for the `@refinedev/simple-rest` data provider. This structure may be different for other data providers.
:::

## API Reference

### Properties

<PropsTable module="@refinedev/antd/Edit" />

:::tip External Props
It also accepts all props of Ant Design [Form](https://ant.design/components/form/#API).
:::

### Type Parameters

| Property     | Extends | Default | Description                                                    |
| ------------ | ------- | ------- | -------------------------------------------------------------- |
| TQueryFnData | unknown | unknown | Result data returned by the query function. Extends unknown    |
| TError       | unknown | unknown | Custom error object that extends unknown                       |
| TVariables   | object  | object  | Values for params. default `object`                            |
| TData        | unknown | unknown | Result data returned by the `select` function. Extends unknown |
| TResponse    | unknown | unknown | Result data returned by the mutation function. Extends unknown |

### Return values

| Property            | Description                                                                                                            |
| ------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| `queryResult`       | If the `queryResult` prop is given, it will be returned. Otherwise, it will return `undefined`.                        |
| `mutationResult`    | Mutation result from `react-query`. [Check here →](https://tanstack.com/query/latest/docs/react/reference/useMutation) |
| `saveButtonProps`   | Props for a save button.                                                                                               |
| `cancelButtonProps` | Props for a cancel button.                                                                                             |
| `deleteButtonProps` | Props for a delete button.                                                                                             |
| `formProps`         | Props for the `<Form>` component.                                                                                      |
| `formLoading`       | Loading state of form.                                                                                                 |
| `setId`             | `id` setter.                                                                                                           |
| `id`                | Record id for edit action. The record to edit.                                                                         |
| `defaultValues`     | Default form values.                                                                                                   |
| `formValues`        | Form values.                                                                                                           |
| `submit`            | Submit method, the parameter is the values to update a record.                                                         |
| `reset`             | Reset method, reset the form values to initial values.                                                                 |
| `redirect`          | Redirect function, will be called after form is submitted successfully.                                                |
| `goBack`            | Go back function, will be called when the cancel button is clicked.                                                    |
| `query`             | Query result from `react-query`. [Check here →](https://tanstack.com/query/latest/docs/react/reference/useQuery)       |

[list-button]: /docs/ui-integrations/ant-design/components/buttons/list-button
[refresh-button]: /docs/ui-integrations/ant-design/components/buttons/refresh-button
[save-button]: /docs/ui-integrations/ant-design/components/buttons/save-button
[delete-button]: /docs/ui-integrations/ant-design/components/buttons/delete-button

================
File: ui-integrations/ant-design/components/basic-views/list/index.md
================
---
title: List
swizzle: true
---

`<List>` provides us a layout to display the page. It does not contain any logic but adds extra functionalities like a create button or giving titles to the page.

We will show what `<List>` does using properties with examples.

```tsx live hideCode url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}

// visible-block-start
import { useMany } from "@refinedev/core";

import { List, TextField, TagField, useTable } from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>({
    syncWithLocation: true,
  });

  const categoryIds =
    tableProps?.dataSource?.map((item) => item.category.id) ?? [];
  const { data, isLoading } = useMany<ICategory>({
    resource: "categories",
    ids: categoryIds,
    queryOptions: {
      enabled: categoryIds.length > 0,
    },
  });

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column
          dataIndex={["category", "id"]}
          title="Category"
          render={(value) => {
            if (isLoading) {
              return <TextField value="Loading..." />;
            }

            return (
              <TextField
                value={data?.data.find((item) => item.id === value)?.title}
              />
            );
          }}
        />
        <Table.Column
          dataIndex="status"
          title="Status"
          render={(value: string) => <TagField value={value} />}
        />
      </Table>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Properties

### title

`title` allows you to add a title to the `<List>` component. If you don't pass the title props, it uses plural form of resource name by default.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { List } from "@refinedev/antd";

const PostList: React.FC = () => {
  return (
    /* highlight-next-line */
    <List title="Custom Title">
      <p>Rest of your page here</p>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### resource

The `<List>` component reads the `resource` information from the route by default. If you want to use a custom resource for the `<List>` component, you can use the `resource` prop:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";

// visible-block-start
import { List } from "@refinedev/antd";

const CustomPage: React.FC = () => {
  return (
    /* highlight-next-line */
    <List resource="posts">
      <p>Rest of your page here</p>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<CustomPage />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### canCreate and createButtonProps

`canCreate` allows us to add the create button inside the `<List />` component. If you want to customize this button you can use `createButtonProps` property like the code below:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);
const { Create } = RefineAntd;
const { default: simpleRest } = RefineSimpleRest;

const dataProvider = simpleRest("https://api.fake-rest.refine.dev");

const customDataProvider = {
  ...dataProvider,
  create: async ({ resource, variables }) => {
    return {
      data: {},
    };
  },
};

const authProvider = {
  login: async () => {
    return {
      success: true,
      redirectTo: "/",
    };
  },
  register: async () => {
    return {
      success: true,
    };
  },
  forgotPassword: async () => {
    return {
      success: true,
    };
  },
  updatePassword: async () => {
    return {
      success: true,
    };
  },
  logout: async () => {
    return {
      success: true,
      redirectTo: "/",
    };
  },
  check: async () => ({
    authenticated: true,
  }),
  onError: async (error) => {
    console.error(error);
    return { error };
  },
  getPermissions: async () => ["admin"],
  getIdentity: async () => null,
};

// visible-block-start
import { List } from "@refinedev/antd";
import { usePermissions } from "@refinedev/core";

const PostList: React.FC = () => {
  const { data: permissionsData } = usePermissions();
  return (
    <List
      /* highlight-start */
      canCreate={permissionsData?.includes("admin")}
      createButtonProps={{ size: "small" }}
      /* highlight-end */
    >
      <p>Rest of your page here</p>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      authProvider={authProvider}
      dataProvider={customDataProvider}
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
          <ReactRouter.Route
            path="/posts/create"
            element={<Create>Create Page</Create>}
          />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

The create button redirects to the create page of the resource according to the value it reads from the URL.

> For more information, refer to the [`usePermission` documentation &#8594](/docs/authentication/hooks/use-permissions)

### breadcrumb <GlobalConfigBadge id="core/refine-component/#breadcrumb" />

To customize or disable the breadcrumb, you can use the `breadcrumb` property. By default it uses the `Breadcrumb` component from `@refinedev/antd` package.

[Refer to the `Breadcrumb` documentation for detailed usage. &#8594](/docs/ui-integrations/ant-design/components/breadcrumb)

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);
// visible-block-start
import { List } from "@refinedev/antd";

const CustomBreadcrumb: React.FC = () => {
  return (
    <p
      style={{
        padding: "3px 6px",
        border: "2px dashed cornflowerblue",
      }}
    >
      My Custom Breadcrumb
    </p>
  );
};

const PostList: React.FC = () => {
  return (
    <List
      // highlight-start
      breadcrumb={<CustomBreadcrumb />}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### wrapperProps

You can use the `wrapperProps` property if you want to customize the wrapper of the `<List/>` component. The `@refinedev/antd` wrapper elements are simply `<div/>`s and `wrapperProps` and can get every attribute that `<div/>` can get.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { List } from "@refinedev/antd";

const PostList: React.FC = () => {
  return (
    <List
      // highlight-start
      wrapperProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### headerProps

You can use the `headerProps` property to customize the header of the `<List/>` component:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { List } from "@refinedev/antd";

const PostList: React.FC = () => {
  return (
    <List
      // highlight-start
      headerProps={{
        subTitle: "This is a subtitle",
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`PageHeader` documentation &#8594](https://procomponents.ant.design/en-US/components/page-header)

### contentProps

You can use the `contentProps` property to customize the content of the `<Create/>` component. The `<List/>` components content is wrapped with a `<div/>` and `contentProps` can get every attribute that `<div/>` can get.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { List } from "@refinedev/antd";

const PostList: React.FC = () => {
  return (
    <List
      // highlight-start
      contentProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### headerButtons

By default, the `<List/>` component has a [`<CreateButton>`][create-button] at the header.

You can customize the buttons at the header by using the `headerButtons` property. It accepts `React.ReactNode` or a render function `({ defaultButtons, createButtonProps }) => React.ReactNode` which you can use to keep the existing buttons and add your own.

If the "create" resource is not defined or if [`canCreate`](#cancreate-and-createbuttonprops) is false, the [`<CreateButton>`][create-button] will not render and `createButtonProps`will be `undefined`.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { List } from "@refinedev/antd";
import { Button } from "antd";

const PostList: React.FC = () => {
  return (
    <List
      // highlight-start
      headerButtons={({ defaultButtons }) => (
        <>
          {defaultButtons}
          <Button type="primary">Custom Button</Button>
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Or, instead of using the `defaultButtons`, you can create your own buttons. If you want, you can use `createButtonProps` to utilize the default values of the [`<CreateButton>`][create-button] component.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { List, CreateButton } from "@refinedev/antd";
import { Button } from "antd";

const PostList: React.FC = () => {
  return (
    <List
      // highlight-start
      headerButtons={({ createButtonProps }) => (
        <>
          {createButtonProps && (
            <CreateButton {...createButtonProps} meta={{ foo: "bar" }} />
          )}
          <Button type="primary">Custom Button</Button>
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### headerButtonProps

You can customize the wrapper element of the buttons at the header by using the `headerButtonProps` property.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { List } from "@refinedev/antd";
import { Button } from "antd";

const PostList: React.FC = () => {
  return (
    <List
      // highlight-start
      headerButtonProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
      headerButtons={<Button type="primary">Custom Button</Button>}
    >
      <p>Rest of your page here</p>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Space` documentation &#8594](https://ant.design/components/space/)

## API Reference

### Properties

<PropsTable module="@refinedev/antd/List"
headerProps-type="[`PageHeaderProps`](https://procomponents.ant.design/en-US/components/page-header)"
headerButtonProps-type="[`SpaceProps`](https://ant.design/components/space/)"
createButtonProps-type="[`ButtonProps`](https://ant.design/components/button/#API) & `{ resourceName: string }`"
breadcrumb-default="[`<Breadcrumb>`](https://ant.design/components/breadcrumb/)"
canCreate-default="If the resource is passed a create component, `true` else `false`"
/>

[create-button]: /docs/ui-integrations/ant-design/components/buttons/create-button

================
File: ui-integrations/ant-design/components/basic-views/show/index.md
================
---
title: Show
swizzle: true
---

`<Show>` provides us a layout for displaying the page. It does not contain any logic but adds extra functionalities like a refresh button or giving title to the page.

We will show what `<Show>` does using properties with examples.

```tsx live hideCode url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}

// visible-block-start
import { Show, MarkdownField } from "@refinedev/antd";
import { Typography } from "antd";
import { useShow, useOne } from "@refinedev/core";

const { Title, Text } = Typography;

const PostShow: React.FC = () => {
  const { queryResult } = useShow<IPost>();
  const { data, isLoading } = queryResult;
  const record = data?.data;

  const { data: categoryData, isLoading: categoryIsLoading } =
    useOne<ICategory>({
      resource: "categories",
      id: record?.category.id || "",
      queryOptions: {
        enabled: !!record,
      },
    });

  return (
    <Show isLoading={isLoading}>
      <Title level={5}>Id</Title>
      <Text>{record?.id}</Text>

      <Title level={5}>Title</Title>
      <Text>{record?.title}</Text>

      <Title level={5}>Category</Title>
      <Text>{categoryIsLoading ? "Loading..." : categoryData?.data.title}</Text>

      <Title level={5}>Content</Title>
      <MarkdownField value={record?.content} />
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Properties

### title

`title` allows you to add a title inside the `<Show>` component. If you don't pass title props, it uses the "Show" prefix and the singular resource name by default. For example, for the "posts" resource, it will be "Show post".

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show } from "@refinedev/antd";

const PostShow: React.FC = () => {
  return (
    /* highlight-next-line */
    <Show title="Custom Title">
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### resource

The `<Show>` component reads the `resource` information from the route by default. If you want to use a custom resource for the `<Show>` component, you can use the `resource` prop:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";

// visible-block-start
import { Show } from "@refinedev/antd";

const CustomPage: React.FC = () => {
  return (
    /* highlight-next-line */
    <Show resource="posts">
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<CustomPage />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### canDelete and canEdit

`canDelete` and `canEdit` allows us to add the delete and edit buttons inside the `<Show>` component.

When clicked on, the delete button executes the `useDelete` method provided by the [`dataProvider`](/docs/data/data-provider) and the edit button redirects the user to the record edit page.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

const { default: simpleRest } = RefineSimpleRest;

const dataProvider = simpleRest("https://api.fake-rest.refine.dev");

const customDataProvider = {
  ...dataProvider,
  deleteOne: async ({ resource, id, variables }) => {
    return {
      data: {},
    };
  },
};

const authProvider = {
  login: async () => {
    return {
      success: true,
      redirectTo: "/",
    };
  },
  register: async () => {
    return {
      success: true,
    };
  },
  forgotPassword: async () => {
    return {
      success: true,
    };
  },
  updatePassword: async () => {
    return {
      success: true,
    };
  },
  logout: async () => {
    return {
      success: true,
      redirectTo: "/",
    };
  },
  check: () => ({
    authenticated: true,
  }),
  onError: async (error) => {
    console.error(error);
    return { error };
  },
  getPermissions: async () => ["admin"],
  getIdentity: async () => null,
};

// visible-block-start
import { Show } from "@refinedev/antd";
import { usePermissions } from "@refinedev/core";

const PostShow: React.FC = () => {
  const { data: permissionsData } = usePermissions();
  return (
    <Show
      /* highlight-start */
      canDelete={permissionsData?.includes("admin")}
      canEdit={permissionsData?.includes("admin")}
      /* highlight-end */
    >
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      authProvider={authProvider}
      dataProvider={customDataProvider}
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
          <ReactRouter.Route path="edit/:id" element={<div>Edit Page</div>} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

[Refer to the `usePermissions` documentation for detailed usage. &#8594](/docs/api-reference/core/hooks/authentication/usePermissions/)

### recordItemId

The `<Show>` component reads the `id` information from the route by default. `recordItemId` is used when it cannot read from the URL (when used on a custom page, modal or drawer).

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show, useModalForm } from "@refinedev/antd";
import { Modal, Button } from "antd";

const PostShow: React.FC = () => {
  const { modalProps, id, show } = useModalForm({
    action: "show",
  });

  return (
    <div>
      <Button onClick={() => show()}>Show Button</Button>
      <Modal {...modalProps}>
        {/* highlight-next-line */}
        <Show recordItemId={id}>
          <p>Rest of your page here</p>
        </Show>
      </Modal>
    </div>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

The `<Show>` component needs the `id` information for `<RefreshButton>` to work properly.

### dataProviderName

If not specified, Refine will use the default data provider. If you have multiple data providers, you can use the `dataProviderName` property to specify which one you want to use:

```tsx
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";

import { Show } from "@refinedev/antd";

// highlight-start
const PostShow = () => {
  return <Show dataProviderName="other">...</Show>;
};
// highlight-end

export const App: React.FC = () => {
  return (
    <Refine
      // highlight-start
      dataProvider={{
        default: dataProvider("https://api.fake-rest.refine.dev/"),
        other: dataProvider("https://other-api.fake-rest.refine.dev/"),
      }}
      // highlight-end
    >
      {/* ... */}
    </Refine>
  );
};
```

### goBack

To customize the back button or to disable it, you can use the `goBack` property:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show } from "@refinedev/antd";
import { Button } from "antd";

const PostShow: React.FC = () => {
  const BackButton = () => <Button>←</Button>;
  return (
    /* highlight-next-line */
    <Show goBack={<BackButton />}>
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

If your route has no `:action` parameter or your action is `list`, the back button will not be shown even if you pass a `goBack` property. You can override this behavior by using the `headerProps` property:

```tsx
/* highlight-next-line */
import { useBack } from "@refinedev/core";
import { Show } from "@refinedev/antd";
import { Button } from "antd";

const PostShow: React.FC = () => {
  /* highlight-next-line */
  const back = useBack();
  const BackButton = () => <Button>←</Button>;

  return (
    /* highlight-next-line */
    <Show goBack={<BackButton />} headerProps={{ onBack: back }}>
      <p>Rest of your page here</p>
    </Show>
  );
};
```

### isLoading

Since `<Show>` uses the Ant Design [`<Card>`](https://ant.design/components/card/) component, the `isLoading` property can be set like the below:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show } from "@refinedev/antd";

const PostShow: React.FC = () => {
  return (
    /* highlight-next-line */
    <Show isLoading={true}>
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### breadcrumb <GlobalConfigBadge id="core/refine-component/#breadcrumb" />

To customize or disable the breadcrumb, you can use the `breadcrumb` property. By default the `Breadcrumb` component from the `@refinedev/antd` package is used for breadcrumbs.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show, Breadcrumb } from "@refinedev/antd";

const PostShow: React.FC = () => {
  return (
    <Show
      // highlight-start
      breadcrumb={
        <div
          style={{
            padding: "3px 6px",
            border: "2px dashed cornflowerblue",
          }}
        >
          <Breadcrumb />
        </div>
      }
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Breadcrumb` documentation &#8594](/docs/ui-integrations/ant-design/components/breadcrumb)

### wrapperProps

You can use the `wrapperProps` property if you want to customize the wrapper of the `<Show/>` component. The `@refinedev/antd` wrapper elements are simply `<div/>`s and `wrapperProps` and can get every attribute that `<div/>` can get.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show } from "@refinedev/antd";

const PostShow: React.FC = () => {
  return (
    <Show
      // highlight-start
      wrapperProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### headerProps

You can use the `headerProps` property to customize the header of the `<Show/>` component:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show } from "@refinedev/antd";

const PostShow: React.FC = () => {
  return (
    <Show
      // highlight-start
      headerProps={{
        subTitle: "This is a subtitle",
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`PageHeader` documentation &#8594](https://procomponents.ant.design/en-US/components/page-header)

### contentProps

You can use the `contentProps` property to customize the content of the `<Show/>` component:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show } from "@refinedev/antd";

const PostShow: React.FC = () => {
  return (
    <Show
      // highlight-start
      contentProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Card` documentation &#8594](https://ant.design/components/card/)

### headerButtons

By default, the `<Show/>` component has a [`<ListButton>`][list-button], [`<EditButton>`][edit-button], [`<DeleteButton>`][delete-button], and a [`<RefreshButton>`][refresh-button] at the header.

You can customize the buttons at the header by using the `headerButtons` property. It accepts `React.ReactNode` or a render function `({ defaultButtons, listButtonProps, editButtonProps, deleteButtonProps, refreshButtonProps }) => React.ReactNode` which you can use to keep the existing buttons and add your own.

If the "list" resource is not defined, the [`<ListButton>`][list-button] will not render and `listButtonProps` will be `undefined`.

If [`canDelete`](#candelete-and-canedit) is `false`, the [`<DeleteButton>`][delete-button] will not render and `deleteButtonProps` will be `undefined`.

If [`canEdit`](#candelete-and-canedit) is `false`, [`<EditButton>`][edit-button] will not render and `editButtonProps` will be `undefined`.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show } from "@refinedev/antd";
import { Button } from "antd";

const PostShow: React.FC = () => {
  return (
    <Show
      // highlight-start
      headerButtons={({ defaultButtons }) => (
        <>
          {defaultButtons}
          <Button type="primary">Custom Button</Button>
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Or, instead of using the `defaultButtons`, you can create your own buttons. If you want, you can use `createButtonProps` to utilize the default values of the [`<ListButton>`][list-button], [`<EditButton>`][edit-button], [`<DeleteButton>`][delete-button], and [`<RefreshButton>`][refresh-button] components.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import {
  Show,
  ListButton,
  EditButton,
  DeleteButton,
  RefreshButton,
} from "@refinedev/antd";
import { Button } from "antd";

const PostShow: React.FC = () => {
  return (
    <Show
      // highlight-start
      headerButtons={({
        deleteButtonProps,
        editButtonProps,
        listButtonProps,
        refreshButtonProps,
      }) => (
        <>
          <Button type="primary">Custom Button</Button>
          {listButtonProps && (
            <ListButton {...listButtonProps} meta={{ foo: "bar" }} />
          )}
          {editButtonProps && (
            <EditButton {...editButtonProps} meta={{ foo: "bar" }} />
          )}
          {deleteButtonProps && (
            <DeleteButton {...deleteButtonProps} meta={{ foo: "bar" }} />
          )}
          <RefreshButton {...refreshButtonProps} meta={{ foo: "bar" }} />
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### headerButtonProps

You can use the `headerButtonProps` property to customize the wrapper element of the buttons at the header:

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show } from "@refinedev/antd";
import { Button } from "antd";

const PostShow: React.FC = () => {
  return (
    <Show
      // highlight-start
      headerButtonProps={{
        style: {
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
      headerButtons={<Button type="primary">Custom Button</Button>}
    >
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Space` documentation &#8594](https://ant.design/components/space/)

### footerButtons

You can customize the buttons at the footer by using the `footerButtons` property. It accepts `React.ReactNode` or a render function `({ defaultButtons }) => React.ReactNode` which you can use to keep the existing buttons and add your own.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show } from "@refinedev/antd";
import { Button } from "antd";

const PostShow: React.FC = () => {
  return (
    <Show
      // highlight-start
      footerButtons={({ defaultButtons }) => (
        <>
          {defaultButtons}
          <Button type="primary">Custom Button</Button>
        </>
      )}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### footerButtonProps

You can customize the wrapper element of the buttons at the footer by using the `footerButtonProps` property.

```tsx live disableScroll previewHeight=280px url=http://localhost:3000/posts/show/123
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { Show } from "@refinedev/antd";
import { Button } from "antd";

const PostShow: React.FC = () => {
  return (
    <Show
      footerButtons={({ defaultButtons }) => (
        <>
          {defaultButtons}
          <Button type="primary">Custom Button</Button>
        </>
      )}
      // highlight-start
      footerButtonProps={{
        style: {
          float: "right",
          marginRight: 24,
          backgroundColor: "cornflowerblue",
          padding: "16px",
        },
      }}
      // highlight-end
    >
      <p>Rest of your page here</p>
    </Show>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            }
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

> For more information, refer to the [`Space` documentation &#8594](https://ant.design/components/space/)

## API Reference

### Properties

<PropsTable module="@refinedev/antd/Show"
contentProps-type="[`CardProps`](https://ant.design/components/card/#API)"
headerProps-type="[`PageHeaderProps`](https://procomponents.ant.design/en-US/components/page-header)"
headerButtons-default="[`ListButton`](/docs/ui-integrations/ant-design/components/buttons/list-button/), [`RefreshButton`](/docs/ui-integrations/ant-design/components/buttons/refresh-button/), [`EditButton`](/docs/ui-integrations/ant-design/components/buttons/edit-button/) and [`DeleteButton`](/docs/ui-integrations/ant-design/components/buttons/delete-button/)"
headerButtonProps-type="[`SpaceProps`](https://ant.design/components/space/)"
deleteButtonProps-type="[`DeleteButtonProps`](/docs/ui-integrations/ant-design/components/buttons/delete-button)"
saveButtonProps-type="[`SaveButtonProps`](/docs/ui-integrations/ant-design/components/buttons/save-button/)"
footerButtonsProps-type="[`SpaceProps`](https://ant.design/components/space/)"
breadcrumb-default="[`<Breadcrumb>`](https://ant.design/components/breadcrumb/)"
goBack-default="`<ArrowLeft />`"
goBack-type="`ReactNode`"
/>

[list-button]: /docs/ui-integrations/ant-design/components/buttons/list-button
[refresh-button]: /docs/ui-integrations/ant-design/components/buttons/refresh-button
[edit-button]: /docs/ui-integrations/ant-design/components/buttons/edit-button
[delete-button]: /docs/ui-integrations/ant-design/components/buttons/delete-button

================
File: ui-integrations/ant-design/components/breadcrumb/index.md
================
---
title: Breadcrumb
swizzle: true
---

A breadcrumb displays the current location within a hierarchy. It allows going back to states higher up in the hierarchy. The `<Breadcrumb>` component was built with Ant Design's [Breadcrumb][antd-breadcrumb] components using the [`useBreadcrumb`](/docs/core/hooks/utilities/use-breadcrumb) hook.

```tsx live url=http://localhost:3000/posts/show/123 previewHeight=280px disableScroll
// visible-block-start
import { BrowserRouter } from "react-router";
import {
  ConfigProvider,
  RefineThemes,
  Show,
  // highlight-next-line
  Breadcrumb,
} from "@refinedev/antd";

//highlight-start
const PostIcon = (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    className="icon icon-tabler icon-tabler-list"
    width={18}
    height={18}
    viewBox="0 0 24 24"
    strokeWidth="2"
    stroke="currentColor"
    fill="none"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <line x1={9} y1={6} x2={20} y2={6}></line>
    <line x1={9} y1={12} x2={20} y2={12}></line>
    <line x1={9} y1={18} x2={20} y2={18}></line>
    <line x1={5} y1={6} x2={5} y2="6.01"></line>
    <line x1={5} y1={12} x2={5} y2="12.01"></line>
    <line x1={5} y1={18} x2={5} y2="18.01"></line>
  </svg>
);
//highlight-end

const PostShow: React.FC = () => {
  return (
    <Show
      // highlight-next-line
      breadcrumb={<Breadcrumb />}
    >
      <p>Content of your show page...</p>
    </Show>
  );
};

const App = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          //...
          resources={[
            {
              name: "posts",
              list: "/posts",
              show: "/posts/show/:id",
              // highlight-next-line
              meta: { icon: PostIcon },
            },
          ]}
        >
          //...
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};
// visible-block-end

const PostList = () => {
  return (
    <RefineAntd.List>
      <p>Content of your list page...</p>
      <RefineAntd.ShowButton recordItemId="123" resource="posts">
        Show Post 123
      </RefineAntd.ShowButton>
    </RefineAntd.List>
  );
};

setInitialRoutes(["/posts/show/123"]);

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          meta: { icon: PostIcon },
          show: "/posts/show/:id",
          list: "/posts",
        },
      ]}
    >
      <RefineAntd.Layout>
        <ReactRouter.Routes>
          <ReactRouter.Route path="/posts" element={<PostList />} />
          <ReactRouter.Route path="/posts/show/:id" element={<PostShow />} />
        </ReactRouter.Routes>
      </RefineAntd.Layout>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::simple Good to know

- You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

- In the earlier versions of Refine, `<Refine>` component had accepted `DashboardPage`, which could be used to add an index page to your app. With the changes in the `routerProvider` API of Refine however, `DashboardPage` is deprecated. You can now define an index route yourself manually by your router package.

- In earlier versions, the home icon in the `Breadcrumb` was created by the `DashboardPage`, now it is rendered if you define a an action route as `/` in any one of your resources. It will be rendered with the home icon regardless of the current route. You can also hide the home icon by setting `showHome` to `false`.

:::

### breadcrumbProps

The `<Breadcrumb>` component uses the Ant Design [Breadcrumb][antd-breadcrumb] component so it can be configured with the `breadcrumbProps` property.

```tsx
import { List, Breadcrumb } from "@refinedev/antd";

export const PostList: React.FC = () => {
  return (
    <List
      // highlight-next-line
      breadcrumb={<Breadcrumb breadcrumbProps={{ separator: "-" }} />}
    >
      ...
    </List>
  );
};
```

### showHome

If you have a page with route `/`, it will be used as the root of the hierarchy and shown in the `Breadcrumb` with a home icon. To hide the root item, set `showHome` to `false.`

```tsx
import { List, Breadcrumb } from "@refinedev/antd";

export const PostList: React.FC = () => {
  return (
    <List
      // highlight-next-line
      breadcrumb={<Breadcrumb showHome={true} />}
    >
      ...
    </List>
  );
};
```

### meta

If your routes has additional parameters in their paths, you can pass the `meta` property to the `<Breadcrumb>` component to use them while creating the paths and filling the parameters in the paths. By default, the existing URL parameters are used. You can use `meta` to override them or add new ones.

```tsx
import { List, Breadcrumb } from "@refinedev/antd";

export const PostList: React.FC = () => {
  return (
    <List
      // highlight-next-line
      breadcrumb={<Breadcrumb meta={{ authorId: "123" }} />}
    >
      ...
    </List>
  );
};
```

### hideIcons

If you don't want to show the resource icons on the breadcrumb, you can set `hideIcons` to `true`.

```tsx
import { List, Breadcrumb } from "@refinedev/antd";

export const PostList: React.FC = () => {
  return (
    <List
      // highlight-next-line
      breadcrumb={<Breadcrumb hideIcons />}
    >
      ...
    </List>
  );
};
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/Breadcrumb"
breadcrumbProps-type="[BreadcrumbProps](https://ant.design/components/breadcrumb/#API)"
breadcrumbProps-description="Passes properties for [`<Breadcrumb>`](https://ant.design/components/breadcrumb/#Breadcrumb)"
/>

[antd-breadcrumb]: https://ant.design/components/breadcrumb

================
File: ui-integrations/ant-design/components/buttons/clone-button/index.md
================
---
title: Clone
swizzle: true
---

`<CloneButton>` uses Ant Design's [`<Button>`](https://ant.design/components/button/) component and the `clone` method from [`useNavigation`](/docs/routing/hooks/use-navigation) under the hood.

It can be useful when redirecting the app to the create page with the record id route of resource.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

```tsx live previewHeight=360px
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  useTable,
  // highlight-next-line
  CloneButton,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" width="100%" />
        <Table.Column<IPost>
          title="Actions"
          dataIndex="actions"
          key="actions"
          render={(_, record) => (
            // highlight-next-line
            <CloneButton size="small" recordItemId={record.id} />
          )}
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
}
// visible-block-end

const PostClone = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          clone: "/posts/:id/clone",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
          <ReactRouter.Route path=":id/clone" element={<PostClone />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## Properties

### recordItemId

`recordItemId` is used to append the record id to the end of the route path. By default, the `recordItemId` is inferred from the route params.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { CloneButton } from "@refinedev/antd";

const MyCloneComponent = () => {
  return <CloneButton resource="posts" recordItemId="123" />;
};

// visible-block-end

const ClonedPage = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          clone: "/posts/:id/clone",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyCloneComponent />} />
          <ReactRouter.Route path=":id/clone" element={<ClonedPage />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the `clone` method of [`useNavigation`](/docs/routing/hooks/use-navigation) and then redirect the app to the `clone` action path of the resource, filling the necessary parameters in the route.

### resource

`resource` is used to redirect the app to the `clone` action of the given resource name. By default, the app redirects to the inferred resource's `clone` action path.

```tsx live previewHeight=120px
setInitialRoutes(["/categories"]);

// visible-block-start
import { CloneButton } from "@refinedev/antd";

const MyCloneComponent = () => {
  return <CloneButton resource="categories" recordItemId="123" />;
};

// visible-block-end

const CategoryClone = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          clone: "/posts/:id/clone",
        },
        {
          name: "categories",
          list: "/categories",
          clone: "/categories/:id/clone",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route path="/categories" element={<MyCloneComponent />} />
        <ReactRouter.Route
          path="/categories/:id/clone"
          element={<CategoryClone />}
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the `clone` method of [`useNavigation`](/docs/routing/hooks/use-navigation) and then redirect the app to the `clone` action path of the resource, filling the necessary parameters in the route.

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### meta

It is used to pass additional parameters to the `clone` method of [`useNavigation`](/docs/routing/hooks/use-navigation). By default, the existing parameters in the route are used by the `clone` method. You can pass additional parameters or override the existing ones using the `meta` prop.

If the `clone` action route is defined by the pattern: `/posts/:authorId/clone/:id`, the `meta` prop can be used as follows:

```tsx
const MyComponent = () => {
  return <CloneButton meta={{ authorId: "10" }} />;
};
```

### hideText

It is used to show and not show the text of the button. When `true`, only the button icon is visible.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);
// visible-block-start
import { CloneButton } from "@refinedev/antd";

const MyCloneComponent = () => {
  return (
    <CloneButton
      recordItemId="123"
      // highlight-next-line
      hideText={true}
    />
  );
};

// visible-block-end

const ClonedPage = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          clone: "/posts/:id/clone",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyCloneComponent />} />
          <ReactRouter.Route path=":id/clone" element={<ClonedPage />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### accessControl

This prop can be used to skip access control check with its `enabled` property or to hide the button when the user does not have the permission to access the resource with `hideIfUnauthorized` property. This is relevant only when an [`accessControlProvider`](/docs/authorization/access-control-provider) is provided to [`<Refine/>`](/docs/core/refine-component)

```tsx
import { CloneButton } from "@refinedev/antd";

export const MyListComponent = () => {
  return (
    <CloneButton
      accessControl={{
        enabled: true,
        hideIfUnauthorized: true,
      }}
    />
  );
};
```

### ~~resourceNameOrRouteName~~ <PropTag deprecated />

Use the `resource` prop instead.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/CloneButton" />

:::simple External Props

It also accepts all props of Ant Design [Button](https://ant.design/components/button/#API).

:::

================
File: ui-integrations/ant-design/components/buttons/create-button/index.md
================
---
title: Create
swizzle: true
---

`<CreateButton>` uses Ant Design's [`<Button>`](https://ant.design/components/button/) component and the `create` method from [`useNavigation`](/docs/routing/hooks/use-navigation) under the hood.

It can be useful when redirecting the app to the create page route of resource.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

```tsx live previewHeight=360px
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  useTable,
  // highlight-next-line
  CreateButton,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List
      // highlight-next-line
      headerButtons={<CreateButton />}
    >
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" width="100%" />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
}
// visible-block-end

const CreatePage = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
          <ReactRouter.Route path="create" element={<CreatePage />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## Properties

### resource

`resource` is used to redirect the app to the `create` action path of the given resource name. By default, the app redirects to the inferred resource's `create` action path.

```tsx live previewHeight=120px
setInitialRoutes(["/categories"]);

// visible-block-start
import { CreateButton } from "@refinedev/antd";

const MyCreateComponent = () => {
  return <CreateButton resource="categories" />;
};

// visible-block-end

const CategoryCreate = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
        {
          name: "categories",
          list: "/categories",
          create: "/categories/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route path="/categories" element={<MyCreateComponent />} />
        <ReactRouter.Route
          path="/categories/create"
          element={<CategoryCreate />}
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the `create` method of [`useNavigation`](/docs/routing/hooks/use-navigation) and then redirect the app to the `create` action path of the resource, filling the necessary parameters in the route.

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### meta

It is used to pass additional parameters to the `create` method of [`useNavigation`](/docs/routing/hooks/use-navigation). By default, existing parameters in the route are used by the `create` method. You can pass additional parameters or override the existing ones using the `meta` prop.

If the `create` action route is defined by the pattern: `/posts/:authorId/create`, the `meta` prop can be used as follows:

```tsx
const MyComponent = () => {
  return <CreateButton meta={{ authorId: "10" }} />;
};
```

### hideText

It is used to show and not show the text of the button. When `true`, only the button icon is visible.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { CreateButton } from "@refinedev/antd";

const MyCreateComponent = () => {
  return (
    <CreateButton
      // highlight-next-line
      hideText={true}
    />
  );
};

// visible-block-end

const CreatePage = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          create: "/posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyCreateComponent />} />
          <ReactRouter.Route path="create" element={<CreatePage />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### accessControl

This prop can be used to skip access control check with its `enabled` property or to hide the button when the user does not have the permission to access the resource with `hideIfUnauthorized` property. This is relevant only when an [`accessControlProvider`](/docs/authorization/access-control-provider) is provided to [`<Refine/>`](/docs/core/refine-component)

```tsx
import { CreateButton } from "@refinedev/antd";

export const MyListComponent = () => {
  return (
    <CreateButton
      accessControl={{
        enabled: true,
        hideIfUnauthorized: true,
      }}
    />
  );
};
```

### ~~resourceNameOrRouteName~~ <PropTag deprecated />

Use `resource` prop instead.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/CreateButton" />

:::simple External Props

It also accepts all props of Ant Design [Button](https://ant.design/components/button/#API).

:::

================
File: ui-integrations/ant-design/components/buttons/delete-button/index.md
================
---
title: Delete
swizzle: true
---

`<DeleteButton>` uses Ant Design's [`<Button>`](https://ant.design/components/button/) and [`<Popconfirm>`](https://ant.design/components/popconfirm/) components.

When you try to delete something, a pop-up shows up and asks for confirmation. When confirmed it executes the [`useDelete`](/docs/data/hooks/use-delete) method provided by your [`dataProvider`](/docs/data/data-provider).

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

```tsx live previewHeight=360px
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  useTable,
  // highlight-next-line
  DeleteButton,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" width="50%" />
        <Table.Column<IPost>
          title="Actions"
          dataIndex="actions"
          key="actions"
          render={(_, record) => (
            // highlight-next-line
            <DeleteButton size="small" recordItemId={record.id} />
          )}
          width="50%"
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## Properties

### recordItemId

`recordItemId` allows us to manage which record will be deleted. By default, the `recordItemId` is inferred from the route params.

```tsx live disableScroll previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { DeleteButton } from "@refinedev/antd";

const MyDeleteComponent = () => {
  return (
    <DeleteButton
      resource="posts"
      // highlight-next-line
      recordItemId="123"
    />
  );
};

// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyDeleteComponent />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the [`useDelete`](/docs/data/hooks/use-delete) method and then the record whose resource is "posts" and whose id is "123" will be deleted.

### resource

`resource` allows us to manage which resource's record is going to be deleted. By default, the `resource` is inferred from the route params.

```tsx live disableScroll previewHeight=120px
setInitialRoutes(["/categories"]);

// visible-block-start
import { DeleteButton } from "@refinedev/antd";

const MyDeleteComponent = () => {
  return <DeleteButton resource="categories" recordItemId="123" />;
};

// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
        {
          name: "categories",
          list: "/categories",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route path="/categories" element={<MyDeleteComponent />} />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the [`useDelete`](/docs/data/hooks/use-delete) method and then the record whose resource is "categories" and whose id is "123" will be deleted.

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### onSuccess

`onSuccess` can be used if you want to do something based on the results returned after the delete request.

For example, let's `console.log` after deletion:

```tsx live disableScroll previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { DeleteButton } from "@refinedev/antd";

const MyDeleteComponent = () => {
  return (
    <DeleteButton
      resource="posts"
      recordItemId="1"
      onSuccess={(value) => {
        console.log(value);
      }}
    />
  );
};
// visible-block-end

const App = () => {
  const simpleRestDataProvider = dataProvider(
    "https://api.fake-rest.refine.dev",
  );

  const customDataProvider = {
    ...simpleRestDataProvider,
    deleteOne: async ({ resource, id, variables }) => {
      await new Promise((resolve) => setTimeout(resolve, 500));

      return {
        message: "You have successfully deleted the record",
      };
    },
  };

  return (
    <ReactRouter.BrowserRouter>
      <RefineAntdDemo
        dataProvider={customDataProvider}
        resources={[
          {
            name: "posts",
            list: "/posts",
          },
        ]}
      >
        <ReactRouter.Routes>
          <ReactRouter.Route
            path="/posts"
            element={
              <div style={{ padding: 16 }}>
                <ReactRouter.Outlet />
              </div>
            }
          >
            <ReactRouter.Route index element={<MyDeleteComponent />} />
          </ReactRouter.Route>
        </ReactRouter.Routes>
      </RefineAntdDemo>
    </ReactRouter.BrowserRouter>
  );
};

render(<App />);
```

### mutationMode

Determines which mode mutation will have while executing `<DeleteButton>`.

> For more information, refer to the [mutation mode documentation &#8594](/docs/advanced-tutorials/mutation-mode)

```tsx live disableScroll previewHeight=360px
setInitialRoutes(["/posts"]);

// visible-block-start
import { List, DeleteButton, useTable } from "@refinedev/antd";
import { Table } from "antd";

const PostList = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column<IPost>
          title="Actions"
          dataIndex="actions"
          render={(_, record) => (
            <DeleteButton
              size="small"
              recordItemId={record.id}
              // highlight-next-line
              mutationMode="undoable"
            />
          )}
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### hideText

It is used to show and not show the text of the button. When `true`, only the button icon is visible.

```tsx live disableScroll previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { DeleteButton } from "@refinedev/antd";

const MyDeleteComponent = () => {
  return (
    <DeleteButton
      // highlight-next-line
      hideText={true}
      recordItemId="123"
    />
  );
};

// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyDeleteComponent />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### accessControl

This prop can be used to skip access control check with its `enabled` property or to hide the button when the user does not have the permission to access the resource with `hideIfUnauthorized` property. This is relevant only when an [`accessControlProvider`](/docs/authorization/access-control-provider) is provided to [`<Refine/>`](/docs/core/refine-component)

```tsx
import { DeleteButton } from "@refinedev/antd";

export const MyListComponent = () => {
  return (
    <DeleteButton
      accessControl={{
        enabled: true,
        hideIfUnauthorized: true,
      }}
    />
  );
};
```

### ~~resourceNameOrRouteName~~ <PropTag deprecated />

Use `resource` prop instead.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/DeleteButton" />

:::simple External Props

It also accepts all props of Ant Design [Button](https://ant.design/components/button/#API).

:::

================
File: ui-integrations/ant-design/components/buttons/edit-button/index.md
================
---
title: Edit
swizzle: true
---

`<EditButton>` uses Ant Design's [`<Button>`](https://ant.design/components/button/) component and the `edit` method from [`useNavigation`](/docs/routing/hooks/use-navigation) under the hood.

It can be useful when redirecting the app to the edit page with the record id route of resource.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

```tsx live previewHeight=360px
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  useTable,
  // highlight-next-line
  EditButton,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" width="100%" />
        <Table.Column<IPost>
          title="Actions"
          dataIndex="actions"
          key="actions"
          render={(_, record) => (
            // highlight-next-line
            <EditButton size="small" recordItemId={record.id} />
          )}
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
}
// visible-block-end

const PostEdit = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/:id/edit",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
          <ReactRouter.Route path=":id/edit" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## Properties

### recordItemId

`recordItemId` is used to append the record id to the end of the route path. By default, the `recordItemId` is inferred from the route params.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { EditButton } from "@refinedev/antd";

const MyEditComponent = () => {
  return (
    <EditButton
      resource="posts"
      // highlight-next-line
      recordItemId="123"
    />
  );
};

// visible-block-end

const PostEdit = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/:id/edit",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyEditComponent />} />
          <ReactRouter.Route path=":id/edit" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the `edit` method of [`useNavigation`](/docs/routing/hooks/use-navigation) and then redirect the app to the `edit` action path of the resource, filling the necessary parameters in the route.

### resource

The redirection endpoint is defined by the `resource` property and its `edit` action path. By default, `<EditButton>` uses the inferred resource from the route.

```tsx live previewHeight=120px
setInitialRoutes(["/categories"]);

// visible-block-start
import { EditButton } from "@refinedev/antd";

const MyEditComponent = () => {
  return (
    <EditButton
      // highlight-next-line
      resource="categories"
      recordItemId="123"
    />
  );
};

// visible-block-end

const CategoryEdit = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/:id/edit",
        },
        {
          name: "categories",
          list: "/categories",
          edit: "/categories/:id/edit",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/categories"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyEditComponent />} />
          <ReactRouter.Route path=":id/edit" element={<CategoryEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the `edit` method of [`useNavigation`](/docs/routing/hooks/use-navigation) and then redirect the app to the `edit` action path of the resource, filling the necessary parameters in the route.

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### meta

It is used to pass additional parameters to the `edit` method of [`useNavigation`](/docs/routing/hooks/use-navigation). By default, existing parameters in the route are used by the `edit` method. You can pass additional parameters or override the existing ones using the `meta` prop.

If the `edit` action route is defined by the pattern: `/posts/:authorId/edit/:id`, the `meta` prop can be used as follows:

```tsx
const MyComponent = () => {
  return <EditButton meta={{ authorId: "10" }} />;
};
```

### hideText

It is used to show and not show the text of the button. When `true`, only the button icon is visible.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { EditButton } from "@refinedev/antd";

const MyEditComponent = () => {
  return (
    <EditButton
      // highlight-next-line
      hideText={true}
      recordItemId="123"
    />
  );
};

// visible-block-end

const PostEdit = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/:id/edit",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyEditComponent />} />
          <ReactRouter.Route path=":id/edit" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### accessControl

This prop can be used to skip access control check with its `enabled` property or to hide the button when the user does not have the permission to access the resource with `hideIfUnauthorized` property. This is relevant only when an [`accessControlProvider`](/docs/authorization/access-control-provider) is provided to [`<Refine/>`](/docs/core/refine-component)

```tsx
import { EditButton } from "@refinedev/antd";

export const MyListComponent = () => {
  return (
    <EditButton
      accessControl={{
        enabled: true,
        hideIfUnauthorized: true,
      }}
    />
  );
};
```

### ~~resourceNameOrRouteName~~ <PropTag deprecated />

Use `resource` prop instead.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/EditButton" />

:::simple External Props

It also accepts all props of Ant Design [Button](https://ant.design/components/button/#API).

:::

================
File: ui-integrations/ant-design/components/buttons/export-button/index.md
================
---
title: Export
swizzle: true
---

`<ExportButton>` is an Ant Design [`<Button>`][button] with a default export icon and a "Export" text. It only has presentational value.

> For more information, refer to the [`useExport` documentation &#8594][useexport]

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

You can use it like any other Ant Design [`<Button>`][button].

For example, you can use it with [useExport][useexport]:

```tsx live previewHeight=360px
setInitialRoutes(["/posts"]);

// visible-block-start
import { useExport } from "@refinedev/core";
import {
  List,
  useTable,
  // highlight-next-line
  ExportButton,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  const { triggerExport, isLoading: exportLoading } = useExport<IPost>();

  return (
    <List
      headerButtons={
        // highlight-start
        <ExportButton onClick={triggerExport} loading={exportLoading} />
        // highlight-end
      }
    >
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## Properties

### hideText

`hideText` is used to hide the text of the button. When its `true`, only the button icon will be visible.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { ExportButton } from "@refinedev/antd";

const MyExportComponent = () => {
  return (
    <ExportButton
      // highlight-next-line
      hideText={true}
    />
  );
};

// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyExportComponent />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/ExportButton" />

:::simple External Props

It also accepts all props of Ant Design [Button](https://ant.design/components/button/#API).

:::

[button]: https://ant.design/components/button/
[useexport]: /docs/core/hooks/utilities/use-export

================
File: ui-integrations/ant-design/components/buttons/import-button/index.md
================
---
title: Import
swizzle: true
---

`<ImportButton>` is compatible with the [`useImport`][useimport] hook and is meant to be used as it's upload button.

It uses Ant Design's [`<Button>`][button] and [`<Upload>`][upload] components. It wraps a [`<Button>`][button] component with an [`<Upload>`][upload] component and accepts properties for [`<Button>`][button] and [`<Upload>`][upload] components separately.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

```tsx live previewHeight=360px
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  useTable,
  // highlight-start
  useImport,
  ImportButton,
  // highlight-end
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  // highlight-next-line
  const importProps = useImport<IPostFile>();

  return (
    <List
      headerButtons={
        // highlight-next-line
        <ImportButton {...importProps} />
      }
    >
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
}

interface IPostFile {
  title: string;
  categoryId: number;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## Properties

### hideText

`hideText` is used to hide the text of the button. When its `true`, only the button icon will be visible.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { ImportButton, useImport } from "@refinedev/antd";

const MyImportComponent = () => {
  const importProps = useImport();

  return (
    <ImportButton
      {...importProps}
      // highlight-next-line
      hideText
    />
  );
};

// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyImportComponent />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/ImportButton" />

[useimport]: /docs/ui-integrations/ant-design/hooks/use-import
[button]: https://ant.design/components/button/
[upload]: https://ant.design/components/upload/

================
File: ui-integrations/ant-design/components/buttons/list-button/index.md
================
---
title: List
swizzle: true
---

`<ListButton>` is using Ant Design's [`<Button>`](https://ant.design/components/button/) component and the `list` method from [`useNavigation`](/docs/routing/hooks/use-navigation) under the hood.

It can be useful when redirecting the app to the list page route of resource.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

```tsx live previewHeight=360px
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { useShow } from "@refinedev/core";
import {
  Show,
  // highlight-next-line
  ListButton,
} from "@refinedev/antd";
import { Typography } from "antd";

const { Title, Text } = Typography;

const PostShow: React.FC = () => {
  const { queryResult } = useShow<IPost>();
  const { data, isLoading } = queryResult;
  const record = data?.data;

  return (
    // highlight-next-line
    <Show headerButtons={<ListButton />} isLoading={isLoading}>
      <Title level={5}>Id</Title>
      <Text>{record?.id}</Text>

      <Title level={5}>Title</Title>
      <Text>{record?.title}</Text>
    </Show>
  );
};

interface IPost {
  id: number;
  title: string;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route
            index
            element={<div>Your list page here...</div>}
          />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

The button text is defined automatically by Refine based on the `resource` definition.

## Properties

### resource

The redirection endpoint is defined by the `resource`'s `list` action path. By default, `<ListButton>` uses the inferred resource from the route.

```tsx live previewHeight=120px
setInitialRoutes(["/"]);

// visible-block-start
import { ListButton } from "@refinedev/antd";

const MyListComponent = () => {
  return <ListButton resource="categories" />;
};

// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "categories",
          list: "/categories",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyListComponent />} />
          <ReactRouter.Route
            path="/categories"
            element={<div>Your list page here...</div>}
          />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the `list` method of [`useNavigation`](/docs/routing/hooks/use-navigation) and then redirect the app to the `list` action path of the resource, filling the necessary parameters in the route.

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### meta

It is used to pass additional parameters to the `list` method of [`useNavigation`](/docs/routing/hooks/use-navigation). By default, existing parameters in the route are used by the `list` method. You can pass additional parameters or override the existing ones using the `meta` prop.

If the `list` action route is defined by the pattern: `/:authorId/posts`, the `meta` prop can be used as follows:

```tsx
const MyComponent = () => {
  return <ListButton meta={{ authorId: "10" }} />;
};
```

### hideText

`hideText` is used to hide the text of the button. When its `true`, only the button icon will be visible.

```tsx live previewHeight=120px
setInitialRoutes(["/"]);

// visible-block-start
import { ListButton } from "@refinedev/antd";

const MyListComponent = () => {
  return (
    <ListButton
      resource="posts"
      // highlight-next-line
      hideText={true}
    />
  );
};

// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyListComponent />} />
          <ReactRouter.Route
            path="/posts"
            element={<div>Your list page here...</div>}
          />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### accessControl

This prop can be used to skip access control check with its `enabled` property or to hide the button when the user does not have the permission to access the resource with `hideIfUnauthorized` property. This is relevant only when an [`accessControlProvider`](/docs/authorization/access-control-provider) is provided to [`<Refine/>`](/docs/core/refine-component)

```tsx
import { ListButton } from "@refinedev/antd";

export const MyListComponent = () => {
  return (
    <ListButton
      accessControl={{
        enabled: true,
        hideIfUnauthorized: true,
      }}
    />
  );
};
```

### ~~resourceNameOrRouteName~~ <PropTag deprecated />

Use `resource` prop instead.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/ListButton" />

:::simple External Props

It also accepts all props of Ant Design [Button](https://ant.design/components/button/#API).

:::

================
File: ui-integrations/ant-design/components/buttons/refresh-button/index.md
================
---
title: Refresh
swizzle: true
---

`<RefreshButton>` uses Ant Design's [`<Button>`](https://ant.design/components/button/) component to update the data shown on the page via the [`useInvalidate`][use-invalidate] hook.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

```tsx live previewHeight=360px
setInitialRoutes(["/posts/show/123"]);

// visible-block-start
import { useShow } from "@refinedev/core";
import {
  // highlight-next-line
  RefreshButton,
  Show,
} from "@refinedev/antd";
import { Typography } from "antd";

const { Title, Text } = Typography;

const PostShow: React.FC = () => {
  const { queryResult } = useShow<IPost>();
  const { data, isLoading } = queryResult;
  const record = data?.data;

  return (
    <Show
      isLoading={isLoading}
      // highlight-next-line
      headerButtons={<RefreshButton />}
    >
      <Title level={5}>Id</Title>
      <Text>{record?.id}</Text>

      <Title level={5}>Title</Title>
      <Text>{record?.title}</Text>
    </Show>
  );
};

interface IPost {
  id: string;
  title: string;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<div>List page here...</div>} />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## Properties

### recordItemId

`recordItemId` allows us to manage which data is going to be refreshed. By default, the `recordItemId` is inferred from the route params.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { RefreshButton } from "@refinedev/antd";

const MyRefreshComponent = () => {
  return (
    <RefreshButton
      resource="posts"
      // highlight-next-line
      recordItemId="123"
    />
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyRefreshComponent />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the [`useInvalidate`][use-invalidate] hook and then fetch the record whose resource is "post" and whose id is "123".

### resource

`resource` allows us to manage which resource is going to be refreshed. By default, the `resource` is inferred from the route params.

```tsx live previewHeight=120px
setInitialRoutes(["/categories"]);

// visible-block-start
import { RefreshButton } from "@refinedev/antd";

const MyRefreshComponent = () => {
  return (
    <RefreshButton
      // highlight-next-line
      resource="categories"
      // highlight-next-line
      recordItemId="123"
    />
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
        {
          name: "categories",
          list: "/categories",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/categories"
          element={
            <div style={{ padding: "16px" }}>
              <MyRefreshComponent />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the [`useInvalidate`][use-invalidate] hook and then fetches the record whose resource is "categories" and whose id is "2".

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### hideText

`hideText` is used to hide the text of the button. When its `true`, only the button icon will be visible.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { RefreshButton } from "@refinedev/antd";

const MyRefreshComponent = () => {
  return (
    <RefreshButton
      // highlight-next-line
      hideText
    />
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyRefreshComponent />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### ~~resourceNameOrRouteName~~ <PropTag deprecated />

Use `resource` prop instead.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/RefreshButton" />

:::simple External Props

It also accepts all props of Ant Design [Button](https://ant.design/components/button/#API).

:::

[use-invalidate]: /docs/data/hooks/use-invalidate

================
File: ui-integrations/ant-design/components/buttons/save-button/index.md
================
---
title: Save
swizzle: true
---

`<SaveButton>` uses Ant Design's [`<Button>`](https://ant.design/components/button/) component. It uses it for presantation purposes only. Some of the hooks that Refine has adds features to this button.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

Let's add logic to the `<SaveButton>` component with the `saveButtonProps` returned by the [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form) hook:

```tsx live previewHeight=360px
setInitialRoutes(["/posts/edit/123"]);

// visible-block-start
import { Edit, useForm } from "@refinedev/antd";
import { Form, Input } from "antd";

const PostEdit: React.FC = () => {
  // highlight-next-line
  const { formProps, saveButtonProps } = useForm<IPost>();

  return (
    // highlight-next-line
    <Edit saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input />
        </Form.Item>
      </Form>
    </Edit>
  );
};

interface IPost {
  id: number;
  title: string;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          edit: "/posts/edit/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<div>List page here...</div>} />
          <ReactRouter.Route path="edit/:id" element={<PostEdit />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

The [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form) hook exposes `saveButtonProps` to be passed to the `<SaveButton>` component which includes submitting the form action, button loading, and disable states.

## Properties

### hideText

`hideText` is used to hide the text of the button. When its `true`, only the button icon will be visible.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { SaveButton } from "@refinedev/antd";

const MySaveComponent = () => {
  return (
    <SaveButton
      // highlight-next-line
      hideText
    />
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MySaveComponent />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/SaveButton" />

:::simple External Props

`<SaveButton>` also accepts all props of Ant Design's [Button](https://ant.design/components/button/#API) component.

:::

================
File: ui-integrations/ant-design/components/buttons/show-button/index.md
================
---
title: Show
swizzle: true
---

`<ShowButton>` uses Ant Design's [`<Button>`](https://ant.design/components/button/) component and the`show` method from [`useNavigation`](/docs/routing/hooks/use-navigation) under the hood.

It can be useful when redirecting the app to the show page with the record id route of resource.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

```tsx live previewHeight=360px
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  useTable,
  // highlight-next-line
  ShowButton,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" width="100%" />
        <Table.Column<IPost>
          title="Actions"
          dataIndex="actions"
          key="actions"
          render={(_, record) => (
            // highlight-next-line
            <ShowButton size="small" recordItemId={record.id} />
          )}
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
}
// visible-block-end

const PostShow = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<PostList />} />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## Properties

### recordItemId

`recordItemId` is used to append the record id to the end of the route path. By default, the `recordItemId` is inferred from the route params.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { ShowButton } from "@refinedev/antd";

const MyShowComponent = () => {
  return (
    <ShowButton
      resource="posts"
      // highlight-next-line
      recordItemId="123"
    />
  );
};

// visible-block-end

const PostShow = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyShowComponent />} />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the `show` method of [`useNavigation`](/docs/routing/hooks/use-navigation) and then redirect the app to the `show` action path of the resource, filling the necessary parameters in the route.

### resource

The redirection endpoint is defined by the `resource`'s `show` action path. By default, `<ShowButton>` uses the inferred resource from the route.

```tsx live previewHeight=120px
setInitialRoutes(["/categories"]);

// visible-block-start
import { ShowButton } from "@refinedev/antd";

const MyShowComponent = () => {
  return (
    <ShowButton
      // highlight-next-line
      resource="categories"
      recordItemId="123"
    />
  );
};

// visible-block-end

const CategoryShow = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
        {
          name: "categories",
          list: "/categories",
          show: "/categories/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/categories"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyShowComponent />} />
          <ReactRouter.Route
            path="/categories/show/:id"
            element={<CategoryShow />}
          />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

Clicking the button will trigger the `show` method of [`useNavigation`](/docs/routing/hooks/use-navigation) and then redirect the app to the `show` action path of the resource, filling the necessary parameters in the route.

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### meta

It is used to pass additional parameters to the `show` method of [`useNavigation`](/docs/routing/hooks/use-navigation). By default, existing parameters in the route are used by the `show` method. You can pass additional parameters or override the existing ones using the `meta` prop.

If the `show` action route is defined by the pattern: `/posts/:authorId/show/:id`, the `meta` prop can be used as follows:

```tsx
const MyComponent = () => {
  return <ShowButton meta={{ authorId: "10" }} />;
};
```

### hideText

`hideText` is used to hide the text of the button. When its `true`, only the button icon will be visible.

```tsx live previewHeight=120px
setInitialRoutes(["/posts"]);

// visible-block-start
import { ShowButton } from "@refinedev/antd";

const MyShowComponent = () => {
  return (
    <ShowButton
      // highlight-next-line
      hideText={true}
      resource="posts"
      recordItemId="123"
    />
  );
};

// visible-block-end

const PostShow = () => {
  const parsed = RefineCore.useParsed();
  return <pre>{JSON.stringify(parsed, null, 2)}</pre>;
};

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
          show: "/posts/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <ReactRouter.Outlet />
            </div>
          }
        >
          <ReactRouter.Route index element={<MyShowComponent />} />
          <ReactRouter.Route path="show/:id" element={<PostShow />} />
        </ReactRouter.Route>
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

### accessControl

This prop can be used to skip the access control check with its `enabled` property or to hide the button when the user does not have the permission to access the resource with its `hideIfUnauthorized` property. However, this only works when an [`accessControlProvider`](/docs/authorization/access-control-provider) is provided to [`<Refine/>`](/docs/core/refine-component)

```tsx
import { ShowButton } from "@refinedev/antd";

export const MyListComponent = () => {
  return (
    <ShowButton
      accessControl={{
        enabled: true,
        hideIfUnauthorized: true,
      }}
    />
  );
};
```

### ~~resourceNameOrRouteName~~ <PropTag deprecated />

Use `resource` prop instead.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/ShowButton" />

:::simple External Props

It also accepts all props of Ant Design [Button](https://ant.design/components/button/#API).

:::

================
File: ui-integrations/ant-design/components/fields/boolean-field/index.md
================
---
title: Boolean
swizzle: true
---

This field is used to display boolean values. It uses the [`<Tooltip>`](https://ant.design/components/tooltip/#header) values from Ant Design.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

Let's see how we can use `<BooleanField>` with the example in the post list:

```tsx live previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  useTable,
  // highlight-next-line
  BooleanField,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  const TrueIcon = () => <span>✅</span>;
  const FalseIcon = () => <span>❌</span>;

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column
          dataIndex="status"
          title="Published"
          render={(value) => (
            // highlight-start
            <BooleanField
              value={value === "published"}
              trueIcon={<TrueIcon />}
              falseIcon={<FalseIcon />}
              valueLabelTrue="published"
              valueLabelFalse="unpublished"
            />
            // highlight-end
          )}
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <PostList />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/BooleanField"
title-description="The text shown in the tooltip"
title-default="`value` ? `valueLabelTrue` : `valueLabelFalse`"
trueIcon-default="[`<CheckOutlined />`](https://ant.design/components/icon/)"
falseIcon-default="[`<CloseOutlined />`](https://ant.design/components/icon/)"
/>

:::simple External Props

This field also accepts all props of Ant Design's [Tooltip](https://ant.design/components/tooltip/#API) component.

:::

================
File: ui-integrations/ant-design/components/fields/date-field/index.md
================
---
title: Date
swizzle: true
---

This field is used to display dates. It uses the [`Day.js`](https://day.js.org/docs/en/display/format) to display date format.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

Let's see how we can use `<DateField>` with the example in the post list:

```tsx live previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { List, useTable, DateField } from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column
          dataIndex="createdAt"
          title="Created At"
          // highlight-next-line
          render={(value) => <DateField value={value} />}
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
  createdAt: string;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <PostList />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/DateField" format-default="`L`"/>

:::simple External Props

This field also accepts all props of Ant Design's [Text](https://ant.design/components/typography/#Typography.Text) component.

:::

================
File: ui-integrations/ant-design/components/fields/email-field/index.md
================
---
title: Email
swizzle: true
---

This field is used to display email values. It uses the [`<Link>`](https://ant.design/components/typography/#FAQ) component of [`<Typography>`](https://ant.design/components/typography) from Ant Design.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

Let's see how we can use `<EmailField>` with the example in the user list:

```tsx live previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/users"]);

// visible-block-start
import {
  List,
  useTable,
  // highlight-next-line
  EmailField,
} from "@refinedev/antd";
import { Table } from "antd";

const UserList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column
          dataIndex="email"
          title="Email"
          // highlight-next-line
          render={(value: string) => <EmailField value={value} />}
          width="100%"
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  email: string;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "users",
          list: "/users",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/users"
          element={
            <div style={{ padding: 16 }}>
              <UserList />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::simple Implementation Tips

`<EmailField>` uses "mailto:" in the href prop of the `<Link>` component. For this reason, clicking `<EmailField>` opens your device's default mail application.

:::

## API Reference

<PropsTable module="@refinedev/antd/EmailField" />

:::simple External Props

This field also accepts all props of Ant Design's [Link](https://ant.design/components/typography/#How-to-use-Typography.Link-in-react-router) component.

:::

> For more information, refer to the [documentation for the rest of Link properties &#8594](https://ant.design/components/typography/#API)

================
File: ui-integrations/ant-design/components/fields/file-field/index.md
================
---
title: File
swizzle: true
---

This field is used to display files and uses [`<Typography.Link>`](https://ant.design/components/typography) from Ant Design.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

Let's see how we can use `<FileField>` with the example in the edit page:

```tsx live previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  useTable,
  // highlight-next-line
  FileField,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column<IPost>
          title="Image"
          dataIndex="image"
          render={(_, record) => (
            // highlight-next-line
            <FileField src={record.image[0].url} />
          )}
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
  image: [
    {
      url: string;
    },
  ];
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <PostList />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::simple Implementation Tips

If you don't use `title` prop it will use `src` as `title`

:::

## API Reference

### Properties

<PropsTable module="@refinedev/antd/FileField" />

:::simple External Props

This field also accepts all props of Ant Design's [Link](https://ant.design/components/typography/#How-to-use-Typography.Link-in-react-router) component.

:::

================
File: ui-integrations/ant-design/components/fields/image-field/index.md
================
---
title: Image
swizzle: true
---

This field is used to display images and uses [`<Image>`](https://ant.design/components/image/#header) from Ant Design.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

Let's see how we can use `<ImageField>` with the example in the edit page:

```tsx live previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  useTable,
  // highlight-next-line
  ImageField,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column<IPost>
          title="Image"
          dataIndex="image"
          render={(_, record) => (
            // highlight-start
            <ImageField
              value={record.image[0].url}
              title={record.image[0].name}
              width={200}
            />
            // highlight-end
          )}
          width="50%"
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
  image: [
    {
      url: string;
    },
  ];
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <PostList />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/ImageField" value-description="Image path"/>

:::simple External Props

It also accepts all props of Ant Design [Image](https://ant.design/components/image/#API).

:::

================
File: ui-integrations/ant-design/components/fields/markdown-field/index.md
================
---
title: Markdown
swizzle: true
---

This field lets you display markdown content. It supports [GitHub Flavored Markdown](https://github.github.com/gfm/).

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

Let's see how we can use `<MarkdownField>` in a show page:

```tsx live previewHeight=280px url=http://localhost:3000/samples/show/123
setInitialRoutes(["/samples", "/samples/show/123"]);

// visible-block-start
import { useShow } from "@refinedev/core";
import {
  Show,
  // highlight-next-line
  MarkdownField,
} from "@refinedev/antd";
import { Typography } from "antd";

const { Title, Text } = Typography;

const SampleShow: React.FC = () => {
  const { queryResult } = useShow<IPost>();
  const { data, isLoading } = queryResult;
  const record = data?.data;

  return (
    <Show isLoading={isLoading}>
      <Title level={5}>Id</Title>
      <Text>{record?.id}</Text>

      <Title level={5}>Content</Title>

      {/* highlight-next-line */}
      <MarkdownField value={record?.content} />
    </Show>
  );
};

interface IPost {
  id: number;
  content: string;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "samples",
          list: "/samples",
          show: "/samples/show/:id",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/samples"
          element={
            <div style={{ padding: 16 }}>
              <div>
                <p>This page is empty.</p>
                <RefineAntd.ShowButton recordItemId="123">
                  Show Item 123
                </RefineAntd.ShowButton>
              </div>
            </div>
          }
        />
        <ReactRouter.Route
          path="/samples/show/:id"
          element={
            <div style={{ padding: 16 }}>
              <SampleShow />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/MarkdownField" value-description="Markdown data to render"/>

## Example

<CodeSandboxExample path="input-custom" />

================
File: ui-integrations/ant-design/components/fields/number-field/index.md
================
---
title: Number
swizzle: true
---

This field is used to display a number formatted according to the browser locale, right aligned. and uses [`Intl`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl) to display date format.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

`<NumberField>` uses `Intl.NumberFormat()` if available, passing the locales and options props as arguments. This allows a perfect display of decimals, currencies, percentages, etc. See the [Intl.NumberFormat documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat) for the options prop syntax.

If Intl is not available, `<NumberField>` outputs numbers as is (and ignores the locales and options props).

```tsx live previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  // highlight-next-line
  NumberField,
  useTable,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column<IPost>
          key="hit"
          title="Hit"
          dataIndex="hit"
          render={(value) => (
            // highlight-start
            <NumberField
              value={value}
              options={{
                notation: "compact",
              }}
            />
            // highlight-end
          )}
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
  hit: number;
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <PostList />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/NumberField" value-description="Number value" />

:::simple External Props

This field also accepts all props of Ant Design's [Text](https://ant.design/components/typography/#Typography.Text) component.

:::

================
File: ui-integrations/ant-design/components/fields/tag-field/index.md
================
---
title: Tag
swizzle: true
---

This field lets you display a value in a tag. It uses Ant Design's [`<Tag>`](https://ant.design/components/tag/) component.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

Let's see how we can use it in a basic list page:

```tsx live previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { List, TagField, useTable } from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column
          dataIndex="status"
          title="Status"
          render={(value: string) => <TagField value={value} />}
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <PostList />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/TagField" value-description="Tag content" />

:::simple External Props

This field also accepts all props of Ant Design's [Tag](https://ant.design/components/tag/#API) component.

:::

================
File: ui-integrations/ant-design/components/fields/text-field/index.md
================
---
title: Text
swizzle: true
---

This field lets you show basic text. It uses Ant Design's [`<Typography.Text>`](https://ant.design/components/typography/#Typography.Text) component.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

Let's see how to use it in a basic list page:

```tsx live previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start
import { useMany } from "@refinedev/core";
import {
  List,
  // highlight-next-line
  TextField,
  useTable,
} from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  const categoryIds =
    tableProps?.dataSource?.map((item) => item.category.id) ?? [];

  const { data: categoriesData, isLoading } = useMany<ICategory>({
    resource: "categories",
    ids: categoryIds,
    queryOptions: {
      enabled: categoryIds.length > 0,
    },
  });

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column
          dataIndex={["category", "id"]}
          title="Category"
          render={(value: number) => {
            // highlight-start
            if (isLoading) {
              return <TextField value="Loading..." />;
            }

            return (
              <TextField
                strong
                value={
                  categoriesData?.data.find((item) => item.id === value)?.title
                }
              />
            );
            // highlight-end
          }}
        />
      </Table>
    </List>
  );
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  category: { id: number };
}
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <PostList />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

:::simple Implementation Tips

Table columns already render their data as text by default. If the rendered data is in text form and its text field won't be customized with any of Ant Design `<Typography.Text>` properties, there isn't any need to use `<TextField>` in a column's render function.

:::

## API Reference

### Properties

<PropsTable module="@refinedev/antd/TextField" />

:::simple External Props

This field also accepts all props of Ant Design's [Text](https://ant.design/components/typography/#Typography.Text) component.

:::

================
File: ui-integrations/ant-design/components/fields/url-field/index.md
================
---
title: Url
swizzle: true
---

This field lets you embed a link. It uses Ant Design's [<Typography.Link\>](https://ant.design/components/typography/) component. You can pass a URL in its `value` prop and you can show a text in its place by passing any `children`.

:::simple Good to know

You can swizzle this component to customize it with the [**Refine CLI**](/docs/packages/list-of-packages)

:::

## Usage

Let's see how we can use `<UrlField>` with an example:

```tsx live previewHeight=280px url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

import { List, UrlField, useTable } from "@refinedev/antd";
import { Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column
          dataIndex={["image", "0", "url"]}
          title="Image"
          // highlight-next-line
          render={(value: string) => <UrlField value={value} />}
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
  image: IImage[];
}

interface IImage {
  url: string;
}

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route
          path="/posts"
          element={
            <div style={{ padding: 16 }}>
              <PostList />
            </div>
          }
        />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/UrlField" value-description="URL for link to reference to"/>

:::simple External Props

This field also accepts all props of Ant Design's [Link](https://ant.design/components/typography/#How-to-use-Typography.Link-in-react-router) component.

:::

================
File: ui-integrations/ant-design/components/filter-dropdown/index.md
================
---
title: <FilterDropdown />
---

## Usage

`<FilterDropdown>` is a helper component for [filter dropdowns in Ant Design's `<Table>` components.](https://ant.design/components/table/#components-table-demo-custom-filter-panel)

It serves as a bridge by synchronizing between its children's input value and `<Table>`'s filter values.

```tsx title="components/pages/postList.tsx"
import {
  List,
  // highlight-start
  FilterDropdown,
  // highlight-end
  useTable,
} from "@refinedev/antd";
import { Table, Select } from "antd";

const PostList: React.FC = (props) => {
  const { tableProps } = useTable<IPost>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column
          dataIndex={["category", "id"]}
          title="Category"
          key="category.id"
          // highlight-start
          filterDropdown={(props) => (
            <FilterDropdown {...props}>
              <Select
                mode="multiple"
                placeholder="Select Category"
                options={[
                  { label: "Ergonomic", value: "1" },
                  { label: "Island", value: "2" },
                ]}
              />
            </FilterDropdown>
          )}
          // highlight-end
        />
      </Table>
    </List>
  );
};

interface IPost {
  id: number;
  category: {
    id: number;
  };
}
```

Selecting categories from dropdown will send the id's of categories as filtering values to **Table** and data will be updated by Refine under the hood.

`<FilterDropdown>` will put two buttons for filtering and clearing filter actions.

<Image src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/category_filter-dropdown.png" alt="Show record action" />

We added category options for `<Select>` manually for the sake of simplicity but the [useSelect](/docs/ui-integrations/ant-design/hooks/use-select) hook can be used to populate the props of `<Select>`

```tsx
const { selectProps: categorySelectProps } = useSelect<ICategory>({
  resource: "categories",
  optionLabel: "title",
  optionValue: "id",
});

<Select {...categorySelectProps} />;
```

## Properties

### selectedKeys, setSelectedKeys, confirm, clearFilters

These are to be passed from [`<Table.Column>`'s filterDropdown](https://ant.design/components/table/#Column) prop.

### mapValue

The `mapValue` function is a utility function used to transform the `selectedKeys` based on certain events.

```ts
function mapValue(selectedKeys: React.Key[], event: "onChange" | "value"): any;
```

- `selectedKeys`: The selected keys from the dropdown.
- `event`: The event that triggered the `mapValue` function. It can be either `onChange` or `value`.
  - `onChange`: The event that is triggered when the value of the dropdown changes. It is used to map the value to the format that the Refine expects(data provider, syncWithLocation etc.).
  - `value`: When the value needs to be mapped for the child component.

For example when using [`useSelect`](/docs/ui-integrations/ant-design/hooks/use-select/) for [`<Select />`](https://ant.design/components/select/) component, in which case, the values must be mapped to `number`s using `mapValue`.

```tsx
import { getDefaultFilter } from "@refinedev/core";
import { useTable, FilterDropdown, useSelect } from "@refinedev/antd";
import { Table, Select } from "antd";

const { tableProps, filters } = useTable<IPost>({
  filters: {
    initial: [
      {
        field: "category.id",
        value: [1, 2],
        operator: "in",
      },
    ],
  },
});

const { selectProps: categorySelectProps } = useSelect<ICategory>({
  resource: "categories",
  optionLabel: "title",
  optionValue: "id",
  defaultValue: getDefaultFilter("category.id", filters, "in"),
});

<Table>
  <Table.Column dataIndex="id" title="ID" />
  <Table.Column
    dataIndex={["category", "id"]}
    title="Category"
    key="category.id"
    filterDropdown={(props) => (
      <FilterDropdown
        {...props}
        mapValue={(selectedKeys) =>
          selectedKeys.map((i) => parseInt(i.toString()))
        }
      >
        <Select
          style={{ minWidth: 200 }}
          mode="multiple"
          placeholder="Select Category"
          {...categorySelectProps}
        />
      </FilterDropdown>
    )}
    defaultFilteredValue={getDefaultFilter("category.id", filters, "in")}
  />
</Table>;
```

#### rangePickerFilterMapper

A more complex example is using a filter dropdown with a date picker.

Imagine you need to filter data based on a date range where Refine's data provider expects dates in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, but Ant Design's [`<DatePicker.RangePicker />`](https://ant.design/components/date-picker) uses Dayjs objects. To solve this, use the `mapValue` and [`rangePickerFilterMapper`](https://github.com/refinedev/refine/blob/main/packages/antd/src/definitions/filter-mappers/index.ts) utility function to convert `selectedKeys` to satisfy both the data provider and `<DatePicker.RangePicker />`.

```tsx
import { getDefaultFilter } from "@refinedev/core";
import {
  DateField,
  FilterDropdown,
  rangePickerFilterMapper,
  useTable,
} from "@refinedev/antd";
import { Table, DatePicker } from "antd";

export const Posts = () => {
  const { tableProps, filters } = useTable({
    filters: {
      initial: [
        {
          field: "created_at",
          value: ["2022-01-01", "2022-01-31"],
          operator: "between",
        },
      ],
    },
  });

  return (
    <Table {...tableProps} rowKey="id">
      <Table.Column dataIndex="id" title="ID" />
      <Table.Column dataIndex="title" title="Title" />
      <Table.Column
        dataIndex="createdAt"
        title="Created At"
        filterDropdown={(props) => (
          <FilterDropdown
            {...props}
            mapValue={(selectedKeys, event) => {
              return rangePickerFilterMapper(selectedKeys, event);
            }}
          >
            <DatePicker.RangePicker />
          </FilterDropdown>
        )}
        defaultFilteredValue={getDefaultFilter(
          "created_at",
          filters,
          "between",
        )}
      />
    </Table>
  );
};
```

Let's closer look at the [`rangePickerFilterMapper`](https://github.com/refinedev/refine/blob/main/packages/antd/src/definitions/filter-mappers/index.ts) function source code to understand how it works.

when the `event` is:

- `"value"`: It converts the `selectedKeys` to Dayjs objects to be used in the `<DatePicker.RangePicker />` component.
- `"onChange"`, It converts the Dayjs objects to ISO 8601 string format to be used in the Refine(data-provider, syncWithLocation etc.) filter.

```ts
import type {
  FilterDropdownProps,
  MapValueEvent,
} from "@components/table/components";
import dayjs from "dayjs";

export const rangePickerFilterMapper = (
  selectedKeys: FilterDropdownProps["selectedKeys"],
  event: MapValueEvent,
) => {
  if (!selectedKeys) {
    return selectedKeys;
  }

  if (event === "value") {
    return selectedKeys.map((key) => {
      if (typeof key === "string") {
        return dayjs(key);
      }

      return key;
    });
  }

  if (event === "onChange") {
    if (selectedKeys.every(dayjs.isDayjs)) {
      return selectedKeys.map((date: any) => dayjs(date).toISOString());
    }
  }

  return selectedKeys;
};
```

:::simple Good to know

If [syncWithLocation](/docs/core/refine-component#syncwithlocation) is enabled, on page refresh, the filter values will be type of `string` since they will be parsed from URL. This might produce some incompatibility if data for filter input comes from an API and it's not type of `string`.

`getDefaultFilter` finds filter values for a given column from the given filters. In the example, `filters` passed to `getDefaultFilter` includes filter values from the URL since it comes from `useTable`.

:::

<PropsTable module="@refinedev/antd/FilterDropdown"/>

## Example

<CodeSandboxExample path="table-antd-use-table" />

================
File: ui-integrations/ant-design/components/inferencer/index.md
================
---
title: Inferencer
---

You can automatically generate views for your resources using `@refinedev/inferencer`. Inferencer exports the `AntdListInferencer`, `AntdShowInferencer`, `AntdEditInferencer`, `AntdCreateInferencer` components and finally the `AntdInferencer` component, which combines all in one place.

## Usage

Inferencer components can be imported from `@refinedev/inferencer/antd`. You can directly use the components in your routes without passing any props. If you use a `routerProvider`, it will infer the `resource`, `action` and `id` from the current route.

<Tabs
defaultValue="resources"
values={[
{label: <>In<code style={{ margin: "0 0.7ch" }}>resources</code>prop</>, value: 'resources'},
{label: 'In Custom Components', value: 'custom'}
]}>
<TabItem value="resources">

```tsx
import routerProvider from "@refinedev/react-router";
import { BrowserRouter } from "react-router";
// highlight-next-line
import { AntdInferencer } from "@refinedev/inferencer/antd";

const App = () => {
  return (
    <BrowserRouter>
      <Refine
        routerProvider={routerProvider}
        resources={[
          {
            name: "samples",
            list: "/samples",
          },
        ]}
      >
        <Routes>
          {/* highlight-next-line */}
          <Route path="/samples" element={<AntdInferencer />} />
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};
```

  </TabItem>
  <TabItem value="custom">

```tsx
// highlight-next-line
import { AntdInferencer } from "@refinedev/inferencer/antd";

const SampleList = () => {
  return (
    // highlight-next-line
    <AntdInferencer resource="samples" action="list" />
  );
};

const SampleShow = () => {
  return (
    // highlight-next-line
    <AntdInferencer resource="samples" action="show" id="1" />
  );
};

const SampleCreate = () => {
  return (
    // highlight-next-line
    <AntdInferencer resource="samples" action="create" />
  );
};

const SampleEdit = () => {
  return (
    // highlight-next-line
    <AntdInferencer resource="samples" action="edit" id="1" />
  );
};
```

  </TabItem>
</Tabs>

> For more information, refer to the [Inferencer documentation](/docs/packages/list-of-packages)

## Views

### List

Generates a sample list view for your resources according to the API response. It uses the `List` and `Table` components with the `useTable` hook from `@refinedev/antd`.

```tsx live hideCode previewHeight=600px url=http://localhost:3000/samples
setInitialRoutes(["/samples"]);

// visible-block-start
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { ConfigProvider } from "antd";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

// highlight-next-line
import { AntdInferencer } from "@refinedev/inferencer/antd";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "samples",
              list: "/samples",
            },
          ]}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              {/* highlight-next-line */}
              <Route path="/samples" element={<AntdInferencer />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

### Show

Generates a sample show view for your resources according to the API response. It uses the `Show` and field components from `@refinedev/antd` with the `useShow` hook from `@refinedev/core`.

```tsx live hideCode previewHeight=600px url=http://localhost:3000/samples/show/123
setInitialRoutes(["/samples/show/123"]);

// visible-block-start
import { Refine } from "@refinedev/core";
import { RefineThemes, ThemedLayoutV2 } from "@refinedev/antd";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { ConfigProvider } from "antd";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

// highlight-next-line
import { AntdInferencer } from "@refinedev/inferencer/antd";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "samples",
              show: "/samples/show/:id",
            },
          ]}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              {/* highlight-next-line */}
              <Route path="/samples/show/:id" element={<AntdInferencer />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

### Create

Generates a sample create view for your resources according to the first record in list API response. It uses the `Create` component and the `useForm` hook from `@refinedev/antd`.

```tsx live hideCode previewHeight=600px url=http://localhost:3000/samples/create
setInitialRoutes(["/samples/create"]);

// visible-block-start
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { ConfigProvider } from "antd";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

// highlight-next-line
import { AntdInferencer } from "@refinedev/inferencer/antd";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "samples",
              create: "/samples/create",
            },
          ]}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              {/* highlight-next-line */}
              <Route path="/samples/create" element={<AntdInferencer />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

### Edit

Generates a sample edit view for your resources according to the API response. It uses the `Edit` component and the `useForm` hook from `@refinedev/antd`.

```tsx live hideCode previewHeight=600px url=http://localhost:3000/samples/edit/123
setInitialRoutes(["/samples/edit/123"]);

// visible-block-start
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import routerProvider from "@refinedev/react-router";
import dataProvider from "@refinedev/simple-rest";

import { ConfigProvider } from "antd";

import { BrowserRouter, Routes, Route, Outlet } from "react-router";

// highlight-next-line
import { AntdInferencer } from "@refinedev/inferencer/antd";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          resources={[
            {
              name: "samples",
              edit: "/samples/edit/:id",
            },
          ]}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              {/* highlight-next-line */}
              <Route path="/samples/edit/:id" element={<AntdInferencer />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

## Example

Below you'll find a Live CodeSandbox Example displaying a fully setup Refine app with the `@refinedev/inferencer/antd` components.

<CodeSandboxExample path="inferencer-antd" />

================
File: ui-integrations/ant-design/components/inputs/custom-inputs.md
================
---
id: custom-inputs
title: Custom Inputs
---

Refine uses Ant Design's [`<Form>`](https://ant.design/components/form/) components to control and work with form data. Ant Design supports custom form items inside the [`<Form.Item>`](https://ant.design/components/form/#Form.Item) components. These items should be controllable via their `value` property and should implement `onChange` (or a custom callback name specified by [`<Form.Item>`](https://ant.design/components/form/#Form.Item)'s `trigger` prop).

For some data types, displaying and editing as plain text may cause user experience problems.

Custom components may be useful when working with markdown (with markdown editor), JSON based rich text (draft, quill like editors), and HTML (a HTML editor). It can be used in table columns and form fields

> For more information, refer to the [Ant Design's `<Form>` documentation. &#8594](https://ant.design/components/form/)

## Example

We will demonstrate how to use custom input fields for markdown data by adding a markdown editor to edit and create forms:

```tsx title="/src/pages/posts/edit.tsx"
import React, { useState } from "react";
import { Edit, useForm } from "@refinedev/antd";
import { Form, Input } from "antd";

// highlight-start
import MDEditor from "@uiw/react-md-editor";
// highlight-end

import { IPost } from "interfaces";

export const PostEdit: React.FC = (props) => {
  const { formProps, saveButtonProps } = useForm<IPost>();

  return (
    <Edit {...props} saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input />
        </Form.Item>
        // highlight-start
        <Form.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <MDEditor data-color-mode="light" />
        </Form.Item>
        // highlight-end
      </Form>
    </Edit>
  );
};
```

<Image src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/guides-and-concepts/components/inputs/custom-inputs/markdown-input.png" alt="Markdown input" />
<br/>

## Example

<CodeSandboxExample path="input-custom" />

================
File: ui-integrations/ant-design/components/themed-layout/index.md
================
---
title: <ThemedLayout />
description: <ThemedLayoutV2> component from Refine, defines the overall structure and layout of a web page.
swizzle: true
source: packages/antd/src/components/themedLayoutV2/index.tsx
---

```tsx live shared
const authProvider = {
  login: async () => ({
    success: true,
    redirectTo: "/",
  }),
  logout: async () => ({
    success: true,
    redirectTo: "/login",
  }),
  onError: async (error) => {
    console.error(error);
    return { error };
  },
  check: async () => ({
    authenticated: true,
  }),
  getIdentity: async () => ({
    id: 1,
    name: "Jane Doe",
    avatar: "https://unsplash.com/photos/IWLOvomUmWU/download?force=true&w=640",
  }),
};
```

`<ThemedLayoutV2>` component uses the [`<Layout>`][antd-layout] and [`<Sider>`][antd-sider] components from the Ant Design library to define the layout and structure of a web page. It includes customizable components for the header, sidebar, title, footer, and off-layout area, which can be replaced or customized as needed.

By using `<ThemedLayoutV2>`, developers can create a consistent look and feel across multiple pages or sections of a website, while also improving code maintainability and reusability. The customizable sections of `<ThemedLayoutV2>` include:

- [`<ThemedHeaderV2>`][themed-header]: displayed at the top of the page and can display the user's name and avatar.
- [`<ThemedSiderV2>`][themed-sider]: displayed on the left side of the page and can display menu items.
- [`<ThemedTitleV2>`][themed-title]: displayed at the top of [`<ThemedSiderV2>`][themed-sider] and includes an icon and text.
- `<Footer>`: displayed at the bottom of the page.
- `<OffLayoutArea>`: rendered outside of the main layout component and can be placed anywhere on the page while still being part of the overall layout.

## Usage

We'll show what default `<ThemedLayoutV2>` looks like in the following example.

```tsx live previewHeight=600px hideCode url=http://localhost:3000/samples
setInitialRoutes(["/samples"]);

// visible-block-start

import { Refine } from "@refinedev/core";
// highlight-next-line
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import { ConfigProvider } from "antd";
import { AntdInferencer } from "@refinedev/inferencer/antd";

import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import dataProvider from "@refinedev/simple-rest";

import { authProvider } from "./authProvider";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          authProvider={authProvider}
          resources={[
            {
              name: "samples",
              list: "/samples",
            },
          ]}
        >
          <Routes>
            <Route
              element={
                // highlight-next-line
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="/samples" element={<AntdInferencer />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

`<ThemedLayoutV2>` is designed to be responsive. In the live-preview, it appears in tablet mode and uses [`<Drawer>`][antd-drawer]. On larger screens, it will use [`<Sider>`][antd-sider].

Example of above showing how to use `<ThemedLayoutV2>` with [`React Router`](/docs/packages/list-of-packages). You can see these examples for other routers:

- [React Router](https://github.com/refinedev/refine/blob/main/examples/auth-antd/src/App.tsx#L186)
- [Next.js](https://github.com/refinedev/refine/blob/main/examples/with-nextjs/src/app/layout.tsx#L35)
- [Remix](https://github.com/refinedev/refine/blob/main/examples/with-remix-auth/app/routes/_protected.tsx)

## Props

### Sider

In `<ThemedLayoutV2>`, the sidebar section is rendered using the [`<ThemedSiderV2>`][themed-sider] component by default. This component is specifically designed to generate menu items based on the resources defined in [`<Refine>`][refine-component] components, using the [`useMenu`][use-menu] hook. However, if desired, it's possible to replace the default [`<ThemedSiderV2>`][themed-sider] component by passing a custom component to the `Sider` prop.

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2 } from "@refinedev/antd";

import { CustomSider } from "./CustomSider";

const App: React.FC = () => {
  return (
    <Refine
    // ...
    >
      <ThemedLayoutV2
        // highlight-next-line
        Sider={() => <CustomSider />}
      >
        {/* ... */}
      </ThemedLayoutV2>
    </Refine>
  );
};
```

Also, you can customize the default [`<ThemedSiderV2>`][themed-sider] component either by using its props or with the [swizzle](#customizing-with-swizzle) feature.

Here is an example of how to customize the default [`<ThemedSiderV2>`][themed-sider] component using the `render` and `Title` prop:

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2, ThemedSiderV2 } from "@refinedev/antd";

import { CustomTitle } from "./CustomTitle";

const App: React.FC = () => {
  return (
    <Refine
    // ...
    >
      <ThemedLayoutV2
        // highlight-start
        Sider={() => (
          <ThemedSiderV2
            Title={({ collapsed }) => <CustomTitle collapsed={collapsed} />}
            render={({ items, logout, collapsed }) => {
              return (
                <>
                  <div>My Custom Element</div>
                  {items}
                  {logout}
                </>
              );
            }}
          />
        )}
        // highlight-end
      >
        {/* ... */}
      </ThemedLayoutV2>
    </Refine>
  );
};
```

Also, you can make the sidebar fixed by passing the `fixed` property, which is optional and `false` by default. You can see the usage as follows:

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2, ThemedSiderV2 } from "@refinedev/antd";

const App: React.FC = () => {
  return (
    <Refine
    // ...
    >
      <ThemedLayoutV2
        // highlight-start
        Sider={() => <ThemedSiderV2 fixed />}
        // highlight-end
      >
        {/* ... */}
      </ThemedLayoutV2>
    </Refine>
  );
};
```

#### Sider Props

| Prop                 | Type                                          | Description                                                                       |
| -------------------- | --------------------------------------------- | --------------------------------------------------------------------------------- |
| [`Title`](#title)    | `React.FC`                                    | Component to render at the top                                                    |
| `render`             | [`SiderRenderFunction`](#siderrenderfunction) | Function to render the menu items and other elements inside the `<ThemedSiderV2>` |
| `meta`               | `Record<string,any>`                          | Meta data to use when creating routes for the menu items                          |
| `fixed`              | `boolean`                                     | Whether the sider is fixed or not                                                 |
| `activeItemDisabled` | `boolean`                                     | Whether clicking on an active sider item should reload the page                   |
| `onSiderCollapsed`   | `(collapsed: boolean) => void`                | Callback function invoked when the sider collapses or expands                     |

```tsx
type SiderRenderFunction = (props: {
  items: JSX.Element[];
  logout: React.ReactNode;
  dashboard: React.ReactNode;
  collapsed: boolean;
}) => React.ReactNode;
```

### initialSiderCollapsed

This prop is used to set the initial collapsed state of the [`<ThemedSiderV2>`][themed-sider] component.

- `true`: The [`<ThemedSiderV2>`][themed-sider] component will be collapsed by default.
- `false`: The [`<ThemedSiderV2>`][themed-sider] component will be expanded by default.

```tsx
<ThemedLayoutV2
  // highlight-next-line
  initialSiderCollapsed={true}
>
  {/* ... */}
</ThemedLayoutV2>
```

### `onSiderCollapsed`

Will be triggered when the [`<ThemedSiderV2>`][themed-sider] component's `collapsed` state changes.

Can be used to persist collapsed state on the localstorage. Then you can use localStorage item to decide if sider should be collapsed initially or not.

Here's an example of how to use the `onSiderCollapsed` prop:

```tsx
const MyLayout = () => {
  const onSiderCollapse = (collapsed: boolean) => {
    localStorage.setItem("siderCollapsed", collapsed);
  };

  const initialSiderCollapsed = Boolean(localStorage.getItem("siderCollapsed"));

  return (
    <ThemedLayoutV2
      initialSiderCollapsed={initialSiderCollapsed}
      onSiderCollapsed={onSiderCollapse}
    >
      {/* ... */}
    </ThemedLayoutV2>
  );
};
```

### Header

In `<ThemedLayoutV2>`, the header section is rendered using the [`<ThemedHeaderV2>`][themed-header] component by default. It uses [`useGetIdentity`](/docs/authentication/hooks/use-get-identity) hook to display the user's name and avatar on the right side of the header. However, if desired, it's possible to replace the default [`<ThemedHeaderV2>`][themed-header] component by passing a custom component to the `Header` prop.

Here is an example of how to replace the default [`<ThemedHeaderV2>`][themed-header] component:

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2 } from "@refinedev/antd";

// highlight-next-line
import { CustomHeader } from "./CustomHeader";

const App: React.FC = () => {
  return (
    <Refine
    // ...
    >
      <ThemedLayoutV2
        // highlight-next-line
        Header={() => <CustomHeader />}
      >
        {/* ... */}
      </ThemedLayoutV2>
    </Refine>
  );
};
```

You can also make it sticky using the `sticky` property:

```tsx
import { Refine } from "@refinedev/core";
import {
  ThemedLayoutV2,
  // highlight-next-line
  ThemedHeaderV2,
} from "@refinedev/antd";

const App: React.FC = () => {
  return (
    <Refine
    // ...
    >
      <ThemedLayoutV2
        // highlight-start
        Header={() => <ThemedHeaderV2 sticky />}
        // highlight-end
      >
        {/* ... */}
      </ThemedLayoutV2>
    </Refine>
  );
};
```

### Title

In `<ThemedLayoutV2>`, the title section is rendered using the [`<ThemedTitleV2>`][themed-title] component by default. However, if desired, it's possible to replace the default [`<ThemedTitleV2>`][themed-title] component by passing a custom component to the `Title` prop.

Here is an example of how to replace the default [`<ThemedTitleV2>`][themed-title] component:

```tsx
import { Refine } from "@refinedev/core";
// highlight-next-line
import { ThemedLayoutV2, ThemedTitleV2 } from "@refinedev/antd";

// highlight-next-line
import { MyLargeIcon, MySmallIcon } from "./MyIcon";

const App: React.FC = () => {
  return (
    <Refine
    // ...
    >
      <ThemedLayoutV2
        // highlight-start
        Title={({ collapsed }) => (
          <ThemedTitleV2
            // collapsed is a boolean value that indicates whether the <Sidebar> is collapsed or not
            collapsed={collapsed}
            icon={collapsed ? <MySmallIcon /> : <MyLargeIcon />}
            text="My Project"
          />
        )}
        // highlight-end
      >
        {/* ... */}
      </ThemedLayoutV2>
    </Refine>
  );
};
```

### Footer

The footer section of the layout is displayed at the bottom of the page. Refine doesn't provide a default footer component. However, you can pass a custom component to the `Footer` prop to display a footer section.

Here is an example of how to display a footer section:

```tsx live previewHeight=600px hideCode url=http://localhost:3000/samples
setInitialRoutes(["/samples"]);

// visible-block-start

import { Refine } from "@refinedev/core";
// highlight-next-line
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import { ConfigProvider, Layout } from "antd";
import { AntdInferencer } from "@refinedev/inferencer/antd";

import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import dataProvider from "@refinedev/simple-rest";

import { authProvider } from "./authProvider";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          authProvider={authProvider}
          resources={[
            {
              name: "samples",
              list: "/samples",
            },
          ]}
        >
          <Routes>
            <Route
              element={
                // highlight-next-line
                <ThemedLayoutV2
                  Footer={() => (
                    <Layout.Footer
                      style={{
                        textAlign: "center",
                        color: "#fff",
                        backgroundColor: "#7dbcea",
                      }}
                    >
                      My Custom Footer
                    </Layout.Footer>
                  )}
                >
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="samples">
                <Route index element={<AntdInferencer />} />
              </Route>
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2 } from "@refinedev/antd";
import { Layout } from "antd";

const App: React.FC = () => {
  return (
    <Refine
    // ...
    >
      <ThemedLayoutV2
        // highlight-next-line
        Footer={() => (
          <Layout.Footer
            style={{
              textAlign: "center",
              color: "#fff",
              backgroundColor: "#7dbcea",
            }}
          >
            My Custom Footer
          </Layout.Footer>
        )}
      >
        {/* ... */}
      </ThemedLayoutV2>
    </Refine>
  );
};
```

### OffLayoutArea

Used to component is rendered outside of the main layout component, allowing it to be placed anywhere on the page while still being part of the overall layout .Refine doesn't provide a default off-layout area component. However, you can pass a custom component to the `OffLayoutArea` prop to display a custom off-layout area.

Here is an example of how to display a custom off-layout area:

```tsx live previewHeight=600px hideCode url=http://localhost:3000/samples
setInitialRoutes(["/samples"]);

// visible-block-start

import { Refine } from "@refinedev/core";
// highlight-next-line
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";
import { ConfigProvider, Button } from "antd";
import { AntdInferencer } from "@refinedev/inferencer/antd";

import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import dataProvider from "@refinedev/simple-rest";

import { authProvider } from "./authProvider";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          authProvider={authProvider}
          resources={[
            {
              name: "samples",
              list: "/samples",
            },
          ]}
        >
          <Routes>
            <Route
              element={
                // highlight-next-line
                <ThemedLayoutV2
                  OffLayoutArea={() => (
                    <Button
                      type="primary"
                      size="small"
                      onClick={() => alert("Off layout are clicked")}
                      style={{
                        position: "fixed",
                        left: "8px",
                        bottom: "8px",
                        zIndex: 1000,
                      }}
                    >
                      Send us Feedback 👋
                    </Button>
                  )}
                >
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              <Route path="/samples" element={<AntdInferencer />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2 } from "@refinedev/antd";
import { Button } from "antd";

const App: React.FC = () => {
  return (
    <Refine
    // ...
    >
      <ThemedLayoutV2
        // highlight-start
        OffLayoutArea={() => (
          <Button
            type="primary"
            size="small"
            onClick={() => alert("Off layout are clicked")}
            style={{
              position: "fixed",
              left: "8px",
              bottom: "8px",
              zIndex: 1000,
            }}
          >
            Send us Feedback 👋
          </Button>
        )}
        // highlight-end
      >
        {/* ... */}
      </ThemedLayoutV2>
    </Refine>
  );
};
```

## Customizing with swizzle

> 🚨 This feature can be used with `@refine/cli`. Please refer to [CLI documentation](/docs/packages/list-of-packages#swizzle) for more information.

`<ThemedLayoutV2>` component source code can be ejecting using the `swizzle` command. This will create a copy of the component in your project's `src` directory, allowing you to customize as your needs.

### Usage

Let's create a new component by swizzling the `<ThemedLayoutV2>` components.

```bash
> npm run refine swizzle

? Which package do you want to swizzle? (Use arrow keys or type to search)

Data Provider
 ◯ @refinedev/simple-rest
UI Framework
 ◉ @refinedev/antd
```

First, you need to select the package you want to swizzle. In this example, we will swizzle the `@refinedev/antd` package.

Refine CLI will only show the packages that are installed in your project.

```bash
? Which component do you want to swizzle?

 ◯ TagField
 ◯ TextField
 ◯ UrlField
Other
 ◯ Breadcrumb
❯◉ ThemedLayoutV2
Pages
 ◯ ErrorPage
 ◯ AuthPage
(Move up and down to reveal more choices)
```

Then, you need to select the component you want to swizzle. In this example, we will swizzle the `ThemedLayoutV2` component.

```bash
Successfully swizzled Themed Layout
Files created:
 - src/components/themedLayout/sider.tsx
 - src/components/themedLayout/header.tsx
 - src/components/themedLayout/title.tsx
 - src/components/themedLayout/index.tsx

Warning:
If you want to change the default layout;
You should pass layout related components to the <ThemedLayoutV2/> component's props.

    ╭ App.tsx ───────────────────────────────────────────────────────────────────────────────────────╮
    │                                                                                                │
    │   import { ThemedLayoutV2 } from "components/themedLayout";                                    │
    │   import { ThemedHeaderV2 } from "components/themedLayout/header";                             │
    │   import { ThemedSiderV2 } from "components/themedLayout/sider";                               │
    │   import { ThemedTitleV2 } from "components/themedLayout/title";                               │
    │                                                                                                │
    │   const App = () => {                                                                          │
    │       return (                                                                                 │
    │           <Refine                                                                              │
    │               /* ... */                                                                        │
    │           >                                                                                    │
    │               <ThemedLayoutV2                                                                  │
    │                    Header={ThemedHeaderV2}                                                     │
    │                    Sider={ThemedSiderV2}                                                       │
    │                    Title={ThemedTitleV2}                                                       │
    │                />                                                                              │
    │                   /* ... */                                                                    │
    │               </ThemedLayoutV2>                                                                │
    │           </Refine>                                                                            │
    │       );                                                                                       │
    │   }                                                                                            │
    │                                                                                                │
    ╰────────────────────────────────────────────────────────────────────────────────────────────────╯
```

Finally, the swizzle command will create a new folder in the `src/components/layout` directory and generate the layout components of the `@refinedev/antd` package in it.

You can use these components in your project as you wish.

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2 } from "components/themedLayout";
import { ThemedHeaderV2 } from "components/themedLayout/header";
import { ThemedSiderV2 } from "components/themedLayout/sider";
import { ThemedTitleV2 } from "components/themedLayout/title";

const App = () => {
  return (
    <Refine
    /* ... */
    >
      <ThemedLayoutV2
        Header={ThemedHeaderV2}
        Sider={ThemedSiderV2}
        Title={ThemedTitleV2}
      >
        /* ... */
      </ThemedLayoutV2>
    </Refine>
  );
};
```

:::simple Good to know

Refine CLI determines the path to create a new folder according to the framework you are using. For example, if you are using the `remix`, the path will be `app/components/layout`.

If there is already a file with the same name in the directory, the swizzle command will not overwrite it.

:::

## Migrate ThemedLayout to ThemedLayoutV2

Fixed some UI problems with `ThemedLayoutV2`. If you are still using `ThemedLayout` you can update it by following these step.

```diff title="src/App.tsx"
-import { ThemedLayout } from "@refinedev/antd";
+import { ThemedLayoutV2 } from "@refinedev/antd";
...
-<ThemedLayout>
+<ThemedLayoutV2>
    <Outlet />
-</ThemedLayout>
+</ThemedLayoutV2>
...
```

## collapse/uncollapse `Sider` component with `useThemedLayoutContext` hook

The `useThemedLayoutContext` hook is that is used to collapse/uncollapse the `Sider` component. You can do this anywhere you want using the `useThemedLayoutContext` hook. Below you can see an example put on the dashboard page.

```tsx live previewHeight=300px hideCode url=http://localhost:3000/
setInitialRoutes(["/"]);

// visible-block-start

import { Refine } from "@refinedev/core";
// highlight-next-line
import {
  ThemedLayoutV2,
  RefineThemes,
  useThemedLayoutContext,
} from "@refinedev/antd";
import { ConfigProvider, Button, Space } from "antd";
import { AntdInferencer } from "@refinedev/inferencer/antd";

import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";

import dataProvider from "@refinedev/simple-rest";

import { authProvider } from "./authProvider";

const API_URL = "https://api.fake-rest.refine.dev";

// highlight-start
const DashboardPage = () => {
  const {
    siderCollapsed,
    setSiderCollapsed,
    mobileSiderOpen,
    setMobileSiderOpen,
  } = useThemedLayoutContext();

  return (
    <Space style={{ paddingTop: 30 }}>
      <Button
        type="primary"
        onClick={() => setMobileSiderOpen(!mobileSiderOpen)}
      >
        toggle mobile sider
      </Button>
      <Button type="primary" onClick={() => setSiderCollapsed(!siderCollapsed)}>
        toggle collapse of sider
      </Button>
    </Space>
  );
};
// highlight-end

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <Refine
          routerProvider={routerProvider}
          dataProvider={dataProvider(API_URL)}
          authProvider={authProvider}
          resources={[
            // highlight-start
            {
              name: "dashboard",
              list: "/",
            },
            // highlight-end
            {
              name: "samples",
              list: "/samples",
            },
          ]}
        >
          <Routes>
            <Route
              element={
                <ThemedLayoutV2>
                  <Outlet />
                </ThemedLayoutV2>
              }
            >
              {/* highlight-next-line */}
              <Route path="/" element={<DashboardPage />} />
              <Route path="/samples" element={<AntdInferencer />} />
            </Route>
          </Routes>
        </Refine>
      </ConfigProvider>
    </BrowserRouter>
  );
};

// visible-block-end

render(<App />);
```

## FAQ

### How can I persist the collapsed state of the [`<ThemedSiderV2>`][themed-sider] component?

You can use [`initialSiderCollapsed`](#initialsidercollapsed) prop to persist the collapsed state of the [`<ThemedSiderV2>`][themed-sider] component.

For example, you can get `initialSiderCollapsed`'s value from `localStorage` or `cookie` for persistence between sessions:

<Tabs
defaultValue="react-router"
values={[
{label: 'React Router', value: 'react-router'},
{label: 'Next.js', value: 'next.js'},
{label: 'Remix', value: 'remix'},
]}>

<TabItem value="react-router">

```tsx title="src/App.tsx"
import { useState } from "react";
import { Refine } from "@refinedev/core";
import { BrowserRouter, Routes, Route, Outlet } from "react-router";
import { ThemedLayoutV2 } from "@refinedev/antd";

const App: React.FC = () => {
  // you can get this value from `localStorage` or `cookie`
  // for persistence between sessions
  const [initialSiderCollapsed, setInitialSiderCollapsed] = useState(true);

  return (
    <BrowserRouter>
      <Refine
      // ...
      >
        {/* ... */}
        <Routes>
          <Route
            element={
              <ThemedLayoutV2 initialSiderCollapsed={initialSiderCollapsed}>
                <Outlet />
              </ThemedLayoutV2>
            }
          >
            {/* ... */}
          </Route>
        </Routes>
      </Refine>
    </BrowserRouter>
  );
};

export default App;
```

</TabItem>

<TabItem value="next.js">

```tsx title="pages/_app.tsx"
import { useState } from "react";

import { Refine } from "@refinedev/core";
import { ThemedLayoutV2 } from "@refinedev/antd";

import type { AppProps } from "next/app";
import type { NextPage } from "next";

function MyApp({ Component, pageProps }: AppProps): JSX.Element {
  // you can get this value from `localStorage` or `cookie`
  // for persistence between sessions
  const [initialSiderCollapsed, setInitialSiderCollapsed] = useState(true);

  const renderComponent = () => {
    if (Component.noLayout) {
      return <Component {...pageProps} />;
    }

    return (
      <ThemedLayoutV2 initialSiderCollapsed={initialSiderCollapsed}>
        <Component {...pageProps} />
      </ThemedLayoutV2>
    );
  };

  return (
    <Refine
    // ...
    >
      {/* ... */}
      {renderComponent()}
    </Refine>
  );
}

export default MyApp;
```

</TabItem>

<TabItem value="remix">

```tsx title="app/routes/_layout.tsx"
import { useState } from "react";
import { Outlet } from "@remix-run/react";
import { ThemedLayoutV2 } from "@refinedev/antd";

export default function BaseLayout() {
  // you can get this value from `localStorage` or `cookie`
  // for persistence between sessions
  const [initialSiderCollapsed, setInitialSiderCollapsed] = useState(true);

  return (
    <ThemedLayoutV2 initialSiderCollapsed={initialSiderCollapsed}>
      <Outlet />
    </ThemedLayoutV2>
  );
}
```

</TabItem>

</Tabs>
```

[themed-sider]: https://github.com/refinedev/refine/blob/main/packages/antd/src/components/themedLayoutV2/sider/index.tsx
[themed-header]: https://github.com/refinedev/refine/blob/main/packages/antd/src/components/themedLayoutV2/header/index.tsx
[themed-title]: https://github.com/refinedev/refine/blob/main/packages/antd/src/components/themedLayoutV2/title/index.tsx
[use-menu]: /docs/core/hooks/utilities/use-menu
[refine-component]: /docs/core/refine-component
[antd-drawer]: https://ant.design/components/drawer
[antd-sider]: https://ant.design/components/layout#layoutsider
[antd-layout]: https://ant.design/components/layout

================
File: ui-integrations/ant-design/hooks/use-checkbox-group/index.md
================
---
title: useCheckboxGroup
---

`useCheckboxGroup` hook allows you to manage an Ant Design [Checkbox.Group](https://ant.design/components/checkbox/#components-checkbox-demo-group) component when records in a resource needs to be used as checkbox options.

## Usage

We will demonstrate how to get data at the `/tags` endpoint from the `https://api.fake-rest.refine.dev` REST API.

```ts title="https://api.fake-rest.refine.dev/tags"
{
  [
    {
      id: 1,
      title: "Driver Deposit",
    },
    {
      id: 2,
      title: "Index Compatible Synergistic",
    },
    {
      id: 3,
      title: "Plum",
    },
  ];
}
```

```tsx title="pages/posts/create.tsx"
import { useCheckboxGroup } from "@refinedev/antd";
import { Form, Checkbox } from "antd";

export const PostCreate: React.FC = () => {
  // highlight-start
  const { checkboxGroupProps } = useCheckboxGroup<ITag>({
    resource: "tags",
  });
  // highlight-end

  return (
    <Form>
      <Form.Item label="Tags" name="tags">
        // highlight-next-line
        <Checkbox.Group {...checkboxGroupProps} />
      </Form.Item>
    </Form>
  );
};

interface ITag {
  id: number;
  title: string;
}
```

<br/>

All we have to do is pass the `checkboxGroupProps` it returns to the `<Checkbox.Group>` component.
`useCheckboxGroup` uses the `useList` hook for fetching data.

<Image src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/hooks/useCheckboxGroup/basic.png" alt="Tags" />

> For more information, refer to the [`useList` documentation &#8594](/docs/data/hooks/use-list)

## Options

### resource

```tsx
const { checkboxGroupProps } = useCheckboxGroup({
  resource: "tags",
});
```

`resource` property determines which API resource endpoint to fetch records from [`dataProvider`](/docs/data/data-provider). It returns properly configured `options` values for checkboxes.

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

> For more information, refer to the [Ant Design's Checkbox.Group component documentation &#8594](https://ant.design/components/checkbox)

### defaultValue

```tsx
const { selectProps } = useCheckboxGroup({
  resource: "languages",
  // highlight-next-line
  defaultValue: [1, 2],
});
```

### selectedOptionsOrder

`selectedOptionsOrder` allows us to sort `selectedOptions` on `defaultValue`. It can be:

- `"in-place"`: sort `selectedOptions` at the bottom. It is by default.
- `"selected-first"`: sort `selectedOptions` at the top.

```tsx
const { selectProps } = useCheckboxGroup({
  resource: "languages",
  // highlight-next-line
  defaultValue: [1, 2],
  // highlight-next-line
  selectedOptionsOrder: "selected-first", // in-place | selected-first
});
```

The easiest way to select default values for checkbox fields is by passing in `defaultValue`.

### optionLabel and optionValue

```tsx
const { checkboxGroupProps } = useCheckboxGroup({
  resource: "tags",
  // highlight-start
  optionLabel: "title",
  optionValue: "id",
  // highlight-end
});
```

`optionLabel` and `optionValue` allows you to change the values and appearances of your options. Default values are `optionLabel = "title"` and `optionValue = "id"`.

These properties also support nested property access with [Object path](https://lodash.com/docs/4.17.15#get) syntax.

```tsx
const { options } = useCheckboxGroup({
  resource: "categories",
  // highlight-start
  optionLabel: "nested.title",
  optionValue: "nested.id",
  // highlight-end
});
```

It's also possible to pass function to these props. These functions will receive `item` argument.

```tsx
const { options } = useCheckboxGroup({
  optionLabel: (item) => `${item.firstName} ${item.lastName}`,
  optionValue: (item) => item.id,
});
```

### searchField

Can be used to specify which field will be searched with value given to `onSearch` function.

```tsx
const { onSearch } = useCheckboxGroup({ searchField: "name" });

onSearch("John"); // Searches by `name` field with value John.
```

By default, it uses `optionLabel`'s value, if `optionLabel` is a string. Uses `title` field otherwise.

```tsx
// When `optionLabel` is string.
const { onSearch } = useCheckboxGroup({ optionLabel: "name" });

onSearch("John"); // Searches by `name` field with value John.

// When `optionLabel` is function.
const { onSearch } = useCheckboxGroup({
  optionLabel: (item) => `${item.id} - ${item.name}`,
});

onSearch("John"); // Searches by `title` field with value John.
```

### filters

`filters` allows us to add filters while fetching the data. For example, if you want to list only the `titles` that are equal to "Driver Deposit":

```tsx
const { checkboxGroupProps } = useCheckboxGroup({
  resource: "tags",
  // highlight-start
  filters: [
    {
      field: "title",
      operator: "eq",
      value: "Driver Deposit",
    },
  ],
  // highlight-end
});
```

### sorters

`sorters` allows us to sort the `options`. For example, if you want to sort your list according to `title` by ascending:

```tsx
const { checkboxGroupProps } = useCheckboxGroup({
  resource: "tags",
  // highlight-start
  sorters: [
    {
      field: "title",
      order: "asc",
    },
  ],
  // highlight-end
});
```

### fetchSize

`fetchSize` is the amount of records to fetch in checkboxes.

```tsx
const { selectProps } = useCheckboxGroup({
  resource: "languages",
  // highlight-next-line
  fetchSize: 20,
});
```

### queryOptions

Passing the `queryOptions` property allows us to set the [useQuery](https://react-query.tanstack.com/reference/useQuery) options

```tsx
const { checkboxGroupProps } = useCheckboxGroup({
  resource: "tags",
  // highlight-start
  queryOptions: {
    onError: () => {
      console.log("triggers when on query return Error");
    },
  },
  // highlight-end
});
```

### pagination

`pagination` allows us to set page and items per page values.

For example, lets say that we have 1000 post records:

```ts
const { selectProps } = useCheckboxGroup({
  resource: "categories",
  // highlight-next-line
  pagination: { current: 3, pageSize: 8 },
});
```

The listing will start from page 3, showing 8 records per page.

### ~~sort~~ <PropTag deprecated />

Use `sorters` instead.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/useCheckboxGroup"/>

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

## Example

<CodeSandboxExample path="field-antd-use-checkbox-group" />

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

```

```

================
File: ui-integrations/ant-design/hooks/use-drawer-form/index.md
================
---
title: useDrawerForm
---

The `useDrawerForm` hook allows you to manage a form within a Drawer. It returns the Ant Design [`<Form>`](https://ant.design/components/form/) and [`<Drawer>`](https://ant.design/components/drawer/) components props.

The`useDrawerForm` hook is extended from [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form) from the [@refinedev/antd](https://github.com/refinedev/refine/tree/main/packages/antd) package. This means that you can use all the features of [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form) hook with it.

## Usage

We will show two examples, one for creating a post and one for editing it. Let's see how `useDrwaerForm` is used in them.

<Tabs
defaultValue="create"
values={[
{label: 'create', value: 'create'},
{label: 'edit', value: 'edit'},
]}>

<TabItem value="create">

In this example, we will show you how to `"create"` a record with `useDrawerForm`:

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import { HttpError } from "@refinedev/core";
import React from "react";

import { Create, List, useDrawerForm, useTable } from "@refinedev/antd";
import { Drawer, Form, Input, Select, Table } from "antd";

interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost, HttpError>();

  // highlight-start
  const { formProps, drawerProps, show, saveButtonProps } = useDrawerForm<
    IPost,
    HttpError,
    IPost
  >({
    action: "create",
  });
  // highlight-end

  return (
    <>
      <List
        canCreate
        // highlight-start
        createButtonProps={{
          onClick: () => {
            show();
          },
        }}
        // highlight-end
      >
        <Table {...tableProps} rowKey="id">
          <Table.Column dataIndex="id" title="ID" />
          <Table.Column dataIndex="title" title="Title" />
        </Table>
      </List>
      {/* highlight-start */}
      <Drawer {...drawerProps}>
        <Create saveButtonProps={saveButtonProps}>
          <Form {...formProps} layout="vertical">
            <Form.Item
              label="Title"
              name="title"
              rules={[
                {
                  required: true,
                },
              ]}
            >
              <Input />
            </Form.Item>
            <Form.Item
              label="Status"
              name="status"
              rules={[
                {
                  required: true,
                },
              ]}
            >
              <Select
                options={[
                  {
                    label: "Published",
                    value: "published",
                  },
                  {
                    label: "Draft",
                    value: "draft",
                  },
                  {
                    label: "Rejected",
                    value: "rejected",
                  },
                ]}
              />
            </Form.Item>
          </Form>
        </Create>
      </Drawer>
      {/* highlight-end */}
    </>
  );
};

// visible-block-end
setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineAntdDemo />);
```

</TabItem>

<TabItem value="edit">

In this example, we will show you how to `"edit"` a record with `useDrawerForm`:

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import { HttpError } from "@refinedev/core";
import React from "react";

import {
  Edit,
  EditButton,
  List,
  useDrawerForm,
  useTable,
} from "@refinedev/antd";
import { Drawer, Form, Input, Select, Space, Table } from "antd";

interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost, HttpError>();

  // highlight-start
  const { formProps, drawerProps, show, saveButtonProps, id } = useDrawerForm<
    IPost,
    HttpError,
    IPost
  >({
    action: "edit",
    warnWhenUnsavedChanges: true,
  });
  // highlight-end

  return (
    <>
      <List
        canCreate
        // highlight-start
        createButtonProps={{
          onClick: () => {
            show();
          },
        }}
        // highlight-end
      >
        <Table {...tableProps} rowKey="id">
          <Table.Column dataIndex="id" title="ID" />
          <Table.Column dataIndex="title" title="Title" />
          <Table.Column<IPost>
            title="Actions"
            dataIndex="actions"
            key="actions"
            render={(_, record) => (
              // highlight-start
              <Space>
                <EditButton
                  hideText
                  size="small"
                  recordItemId={record.id}
                  onClick={() => show(record.id)}
                />
              </Space>
              // highlight-end
            )}
          />
        </Table>
      </List>
      {/* highlight-start */}
      <Drawer {...drawerProps}>
        <Edit saveButtonProps={saveButtonProps} recordItemId={id}>
          <Form {...formProps} layout="vertical">
            <Form.Item
              label="Title"
              name="title"
              rules={[
                {
                  required: true,
                },
              ]}
            >
              <Input />
            </Form.Item>
            <Form.Item
              label="Status"
              name="status"
              rules={[
                {
                  required: true,
                },
              ]}
            >
              <Select
                options={[
                  {
                    label: "Published",
                    value: "published",
                  },
                  {
                    label: "Draft",
                    value: "draft",
                  },
                  {
                    label: "Rejected",
                    value: "rejected",
                  },
                ]}
              />
            </Form.Item>
          </Form>
        </Edit>
      </Drawer>
      {/* highlight-end */}
    </>
  );
};

// visible-block-end
setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineAntdDemo />);
```

Refine doesn't automatically add a `<EditButton/>` to the each record in `<PostList>` which opens the edit form in `<Drawer>` when clicked.

So, we have to put the `<EditButton/>` on our list manually. In that way, `<Edit>` form in `<Drawer>` can fetch data by the record `id`.

```tsx
<Table.Column<IPost>
  title="Actions"
  dataIndex="actions"
  key="actions"
  render={(_value, record) => <EditButton onClick={() => show(record.id)} />}
/>
```

Don't forget to pass the record `"id"` to `show` to fetch the record data. This is necessary for both `"edit"` and `"clone"` forms.

</TabItem>

</Tabs>

## Properties

All [`useForm`][antd-use-form] props are also available in `useDrawerForm`. You can find descriptions on the [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form#properties) documentation.

### syncWithLocation

When `syncWithLocation` is `true`, the drawers visibility state and the `id` of the record will be synced with the URL. It is `false` by default.

This property can also be set as an object `{ key: string; syncId?: boolean }` to customize the key of the URL query parameter. `id` will be synced with the URL only if `syncId` is `true`.

```tsx
const drawerForm = useDrawerForm({
  syncWithLocation: { key: "my-modal", syncId: true },
});
```

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useDrawerForm({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### autoSave

If you want to save the form automatically after some delay when user edits the form, you can pass true to `autoSave.enabled` prop.

By default the `autoSave` feature does not invalidate queries. However, you can use the `invalidateOnUnmount` and `invalidateOnClose` props to invalidate queries upon unmount or close.

It also supports `onMutationSuccess` and `onMutationError` callback functions. You can use `isAutoSave` parameter to determine whether the mutation is triggered by `autoSave` or not.

`autoSave` feature operates exclusively in `edit` mode. Users can take advantage of this feature while editing data, as changes are automatically saved in editing mode. However, when creating new data, manual saving is still required.

`onMutationSuccess` and `onMutationError` callbacks will be called after the mutation is successful or failed.

#### enabled

To enable the `autoSave` feature, set the `enabled` parameter to `true`. Default value is `false`.

```tsx
useDrawerForm({
  autoSave: {
    enabled: true,
  },
});
```

#### debounce

Set the debounce time for the `autoSave` prop. Default value is `1000` milliseconds.

```tsx
useDrawerForm({
  autoSave: {
    enabled: true,
    // highlight-next-line
    debounce: 2000,
  },
});
```

#### onFinish

If you want to modify the data before sending it to the server, you can use `onFinish` callback function.

```tsx
useDrawerForm({
  autoSave: {
    enabled: true,
    // highlight-start
    onFinish: (values) => {
      return {
        foo: "bar",
        ...values,
      };
    },
    // highlight-end
  },
});
```

#### invalidateOnUnmount

This prop is useful when you want to invalidate the `list`, `many` and `detail` queries from the current resource when the hook is unmounted. By default, it invalidates the `list`, `many` and `detail` queries associated with the current resource. Also, You can use the `invalidates` prop to select which queries to invalidate. Default value is `false`.

```tsx
useDrawerForm({
  autoSave: {
    enabled: true,
    // highlight-next-line
    invalidateOnUnmount: true,
  },
});
```

#### invalidateOnClose

This prop is useful when you want to invalidate the `list`, `many` and `detail` queries from the current resource when the drawer is closed. By default, it invalidates the `list`, `many` and `detail` queries associated with the current resource. Also, You can use the `invalidates` prop to select which queries to invalidate. Default value is `false`.

```tsx
useDrawerForm({
  autoSave: {
    enabled: true,
    // highlight-next-line
    invalidateOnClose: true,
  },
});
```

### defaultFormValues

Default values for the form. Use this to pre-populate the form with data that needs to be displayed.

```tsx
useForm({
  defaultFormValues: {
    title: "Hello World",
  },
});
```

Also, it can be provided as an async function to fetch the default values. The loading state can be tracked using the [`defaultFormValuesLoading`](#defaultformvaluesloading) state returned from the hook.

> 🚨 When `action` is "edit" or "clone" a race condition with `async defaultFormValues` may occur. In this case, the form values will be the result of the last completed operation.

```tsx
const { defaultFormValuesLoading } = useForm({
  defaultFormValues: async () => {
    const response = await fetch("https://my-api.com/posts/1");
    const data = await response.json();
    return data;
  },
});
```

## Return values

`useDrawerForm` returns the same values from [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form#return-values) and additional values to work with [`<Drawer>`](https://ant.design/components/drawer/) components.

### show

A function that opens the `<Drawer>`. It takes an optional `id` parameter. If `id` is provided, it will fetch the record data and fill the `<Form>` with it.

### close

A function that closes the `<Drawer>`. Same as `[onClose][#onClose]`.

### saveButtonProps

It contains the props needed by the `"submit"` button within the `<Drawer>` (disabled,loading etc.). When `saveButtonProps.onClick` is called, it triggers `form.submit()`. You can manually pass these props to your custom button.

### deleteButtonProps

It contains the props needed by the `"delete"` button within the `<Drawer>` (disabled,loading etc.). When `deleteButtonProps.onSuccess` is called, it triggers it sets `id` to `undefined` and `open` to `false`. You can manually pass these props to your custom button.

### formProps

It's required to manage `<Form>` state and actions. Under the hood the `formProps` came from [`useForm`][antd-use-form].

It contains the props to manage the [Antd `<Form>`](https://ant.design/components/form#api) component such as [_`onValuesChange`, `initialValues`, `onFieldsChange`, `onFinish` etc._](/docs/ui-integrations/ant-design/hooks/use-form#return-values)

:::note Difference between `onFinish` and `formProps.onFinish`

`onFinish` method returned directly from `useDrawerForm` is same with the `useForm`'s `onFinish`. When working with drawers, closing the drawer after submission and resetting the fields are necessary and to handle these, `formProps.onFinish` extends the `onFinish` method and handles the closing of the drawer and clearing the fields under the hood.

If you're customizing the data before submitting it to your data provider, it's recommended to use `formProps.onFinish` and let it handle the operations after the submission.

:::

### drawerProps

It's required to manage [`<Drawer>`](https://ant.design/components/drawer/#API) state and actions.

#### width

It's the width of the `<Drawer>`. Default value is `"500px"`.

#### onClose

A function that can close the `<Drawer>`. It's useful when you want to close the `<Drawer>` manually.
When [`warnWhenUnsavedChanges`](/docs/ui-integrations/ant-design/hooks/use-form#warnwhenunsavedchanges) is `true`, it will show a confirmation modal before closing the `<Drawer>`. If you override this function, you have to handle this confirmation modal manually.

#### open

Current visible state of `<Drawer>`. Default value is `false`.

#### forceRender

It renders `<Drawer>` instead of lazy rendering it. Default value is `true`.

### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useDrawerForm();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

### autoSaveProps

If `autoSave` is enabled, this hook returns `autoSaveProps` object with `data`, `error`, and `status` properties from mutation.

### defaultFormValuesLoading

If [`defaultFormValues`](#defaultformvalues) is an async function, `defaultFormValuesLoading` will be `true` until the function is resolved.

## FAQ

### How can I change the form data before submitting it to the API?

You may need to modify the form data before it is sent to the API.

For example, Let's send the values we received from the user in two separate inputs, `name` and `surname`, to the API as `fullName`.

```tsx title="pages/user/create.tsx"
import { Create, Drawer, useDrawerForm } from "@refinedev/antd";
import { Form, Input } from "antd";
import React from "react";

export const UserCreate: React.FC = () => {
  // highlight-start
  const { formProps, drawerProps, saveButtonProps } = useDrawerForm({
    action: "create",
  });
  // highlight-end

  // highlight-start
  const handleOnFinish = (values) => {
    formProps.onFinish?.({
      fullName: `${values.name} ${values.surname}`,
    });
  };
  // highlight-end

  return (
    <Drawer {...drawerProps}>
      <Create saveButtonProps={saveButtonProps}>
        // highlight-next-line
        <Form {...formProps} onFinish={handleOnFinish} layout="vertical">
          <Form.Item label="Name" name="name">
            <Input />
          </Form.Item>
          <Form.Item label="Surname" name="surname">
            <Input />
          </Form.Item>
        </Form>
      </Create>
    </Drawer>
  );
};
```

## API Parameters

### Properties

<PropsTable module="@refinedev/antd/useDrawerForm"/>

> `*`: These props have default values in `RefineContext` and can also be set on **<[Refine](/docs/core/refine-component)>** component. `useDrawerForm` will use what is passed to `<Refine>` as default but a local value will override it.

> `**`: If not explicitly configured, default value of `redirect` depends which `action` used. If `action` is `create`, `redirect`s default value is `edit` (created resources edit page). Otherwise if `action` is `edit`, `redirect`s default value is `list`.

### Type Parameters

| Property       | Description                                                                                                                                                         | Type                       | Default                    |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData   | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError         | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TVariables     | Values for params.                                                                                                                                                  | `{}`                       |                            |
| TData          | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |
| TResponse      | Result data returned by the mutation function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TData` will be used as the default value.        | [`BaseRecord`][baserecord] | `TData`                    |
| TResponseError | Custom error object that extends [`HttpError`][httperror]. If not specified, the value of `TError` will be used as the default value.                               | [`HttpError`][httperror]   | `TError`                   |

### Return Value

| resourceName? | `string` |
| recordItemId? | [`BaseKey`](#basekey) |
| onSuccess? | `<TData = BaseRecord>(value: { data: TData; }) => void;` |
| mutationMode? | [`MutationMode`](#mutationmode) |
| hideText? | `boolean` |

| Key                      | Description                                                  | Type                                                                                                                                     |
| ------------------------ | ------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- |
| show                     | A function that opens the drawer                             | `(id?: BaseKey) => void`                                                                                                                 |
| form                     | Ant Design form instance                                     | [`FormInstance<TVariables>`](https://ant.design/components/form/#FormInstance)                                                           |
| formProps                | Ant Design form props                                        | [`FormProps`](/docs/ui-integrations/ant-design/hooks/use-form#properties)                                                                |
| drawerProps              | Props for managed drawer                                     | [`DrawerProps`](#drawerprops)                                                                                                            |
| saveButtonProps          | Props for a submit button                                    | `{ disabled: boolean; onClick: () => void; loading: boolean; }`                                                                          |
| deleteButtonProps        | Adds props for delete button                                 | `{ resourceName?: string; recordItemId?: BaseKey; onSuccess?: (data: TData) => void; mutationMode?: MutationMode; hideText?: boolean; }` |
| submit                   | Submit method, the parameter is the value of the form fields | `() => void`                                                                                                                             |
| open                     | Whether the drawer is open or not                            | `boolean`                                                                                                                                |
| close                    | Specify a function that can close the drawer                 | `() => void`                                                                                                                             |
| overtime                 | Overtime loading props                                       | `{ elapsedTime?: number }`                                                                                                               |
| autoSaveProps            | Auto save props                                              | `{ data: UpdateResponse<TData>` \| `undefined, error: HttpError` \| `null, status: "loading"` \| `"error"` \| `"idle"` \| `"success" }`  |
| defaultFormValuesLoading | DefaultFormValues loading status of form                     | `boolean`                                                                                                                                |

## Example

<CodeSandboxExample path="form-antd-use-drawer-form" />

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[antd-use-form]: /docs/ui-integrations/ant-design/hooks/use-form

================
File: ui-integrations/ant-design/hooks/use-editable-table/_partial-use-editable-table-live-preview.md
================
```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import {
  List,
  SaveButton,
  EditButton,
  TextField,
  useEditableTable,
} from "@refinedev/antd";
import { Table, Form, Space, Button, Input } from "antd";

interface IPost {
  id: number;
  title: string;
}

const PostList: React.FC = () => {
  const {
    tableProps,
    formProps,
    isEditing,
    setId: setEditId,
    saveButtonProps,
    cancelButtonProps,
    editButtonProps,
  } = useEditableTable<IPost>();

  return (
    <List>
      <Form {...formProps}>
        <Table
          {...tableProps}
          rowKey="id"
          onRow={(record) => ({
            // eslint-disable-next-line
            onClick: (event: any) => {
              if (event.target.nodeName === "TD") {
                setEditId && setEditId(record.id);
              }
            },
          })}
        >
          <Table.Column dataIndex="id" title="ID" />
          <Table.Column<IPost>
            dataIndex="title"
            title="Title"
            render={(value, record) => {
              if (isEditing(record.id)) {
                return (
                  <Form.Item name="title" style={{ margin: 0 }}>
                    <Input />
                  </Form.Item>
                );
              }
              return <TextField value={value} />;
            }}
          />
          <Table.Column<IPost>
            title="Actions"
            dataIndex="actions"
            render={(_, record) => {
              if (isEditing(record.id)) {
                return (
                  <Space>
                    <SaveButton {...saveButtonProps} hideText size="small" />
                    <Button {...cancelButtonProps} size="small">
                      Cancel
                    </Button>
                  </Space>
                );
              }
              return (
                <EditButton
                  {...editButtonProps(record.id)}
                  hideText
                  size="small"
                />
              );
            }}
          />
        </Table>
      </Form>
    </List>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          list: "/posts",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route path="/posts" element={<PostList />} />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: ui-integrations/ant-design/hooks/use-editable-table/index.md
================
---
title: useEditableTable
source: packages/antd/src/hooks/table/useTable
---

import LivePreview from "./\_partial-use-editable-table-live-preview.md";

`useEditeableTable` allows you to implement the edit feature on the [`<Table>`][table] with ease and returns properties that can be used on Ant Design's [`<Table>`][table] and [`<Form>`][form] components.

`useEditeableTable` hook is extended from the [`useTable`][usetable] hook from the [`@refinedev/antd`](https://github.com/refinedev/refine/tree/main/packages/antd) package. This means that you can use all the features of [`useTable`][usetable] hook.

## Usage

Here is an example of how to use `useEditableTable` hook. We will explain the details of this example and hooks usage in the following sections.

<LivePreview/>

### Editing with buttons

Let's say that we want to make the `Post` data where we show the `id` and `title` values a listing page:

This time, to add the edit feature, we have to cover the `<Table>` component with a `<Form>` component and pass the properties coming from `useEditableTable` to the corresponding components:

```tsx title="/pages/posts/list.tsx"
import { List, useEditableTable, TextField } from "@refinedev/antd";
import { Table, Form } from "antd";

export const PostList: React.FC = () => {
  // highlight-next-line
  const { tableProps, formProps } = useEditableTable<IPost>();

  return (
    <List>
      // highlight-start
      <Form {...formProps}>
        <Table {...tableProps} rowKey="id">
          <Table.Column dataIndex="id" title="ID" />
          <Table.Column dataIndex="title" title="Title" />
        </Table>
      </Form>
      // highlight-end
    </List>
  );
};

interface IPost {
  id: number;
  title: string;
}
```

Now lets add a column for edit buttons:

```tsx title="/pages/posts/list.tsx"
import {
  List,
  // highlight-start
  SaveButton,
  EditButton,
  // highlight-end
  useEditableTable,
} from "@refinedev/antd";
import {
  Table,
  Form,
  // highlight-start
  Space,
  Button,
  // highlight-end
} from "antd";

export const PostList: React.FC = () => {
  const {
    tableProps,
    formProps,
    isEditing,
    // highlight-start
    saveButtonProps,
    cancelButtonProps,
    editButtonProps,
    // highlight-end
  } = useEditableTable<IPost>();

  return (
    <List>
      <Form {...formProps}>
        <Table {...tableProps} rowKey="id">
          <Table.Column key="id" dataIndex="id" title="ID" />
          <Table.Column key="title" dataIndex="title" title="Title" />
          <Table.Column<IPost>
            title="Actions"
            dataIndex="actions"
            key="actions"
            // highlight-start
            render={(_text, record) => {
              if (isEditing(record.id)) {
                return (
                  <Space>
                    <SaveButton {...saveButtonProps} size="small" />
                    <Button {...cancelButtonProps} size="small">
                      Cancel
                    </Button>
                  </Space>
                );
              }
              return (
                <Space>
                  <EditButton {...editButtonProps(record.id)} size="small" />
                </Space>
              );
            }}
            // highlight-end
          />
        </Table>
      </Form>
    </List>
  );
};
```

`isEditing` function that returns from `useEditableTable` lets us check whether a line is currently in edit mode or not.

For now, our post is not editable yet. If a post is being edited, we must show editable columns inside a `<Form.Item>` using conditional rendering:

```tsx title="/pages/posts/list.tsx"
import {
  List,
  SaveButton,
  EditButton,
  // highlight-start
  TextField,
  // highlight-end
  useEditableTable,
} from "@refinedev/antd";
import {
  Table,
  Form,
  Space,
  Button,
  // highlight-next-line
  Input,
} from "antd";

export const PostList: React.FC = () => {
  const {
    tableProps,
    formProps,
    isEditing,
    saveButtonProps,
    cancelButtonProps,
    editButtonProps,
  } = useEditableTable<IPost>();

  return (
    <List>
      <Form {...formProps}>
        <Table {...tableProps} rowKey="id">
          <Table.Column key="id" dataIndex="id" title="ID" />
          <Table.Column<IPost>
            key="title"
            dataIndex="title"
            title="Title"
            // highlight-start
            render={(value, record) => {
              if (isEditing(record.id)) {
                return (
                  <Form.Item name="title" style={{ margin: 0 }}>
                    <Input />
                  </Form.Item>
                );
              }
              return <TextField value={value} />;
            }}
            // highlight-end
          />
          <Table.Column<IPost>
            title="Actions"
            dataIndex="actions"
            key="actions"
            render={(_text, record) => {
              if (isEditing(record.id)) {
                return (
                  <Space>
                    <SaveButton {...saveButtonProps} size="small" />
                    <Button {...cancelButtonProps} size="small">
                      Cancel
                    </Button>
                  </Space>
                );
              }
              return (
                <Space>
                  <EditButton {...editButtonProps(record.id)} size="small" />
                </Space>
              );
            }}
          />
        </Table>
      </Form>
    </List>
  );
};
```

With this, when a user clicks on the edit button, `isEditing(lineId)` will turn `true` for the relevant line. This will also cause `<TextInput>` to show up on the line that's being edited. When the editing is finished, a new value can be saved by clicking `<SaveButton>`.

:::simple Implementation Tips

By giving the `<Table.Column>` component a unique `render` property, you can render the value in that column however you want.

For more information, refer to the [`<Table.Column>` documentation &#8594][table.column]

:::

### Editing by clicking to row

A line with the `id` value can be put to edit mode programmatically by using the `setId` function that returns from `useEditableTable`.

The `onRow` property of the `<Table>` component can be used to put a line to editing mode when it's clicked on. The function given to the `onRow` property is called every time one of these lines is clicked on, with the information of which line was clicked on.

We can use `setId` to put a line to edit mode whenever it's clicked on.

```tsx title="/pages/posts/list.tsx"
import { List, TextField, useEditableTable } from "@refinedev/antd";
import { Table, Form, Input } from "antd";

export const PostList: React.FC = () => {
  // highlight-start
  const { tableProps, formProps, isEditing, setId } = useEditableTable<IPost>();
  // highlight-end

  return (
    <List>
      <Form {...formProps}>
        <Table
          {...tableProps}
          key="id"
          // highlight-start
          onRow={(record) => ({
            onClick: (event: any) => {
              if (event.target.nodeName === "TD") {
                setId && setId(record.id);
              }
            },
          })}
          // highlight-end
        >
          <Table.Column key="id" dataIndex="id" title="ID" />
          <Table.Column<IPost>
            key="title"
            dataIndex="title"
            title="Title"
            render={(value, data: any) => {
              if (isEditing(data.id)) {
                return (
                  <Form.Item name="title" style={{ margin: 0 }}>
                    <Input />
                  </Form.Item>
                );
              }
              return <TextField value={value} />;
            }}
          />
        </Table>
      </Form>
    </List>
  );
};
```

## Properties

All `useForm` and [`useTable`][usetable] properties are available in `useEditableTable`. You can read the documentation of [`useForm`][useform] and [`useTable`][usetable] for more information.

### autoSubmitClose

`autoSubmitClose` makes the table's row close after a successful submit. It is `true` by default.

For this effect, `useEditableTable` automatically calls the `setId` function with `undefined` after successful submit.

```tsx
const editableTable = useEditableTable({
  autoSubmitClose: false,
});
```

## Return Values

All `useForm` and [`useTable`][usetable] return values are available in `useEditableTable`. You can read the documentation of [`useForm`][useform] and [`useTable`][usetable] for more information.

### cancelButtonProps

`cancelButtonProps` returns the props for needed by the `<EditButton>`.

By default, the `onClick` function is overridden by `useEditableTable`. Which will call `useForm's` `setId` function with `undefined` when called.

```tsx
cancelButtonProps: () => ButtonProps;
```

### editButtonProps

`editButtonProps` takes `id` as a parameter and returns the props needed by the `<EditButton>`.

By default, the `onClick` function is overridden by `useEditableTable`. Which will call `useForm's` `setId` function with the given `id` when called.

```tsx
editButtonProps: (id: BaseKey) => ButtonProps;
```

It also returns a function that takes an `id` as a parameter and returns the props for the edit button.

### isEditing

```tsx
isEditing: (id: BaseKey) => boolean;
```

Takes a `id` as a parameter and returns `true` if the given `BaseKey` is equal to the selected `useForm's` `id`.

## API

### Properties

<PropsTable module="@refinedev/antd/useEditableTable"/>

### Type Parameters

| Property         | Description                                                                                                                                                         | Type                       | Default                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData     | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError           | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TVariables       | Values for params                                                                                                                                                   |                            | `{}`                       |
| TSearchVariables | Values for search params                                                                                                                                            |                            | `{}`                       |
| TData            | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Property          | Description                                             | Type                                                                                 |
| ----------------- | ------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| searchFormProps   | Ant Design [`<Form>`][form] props                       | [`FormProps<TSearchVariables>`][form]                                                |
| tableProps        | Ant Design [`<Table>`][table] props                     | [`TableProps<TData>`][table]                                                         |
| tableQuery        | Result of the `react-query`'s `useQuery`                | [` QueryObserverResult<{`` data: TData[];`` total: number; },`` TError> `][usequery] |
| sorter            | Current sorting state                                   | [`CrudSorting`][crudsorting]                                                         |
| filters           | Current filters state                                   | [`CrudFilters`][crudfilters]                                                         |
| form              | Ant Design [`<Form>`][form] instance                    | [`FormInstance`][forminstance]                                                       |
| formProps         | Ant Design [`<Form>`][form] props                       | [`FormProps`][form]                                                                  |
| saveButtonProps   | Props for a submit button                               | `{ disabled: boolean; onClick: () => void; }`                                        |
| cancelButtonProps | Props for a cancel button                               | `{ onClick: () => void; }`                                                           |
| editButtonProps   | Props for an edit button                                | `{ onClick: () => void; }`                                                           |
| query             | Result of the query of a record                         | [`QueryObserverResult<T>`][usequery]                                                 |
| mutation          | Result of the mutation triggered by submitting the form | [`UseMutationResult<T>`][usemutation]                                                |
| formLoading       | Loading state of form request                           | `boolean`                                                                            |
| id                | Record id for edit action                               | [`BaseKey`][basekey]                                                                 |
| setId             | `id` setter                                             | `Dispatch<SetStateAction<` [`BaseKey`][basekey] \| `undefined>>`                     |
| isEditing         | Check if is editing                                     | `(id: `[`BaseKey`][basekey]`) => boolean`                                            |

## Example

<CodeSandboxExample path="table-antd-use-editable-table" />

[table]: https://ant.design/components/table/#API
[form]: https://ant.design/components/form/#API
[useform]: /docs/ui-integrations/ant-design/hooks/use-table
[usetable]: /docs/ui-integrations/ant-design/hooks/use-table
[usequery]: https://react-query.tanstack.com/reference/useQuery
[usemutation]: https://react-query.tanstack.com/reference/useMutation
[baserecord]: /docs/core/interface-references#baserecord
[basekey]: /docs/core/interface-references#basekey
[crudsorting]: /docs/core/interface-references#crudsorting
[crudfilters]: /docs/core/interface-references#crudfilters
[httperror]: /docs/core/interface-references#httperror
[table search]: /advanced-tutorials/search/table-search.md
[table.column]: https://ant.design/components/table/#Column
[forminstance]: https://ant.design/components/form/#FormInstance

================
File: ui-integrations/ant-design/hooks/use-form/index.md
================
---
title: useForm
source: packages/antd/src/hooks/form/useForm.ts
---

```tsx live shared
import {
  CloneButton as AntdCloneButton,
  Create as AntdCreate,
  EditButton as AntdEditButton,
  List as AntdList,
  useForm as useAntdForm,
  useTable as useAntdTable,
} from "@refinedev/antd";
import {
  Edit as AntdEdit,
  Form as AntdForm,
  Input as AntdInput,
  Space as AntdSpace,
  Table as AntdTable,
} from "antd";

interface IPost {
  id: number;
  title: string;
  content: string;
}

const PostList = () => {
  const { tableProps } = useAntdTable();

  return (
    <AntdList>
      <AntdTable {...tableProps} rowKey="id">
        <AntdTable.Column dataIndex="id" title="ID" />
        <AntdTable.Column dataIndex="title" title="Title" />
        <AntdTable.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record) => (
            <AntdSpace>
              <AntdEditButton hideText size="small" recordItemId={record.id} />
              <AntdCloneButton hideText size="small" recordItemId={record.id} />
            </AntdSpace>
          )}
        />
      </AntdTable>
    </AntdList>
  );
};

const PostEdit = () => {
  const { formProps, saveButtonProps } = useAntdForm();

  return (
    <AntdEdit saveButtonProps={saveButtonProps}>
      <AntdForm {...formProps} layout="vertical">
        <AntdForm.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
        <AntdForm.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput.TextArea />
        </AntdForm.Item>
      </AntdForm>
    </AntdEdit>
  );
};

const PostCreate = () => {
  const { formProps, saveButtonProps } = useAntdForm();

  return (
    <AntdCreate saveButtonProps={saveButtonProps}>
      <AntdForm {...formProps} layout="vertical">
        <AntdForm.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput />
        </AntdForm.Item>
        <AntdForm.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <AntdInput.TextArea />
        </AntdForm.Item>
      </AntdForm>
    </AntdCreate>
  );
};
```

`useForm` is used to manage forms. It returns the necessary properties and methods to control the [Antd Form](https://ant.design/components/form/). It has been developed by using [`useForm`](/docs/data/hooks/use-form/) imported from the [@refinedev/core](https://github.com/refinedev/refine/tree/main/packages/core) package.

<GeneralConceptsLink />

## Usage

We will show the basic usage of `useForm` by adding an editing form.

```tsx title="pages/posts/edit.tsx"
// highlight-next-line
import { Edit, useForm } from "@refinedev/antd";
import { Form, Input, Select } from "antd";

export const PostEdit: React.FC = () => {
  // highlight-next-line
  const { formProps, saveButtonProps } = useForm<IPost>();

  return (
    // highlight-next-line
    <Edit saveButtonProps={saveButtonProps}>
      // highlight-next-line
      <Form {...formProps} layout="vertical">
        <Form.Item label="Title" name="title">
          <Input />
        </Form.Item>
        <Form.Item label="Status" name="status">
          <Select
            options={[
              {
                label: "Published",
                value: "published",
              },
              {
                label: "Draft",
                value: "draft",
              },
              {
                label: "Rejected",
                value: "rejected",
              },
            ]}
          />
        </Form.Item>
      </Form>
    </Edit>
  );
};

interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}
```

`formProps` includes all necessary values to manage Ant Design [Form](https://ant.design/components/form/) components.

In the example if you navigate to `/posts/edit/1234` it will manage the data of the post with id of `1234` in an editing context. See the `action` section below on how `useForm` determines this is an editing context.

Since this is an edit form it will fill the form with the data of the post with the id of `1234` and then the form will be ready to edit further and submit the changes.

Submit functionality is provided by `saveButtonProps` which includes all of the necessary props for a button to submit a form including the automatically updating loading states.

`useForm` accepts type parameters for the record in use and for the response type of the mutation. `IPost` in the example represents the record to edit. It is also used as the default type for mutation response.

If you want to show a form in a modal or drawer where necessary route params might not be there you can use the [useModalForm](/docs/ui-integrations/ant-design/hooks/use-modal-form) or the [useDrawerForm](/docs/ui-integrations/ant-design/hooks/use-drawer-form) hook.

> For more detailed usage examples, refer to the [Ant Design Form](https://ant.design/components/form/) documentation.

## Properties

### action

`useForm` can handle `edit`, `create` and `clone` actions.

By default, it determines the `action` from route. The action is inferred by matching the resource's action path with the current route.

It can be overridden by passing the `action` prop where it isn't possible to determine the action from the route (e.g. when using form in a modal or using a custom route).

<Tabs
defaultValue="create"
values={[
{label: 'create', value: 'create'},
{label: 'edit', value: 'edit'},
{label: 'clone', value: 'clone'}
]}>
<TabItem value="create">

`action: "create"` is used for creating new records. `useForm` uses [`useCreate`](/docs/data/hooks/use-create) under the hood for mutations on create mode.

In the following example, we will show how to use `useForm` with `action: "create"`:

```tsx live url=http://localhost:3000/posts/create previewHeight=420px
setInitialRoutes(["/posts/create"]);

// visible-block-start
import React from "react";

import { Create, useForm } from "@refinedev/antd";
import { Form, Input } from "antd";

interface IPost {
  id: number;
  title: string;
  content: string;
}

const PostCreatePage: React.FC = () => {
  const { formProps, saveButtonProps } = useForm<IPost>();

  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input />
        </Form.Item>
        <Form.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input.TextArea />
        </Form.Item>
      </Form>
    </Create>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreatePage,
      edit: PostEdit,
    },
  ],
});

render(<RefineAntdDemo />);
```

</TabItem>

<TabItem value="edit">

`action: "edit"` is used for editing an existing record. It requires the `id` for determining the record to edit. By default, it uses the `id` from the route but that can be changed with the `setId` function or `id` property.

It fetches the record data according to the `id` with [`useOne`](/docs/data/hooks/use-one) and returns the `query` for you to fill the form. After the form is submitted, it updates the record with [`useUpdate`](/docs/data/hooks/use-update).

In the following example, we will show how to use `useForm` with `action: "edit"`.

```tsx live url=http://localhost:3000/edit/123 previewHeight=420px
setInitialRoutes(["/posts/edit/123"]);

// visible-block-start
import React from "react";

import { Edit, useForm } from "@refinedev/antd";
import { Form, Input } from "antd";

interface IPost {
  id: number;
  title: string;
  content: string;
}

const PostEditPage: React.FC = () => {
  const { formProps, saveButtonProps } = useForm<IPost>();

  return (
    <Edit saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input />
        </Form.Item>
        <Form.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input.TextArea />
        </Form.Item>
      </Form>
    </Edit>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreate,
      edit: PostEditPage,
    },
  ],
});

render(<RefineAntdDemo />);
```

</TabItem>

<TabItem value="clone">

`action: "clone"` is used for cloning an existing record. It requires the `id` for determining the record to clone. By default, it uses the `id` from the route but that can be changed with the `setId` function.

You can think `action:clone` like "save as". It is also similar to `action:edit` but it creates a new record instead of updating the existing one.

It fetches the record data according to the `id` with [`useOne`](/docs/data/hooks/use-one) and returns the `query` for you to fill the form. After the form is submitted, it creates a new record with [`useCreate`](/docs/data/hooks/use-create).

```tsx live url=http://localhost:3000/clone/123 previewHeight=420px
setInitialRoutes(["/posts/clone/123"]);

// visible-block-start
import React from "react";

import { Create, useForm } from "@refinedev/antd";
import { Form, Input } from "antd";

interface IPost {
  id: number;
  title: string;
  content: string;
}

const PostCreatePage: React.FC = () => {
  const { formProps, saveButtonProps } = useForm<IPost>();

  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Title"
          name="title"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input />
        </Form.Item>
        <Form.Item
          label="Content"
          name="content"
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Input.TextArea />
        </Form.Item>
      </Form>
    </Create>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreatePage,
      edit: PostEdit,
    },
  ],
});

render(<RefineAntdDemo />);
```

</TabItem>

</Tabs>

### resource

`resource` will be passed to the [`dataProvider`][data-provider]'s method as a params. This parameter is usually used to as a API endpoint path but it all depends on how to handle the `resource` in your [`dataProvider`][data-provider]. By default it uses the inferred resource name from the route.

> For more information on how `resource` is handled, refer to the [`creating a data provider` section](/docs/data/data-provider#creating-a-data-provider)

- When `action` is `"create"`, it will be passed to the [`create`][create] method from the [`dataProvider`][data-provider].
- When `action` is `"edit"`, it will be passed to the [`update`][update] and the [`getOne`][get-one] method from the [`dataProvider`][data-provider].
- When `action` is `"clone"`, it will be passed to the [`create`][create] and the [`getOne`][get-one] method from the [`dataProvider`][data-provider].

```tsx
useForm({
  resource: "categories",
});
```

If the `resource` is passed, the `id` from the current URL will be ignored because it may belong to a different resource. To retrieve the `id` value from the current URL, use the `useParsed` hook and pass the `id` value to the `useForm` hook.

```tsx
import { useForm } from "@refinedev/antd";
import { useParsed } from "@refinedev/core";

const { id } = useParsed();

useForm({
  resource: "custom-resource",
  id,
});
```

Or you can use the `setId` function to set the `id` value.

```tsx
import { useForm } from "@refinedev/antd";

const { setId } = useForm({
  resource: "custom-resource",
});

setId("123");
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### id

`id` is used for determining the record to `edit` or `clone`. By default the `id` is determinted from the route. It can be changed with the `setId` function or the `id` property. Keep in mind that `id` is required for `action: "edit"` and `action: "clone"`.

It is useful when you want to `edit` or `clone` a `resource` from a different page.

```tsx
useForm({
  action: "edit", // or clone
  resource: "categories",
  id: 1, // <BASE_URL_FROM_DATA_PROVIDER>/categories/1
});
```

### redirect

`redirect` is used for determining the page to redirect after the form is submitted. By default, it uses the `list`. It can be changed with the `redirect` property.

It can be set to `"show" | "edit" | "list" | "create"` or `false` to prevent the page from redirecting to the list page after the form is submitted.

```tsx
useForm({
  redirect: false,
});
```

### onMutationSuccess

`onMutationSuccess` is a callback function that will be called after a successful mutation.

It receives the following parameters:

- `data`: Returned value from [`useCreate`](/docs/data/hooks/use-create) or [`useUpdate`](/docs/data/hooks/use-update) depending on the `action`.
- `variables`: The variables passed to the mutation.
- `context`: react-query context.
- `isAutoSave`: It's a boolean value that indicates whether the mutation is triggered by the [`autoSave`](#autoSave) feature or not.

```tsx
useForm({
  onMutationSuccess: (data, variables, context, isAutoSave) => {
    console.log({ data, variables, context, isAutoSave });
  },
});
```

### onMutationError

It's a callback function that will be called after a mutation fails.

It receives the following parameters:

- `data`: Returned value from [`useCreate`](/docs/data/hooks/use-create) or [`useUpdate`](/docs/data/hooks/use-update) depending on the `action`.
- `variables`: The variables passed to the mutation.
- `context`: react-query context.
- `isAutoSave`: It's a boolean value that indicates whether the mutation is triggered by the [`autoSave`](#autoSave) feature or not.

```tsx
useForm({
  onMutationError: (data, variables, context, isAutoSave) => {
    console.log({ data, variables, context, isAutoSave });
  },
});
```

### invalidates

You can use `invalidates` to manage the invalidations that will occur at the end of the mutation.

By default it's invalidates following queries from the current `resource`:

- on `create` or `clone` mode: `"list"` and `"many"`
- on `edit` mode: `"list"`, `"many"` and `"detail"`

```tsx
useForm({
  invalidates: ["list", "many", "detail"],
});
```

### dataProviderName

If there is more than one `dataProvider`, you should pass the name of the `dataProvider` you are going to use to `dataProviderName`.

If you want to use a different `dataProvider` on all resource pages, you can use the [`dataProvider` prop](/docs/core/refine-component#dataprovidername) of the `<Refine>` component.

```tsx
useForm({
  dataProviderName: "second-data-provider",
});
```

### mutationMode

Mutation mode determines which mode the mutation runs with. Mutations can run under three different modes: `pessimistic`, `optimistic` and `undoable`. Default mode is `pessimistic`.
Each mode corresponds to a different type of user experience.

```tsx
useForm({
  mutationMode: "undoable", // "pessimistic" | "optimistic" | "undoable",
});
```

> For more information about mutation modes, refer to the [Mutation Mode documentation](/docs/advanced-tutorials/mutation-mode)

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

`successNotification` allows you to customize the success notification that pops up after the form is submitted, and `useForm` calls the `open` function from [`NotificationProvider`][notification-provider]:

```tsx
useForm({
  successNotification: (data, values, resource) => {
    return {
      message: `Post Successfully created with ${data.title}`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

`errorNotification` allows you to customize the error notification that pops up after the form submission fails, and `useForm` calls the `open` function from [`NotificationProvider`][notification-provider]:

```tsx
useForm({
  action: "create",
  resource: "post",
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when deleting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

```json title="Default values"
{
    "message": "Error when updating <resource-name> (status code: ${err.statusCode})" or "Error when creating <resource-name> (status code: ${err.statusCode})",
    "description": "Error",
    "type": "error",
}
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).
- Providing additional parameters to the redirection path after the form is submitted.

> For more information, refer to the [`meta` section of the General Concepts documentation &#8594](/docs/guides-concepts/general-concepts/#meta-concept)

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useForm({
  meta: {
    headers: { "x-meta-data": "true" },
  },
});

const myDataProvider = {
  //...
  // highlight-start
  create: async ({ resource, variables, meta }) => {
    const headers = meta?.headers ?? {};
    // highlight-end
    const url = `${apiUrl}/${resource}`;

    // highlight-next-line
    const { data } = await httpClient.post(url, variables, { headers });

    return {
      data,
    };
  },
  //...
};
```

### queryMeta

In addition to the [`meta`](#meta) property, you can also pass the `queryMeta` property to the `useForm` hook. This property is used to pass additional information to the `useOne` hook that is used to fetch the data in the `edit` and `clone` modes. This is useful when you have to apply different values to the `useOne` hook from the `useCreate` or `useUpdate` hook mutations.

```tsx
useForm({
  queryMeta: {
    querySpecificValue: "someValue",
  },
});
```

If you have overlapping properties in both `meta` and `queryMeta`, the `queryMeta` property will be used.

### mutationMeta

In addition to the [`meta`](#meta) property, you can also pass the `mutationMeta` property to the `useForm` hook. This property is used to pass additional information to the `useCreate` or `useUpdate` hook mutations. This is useful when you have to apply different values to the `useCreate` or `useUpdate` hooks from the `useOne` hook query.

```tsx
useForm({
  mutationMeta: {
    mutationSpecificValue: "someValue",
  },
});
```

If you have overlapping properties in both `meta` and `mutationMeta`, the `mutationMeta` property will be used.

### queryOptions

In the `edit` and `clone` modes, Refine uses [`useOne`](/docs/data/hooks/use-one) hook to fetch data. You can pass the [`queryOptions`](https://tanstack.com/query/v4/docs/react/reference/useQuery) options by passing the `queryOptions` property. This property will only work in the `edit` and `clone` actions.

```tsx
useForm({
  queryOptions: {
    retry: 3,
  },
});
```

### createMutationOptions

In the `create` and `clone` modes, Refine uses the [`useCreate`](/docs/data/hooks/use-create) hook to create data. You can pass [`mutationOptions`](https://tanstack.com/query/v4/docs/react/reference/useMutation) by passing the `createMutationOptions` property. This property will only work in the `create` and `clone` actions.

```tsx
useForm({
  createMutationOptions: {
    retry: 3,
  },
});
```

### updateMutationOptions

In the `edit` mode, Refine uses [`useUpdate`](/docs/data/hooks/use-update) hook to update data. You can pass [`mutationOptions`](https://tanstack.com/query/v4/docs/react/reference/useMutation) by passing `updateMutationOptions` property. This property will only work in the `edit` action.

```tsx
useForm({
  updateMutationOptions: {
    retry: 3,
  },
});
```

### warnWhenUnsavedChanges

When set to true, `warnWhenUnsavedChanges` shows a warning when the user tries to leave the page with unsaved changes. It is used to prevent the user from accidentally leaving the page. It is `false` by default

It can be set globally in [`Refine config`](/docs/core/refine-component#warnwhenunsavedchanges).

```tsx
useForm({
  warnWhenUnsavedChanges: true,
});
```

### submitOnEnter

When it's true, `submitOnEnter` will submit the form when the enter key is pressed. It can be used to prevent the user from accidentally leaving the page. It is `false` by default

```tsx
useForm({
  submitOnEnter: true,
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

`liveMode` is where you can choose whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in real time throughout your app.

```tsx
useForm({
  liveMode: "auto",
});
```

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

`onLiveEvent` is the callback function that is executed when new events from a subscription are arrived.

```tsx
useForm({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to [liveProvider](/docs/realtime/live-provider#subscribe)'s subscribe method.

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useForm({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### autoSave

If you want to save the form automatically after some delay when user edits the form, you can pass true to `autoSave.enabled` prop.

By default the `autoSave` feature does not invalidate queries. However, you can use the `invalidateOnUnmount` prop to invalidate queries upon unmount.

It also supports [`onMutationSuccess`](#onmutationsuccess) and [`onMutationError`](#onmutationerror) callback functions. You can use `isAutoSave` parameter to determine whether the mutation is triggered by `autoSave` or not.

`autoSave` feature operates exclusively in `edit` mode. Users can take advantage of this feature while editing data, as changes are automatically saved in editing mode. However, when creating new data, manual saving is still required.

`onMutationSuccess` and `onMutationError` callbacks will be called after the mutation is successful or failed.

#### enabled

To enable the `autoSave` feature, set the `enabled` parameter to `true`. By default, it is `false`.

```tsx
useForm({
  autoSave: {
    enabled: true,
  },
});
```

#### debounce

Set the debounce time for the `autoSave` prop. By default, it is `1000` milliseconds.

```tsx
useForm({
  autoSave: {
    enabled: true,
    // highlight-next-line
    debounce: 2000,
  },
});
```

#### onFinish

If you want to modify the data before sending it to the server, you can use `onFinish` callback function.

```tsx
useForm({
  autoSave: {
    enabled: true,
    // highlight-start
    onFinish: (values) => {
      return {
        foo: "bar",
        ...values,
      };
    },
    // highlight-end
  },
});
```

#### invalidateOnUnmount

This prop is useful when you want to invalidate the `list`, `many` and `detail` queries from the current resource when the hook is unmounted. By default, it invalidates the `list`, `many` and `detail` queries associated with the current resource. Also, You can use the `invalidates` prop to select which queries to invalidate. By default, it is `false`.

```tsx
useForm({
  autoSave: {
    enabled: true,
    // highlight-next-line
    invalidateOnUnmount: true,
  },
});
```

### defaultFormValues

Default values for the form. Use this to pre-populate the form with data that needs to be displayed.

```tsx
useForm({
  defaultFormValues: {
    title: "Hello World",
  },
});
```

Also, it can be provided as an async function to fetch the default values. The loading state can be tracked using the [`defaultFormValuesLoading`](#defaultformvaluesloading) state returned from the hook.

> 🚨 When `action` is "edit" or "clone" a race condition with `async defaultFormValues` may occur. In this case, the form values will be the result of the last completed operation.

```tsx
const { defaultFormValuesLoading } = useForm({
  defaultFormValues: async () => {
    const response = await fetch("https://my-api.com/posts/1");
    const data = await response.json();
    return data;
  },
});
```

## Return Values

All [`Refine Core's useForm`](/docs/data/hooks/use-form/) return values also available in `useForm`.

### form

It's a [`<Form>`](https://ant.design/components/form) instance. You can refer to [Antd `<Form>` documentation](https://ant.design/components/form#api) for more information.

### formProps

It's required to manage [`<Form>`](https://ant.design/components/form) state and actions.

#### onFinish

`onFinish` is called when the form is submitted. It will call the appropriate mutation based on the `action` property.

The only difference between `onFinish` and `formProps.onFinish` is that passing a value to `formProps.onFinish`is mandatory, whereas `onFinish` can automatically retrieve values from the form state.

#### onValuesChange

The `warnWhenUnsavedChanges` feature requires this function to work. If you want to override the form's `onValuesChange`, keep this in mind.

#### onKeyUp

`onKeyUp` is a function that will be called when a key is pressed. By default, it will call `form.submit()` function when the pressed key is `Enter`.

#### initialValues

When `action` is set to `"edit"` or `"clone"`, `initialValues` will be set to the `data` returned from [`useOne`](/docs/data/hooks/use-one) hook.

### saveButtonProps

It contains all the props needed by the `"submit"` button within the form (disabled,loading etc.). When `saveButtonProps.onClick` is called, it triggers `form.submit()`. You can manually pass these props to your custom button.

### formLoading

`formLoading` is the loading state of a modal. It's `true` when `useForm` is currently being submitted or data is being fetched for the `"edit"` or `"clone"` mode.

### query

If the `action` is set to `"edit"` or `"clone"` or if a `resource` with an `id` is provided, `useForm` will call [`useOne`](/docs/data/hooks/use-one) and set the returned values as the `query` property.

```tsx
const { query } = useForm();

const { data } = query;
```

### mutation

When in `"create"` or `"clone"` mode, `useForm` will call [`useCreate`](/docs/data/hooks/use-create). When in `"edit"` mode, it will call [`useUpdate`](/docs/data/hooks/use-update) and set the resulting values as the `mutation` property.

```tsx
const { mutation } = useForm();

const { data } = mutation;
```

### setId

`useForm` determine the `id` from the router. If you want to change the `id` dynamically, you can use the `setId` function.

```tsx
const { id, setId } = useForm();

const handleIdChange = (id: string) => {
  setId(id);
};

return (
  <div>
    <input value={id} onChange={(e) => handleIdChange(e.target.value)} />
  </div>
);
```

### redirect

By default, after a successful mutation, `useForm` will redirect to the `"list"` page. To redirect to a different page, you can either use the `redirect` function to programmatically specify the destination, or set the `redirect` [property](/docs/data/hooks/use-form/#redirect) in the hook's options.

In the following example, we redirect to the `"show"` page after a successful mutation:

```tsx
const { onFinish, redirect } = useForm();

// --

const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  const data = await onFinish(formValues);
  redirect("show", data?.data?.id);
};

// --
```

### onFinish

`onFinish` is a function that is called when the form is submitted. It will call the appropriate mutation based on the `action` property.
You can override the default behavior by passing an `onFinish` function in the hook's options.

For example you can [change values before sending to the API](/docs/ui-integrations/ant-design/hooks/use-form#how-can-i-change-the-form-data-before-submitting-it-to-the-api).

### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useForm();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

### autoSaveProps

If `autoSave` is enabled, this hook returns `autoSaveProps` object with `data`, `error`, and `status` properties from mutation.

### defaultFormValuesLoading

If [`defaultFormValues`](#defaultformvalues) is an async function, `defaultFormValuesLoading` will be `true` until the function is resolved.

### ~~mutationResult~~ <PropTag deprecated />

This prop is deprecated and will be removed in the future versions. Use [`mutation`](#mutation) instead.

### ~~queryResult~~ <PropTag deprecated />

This prop is deprecated and will be removed in the future versions. Use [`query`](#query) instead.

## FAQ

### How can Invalidate other resources?

You can invalidate other resources with help of [`useInvalidate`](/docs/data/hooks/use-invalidate) hook.

It is useful when you want to `invalidate` other resources don't have relation with the current resource.

```tsx
import { useForm } from "@refinedev/antd";

const PostEdit = () => {
  const invalidate = useInvalidate();

  useForm({
    // highlight-start
    onMutationSuccess: (data, variables, context) => {
      invalidate({
        resource: "users",
        invalidates: ["resourceAll"],
      });
    },
    // highlight-end
  });

  // ---
};
```

### How can I change the form data before submitting it to the API?

Here is an example where we modify the form data before submit:

We need to send the values we received from the user in two separate inputs, `name` and `surname`, to the API as `fullName`.

```tsx title="pages/user/create.tsx"
import { Create, useForm } from "@refinedev/antd";
import { Form, Input } from "antd";
import React from "react";

export const UserCreate: React.FC = () => {
  // highlight-next-line
  const { formProps, saveButtonProps, onFinish } = useForm();

  // highlight-start
  const handleOnFinish = (values) => {
    onFinish({
      fullName: `${values.name} ${values.surname}`,
    });
  };
  // highlight-end

  return (
    <Create saveButtonProps={saveButtonProps}>
      // highlight-next-line
      <Form {...formProps} onFinish={handleOnFinish} layout="vertical">
        <Form.Item label="Name" name="name">
          <Input />
        </Form.Item>
        <Form.Item label="Surname" name="surname">
          <Input />
        </Form.Item>
      </Form>
    </Create>
  );
};
```

### How to pass `meta` values only for the mutation or query?

You can use the `meta` property to pass common values to the mutation and the query. But in some cases, you may want to pass different values to the mutation and the query. To do this, you can use `mutationMeta` and `queryMeta` properties.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/useForm"/>

> `*`: These props have default values in `RefineContext` and can also be set on **<[Refine](/docs/core/refine-component)>** component. `useForm` will use what is passed to `<Refine>` as default but a local value will override it.

<br/>

### Type Parameters

| Property       | Description                                                                                                                                                         | Type                       | Default                    |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData   | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError         | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TVariables     | Values for params.                                                                                                                                                  | `{}`                       |                            |
| TData          | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |
| TResponse      | Result data returned by the mutation function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TData` will be used as the default value.        | [`BaseRecord`][baserecord] | `TData`                    |
| TResponseError | Custom error object that extends [`HttpError`][httperror]. If not specified, the value of `TError` will be used as the default value.                               | [`HttpError`][httperror]   | `TError`                   |

### Return values

| Property                 | Description                                             | Type                                                                                                                                                             |
| ------------------------ | ------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| onFinish                 | Triggers the mutation                                   | `(values?: TVariables) => Promise<CreateResponse<TData>` \| `UpdateResponse<TData>` \| `void`>                                                                   |
| form                     | Ant Design form instance                                | [`FormInstance`](https://ant.design/components/form/#FormInstance)                                                                                               |
| formProps                | Ant Design form props                                   | [`FormProps`](https://ant.design/components/form/#Form)                                                                                                          |
| saveButtonProps          | Props for a submit button                               | `{ disabled: boolean; onClick: () => void; loading?:boolean; }`                                                                                                  |
| redirect                 | Redirect function for custom redirections               | `(redirect:` `"list"`\|`"edit"`\|`"show"`\|`"create"`\| `false` ,`idFromFunction?:` [`BaseKey`](/docs/core/interface-references#basekey)\|`undefined`) => `data` |
| query                    | Result of the query of a record                         | [`QueryObserverResult<T>`](https://react-query.tanstack.com/reference/useQuery)                                                                                  |
| mutation                 | Result of the mutation triggered by submitting the form | [`UseMutationResult<T>`](https://react-query.tanstack.com/reference/useMutation)                                                                                 |
| formLoading              | Loading state of form request                           | `boolean`                                                                                                                                                        |
| id                       | Record id for `clone` and `create` action               | [`BaseKey`](/docs/core/interface-references#basekey)                                                                                                             |
| setId                    | `id` setter                                             | `Dispatch<SetStateAction<` `string` \| `number` \| `undefined>>`                                                                                                 |
| overtime                 | Overtime loading props                                  | `{ elapsedTime?: number }`                                                                                                                                       |
| autoSaveProps            | Auto save props                                         | `{ data: UpdateResponse<TData>` \| `undefined, error: HttpError` \| `null, status: "loading"` \| `"error"` \| `"idle"` \| `"success" }`                          |
| defaultFormValuesLoading | DefaultFormValues loading status of form                | `boolean`                                                                                                                                                        |

## Example

<CodeSandboxExample path="form-antd-use-form" />

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[notification-provider]: /docs/notification/notification-provider
[get-one]: /docs/data/data-provider#getone-
[create]: /docs/data/data-provider#create-
[update]: /docs/data/data-provider#update-
[data-provider]: /docs/data/data-provider

================
File: ui-integrations/ant-design/hooks/use-import/index.md
================
---
title: useImport
---

The `useImport` hook allows you to import data from a `CSV` file. For each row in the file, it calls the `create` or `createMany` method of your data provider according to your configuration.

Internally, it uses [Papa Parse][papaparse] to parse the file contents.

It will return properties that are compatible with Ant Design's [`<Upload>`](https://ant.design/components/upload/) and [`<Button>`](https://ant.design/components/button/) components.

The `useImport` hook is extended from [`useImport`][use-import-core] hook from the [`@refinedev/core`](https://github.com/refinedev/refine/tree/main/packages/core) package. This means that you can use all the features of [`useImport`][use-import-core] hook.

## Usage

Here is a basic usage example of `useImport` hook:

```tsx
import { ImportButton, useImport } from "@refinedev/antd";

export const PostList: React.FC = () => {
  const importProps = useImport();

  return <ImportButton {...importProps}>Import</ImportButton>;
};
```

> For more information, refer to the [`<ImportButton>` interface &#8594](/docs/ui-integrations/ant-design/components/buttons/import-button)

Also, you can use the `inputProps` and `uploadProps` properties without the `<ImportButton>` component for more customization:

```tsx
import { useImport } from "@refinedev/antd";
import { Upload, Button } from "antd";

export const PostList: React.FC = () => {
  const { buttonProps, uploadProps } = useImport();

  return (
    <Upload {...uploadProps}>
      <Button {...buttonProps}>Import</Button>
    </Upload>
  );
};
```

## Properties

### resource

`resource` determines which resource is passed to the `create` or `createMany` method of your data provider. It reads from the URL by default.

```ts
useImport({
  resource: "posts",
});
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation #8594](/docs/core/refine-component#identifier)

### mapData

If you want to map the data before sending it to a data provider method, you can use the `mapData` property.

```ts
useImport({
  mapData: (data) => ({
    ...data,
    category: {
      id: data.categoryId,
    },
  }),
});
```

### paparseOptions

You can pass any Papa Parse [options](https://www.papaparse.com/docs#config) to the `paparseOptions` property.

```ts
useImport({
  paparseOptions: {
    header: true,
  },
});
```

### batchSize

If you want to send the data in batches, you can use the `batchSize` property. When the `batchSize` is 1, it calls the `create` method of your data provider for each row in the file. When the `batchSize` is greater than 1, it calls the `createMany` method of your data provider for each batch. By default, it is [`Number.MAX_SAFE_INTEGER`][number.max_safe_integer]

```ts
useImport({
  batchSize: 1,
});
```

### onFinish

If you want to do something after the import is finished, you can use the `onFinish` property. It returns an object with two properties: `succeeded` and `errored` which contain the responses of the successful and failed requests.

```ts
useImport({
  onFinish: (result) => {
    // success requests response
    result.succeeded.forEach((item) => {
      console.log(item);
    });

    // failed requests response
    result.errored.forEach((item) => {
      console.log(item);
    });
  },
});
```

### meta

If you want to send additional data to the `create` or `createMany` method of your data provider, you can use the `meta` property.

```ts
useImport({
  meta: {
    foo: "bar",
  },
});
```

### onProgress

A callback function that is called when the import progress changes. It returns an object with two properties: `totalAmount` and `processedAmount` which contain the total amount of rows and the processed amount of rows.

```ts
useImport({
  onProgress: ({ totalAmount, processedAmount }) => {
    // progress percentage
    console.log((processedAmount / totalAmount) * 100);
  },
});
```

By default, it shows a notification with the progress percentage. You can override this behavior by passing a custom `onProgress` function.

### dataProviderName

If there is more than one `dataProvider`, you can specify which one to use by passing the `dataProviderName` prop. It is useful when you have a different data provider for different resources.

```tsx
useImport({
  dataProviderName: "second-data-provider",
});
```

### ~~resourceName~~ <PropTag deprecated />

Use `resource` instead.

## Return Values

### buttonProps

`buttonProps` are button properties that are compatible with Ant Design [`<Button>`](https://ant.design/components/button/) component.

```tsx
import { useImport } from "@refinedev/antd";
import { Button } from "antd";

export const PostList: React.FC = () => {
  const { buttonProps } = useImport();

  return <Button {...buttonProps}>Import</Button>;
};
```

#### type

It is set to `default` by default.

#### loading

`loading` sets the loading state of the button if the import is in progress.

### uploadProps

Upload properties that are compatible with Ant Design [`<Upload>`](https://ant.design/components/upload/) component.

```tsx
import { useImport } from "@refinedev/antd";
import { Upload } from "antd";

export const PostList: React.FC = () => {
  const { uploadProps } = useImport();

  return <Upload {...uploadProps}>Import</Upload>;
};
```

#### onChange

Handles the file upload.

#### beforeUpload

By default, `() => false` is set to prevent the file from being uploaded automatically.

#### showUploadList

By default, `false` is set to hide the upload list.

#### accept

By default, `".csv"` is set to accept only CSV files.

### isLoading

It is a boolean value that indicates whether the import is in progress.

### mutationResult

Result of the [`useCreate`](/docs/data/hooks/use-create) or [`useCreateMany`](/docs/data/hooks/use-create) method of your data provider.

## FAQ

### Handling Relational Data

Sometimes you need to process your parsed `CSV` data for certain cases, such as when your data includes relational data and references to other data, or when your backend API requires a specific data format. To handle this, you can use the `mapData` option in `useImport` to customize the process.

For example, the `CSV` file is as follows:

```csv title="dummy.csv"
"title","content","status","categoryId","userId"
"dummy title 1","dummy content 1","rejected","3","8"
"dummy title 2","dummy content 2","draft","44","8"
"dummy title 3","cummy content 3","published","41","10"
```

Since the user and category are relational fields, we store only their id fields in the exported file as userId and categoryId, respectively. To create resources from this file, we need to map the data back to the required format of the backend API. To do this, we use the mapData option in useImport. Here's an example:

When creating these resources back, we should map them back to our backend API's required format. The `mapData` option allows us to do this. Here is an example:

```ts
useImport<IPostFile>({
  mapData: (item) => {
    return {
      title: item.title,
      content: item.content,
      status: item.status,
      category: {
        id: item.categoryId,
      },
      user: {
        id: item.userId,
      },
    };
  },
});

interface IPostFile {
  title: string;
  status: string;
  content: string;
  categoryId: string;
  userId: string;
}
```

With this code, the parsed data will be mapped to conform to the API requirements.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/useImport"/>

### Return Values

| Property       | Description                                                            | Type                                                                                                                                                                                                                                    |
| -------------- | ---------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| buttonProps    | Properties that are compatible with Ant Design `<Button>` component    | [`ButtonProps`](#buttonprops)                                                                                                                                                                                                           |
| uploadProps    | Properties that are compatible with Ant Design `<Upload>` component    | [`UploadProps`](#uploadprops)                                                                                                                                                                                                           |
| isLoading      | It can be used to handle the `loading` status for the Import operation | `boolean`                                                                                                                                                                                                                               |
| mutationResult | Result of the mutation/mutations of creating imported resources        | [`UseMutationResult<{ data: TData }, TError, { resource: string; values: TVariables; }, unknown>`][usemutation]) \| [`UseMutationResult<{ data: TData[]}, TError, { resource: string; values: TVariables[]; }, unknown>`][usemutation]) |

### Type Parameters

| Property   | Description                                                                | Default                    |
| ---------- | -------------------------------------------------------------------------- | -------------------------- |
| TItem      | Interface of parsed csv data                                               | `any`                      |
| TData      | Result type of the data query type that extends [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError     | Custom error object that extends [`HttpError`][httperror]                  | [`HttpError`][httperror]   |
| TVariables | Values for mutation function                                               | `any`                      |

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[papaparse]: https://www.papaparse.com/docs
[usemutation]: https://react-query.tanstack.com/reference/useMutation
[number.max_safe_integer]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER
[use-import-core]: /docs/core/hooks/utilities/use-import

================
File: ui-integrations/ant-design/hooks/use-modal-form/index.md
================
---
title: useModalForm
---

The `useModalForm` hook allows you to manage a form within a [`<Modal>`][antd-modal]. It returns Ant Design [`<Form>`][antd-form] and [Modal][antd-modal] components props.

`useModalForm` hook is extended from [`useForm`][antd-use-form] from the [`@refinedev/antd`][@refinedev/antd] package. This means that you can use all the features of [`useForm`][antd-use-form] hook.

## Usage

We'll show three examples, `"create"`, `"edit"` and `"clone"`. Let's see how `useModalForm` is used in all.

<Tabs
defaultValue="create"
values={[
{label: 'create', value: 'create'},
{label: 'edit', value: 'edit'},
{label: 'clone', value: 'clone'},
]}>

<TabItem value="create">

In this example, we will show you how to create a record with `useModalForm`.

```tsx live url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

// visible-block-start

import React from "react";

import { List, useModalForm, useTable } from "@refinedev/antd";
import { Form, Input, Modal, Select, Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  // highlight-start
  const {
    modalProps: createModalProps,
    formProps: createFormProps,
    show: createModalShow,
  } = useModalForm<IPost>({
    action: "create",
  });
  // highlight-end

  return (
    <>
      <List
        // createButtonProps allows us to create and manage a button above the table.
        // This code block makes <Modal> appear when you click the button.
        createButtonProps={{
          // highlight-start
          onClick: () => {
            createModalShow();
          },
          // highlight-end
        }}
      >
        <Table {...tableProps} rowKey="id">
          <Table.Column dataIndex="id" title="ID" />
          <Table.Column dataIndex="title" title="Title" />
          <Table.Column dataIndex="status" title="Status" />
        </Table>
      </List>
      {/* highlight-start */}
      <Modal {...createModalProps}>
        <Form {...createFormProps} layout="vertical">
          <Form.Item
            label="Title"
            name="title"
            rules={[
              {
                required: true,
              },
            ]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            label="Status"
            name="status"
            rules={[
              {
                required: true,
              },
            ]}
          >
            <Select
              options={[
                {
                  label: "Published",
                  value: "published",
                },
                {
                  label: "Draft",
                  value: "draft",
                },
                {
                  label: "Rejected",
                  value: "rejected",
                },
              ]}
            />
          </Form.Item>
        </Form>
      </Modal>
      {/* highlight-end */}
    </>
  );
};

interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineAntdDemo />);
```

</TabItem>

<TabItem value="edit">

Let's learn how to add editing capabilities to records that will be opening form in Modal by using the `action` prop.

```tsx live url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

import React from "react";

import { EditButton, List, useModalForm, useTable } from "@refinedev/antd";
import { Form, Input, Modal, Select, Space, Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  // highlight-start
  const {
    modalProps: editModalProps,
    formProps: editFormProps,
    show: editModalShow,
  } = useModalForm<IPost>({
    action: "edit",
    warnWhenUnsavedChanges: true,
  });
  // highlight-end

  return (
    <>
      <List>
        <Table {...tableProps} rowKey="id">
          <Table.Column dataIndex="id" title="ID" />
          <Table.Column dataIndex="title" title="Title" />
          <Table.Column dataIndex="status" title="Status" />
          <Table.Column<IPost>
            title="Actions"
            dataIndex="actions"
            key="actions"
            render={(_, record) => (
              <Space>
                {/* highlight-start */}
                <EditButton
                  hideText
                  size="small"
                  recordItemId={record.id}
                  onClick={() => editModalShow(record.id)}
                />
                {/* highlight-end */}
              </Space>
            )}
          />
        </Table>
      </List>
      {/* highlight-start */}
      <Modal {...editModalProps}>
        <Form {...editFormProps} layout="vertical">
          <Form.Item
            label="Title"
            name="title"
            rules={[
              {
                required: true,
              },
            ]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            label="Status"
            name="status"
            rules={[
              {
                required: true,
              },
            ]}
          >
            <Select
              options={[
                {
                  label: "Published",
                  value: "published",
                },
                {
                  label: "Draft",
                  value: "draft",
                },
                {
                  label: "Rejected",
                  value: "rejected",
                },
              ]}
            />
          </Form.Item>
        </Form>
      </Modal>
      {/* highlight-end */}
    </>
  );
};

interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineAntdDemo />);
```

Refine doesn't automatically add a `<EditButton/>` to the each record in `<PostList>` which opens the edit form in `<Modal>` when clicked.

So, we have to put the `<EditButton/>` on our list. In that way, `<Edit>` form in `<Modal>` can fetch data by the record `id`.

```tsx
<Table.Column<IPost>
  title="Actions"
  dataIndex="actions"
  key="actions"
  render={(_value, record) => <EditButton onClick={() => show(record.id)} />}
/>
```

Don't forget to pass the record `"id"` to `show` to fetch the record data. This is necessary for both `"edit"` and `"clone"` forms.

</TabItem>

<TabItem value="clone">

Let's learn how to add cloning capabilities to records that will be opening form in Modal by using the `action` prop.

```tsx live url=http://localhost:3000/posts
setInitialRoutes(["/posts"]);

import React from "react";

import { CloneButton, List, useModalForm, useTable } from "@refinedev/antd";
import { Form, Input, Modal, Select, Space, Table } from "antd";

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost>();

  // highlight-start
  const {
    modalProps: cloneModalProps,
    formProps: cloneFormProps,
    show: cloneModalShow,
  } = useModalForm<IPost>({
    action: "clone",
  });
  // highlight-end

  return (
    <>
      <List>
        <Table {...tableProps} rowKey="id">
          <Table.Column dataIndex="id" title="ID" />
          <Table.Column dataIndex="title" title="Title" />
          <Table.Column dataIndex="status" title="Status" />
          <Table.Column<IPost>
            title="Actions"
            dataIndex="actions"
            key="actions"
            render={(_, record) => (
              <Space>
                {/* highlight-start */}
                <CloneButton
                  hideText
                  size="small"
                  recordItemId={record.id}
                  onClick={() => cloneModalShow(record.id)}
                />
                {/* highlight-end */}
              </Space>
            )}
          />
        </Table>
      </List>
      {/* highlight-start */}
      <Modal {...cloneModalProps}>
        <Form {...cloneFormProps} layout="vertical">
          <Form.Item
            label="Title"
            name="title"
            rules={[
              {
                required: true,
              },
            ]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            label="Status"
            name="status"
            rules={[
              {
                required: true,
              },
            ]}
          >
            <Select
              options={[
                {
                  label: "Published",
                  value: "published",
                },
                {
                  label: "Draft",
                  value: "draft",
                },
                {
                  label: "Rejected",
                  value: "rejected",
                },
              ]}
            />
          </Form.Item>
        </Form>
      </Modal>
      {/* highlight-end */}
    </>
  );
};

interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
}
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineAntdDemo />);
```

Refine doesn't automatically add a `<CloneButton/>` to the each record in `<PostList>` which opens clone form in `<Modal>` when clicked.

So, we have to put the `<CloneButton/>` on our list. In that way, `<Clone>` form in `<Modal>` can fetch data by the record `id`.

```tsx
<Table.Column<IPost>
  title="Actions"
  dataIndex="actions"
  key="actions"
  render={(_value, record) => <CloneButton onClick={() => show(record.id)} />}
/>
```

Don't forget to pass the record id to `show` to fetch the record data. This is necessary for both `"edit"` and `"clone"` forms.

</TabItem>

</Tabs>

## Properties

All [`useForm`][antd-use-form] props are also available in `useModalForm`. You can find descriptions on the [`useForm` documentation](/docs/ui-integrations/ant-design/hooks/use-form#properties).

### syncWithLocation

When `syncWithLocation` is `true`, the drawers visibility state and the `id` of the record will be synced with the URL. It is `false` by default.

This property can also be set as an object `{ key: string; syncId?: boolean }` to customize the key of the URL query parameter. `id` will be synced with the URL only if `syncId` is `true`.

```tsx
const modalForm = useModalForm({
  syncWithLocation: { key: "my-modal", syncId: true },
});
```

### defaultFormValues

Default values for the form. Use this to pre-populate the form with data that needs to be displayed.

```tsx
useModalForm({
  defaultFormValues: {
    title: "Hello World",
  },
});
```

Also, it can be provided as an async function to fetch the default values. The loading state can be tracked using the [`defaultFormValuesLoading`](#defaultformvaluesloading) state returned from the hook.

> 🚨 When `action` is "edit" or "clone" a race condition with `async defaultFormValues` may occur. In this case, the form values will be the result of the last completed operation.

```tsx
const { defaultFormValuesLoading } = useModalForm({
  defaultFormValues: async () => {
    const response = await fetch("https://my-api.com/posts/1");
    const data = await response.json();
    return data;
  },
});
```

### defaultVisible

When `defaultVisible` is `true`, the modal will be visible by default. It is `false` by default.

```tsx
const modalForm = useModalForm({
  defaultVisible: true,
});
```

### autoSubmitClose

`autoSubmitClose` will make the modal close after a successful submit. It is `true` by default.

```tsx
const modalForm = useModalForm({
  autoSubmitClose: false,
});
```

### autoResetForm

`autoResetForm` will reset the form after a successful submit. It is `true` by default.

```tsx
const modalForm = useModalForm({
  autoResetForm: false,
});
```

### warnWhenUnsavedChanges

When set to true, `warnWhenUnsavedChanges` shows a warning when the user tries to leave the page with unsaved changes. It is used to prevent the user from accidentally leaving the page. It is `false` by default

You can also set this value in [`<Refine>`](/docs/core/refine-component#warnwhenunsavedchanges) component.

```tsx
const modalForm = useModalForm({
  warnWhenUnsavedChanges: true,
});
```

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useModalForm({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### autoSave

If you want to save the form automatically after some delay when user edits the form, you can pass true to `autoSave.enabled` prop.

By default the `autoSave` feature does not invalidate queries. However, you can use the `invalidateOnUnmount` and `invalidateOnClose` props to invalidate queries upon unmount or close.

It also supports `onMutationSuccess` and `onMutationError` callback functions. You can use `isAutoSave` parameter to determine whether the mutation is triggered by `autoSave` or not.

`autoSave` feature operates exclusively in `edit` mode. Users can take advantage of this feature while editing data, as changes are automatically saved in editing mode. However, when creating new data, manual saving is still required.

`onMutationSuccess` and `onMutationError` callbacks will be called after the mutation is successful or failed.

#### enabled

To enable the `autoSave` feature, set the `enabled` parameter to `true`. By default, it is `false`.

```tsx
useModalForm({
  autoSave: {
    enabled: true,
  },
});
```

#### debounce

Set the debounce time for the `autoSave` prop. By default, it is `1000` milliseconds.

```tsx
useModalForm({
  autoSave: {
    enabled: true,
    // highlight-next-line
    debounce: 2000,
  },
});
```

#### onFinish

If you want to modify the data before sending it to the server, you can use `onFinish` callback function.

```tsx
useModalForm({
  autoSave: {
    enabled: true,
    // highlight-start
    onFinish: (values) => {
      return {
        foo: "bar",
        ...values,
      };
    },
    // highlight-end
  },
});
```

#### invalidateOnUnmount

This prop is useful when you want to invalidate the `list`, `many` and `detail` queries from the current resource when the hook is unmounted. By default, it invalidates the `list`, `many` and `detail` queries associated with the current resource. Also, You can use the `invalidates` prop to select which queries to invalidate. By default, it is `false`.

```tsx
useModalForm({
  autoSave: {
    enabled: true,
    // highlight-next-line
    invalidateOnUnmount: true,
  },
});
```

#### invalidateOnClose

This prop is useful when you want to invalidate the `list`, `many` and `detail` queries from the current resource when the modal is closed. By default, it invalidates the `list`, `many` and `detail` queries associated with the current resource. Also, You can use the `invalidates` prop to select which queries to invalidate. By default, it is `false`.

```tsx
useModalForm({
  autoSave: {
    enabled: true,
    // highlight-next-line
    invalidateOnClose: true,
  },
});
```

## Return Values

`useModalForm` returns the same values from [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form#return-values) and additional values to work with [`<Modal>`][antd-modal] components.

### formProps

It's required to manage `<Form>` state and actions. Under the hood the `formProps` came from [`useForm`][antd-use-form].

It contains the props to manage the [Antd `<Form>`](https://ant.design/components/form#api) components such as [`onValuesChange`, `initialValues`, `onFieldsChange`, `onFinish` etc.](/docs/ui-integrations/ant-design/hooks/use-form#return-values)

:::note Difference between `onFinish` and `formProps.onFinish`

`onFinish` method returned directly from `useModalForm` is same with the `useForm`'s `onFinish`. When working with modals, closing the modal after submission and resetting the fields are necessary and to handle these, `formProps.onFinish` extends the `onFinish` method and handles the closing of the modal and clearing the fields under the hood.

If you're customizing the data before submitting it to your data provider, it's recommended to use `formProps.onFinish` and let it handle the operations after the submission.

:::

### modalProps

The props needed by the [`<Modal>`][antd-modal] component.

#### title

Title of the modal. Value is based on resource and action values.

#### okText

`okText` is the text of the `"submit"` button within the modal. It is "Save" by default.

#### cancelText

`cancelText` is the text of the `"cancel"` button within the modal. It is "Cancel" by default.

#### width

Width of the `<Modal>`. It is `1000px` by default.

#### forceRender

`forceRender` renders the `<Modal>` instead of lazy rendering it. It is `true` by default.

#### okButtonProps

`okButtonProps` contains all the props needed by the `"submit"` button within the modal (disabled,loading etc.). When `okButtonProps.onClick` is called, it triggers `form.submit()`. You can manually pass these props to your custom button.

#### onOk

A function that can submit the `<Form>` inside `<Modal>`. It's useful when you want to submit the form manually.

#### onCancel

> Same as `close`

A function that can close the `<Modal>`. It's useful when you want to close the modal manually.

#### ~~visible~~ <PropTag deprecated />

Please use `open` instead.

### open

Current visible state of `<Modal>`. Default value depends on `defaultVisible` prop.

### close

A function that can close the `<Modal>`. It's useful when you want to close the modal manually.

```tsx
const { close, modalProps, formProps, onFinish } = useModalForm();

const onFinishHandler = async (values) => {
  // Awaiting `onFinish` is important for features like unsaved changes notifier, invalidation, redirection etc.
  // If you're using the `onFinish` from `formProps`, it will call the `close` internally.
  await onFinish(values);
  close();
};

// ---

return (
  <Modal {...modalProps}>
    <Form {...formProps} onFinish={onFinishHandler} layout="vertical">
      <Form.Item label="Title" name="title">
        <Input />
      </Form.Item>
    </Form>
  </Modal>
);
```

### submit

`submit` is a function that can submit the form. It's useful when you want to submit the form manually.

```tsx
const { modalProps, formProps, submit } = useModalForm();

// ---

return (
  <Modal
    {...modalProps}
    footer={[
      <Button key="submit" type="primary" onClick={submit}>
        Submit
      </Button>,
    ]}
  >
    <Form {...formProps} layout="vertical">
      <Form.Item label="Title" name="title">
        <Input />
      </Form.Item>
    </Form>
  </Modal>
);
```

### show

`show` is a function that can show the modal.

```tsx
const { modalProps, formProps, show } = useModalForm();

return (
  <>
    <Button type="primary" onClick={() => show()}>
      Show Modal
    </Button>
    <Modal
      {...modalProps}
      footer={[
        <Button key="submit" type="primary" onClick={submit}>
          Submit
        </Button>,
      ]}
    >
      <Form {...formProps} onFinish={onFinishHandler} layout="vertical">
        <Form.Item label="Title" name="title">
          <Input />
        </Form.Item>
      </Form>
    </Modal>
  </>
);
```

```tsx
const { modalProps, formProps } = useModalForm();

// ---

return (
  <Modal
    {...modalProps}
    footer={
      <Button
        onClick={(
          e: React.MouseEvent<HTMLAnchorElement, MouseEvent> &
            React.MouseEvent<HTMLButtonElement, MouseEvent>,
        ) => modalProps.onCancel(e)}
      >
        Cancel
      </Button>
    }
  >
    <Form {...formProps} layout="vertical">
      <Form.Item label="Title" name="title">
        <Input />
      </Form.Item>
    </Form>
  </Modal>
);
```

### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useModalForm();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

### autoSaveProps

If `autoSave` is enabled, this hook returns `autoSaveProps` object with `data`, `error`, and `status` properties from mutation.

### defaultFormValuesLoading

If [`defaultFormValues`](#defaultformvalues) is an async function, `defaultFormValuesLoading` will be `true` until the function is resolved.

## FAQ

### How can I change the form data before submitting it to the API?

Here is an example where we modify the form data before submit:

We need to send the values we received from the user in two separate inputs, `name` and `surname`, to the API as `fullName`.

```tsx title="pages/user/create.tsx"
import { Modal, useModalForm } from "@refinedev/antd";
import { Form, Input } from "antd";
import React from "react";

export const UserCreate: React.FC = () => {
  // highlight-start
  const { formProps, modalProps } = useModalForm({
    action: "create",
  });
  // highlight-end

  // highlight-start
  const handleOnFinish = (values) => {
    formProps.onFinish?.({
      fullName: `${values.name} ${values.surname}`,
    });
  };
  // highlight-end

  return (
    <Modal {...modalProps}>
      // highlight-next-line
      <Form {...formProps} onFinish={handleOnFinish} layout="vertical">
        <Form.Item label="Name" name="name">
          <Input />
        </Form.Item>
        <Form.Item label="Surname" name="surname">
          <Input />
        </Form.Item>
      </Form>
    </Modal>
  );
};
```

## API Reference

### Properties

<PropsTable module="@refinedev/antd/useModalForm"/>

> `*`: These props have default values in `RefineContext` and can also be set on **<[Refine](/docs/core/refine-component)>** component. `useModalForm` will use what is passed to `<Refine>` as default but a local value will override it.

> `**`: If not explicitly configured, default value of `redirect` depends on which `action` used. If `action` is `create`, `redirect`s default value is `edit` (created resources edit page). If `action` is `edit` instead, `redirect`s default value is `list`.

### Type Parameters

| Property       | Description                                                                                                                                                         | Type                       | Default                    |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData   | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError         | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TVariables     | Values for params.                                                                                                                                                  | `{}`                       |                            |
| TData          | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |
| TResponse      | Result data returned by the mutation function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TData` will be used as the default value.        | [`BaseRecord`][baserecord] | `TData`                    |
| TResponseError | Custom error object that extends [`HttpError`][httperror]. If not specified, the value of `TError` will be used as the default value.                               | [`HttpError`][httperror]   | `TError`                   |

### Return Value

| Key                      | Description                                                                                                    | Type                                                                                                                                                       |
| ------------------------ | -------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| show                     | A function that can open the modal                                                                             | `(id?: BaseKey) => void`                                                                                                                                   |
| formProps                | [Props needed to manage form component](/docs/ui-integrations/ant-design/hooks/use-modal-form#formprops)       | [`FormProps`](https://ant.design/components/form/#Form)                                                                                                    |
| modalProps               | [Props for needed to manage modal component](/docs/ui-integrations/ant-design/hooks/use-modal-form#modalprops) | [`ModalProps`](https://ant.design/components/modal/#API)                                                                                                   |
| formLoading              | Loading status of form                                                                                         | `boolean`                                                                                                                                                  |
| submit                   | Submit method, the parameter is the value of the form fields                                                   | `() => void`                                                                                                                                               |
| open                     | Whether the modal dialog is open or not                                                                        | `boolean`                                                                                                                                                  |
| close                    | Specify a function that can close the modal                                                                    | `() => void`                                                                                                                                               |
| defaultFormValuesLoading | DefaultFormValues loading status of form                                                                       | `boolean`                                                                                                                                                  |
| form                     | Ant Design form instance                                                                                       | [`FormInstance<TVariables>`](https://ant.design/components/form/#FormInstance)                                                                             |
| id                       | Record id for edit action                                                                                      | [`BaseKey`][basekey] \| `undefined`                                                                                                                        |
| setId                    | `id` setter                                                                                                    | `Dispatch<SetStateAction<` [`BaseKey`][basekey] \| `undefined>>`                                                                                           |
| queryResult              | Result of the query of a record                                                                                | [`QueryObserverResult<{ data: TData }>`](https://react-query.tanstack.com/reference/useQuery)                                                              |
| mutation                 | Result of the mutation triggered by submitting the form                                                        | [`UseMutationResult<{ data: TData }, TError, { resource: string; values: TVariables; }, unknown>`](https://react-query.tanstack.com/reference/useMutation) |
| overtime                 | Overtime loading props                                                                                         | `{ elapsedTime?: number }`                                                                                                                                 |
| autoSaveProps            | Auto save props                                                                                                | `{ data: UpdateResponse<TData>` \| `undefined, error: HttpError` \| `null, status: "loading"` \| `"error"` \| `"idle"` \| `"success" }`                    |
| defaultFormValuesLoading | DefaultFormValues loading status of form                                                                       | `boolean`                                                                                                                                                  |

## Example

<CodeSandboxExample path="form-antd-use-modal-form" />

[@refinedev/antd]: https://github.com/refinedev/refine/tree/main/packages/antd
[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[basekey]: /docs/core/interface-references#basekey
[antd-use-form]: /docs/ui-integrations/ant-design/hooks/use-form
[antd-modal]: https://ant.design/components/modal/
[antd-form]: https://ant.design/components/form/

================
File: ui-integrations/ant-design/hooks/use-modal/index.md
================
---
title: useModal
---

The `useModal` hook helps you manage the [Ant Design Modal](https://ant.design/components/modal) component.

```ts
const { show, close, modalProps } = useModal();
```

You can use the `show` and `close` props to control the `modal` visibility. You have to descturt `modalProps` to the `<Modal/>` component.

## Usage

Let's see an example:

```tsx title="src/pages/posts/list.tsx"
// highlight-start
import { useModal } from "@refinedev/antd";
import { Modal, Button } from "antd";
// highlight-end

export const PostList: React.FC = () => {
  // highlight-next-line
  const { show, modalProps } = useModal();

  return (
    <>
      // highlight-start
      <Button onClick={show}>Show Modal</Button>
      <Modal {...modalProps}>
        <p>Modal Content</p>
      </Modal>
      // highlight-end
    </>
  );
};
```

<br />

Here, we show a button somewhere on the page and use `show` on it's `onClick` callback to trigger opening of the `<Modal>`. When the user clicks on the button, the `<Modal>` appears.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/useModal"  />

### Return Value

| Key        | Description                                 | Type         |
| ---------- | ------------------------------------------- | ------------ |
| show       | Returns the visibility state of the Modal   | `() => void` |
| close      | A function that can open the modal          | `() => void` |
| modalProps | Specify a function that can close the modal | `() => void` |

================
File: ui-integrations/ant-design/hooks/use-radio-group/index.md
================
---
title: useRadioGroup
---

`useRadioGroup` hook allows you to manage an Ant Design [Radio.Group](https://ant.design/components/radio/#components-radio-demo-radiogroup-with-name) component when records in a resource needs to be used as radio options.

## Usage

We will demonstrate how to get data at `/languages` endpoint from the `https://api.fake-rest.refine.dev` REST API.

```ts title="https://api.fake-rest.refine.dev/languages"
{
  [
    {
      id: 1,
      title: "Turkish",
    },
    {
      id: 2,
      title: "English",
    },
    {
      id: 3,
      title: "German",
    },
  ];
}
```

```tsx title="pages/posts/create.tsx"
import { useRadioGroup } from "@refinedev/antd";
import { Form, Radio } from "antd";

export const PostCreate = () => {
  // highlight-start
  const { radioGroupProps } = useRadioGroup<ILanguage>({
    resource: "languages",
  });
  // highlight-end

  return (
    <Form>
      <Form.Item label="Languages" name="languages">
        // highlight-next-line
        <Radio.Group {...radioGroupProps} />
      </Form.Item>
    </Form>
  );
};

interface ILanguage {
  id: number;
  title: string;
}
```

<Image src="https://refine.ams3.cdn.digitaloceanspaces.com/website/static/img/hooks/useRadioGroup/basic-usage.png" alt="Radio group" />

All we have to do is pass the `radioGroupProps` it returns to the `<Radio.Group>` component.

`useRadioGroup` uses the `useList` hook for fetching data.

> For more information, refer to the [Refine Core's `useList` hook documentation &#8594](/docs/data/hooks/use-list)

## Options

### resource

```tsx
const { radioGroupProps } = useRadioGroup({
  resource: "languages",
});
```

`resource` property determines API resource endpoint to fetch records from [`dataProvider`](/docs/data/data-provider). It returns properly configured `options` values for radio buttons.

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

> For more information, refer to the [Ant Design's `Radio.Group` component documentation &#8594](https://ant.design/components/radio)

### defaultValue

```tsx
const { radioGroupProps } = useRadioGroup({
  resource: "languages",
  // highlight-next-line
  defaultValue: 1,
});
```

### selectedOptionsOrder

`selectedOptionsOrder` allows us to sort `selectedOptions` on `defaultValue`. It can be:

- `"in-place"`: sort `selectedOptions` at the bottom. It is by default.
- `"selected-first"`: sort `selectedOptions` at the top.

```tsx
const { radioGroupProps } = useRadioGroup({
  resource: "languages",
  // highlight-next-line
  defaultValue: 1,
  // highlight-next-line
  selectedOptionsOrder: "selected-first", // in-place | selected-first
});
```

The easiest way to selecting a default value for an radio button field is by passing in `defaultValue`.

### optionLabel and optionValue

```tsx
const { radioGroupProps } = useRadioGroup({
  resource: "languages",
  // highlight-start
  optionLabel: "title",
  optionValue: "id",
  // highlight-end
});
```

`optionLabel` and `optionValue` allows you to change the values and appearances of your options. Default values are `optionLabel = "title"` and `optionValue = "id"`.

These properties also support nested property access with [Object path](https://lodash.com/docs/4.17.15#get) syntax.

```tsx
const { options } = useRadioGroup({
  resource: "categories",
  // highlight-start
  optionLabel: "nested.title",
  optionValue: "nested.id",
  // highlight-end
});
```

It's also possible to pass function to these props. These functions will receive `item` argument.

```tsx
const { options } = useRadioGroup({
  optionLabel: (item) => `${item.firstName} ${item.lastName}`,
  optionValue: (item) => item.id,
});
```

### searchField

Can be used to specify which field will be searched with value given to `onSearch` function.

```tsx
const { onSearch } = useRadioGroup({ searchField: "name" });

onSearch("John"); // Searches by `name` field with value John.
```

By default, it uses `optionLabel`'s value, if `optionLabel` is a string. Uses `title` field otherwise.

```tsx
// When `optionLabel` is string.
const { onSearch } = useRadioGroup({ optionLabel: "name" });

onSearch("John"); // Searches by `name` field with value John.

// When `optionLabel` is function.
const { onSearch } = useRadioGroup({
  optionLabel: (item) => `${item.id} - ${item.name}`,
});

onSearch("John"); // Searches by `title` field with value John.
```

### filters

`filters` allows us to add filters while fetching the data. For example, if you want to list only the `titles` that are equal to "German":

```tsx
const { radioGroupProps } = useRadioGroup({
  resource: "languages",
  // highlight-start
  filters: [
    {
      field: "title",
      operator: "eq",
      value: "German",
    },
  ],
  // highlight-end
});
```

### sorters

`sorters` allows us to sort the `options`. For example, if you want to sort your list according to `title` by ascending:

```tsx
const { radioGroupProps } = useRadioGroup({
  resource: "languages",
  // highlight-start
  sorters: [
    {
      field: "title",
      order: "asc",
    },
  ],
  // highlight-end
});
```

### fetchSize

`fetchSize` is the amount of records to fetch in checkboxes.

```tsx
const { radioGroupProps } = useRadioGroup({
  resource: "languages",
  // highlight-next-line
  fetchSize: 20,
});
```

### queryOptions

Passing the `queryOptions` property allows us to set the [useQuery](https://react-query.tanstack.com/reference/useQuery) options

```tsx
const { radioGroupProps } = useRadioGroup({
  resource: "languages",
  // highlight-start
  queryOptions: {
    onError: () => {
      console.log("triggers when on query return Error");
    },
  },
  // highlight-end
});
```

### pagination

`pagination` allows us to set page and items per page values.

For example, lets say that we have 1000 post records:

```ts
const { radioGroupProps } = useRadioGroup({
  resource: "categories",
  // highlight-next-line
  pagination: { current: 3, pageSize: 8 },
});
```

The listing will start from page 3, showing 8 records per page.

### ~~sort~~ <PropTag deprecated />

Use `sorters` instead.

## API Reference

### Properties

<PropsTable module="@refinedev/antd/useRadioGroup"/>

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Property        | Description                      | Type                                                                                          |
| --------------- | -------------------------------- | --------------------------------------------------------------------------------------------- |
| radioGroupProps | Ant design radio group props     | [`Radio Group`](https://ant.design/components/radio/#RadioGroup)                              |
| queryResult     | Results of the query of a record | [`QueryObserverResult<{ data: TData }>`](https://react-query.tanstack.com/reference/useQuery) |

## Example

<CodeSandboxExample path="field-antd-use-radio-group" />

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: ui-integrations/ant-design/hooks/use-select/_basic-usage-live-preview.md
================
```tsx live url=http://localhost:3000 previewHeight=300px
setInitialRoutes(["/posts/create"]);
// visible-block-start
import { useSelect } from "@refinedev/antd";
import { Select } from "antd";

interface ICategory {
  id: number;
  title: string;
}

const PostCreate: React.FC = () => {
  const { selectProps } = useSelect<ICategory>({
    resource: "categories",
  });

  return (
    <Select
      placeholder="Select a category"
      style={{ width: 300 }}
      {...selectProps}
    />
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          create: "posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route path="posts/create" element={<PostCreate />} />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: ui-integrations/ant-design/hooks/use-select/_crud-live-preview.md
================
```tsx live url=http://localhost:3000 previewHeight=300px
setInitialRoutes(["/posts/create"]);
// visible-block-start
import { Create, useSelect, useForm } from "@refinedev/antd";
import { Form, Select } from "antd";

interface ICategory {
  id: number;
  title: string;
}

const PostCreate: React.FC = () => {
  const { formProps, saveButtonProps } = useForm<ICategory>();

  const { selectProps } = useSelect<ICategory>({
    resource: "categories",
  });

  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
          label="Category"
          placeholder="Select a category"
          name={["category", "id"]}
          rules={[
            {
              required: true,
            },
          ]}
        >
          <Select {...selectProps} />
        </Form.Item>
      </Form>
    </Create>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          create: "posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route path="posts/create" element={<PostCreate />} />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: ui-integrations/ant-design/hooks/use-select/_default-value-live-preview.md
================
```tsx live url=http://localhost:3000 previewHeight=300px
setInitialRoutes(["/posts/create"]);
// visible-block-start
import { useSelect } from "@refinedev/antd";
import { Select } from "antd";

interface ICategory {
  id: number;
  title: string;
}

const PostCreate: React.FC = () => {
  const { selectProps } = useSelect<ICategory>({
    resource: "categories",
    // highlight-next-line
    defaultValue: 11,
  });

  return (
    <Select
      placeholder="Select a category"
      style={{ width: 300 }}
      {...selectProps}
    />
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          create: "posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route path="posts/create" element={<PostCreate />} />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: ui-integrations/ant-design/hooks/use-select/_on-search-live-preview.md
================
```tsx live url=http://localhost:3000 previewHeight=300px
setInitialRoutes(["/posts/create"]);
// visible-block-start
import { useSelect } from "@refinedev/antd";
import { Select } from "antd";

interface ICategory {
  id: number;
  title: string;
}

const PostCreate: React.FC = () => {
  const { selectProps } = useSelect<ICategory>({
    resource: "categories",
    // highlight-start
    onSearch: (value) => [
      {
        field: "title",
        operator: "contains",
        value,
      },
    ],
    // highlight-end
  });

  return (
    <Select
      placeholder="Select a category"
      style={{ width: 300 }}
      {...selectProps}
    />
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          create: "posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route path="posts/create" element={<PostCreate />} />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: ui-integrations/ant-design/hooks/use-select/_sort-live-preview.md
================
```tsx live url=http://localhost:3000 previewHeight=300px
setInitialRoutes(["/posts/create"]);
// visible-block-start
import { useSelect } from "@refinedev/antd";
import { Select, Button } from "antd";

interface ICategory {
  id: number;
  title: string;
}

const PostCreate: React.FC = () => {
  const [order, setOrder] = React.useState<"asc" | "desc">("asc");

  const { selectProps } = useSelect<ICategory>({
    resource: "categories",
    // highlight-start
    sorters: [
      {
        field: "title",
        order,
      },
    ],
    // highlight-end
  });

  return (
    <>
      <Select
        placeholder={`Ordered Categories: ${order}`}
        style={{ width: 300 }}
        {...selectProps}
      />
      <Button onClick={() => setOrder(order === "asc" ? "desc" : "asc")}>
        Toggle Order
      </Button>
    </>
  );
};
// visible-block-end

render(
  <ReactRouter.BrowserRouter>
    <RefineAntdDemo
      resources={[
        {
          name: "posts",
          create: "posts/create",
        },
      ]}
    >
      <ReactRouter.Routes>
        <ReactRouter.Route path="posts/create" element={<PostCreate />} />
      </ReactRouter.Routes>
    </RefineAntdDemo>
  </ReactRouter.BrowserRouter>,
);
```

================
File: ui-integrations/ant-design/hooks/use-select/index.md
================
---
title: useSelect
siderbar_label: useSelect
source: https://github.com/refinedev/refine/blob/main/packages/antd/src/hooks/fields/useSelect/index.ts
---

import BasicUsageLivePreview from "./\_basic-usage-live-preview.md";
import OnSearchLivePreview from "./\_on-search-live-preview.md";
import SortLivePreview from "./\_sort-live-preview.md";
import DefaultValueLivePreview from "./\_default-value-live-preview.md";
import CrudLivePreview from "./\_crud-live-preview.md";

`useSelect` hook allows you to manage Ant Design's [`<Select>`](https://ant.design/components/select) component when the records in a resource needs to be used as select options.

This hook uses the `useList` hook for fetching data.

> For more information, refer to the [useList documentation &#8594](/docs/data/hooks/use-list)

## Usage

Here is a basic example that uses the `useSelect` hook.

<BasicUsageLivePreview />

## Realtime Updates

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

When the `useSelect` hook is mounted, it passes some parameters (`channel`, `resource` etc.) to the `subscribe` method from the `liveProvider` that allow you to subscribe to live updates.

## Properties

### resource <PropTag required />

`resource` will be passed to the `getList` method from the `dataProvider` as parameter via the `useList` hook. The parameter is usually used as an API endpoint path but it all depends on how you handle the `resource` in the `getList` method.

See the [creating a data provider documentation](/docs/data/data-provider) for an example of how resource are handled.

```tsx
useSelect({
  resource: "categories",
});
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### optionLabel and optionValue

Allows you to change the `value` and `label` of your options.
Default values are `optionLabel = "title"` and `optionValue = "id"`

```tsx
useSelect<ICategory>({
    resource: "products",
    optionLabel: "name"
    optionValue: "productId"
});
```

These properties also support nested property access with [Object path](https://lodash.com/docs/4.17.15#get) syntax.

```tsx
const { options } = useSelect({
  resource: "categories",
  optionLabel: "nested.title",
  optionValue: "nested.id",
});
```

It's also possible to pass function to these props. These functions will receive `item` argument.

```tsx
const { options } = useSelect({
  optionLabel: (item) => `${item.firstName} ${item.lastName}`,
  optionValue: (item) => item.id,
});
```

### searchField

Can be used to specify which field will be searched with value given to `onSearch` function.

```tsx
const { onSearch } = useSelect({ searchField: "name" });

onSearch("John"); // Searches by `name` field with value John.
```

By default, it uses `optionLabel`'s value, if `optionLabel` is a string. Uses `title` field otherwise.

```tsx
// When `optionLabel` is string.
const { onSearch } = useSelect({ optionLabel: "name" });

onSearch("John"); // Searches by `name` field with value John.

// When `optionLabel` is function.
const { onSearch } = useSelect({
  optionLabel: (item) => `${item.id} - ${item.name}`,
});

onSearch("John"); // Searches by `title` field with value John.
```

### sorters

`sorters` prop allows you to show the options in the desired order. It will be passed to the `getList` method from the `dataProvider` as parameter via the `useList` hook and used to send sort query parameters to the API.

```tsx
useSelect({
  sorters: [
    {
      field: "title",
      order: "asc",
    },
  ],
});
```

<SortLivePreview />

> For more information, refer to the [`CrudSorting` interface documentation &#8594](/docs/core/interface-references#crudsorting)

### filters

`filters` is used to filter the options you are showing. `filters` will be passed to the `getList` method from the `dataProvider` as parameter via the `useList` hook and used to send filter query parameters to the API.

```tsx
useSelect({
  filters: [
    {
      field: "isActive",
      operator: "eq",
      value: true,
    },
  ],
});
```

> For more information, refer to the [`CrudFilters` interface documentation &#8594](/docs/core/interface-references#crudfilters)

### defaultValue

Is used to fetch extra options from the API.

If there are many `<select>` options and pagination is needed, the `defaultValue` might not be in the visible list. This can break the `<select>` component. To prevent this, a separate `useMany` query fetches the `defaultValue` from the backend and adds it to the options, ensuring it exists in the list. Since it uses `useMany`, `defaultValue` can be a single value or an array:

```tsx
useSelect({
  defaultValue: 1, // or [1, 2]
});
```

:::info

`defaultValue` **does not** set a default selection. It only ensures the default value exists in the options.

To set a default selection, pass `defaultValue` to the `value` prop of `<Select>` or `useForm`:

```tsx
const form = useForm({
  defaultValues: {
    category: { id: 1 }, // Default selected value
  },
});

const { selectProps } = useSelect({
  resource: "categories",
  defaultValue: [1], // Ensures the default value is included in options
});
```

:::

### selectedOptionsOrder

`selectedOptionsOrder` allows us to sort `selectedOptions` on `defaultValue`. It can be:

- `"in-place"`: sort `selectedOptions` at the bottom. It is by default.
- `"selected-first"`: sort `selectedOptions` at the top.

```tsx
useSelect({
  defaultValue: 1, // or [1, 2]
  selectedOptionsOrder: "selected-first", // in-place | selected-first
});
```

> For more information, refer to the [`useMany` documentation &#8594](/docs/data/hooks/use-many)

### debounce

This prop allows us to `debounce` the `onSearch` function.

```tsx
useSelect({
  resource: "categories",
  debounce: 500,
});
```

### queryOptions

`queryOptions` is used to pass additional options to the `useQuery` hook. It is useful when you want to pass additional options to the `useQuery` hook.

```tsx
useSelect({
  queryOptions: {
    retry: 3,
  },
});
```

> For more information, refer to the [`useQuery` documentation &#8594](https://tanstack.com/query/v4/docs/react/reference/useQuery)

### pagination

`pagination` will be passed to the `getList` method from the `dataProvider` as parameter. It is used to send pagination query parameters to the API.

#### current

You can pass the `current` page number to the `pagination` property.

```tsx
useSelect({
  pagination: {
    current: 2,
  },
});
```

#### pageSize

You can pass the `pageSize` to the `pagination` property.

```tsx
useSelect({
  pagination: {
    pageSize: 20,
  },
});
```

#### mode

It can be `"off"`, `"client"` or `"server"`. It is used to determine whether to use server-side pagination or not.

```tsx
useSelect({
  pagination: {
    mode: "off",
  },
});
```

### defaultValueQueryOptions

When the `defaultValue` property is given, the `useMany` data hook is called for the selected records. `defaultValueQueryOptions` allows you to change the options of this query.

If `defaultValue` property is not given, the values given in the `queryOptions` will be used instead.

```tsx
const { options } = useSelect({
  resource: "categories",
  defaultValueQueryOptions: {
    onSuccess: (data) => {
      console.log("triggers when on query return on success");
    },
  },
});
```

### onSearch

`onSearch` allows the addittion of `AutoComplete` to the `options`.

<OnSearchLivePreview />

If `onSearch` is used, it will override the existing `filters`.

> For more information, refer to the [`CrudFilters` interface documentation &#8594](/docs/core/interface-references#crudfilters)

#### Client-side filtering

Sometimes, you may want to filter the options on the client-side. You can do this by passing the `onSearch` function as `undefined` and setting `filterOption` to `true`. You can also set `optionFilterProp` to `label` or `value` to filter the options by label or value respectively.

```tsx
const { selectProps } = useSelect({
  resource: "categories",
});

<Select
  {...selectProps}
  onSearch={undefined}
  filterOption={true}
  optionFilterProp="label" // or "value"
/>;
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useSelect({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  getList: async ({
    resource,
    pagination,
    sorters,
    filters,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;
    //...
    //...
    // highlight-next-line
    const { data, headers } = await httpClient.get(`${url}`, { headers });
    return {
      data,
    };
  },
  //...
};
```

> For more information, refer to the [`meta` section of the General Concepts documentation &#8594](/docs/guides-concepts/general-concepts/#meta-concept)

### dataProviderName

If there is more than one `dataProvider`, you can specify which one to use by passing the `dataProviderName` prop. It is useful when you have different data providers for different resources.

```tsx
useSelect({
  dataProviderName: "second-data-provider",
});
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useSelect` can call the `open` function from `NotificationProvider` to show a success notification. This prop allows you to customize the success notification message

```tsx
useSelect({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useSelect` will call the `open` function from `NotificationProvider` to show an error notification. This prop allows you to customize the error notification message

```tsx
useSelect({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

This property determines whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.

```tsx
useSelect({
  liveMode: "auto",
});
```

> For more information, refer to the [Live / Realtime documentation &#8594](/docs/realtime/live-provider#livemode)

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

The callback function that is executed when new events from a subscription are arrived.

```tsx
useSelect({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds while `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useSelect({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### ~~sort~~ <PropTag deprecated />

Use `sorters` instead.

### ~~hasPagination~~ <PropTag deprecated />

Use `pagination.mode` instead.

## FAQ

### How to add search to options (Autocomplete)?

[`onSearch`](/docs/data/hooks/use-select#onsearch) is a function that is used to set the search value. It is useful when you want to search for a specific value. A simple example of this is shown below.

<OnSearchLivePreview />

### How to ensure `defaultValue` is included in the options?

In some cases we only have `id`, it may be necessary to show it selected in the selection box. This hook sends the request via [`useMany`](/docs/data/hooks/use-many), gets the data and mark as selected.

<DefaultValueLivePreview />

### How to change the `label` and `value` properties in options?

[`optionLabel` and `optionValue`](/docs/data/hooks/use-select#optionlabel-and-optionvalue) are used to change the value of your options.
The default values are `optionsLabel="title"` and `optionsValue="id"`.

To change to `name` and `categoryId`;

```tsx
useSelect({
  optionLabel: "name",
  optionValue: "categoryId",
});
```

### Can I create the options manually?

Sometimes it may not be enough to create `optionLabel` and `optionValue` options. In this case we create options with `query`.

```tsx
const { query } = useSelect();

const options = query.data?.data.map((item) => ({
  label: item.title,
  value: item.id,
}));

return <Select options={options} />;
```

### How do I use it with `CRUD` components and `useForm`?

<CrudLivePreview />

## API Reference

### Properties

<PropsTable module="@refinedev/antd/useSelect"  />

### Type Parameters

| Property     | Description                                                                                                                                                         | Type                       | Default                    |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError       | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TData        | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Property                   | Description                                    | Type                                                                                          |
| -------------------------- | ---------------------------------------------- | --------------------------------------------------------------------------------------------- |
| selectProps                | Ant design Select props                        | [`Select`](https://ant.design/components/select/#API)                                         |
| query                      | Result of the query of a record                | [`QueryObserverResult<{ data: TData }>`](https://react-query.tanstack.com/reference/useQuery) |
| defaultValueQuery          | Result of the query of a `defaultValue` record | [`QueryObserverResult<{ data: TData }>`](https://react-query.tanstack.com/reference/useQuery) |
| defaultValueQueryOnSuccess | Default value onSuccess method                 | `() => void`                                                                                  |
| overtime                   | Overtime loading props                         | `{ elapsedTime?: number }`                                                                    |

## Example

<CodeSandboxExample path="field-antd-use-select-basic" />

## Infinite Loading Example

<CodeSandboxExample path="field-antd-use-select-infinite" />

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror

================
File: ui-integrations/ant-design/hooks/use-simple-list/_basic-usage-live-preview.md
================
```tsx live url=http://localhost:3000/products previewHeight=420px
setInitialRoutes(["/products"]);

// visible-block-start
import { useSimpleList } from "@refinedev/antd";
import { Typography, List } from "antd";

const { Text } = Typography;

interface IProduct {
  id: number;
  name: string;
  description: string;
  price: string;
}

const ProductList: React.FC = () => {
  const { listProps } = useSimpleList<IProduct>();

  return <List {...listProps} renderItem={renderItem} />;
};

const renderItem = (item: IProduct) => {
  const { id, name, description, price } = item;

  return (
    <List.Item actions={[<Text key={id}>{price}</Text>]}>
      <List.Item.Meta title={name} description={description} />
    </List.Item>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "products",
      list: ProductList,
    },
  ],
});

render(<RefineAntdDemo />);
```

================
File: ui-integrations/ant-design/hooks/use-simple-list/_filtering-live-preview.md
================
```tsx live url=http://localhost:3000/products previewHeight=420px
setInitialRoutes(["/products"]);

// visible-block-start
import { useSimpleList } from "@refinedev/antd";
import { Typography, List, Input } from "antd";

const { Text } = Typography;

interface IProduct {
  id: number;
  name: string;
  description: string;
  price: string;
}

const ProductList: React.FC = () => {
  const { listProps, setFilters } = useSimpleList<IProduct>({
    filters: {
      initial: [
        {
          field: "name",
          operator: "contains",
          value: "Awesome",
        },
      ],
    },
  });

  return (
    <div>
      <Input.Search
        placeholder="Search by name"
        onChange={(e) => {
          setFilters([
            {
              field: "name",
              operator: "contains",
              value: e.target.value,
            },
          ]);
        }}
      />
      <List {...listProps} renderItem={renderItem} />
    </div>
  );
};

const renderItem = (item: IProduct) => {
  const { id, name, description, price } = item;

  return (
    <List.Item actions={[<Text key={id}>{price}</Text>]}>
      <List.Item.Meta title={name} description={description} />
    </List.Item>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "products",
      list: ProductList,
    },
  ],
});

render(<RefineAntdDemo />);
```

================
File: ui-integrations/ant-design/hooks/use-simple-list/_search-live-preview.md
================
```tsx live url=http://localhost:3000/products previewHeight=420px
setInitialRoutes(["/products"]);

// visible-block-start
import { useSimpleList } from "@refinedev/antd";
import { Typography, List, Form, Input, Button } from "antd";
import { HttpError } from "@refinedev/core";

const { Text } = Typography;

interface IProduct {
  id: number;
  name: string;
  description: string;
  price: string;
}

interface ISearch {
  name: string;
  description: string;
}

const ProductList: React.FC = () => {
  const { listProps, searchFormProps } = useSimpleList<
    IProduct,
    HttpError,
    ISearch
  >({
    onSearch: (values) => {
      return [
        {
          field: "name",
          operator: "contains",
          value: values.name,
        },
        {
          field: "description",
          operator: "contains",
          value: values.description,
        },
      ];
    },
  });

  return (
    <div>
      <Form {...searchFormProps} layout="inline">
        <Form.Item name="name">
          <Input placeholder="Search by name" />
        </Form.Item>
        <Form.Item name="description">
          <Input placeholder="Search by description" />
        </Form.Item>
        <Button type="primary" onClick={searchFormProps.form?.submit}>
          Search
        </Button>
      </Form>
      <List {...listProps} renderItem={renderItem} />
    </div>
  );
};

const renderItem = (item: IProduct) => {
  const { id, name, description, price } = item;

  return (
    <List.Item actions={[<Text key={id}>{price}</Text>]}>
      <List.Item.Meta title={name} description={description} />
    </List.Item>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "products",
      list: ProductList,
    },
  ],
});

render(<RefineAntdDemo />);
```

================
File: ui-integrations/ant-design/hooks/use-simple-list/_sorting-live-preview.md
================
```tsx live url=http://localhost:3000/products previewHeight=420px
setInitialRoutes(["/products"]);

// visible-block-start
import { useSimpleList } from "@refinedev/antd";
import { Typography, List } from "antd";

const { Text } = Typography;

interface IProduct {
  id: number;
  name: string;
  description: string;
  price: string;
}

const ProductList: React.FC = () => {
  const { listProps } = useSimpleList<IProduct>({
    // highlight-start
    sorters: {
      initial: [
        {
          field: "name",
          order: "desc",
        },
      ],
    },
    // highlight-end
  });

  return <List {...listProps} renderItem={renderItem} />;
};

const renderItem = (item: IProduct) => {
  const { id, name, description, price } = item;

  return (
    <List.Item actions={[<Text key={id}>{price}</Text>]}>
      <List.Item.Meta title={name} description={description} />
    </List.Item>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "products",
      list: ProductList,
    },
  ],
});

render(<RefineAntdDemo />);
```

================
File: ui-integrations/ant-design/hooks/use-simple-list/index.md
================
---
title: useSimpleList
source: https://github.com/refinedev/refine/blob/main/packages/antd/src/hooks/list/useSimpleList/useSimpleList.ts
---

import BasicUsageLivePreview from "./\_basic-usage-live-preview.md";
import SortingLivePreview from "./\_sorting-live-preview.md";
import FilteringLivePreview from "./\_filtering-live-preview.md";
import SearchLivePreview from "./\_search-live-preview.md";

By using `useSimpleList`, you can get properties that are compatible with the Ant Design's [`<List>`](https://ant.design/components/list/) component. All features such as sorting, filtering, and pagination come out of the box. `useSimpleList` uses [`useTable`](/docs/data/hooks/use-table) under the hood for the fetch.

For all the other features, you can refer to the Ant Design's [`<List>`](https://ant.design/components/list/) documentation.

## Usage

In the following example, we will show how to use `useSimpleList` to list the products.

It returns `listProps` which is compatible with the Ant Design's `<List>` component. By default, it reads the [`resource`](#resource) from the current URL.

<BasicUsageLivePreview />

## Pagination

This feature comes out of the box with the `listProps.pagination`. It generates the pagination links for the `<List>` component instead of react state and overrides `<List>`'s `pagination.itemRender` value.

It also syncs the pagination state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

If you want to make a change in the pagination of the `<List>`. You should pass the pagination object of the `listProps` to the pagination property of the `<List>` as below. You can override the values of the pagination object as your need.

```tsx
// ...
const { listProps } = useSimpleList<IProduct>();

// ...

return (
  <AntdList
    {...listProps}
    renderItem={renderItem}
    // highlight-start
    pagination={{
      ...listProps.pagination,
      position: "top",
      size: "small",
    }}
    // highlight-end
  />
);
```

:::simple Implementation Tips

By default, pagination happens on the server side. If you want to do pagination handling on the client side, you can pass the pagination.mode property and set it to "client". You can also disable the pagination by setting it to "off".

:::

## Sorting

The `useSimpleList` hook supports the sorting feature. You can pass the `sorters` property to the hook to set the initial and permanent sorting state.

It also syncs the sorting state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

<SortingLivePreview />

## Filtering

The `useSimpleList` hook supports the filtering feature. You can pass the `filters` property to the hook to set the initial and permanent filtering state and you change the filtering state by using the `setFilter` function.

It also syncs the filtering state with the URL if you enable the [`syncWithLocation`](#syncWithLocation).

<FilteringLivePreview />

## Search

We can use the [`onSearch`](#onsearch) property and the [`searchFormProps`](#searchformprops) return value to make a custom filter form. `onSearch` is a function that is called when the form is submitted. `searchFormProps` is a property that is passed to the [`<Form>`](https://ant.design/components/form) component.

<SearchLivePreview />

## Realtime Updates

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

When the `useSimpleList` hook is mounted, it will call the `subscribe` method from the `liveProvider` with some parameters such as `channel`, `resource` etc. It is useful when you want to subscribe to live updates.

## Properties

### resource

The `useSimpleList` passes the `resource` to the `dataProvider` as a param. This parameter is usually used as an API endpoint path. It all depends on how to handle the resources in your `dataProvider`.

Refer to the [`creating a data provider`](/docs/data/data-provider#creating-a-data-provider) documentation for an example of how resources are handled.

The `resource` value is inferred from the current route where the component or the hook is used. It can be overridden by passing the `resource` prop.

The use case for overriding the `resource` prop:

- We can list a `category` from the `<ProductList>` page.

```tsx
import React from "react";
import { HttpError } from "@refinedev/core";
import { useSimpleList } from "@refinedev/antd";

interface IProduct {
  id: number;
  name: string;
  description: string;
  price: string;
}

interface ICategory {
  id: number;
  name: string;
}

export const ProductList: React.FC = () => {
  const { query: productsQuery } = useSimpleList<IProduct, HttpError>();

  const { query: categoriesQuery } = useSimpleList<ICategory, HttpError>({
    resource: "categories",
  });

  return <div>{/* ... */}</div>;
};
```

Also, you can give a URL path to the `resource` prop.

```tsx
useSimpleList({
  resource: "categories/subcategory", // <BASE_URL_FROM_DATA_PROVIDER>/categories/subcategory
});
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### pagination.current

Sets the initial value of the page index. It is `1` by default.

```tsx
useSimpleList({
  pagination: {
    current: 2,
  },
});
```

### pagination.pageSize

Sets the initial value of the page size. It is `10` by default.

```tsx
useSimpleList({
  pagination: {
    pageSize: 20,
  },
});
```

### pagination.mode

It can be `"off"`, `"server"` or `"client"`. It is `"server"` by default.

- **"off":** Pagination is disabled. All records will be fetched.
- **"client":** Pagination is done on the client side. All records will be fetched and then the records will be paginated on the client side.
- **"server":**: Pagination is done on the server side. Records will be fetched by using the `current` and `pageSize` values.

```tsx
useSimpleList({
  pagination: {
    mode: "client",
  },
});
```

### sorters.initial

Sets the initial value of the sorter. The `initial` is not permanent. It will be cleared when the user changes the sorter. If you want to set a permanent value, use the `sorters.permanent` prop.

> For more information, refer to the [`CrudSorting` interface documentation &#8594](/docs/core/interface-references#crudsorting)

```tsx
useSimpleList({
  sorters: {
    initial: [
      {
        field: "name",
        order: "asc",
      },
    ],
  },
});
```

### sorters.permanent

Sets the permanent value of the sorter. The `permanent` is permanent and unchangeable. It will not be cleared when the user changes the sorter. If you want to set a temporary value, use the `sorters.initial` prop.

> For more information, refer to the [`CrudSorting` interface documentation &#8594](/docs/core/interface-references#crudsorting)

```tsx
useSimpleList({
  sorters: {
    permanent: [
      {
        field: "name",
        order: "asc",
      },
    ],
  },
});
```

### filters.initial

Sets the initial value of the filter. The `initial` is not permanent. It will be cleared when the user changes the filter. If you want to set a permanent value, use the `filters.permanent` prop.

> For more information, refer to the [`CrudFilters` &#8594](/docs/core/interface-references#crudfilters)

```tsx
useSimpleList({
  filters: {
    initial: [
      {
        field: "name",
        operator: "contains",
        value: "Foo",
      },
    ],
  },
});
```

### filters.permanent

Sets the permanent value of the filter. The `permanent` is permanent and unchangeable. It will not be cleared when the user changes the filter. If you want to set a temporary value, use the `filters.initial` prop.

> For more information, refer to the [`CrudFilters` &#8594](/docs/core/interface-references#crudfilters)

```tsx
useSimpleList({
  filters: {
    permanent: [
      {
        field: "name",
        operator: "contains",
        value: "Foo",
      },
    ],
  },
});
```

### filters.defaultBehavior

The filtering behavior can be set to either `"merge"` or `"replace"`. It is `merge` by default.

- When the filter behavior is set to `"merge"`, it will merge the new filter with the existing filters. This means that if the new filter has the same column as an existing filter, the new filter will replace the existing filter for that column. If the new filter has a different column than the existing filters, it will be added to the existing filters.

- When the filter behavior is set to `"replace"`, it will replace all existing filters with the new filter. This means that any existing filters will be removed and only the new filter will be applied to the table.

You can also override the default value by using the second parameter of the [`setFilters`](#setfilters) function.

```tsx
useSimpleList({
  filters: {
    defaultBehavior: "replace",
  },
});
```

### syncWithLocation <GlobalConfigBadge id="core/refine-component/#syncwithlocation" />

When you use the syncWithLocation feature, the `useSimpleList`'s state (e.g. sort order, filters, pagination) is automatically encoded in the query parameters of the URL, and when the URL changes, the `useSimpleList` state is automatically updated to match. This makes it easy to share list states across different routes or pages and allows users to bookmark or share links to specific table views. `syncWithLocation` is set to `false` by default.

```tsx
useSimpleList({
  syncWithLocation: true,
});
```

### queryOptions

`useSimpleList` uses the [`useTable`](/docs/data/hooks/use-table) hook to fetch data. You can pass the [`queryOptions`](https://tanstack.com/query/v4/docs/react/reference/useQuery) to it like this:

```tsx
useSimpleList({
  queryOptions: {
    retry: 3,
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

> For more information, refer to the [`meta` section of the General Concepts documentation for more information &#8594](/docs/guides-concepts/general-concepts/#meta-concept)

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useSimpleList({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  getList: async ({
    resource,
    pagination,
    sorters,
    filters,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;

    //...
    //...

    // highlight-next-line
    const { data, headers } = await httpClient.get(`${url}`, { headers });

    return {
      data,
    };
  },
  //...
};
```

### dataProviderName

If there is more than one `dataProvider`, you can specify which one to use by passing the `dataProviderName` prop. This is useful when you have a different data provider for different resources.

```tsx
useSimpleList({
  dataProviderName: "second-data-provider",
});
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useSimpleList` can call the `open` function from `NotificationProvider` to show a success notification. With this prop, you can customize the success notification.

```tsx
useSimpleList({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useSimpleList` will call the `open` function from `NotificationProvider` to show an error notification. With this prop, you can customize the error notification.

```tsx
useSimpleList({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Determines whether to update data automatically (`"auto"`) or not (`"manual"`) if a related live event is received. It can be used to update and show data in Realtime throughout your app.

> For more information, refer to the [Live / Realtime documentation &#8594](/docs/realtime/live-provider#livemode)

```tsx
useSimpleList({
  liveMode: "auto",
});
```

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

The callback function is executed when new events from a subscription have arrived.

```tsx
useSimpleList({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### onSearch

When [`searchFormProps.onFinish`](#searchformprops) is called, the `onSearch` function is called with the values of the form. The `onSearch` function should return [`CrudFilters | Promise<CrudFilters>`][crudfilters]. When the `onSearch` function is called, the current page will be set to 1.

`onSearch` is useful when you want to filter the data with multiple fields by using the `<Form>` component.

```tsx
// ...

const { searchFormProps, listProps } = useSimpleList({
  onSearch: (values) => {
    return [
      {
        field: "name",
        operator: "contains",
        value: values.name,
      },
      {
        field: "description",
        operator: "contains",
        value: values.description,
      },
    ];
  },
});

// ...

return (
  <div>
    <Form {...searchFormProps} layout="inline">
      <Form.Item name="name">
        <Input placeholder="Search by name" />
      </Form.Item>
      <Form.Item name="description">
        <Input placeholder="Search by description" />
      </Form.Item>
      <Button type="primary" onClick={searchFormProps.form?.submit}>
        Search
      </Button>
    </Form>
    <AntdList {...listProps} renderItem={renderItem} />
  </div>
);
```

### ~~initialCurrent~~ <PropTag deprecated />

Use `pagination.current` instead.

### ~~initialPageSize~~ <PropTag deprecated />

Use `pagination.pageSize` instead.

### ~~hasPagination~~ <PropTag deprecated />

Use `pagination.mode` instead.

### ~~initialSorter~~ <PropTag deprecated />

Use `sorters.initial` instead.

### ~~permanentSorter~~ <PropTag deprecated />

Use `sorters.permanent` instead.

### ~~initialFilter~~ <PropTag deprecated />

Use `filters.initial` instead.

### ~~permanentFilter~~ <PropTag deprecated />

Use `filters.permanent` instead.

### ~~defaultSetFilterBehavior~~ <PropTag deprecated />

Use `filters.defaultBehavior` instead.

### overtimeOptions

If you want the loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful if you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds while `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useSimpleList({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

## Return Values

### query

`query` is the returned values from [`useList`](/docs/data/hooks/use-list) hook.

### searchFormProps

`searchFormProps` returns the [`<Form>`](https://ant.design/components/form/) instance of Ant Design. When `searchFormProps.onFinish` is called, it will trigger [`onSearch`](#onsearch) function.
You can also use `searchFormProps.form.submit` to submit the form manually.

It's useful when you want to create a filter form for your `<List>`.

```tsx
// ...

const { searchFormProps, listProps } = useSimpleList({
  onSearch: (values) => {
    return [
      {
        field: "name",
        operator: "contains",
        value: values.name,
      },
      {
        field: "description",
        operator: "contains",
        value: values.description,
      },
    ];
  },
});

// ...

return (
  <div>
    <Form {...searchFormProps} layout="inline">
      <Form.Item name="name">
        <Input placeholder="Search by name" />
      </Form.Item>
      <Form.Item name="description">
        <Input placeholder="Search by description" />
      </Form.Item>
      <Button type="primary" onClick={searchFormProps.form?.submit}>
        Search
      </Button>
    </Form>
    <AntdList {...listProps} renderItem={renderItem} />
  </div>
);
```

### listProps

`listProps` is an object that contains compatible props for Ant Design [`<List>`][antd list] component.

#### dataSource

`dataSource` contains the data to be displayed in the list. Values are fetched with the [`useList`](/docs/data/hooks/use-list) hook.

#### loading

`loading` indicates whether the data is being fetched or not.

#### pagination

`pagination` returns the pagination configuration values(pageSize, current, position, etc.).

### sorters

`sorters` is the current [sorters state][crudsorting].

### setSorters

`setSorters` is a function to set the current[sorters state][crudsorting].

```tsx
 (sorters: CrudSorting) => void;
```

### filters

`filters` is the current [filters state][crudfilters].

### setFilters

```tsx
((filters: CrudFilters, behavior?: SetFilterBehavior) => void) & ((setter: (prevFilters: CrudFilters) => CrudFilters) => void)
```

`setFilters` is a function to set the current [filters state][crudfilters].

### current

`current` is the current page index state. If pagination is disabled, it will be `undefined`.

### setCurrent

```tsx
React.Dispatch<React.SetStateAction<number>> | undefined;
```

`setCurrent` is a function to set the current page index state. If pagination is disabled, it will be `undefined`.

### pageSize

`pageSize` is the current page size state. If pagination is disabled, it will be `undefined`.

### setPageSize

```tsx
React.Dispatch<React.SetStateAction<number>> | undefined;
```

`setPageSize` is a function to set the current page size state. If pagination is disabled, it will be `undefined`.

### pageCount

`pageCount` is the total page count state. If pagination is disabled, it will be `undefined`.

### createLinkForSyncWithLocation

```tsx
(params: SyncWithLocationParams) => string;
```

`createLinkForSyncWithLocation` is a function that creates accessible links for `syncWithLocation`. It takes an [SyncWithLocationParams][syncwithlocationparams] as parameters.

### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useSimpleList();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

### ~~sorter~~ <PropTag deprecated />

Use `sorters` instead.

### ~~setSorter~~ <PropTag deprecated />

Use `setSorters` instead.

### ~~queryResult~~ <PropTag deprecated />

Use [`query`](#query) instead.

## API

### Properties

<PropsTable module="@refinedev/antd/useSimpleList"/>

### Type Parameters

| Property         | Description                                                                                                                                                         | Type                       | Default                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData     | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError           | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TSearchVariables | Antd form values                                                                                                                                                    | `{}`                       | `{}`                       |
| TData            | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Property        | Description                                                                           | Type                                                                                                                                                    |
| --------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| query           | Result of the query of a record                                                       | [`QueryObserverResult<{ data: TData }>`][usequery]                                                                                                      |
| searchFormProps | Ant design Form props                                                                 | [`Form`][form]                                                                                                                                          |
| listProps       | Ant design List props                                                                 | [`List`][list]                                                                                                                                          |
| totalPage       | Total page count (returns `undefined` if pagination is disabled)                      | `number` \| `undefined`                                                                                                                                 |
| current         | Current page index state (returns `undefined` if pagination is disabled)              | `number` \| `undefined`                                                                                                                                 |
| setCurrent      | A function that changes the current (returns `undefined` if pagination is disabled)   | `React.Dispatch<React.SetStateAction<number>>` \| `undefined`                                                                                           |
| pageSize        | Current pageSize state (returns `undefined` if pagination is disabled)                | `number` \| `undefined`                                                                                                                                 |
| setPageSize     | A function that changes the pageSize. (returns `undefined` if pagination is disabled) | `React.Dispatch<React.SetStateAction<number>>` \| `undefined`                                                                                           |
| sorters         | Current sorting state                                                                 | [`CrudSorting`][crudsorting]                                                                                                                            |
| setSorters      | A function that accepts a new sorters state.                                          | `(sorters: CrudSorting) => void`                                                                                                                        |
| ~~sorter~~      | Current sorting state                                                                 | [`CrudSorting`][crudsorting]                                                                                                                            |
| ~~setSorter~~   | A function that accepts a new sorters state.                                          | `(sorters: CrudSorting) => void`                                                                                                                        |
| filters         | Current filters state                                                                 | [`CrudFilters`][crudfilters]                                                                                                                            |
| setFilters      | A function that accepts a new filter state                                            | - `(filters: CrudFilters, behavior?: "merge" \| "replace" = "merge") => void` <br/> - `(setter: (previousFilters: CrudFilters) => CrudFilters) => void` |
| overtime        | Overtime loading props                                                                | `{ elapsedTime?: number }`                                                                                                                              |

[crudfilters]: /docs/core/interface-references#crudfilters
[crudsorting]: /docs/core/interface-references#crudsorting
[form]: https://ant.design/components/form/#API
[list]: https://ant.design/components/list/#API
[usequery]: https://react-query.tanstack.com/reference/useQuery
[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[Refine swl]: /docs/core/refine-component#syncwithlocation

================
File: ui-integrations/ant-design/hooks/use-steps-form/index.md
================
---
title: useStepsForm
---

```tsx live shared
import { useMany } from "@refinedev/core";

import {
  Create as AntdCreate,
  Edit as AntdEdit,
  EditButton,
  List,
  SaveButton as AntdSaveButton,
  TextField,
  useSelect as useSelectAntd,
  useStepsForm as useStepsFormAntd,
  useTable,
} from "@refinedev/antd";
import {
  Button as AntdButton,
  Form as AntdForm,
  Input as AntdInput,
  Select as AntdSelect,
  Space,
  Steps as AntdSteps,
  Table,
} from "antd";

const PostList = () => {
  const { tableProps } = useTable<IPost>();

  const categoryIds =
    tableProps?.dataSource?.map((item) => item.category.id) ?? [];
  const { data, isLoading } = useMany({
    resource: "categories",
    ids: categoryIds,
    queryOptions: {
      enabled: categoryIds.length > 0,
    },
  });

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column
          dataIndex={["category", "id"]}
          title="Category"
          render={(value) => {
            if (isLoading) {
              return <TextField value="Loading..." />;
            }

            return (
              <TextField
                value={data?.data.find((item) => item.id === value)?.title}
              />
            );
          }}
        />
        <Table.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record) => (
            <Space>
              <EditButton hideText size="small" recordItemId={record.id} />
            </Space>
          )}
        />
      </Table>
    </List>
  );
};

const PostEdit = () => {
  const { current, gotoStep, stepsProps, formProps, saveButtonProps } =
    useStepsFormAntd();

  const { selectProps: categorySelectProps } = useSelectAntd({
    resource: "categories",
  });

  const formList = [
    <>
      <AntdForm.Item
        label="Title"
        name="title"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <AntdInput />
      </AntdForm.Item>
      <AntdForm.Item
        label="Category"
        name={["category", "id"]}
        rules={[
          {
            required: true,
          },
        ]}
      >
        <AntdSelect {...categorySelectProps} />
      </AntdForm.Item>
      <AntdForm.Item
        label="Status"
        name="status"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <AntdSelect
          options={[
            {
              label: "Published",
              value: "published",
            },
            {
              label: "Draft",
              value: "draft",
            },
            {
              label: "Rejected",
              value: "rejected",
            },
          ]}
        />
      </AntdForm.Item>
    </>,
    <>
      <AntdForm.Item
        label="Content"
        name="content"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <AntdInput.TextArea />
      </AntdForm.Item>
    </>,
  ];

  return (
    <AntdEdit
      footerButtons={
        <>
          {current > 0 && (
            <AntdButton
              onClick={() => {
                gotoStep(current - 1);
              }}
            >
              Previous
            </AntdButton>
          )}
          {current < formList.length - 1 && (
            <AntdButton
              onClick={() => {
                gotoStep(current + 1);
              }}
            >
              Next
            </AntdButton>
          )}
          {current === formList.length - 1 && (
            <AntdSaveButton {...saveButtonProps} />
          )}
        </>
      }
    >
      <AntdSteps {...stepsProps}>
        <AntdSteps.Step title="About Post" />
        <AntdSteps.Step title="Content" />
      </AntdSteps>

      <AntdForm {...formProps} layout="vertical" style={{ marginTop: 30 }}>
        {formList[current]}
      </AntdForm>
    </AntdEdit>
  );
};

const PostCreate = () => {
  const { current, gotoStep, stepsProps, formProps, saveButtonProps } =
    useStepsFormAntd();

  const { selectProps: categorySelectProps } = useSelectAntd({
    resource: "categories",
  });

  const formList = [
    <>
      <AntdForm.Item
        label="Title"
        name="title"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <AntdInput />
      </AntdForm.Item>
      <AntdForm.Item
        label="Category"
        name={["category", "id"]}
        rules={[
          {
            required: true,
          },
        ]}
      >
        <AntdSelect {...categorySelectProps} />
      </AntdForm.Item>
      <AntdForm.Item
        label="Status"
        name="status"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <AntdSelect
          options={[
            {
              label: "Published",
              value: "published",
            },
            {
              label: "Draft",
              value: "draft",
            },
            {
              label: "Rejected",
              value: "rejected",
            },
          ]}
        />
      </AntdForm.Item>
    </>,
    <>
      <AntdForm.Item
        label="Content"
        name="content"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <AntdInput.TextArea />
      </AntdForm.Item>
    </>,
  ];

  return (
    <AntdCreate
      footerButtons={
        <>
          {current > 0 && (
            <AntdButton
              onClick={() => {
                gotoStep(current - 1);
              }}
            >
              Previous
            </AntdButton>
          )}
          {current < formList.length - 1 && (
            <AntdButton
              onClick={() => {
                gotoStep(current + 1);
              }}
            >
              Next
            </AntdButton>
          )}
          {current === formList.length - 1 && (
            <AntdSaveButton {...saveButtonProps} />
          )}
        </>
      }
    >
      <AntdSteps {...stepsProps}>
        <AntdSteps.Step title="About Post" />
        <AntdSteps.Step title="Content" />
      </AntdSteps>

      <AntdForm {...formProps} layout="vertical" style={{ marginTop: 30 }}>
        {formList[current]}
      </AntdForm>
    </AntdCreate>
  );
};
```

The `useStepsForm` hook allows you to split your form under an Ant Design based [Steps](https://ant.design/components/steps/) component and provides you with a few useful functionalities that will help you manage your form.

The `useStepsForm` hook is extended from [`useForm`][antd-use-form] under the hood. This means that you can use all the functionalities of [`useForm`][antd-use-form] in your `useStepsForm`.

## Usage

We will show two examples, one for creating a post and one for editing it. Let's see how `useStepsForm` is used in both.

<Tabs
defaultValue="create"
values={[
{label: 'create', value: 'create'},
{label: 'edit', value: 'edit'},
]}>

<TabItem value="create">

Here is the final result of the form: We will explain the code in following sections.

```tsx live url=http://localhost:3000/posts/create previewHeight=420px hideCode
setInitialRoutes(["/posts/create"]);

// visible-block-start
import { HttpError } from "@refinedev/core";
import React from "react";

import { Create, SaveButton, useSelect, useStepsForm } from "@refinedev/antd";
import { Button, Form, Input, Select, Steps } from "antd";

const { Step } = Steps;

const PostCreatePage: React.FC = () => {
  const { current, gotoStep, stepsProps, formProps, saveButtonProps } =
    useStepsForm<IPost, HttpError, IPost>();

  const { selectProps: categorySelectProps } = useSelect<ICategory, HttpError>({
    resource: "categories",
  });

  const formList = [
    <>
      <Form.Item
        label="Title"
        name="title"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Category"
        name={["category", "id"]}
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Select {...categorySelectProps} />
      </Form.Item>
      <Form.Item
        label="Status"
        name="status"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Select
          options={[
            {
              label: "Published",
              value: "published",
            },
            {
              label: "Draft",
              value: "draft",
            },
            {
              label: "Rejected",
              value: "rejected",
            },
          ]}
        />
      </Form.Item>
    </>,
    <>
      <Form.Item
        label="Content"
        name="content"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Input.TextArea />
      </Form.Item>
    </>,
  ];

  return (
    <Create
      footerButtons={
        <>
          {current > 0 && (
            <Button
              onClick={() => {
                gotoStep(current - 1);
              }}
            >
              Previous
            </Button>
          )}
          {current < formList.length - 1 && (
            <Button
              onClick={() => {
                gotoStep(current + 1);
              }}
            >
              Next
            </Button>
          )}
          {current === formList.length - 1 && (
            <SaveButton {...saveButtonProps} />
          )}
        </>
      }
    >
      <Steps {...stepsProps}>
        <Step title="About Post" />
        <Step title="Content" />
      </Steps>

      <Form {...formProps} layout="vertical" style={{ marginTop: 30 }}>
        {formList[current]}
      </Form>
    </Create>
  );
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreatePage,
      edit: PostEdit,
    },
  ],
});

render(<RefineAntdDemo />);
```

</TabItem>

<TabItem value="edit">

Here is the final result of the form: We will explain the code in following sections.

```tsx live url=http://localhost:3000/posts/edit/123 previewHeight=420px hideCode
setInitialRoutes(["/posts/edit/123"]);

// visible-block-start
import { HttpError } from "@refinedev/core";
import React from "react";

import { Edit, SaveButton, useSelect, useStepsForm } from "@refinedev/antd";
import { Button, Form, Input, Select, Steps } from "antd";

const { Step } = Steps;

const PostEditPage: React.FC = () => {
  const { current, gotoStep, stepsProps, formProps, saveButtonProps, query } =
    useStepsForm<IPost, HttpError, IPost>();

  const postData = query?.data?.data;
  const { selectProps: categorySelectProps } = useSelect<ICategory, HttpError>({
    resource: "categories",
    defaultValue: postData?.category.id,
  });

  const formList = [
    <>
      <Form.Item
        label="Title"
        name="title"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Category"
        name={["category", "id"]}
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Select {...categorySelectProps} />
      </Form.Item>
      <Form.Item
        label="Status"
        name="status"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Select
          options={[
            {
              label: "Published",
              value: "published",
            },
            {
              label: "Draft",
              value: "draft",
            },
            {
              label: "Rejected",
              value: "rejected",
            },
          ]}
        />
      </Form.Item>
    </>,
    <>
      <Form.Item
        label="Content"
        name="content"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Input.TextArea />
      </Form.Item>
    </>,
  ];

  return (
    <Edit
      footerButtons={
        <>
          {current > 0 && (
            <Button
              onClick={() => {
                gotoStep(current - 1);
              }}
            >
              Previous
            </Button>
          )}
          {current < formList.length - 1 && (
            <Button
              onClick={() => {
                gotoStep(current + 1);
              }}
            >
              Next
            </Button>
          )}
          {current === formList.length - 1 && (
            <SaveButton {...saveButtonProps} />
          )}
        </>
      }
    >
      <Steps {...stepsProps}>
        <Step title="About Post" />
        <Step title="Content" />
      </Steps>
      <Form {...formProps} layout="vertical" style={{ marginTop: 30 }}>
        {formList[current]}
      </Form>
    </Edit>
  );
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
      create: PostCreate,
      edit: PostEditPage,
    },
  ],
});

render(<RefineAntdDemo />);
```

</TabItem>

</Tabs>

For the sake of simplicity, in this example we're going to build a Post `"create"` form that consists of only a `title` and a relational `category` field.

To split your form items under a `<Steps>` component, first import and use `useStepsForm` hook in your page:

```tsx title="pages/posts/create.tsx"
import { useStepsForm } from "@refinedev/antd";
import { HttpError } from "@refinedev/core";
import React from "react";

export const PostCreate: React.FC = () => {
  const { current, gotoStep, stepsProps, formProps, saveButtonProps, query } =
    useStepsForm<IPost, HttpError, IPost>();

  return null;
};

interface ICategory {
  id: number;
}

interface IPost {
  id: number;
  title: string;
  status: "published" | "draft" | "rejected";
  category: {
    id: ICategory["id"];
  };
}
```

`useStepsForm` is a generic over the type form data to help you type check your code.

This hook returns a set of useful values to render steps form. Given `current` value, you should have a way to render your form items conditionally with this index value. You can use an array to achieve this.

Here, each item of `formList` corresponds to one step in form:

```tsx title="pages/posts/create.tsx"
import { useSelect, useStepsForm } from "@refinedev/antd";
import { HttpError } from "@refinedev/core";
import { Form, Input, Select } from "antd";
import React from "react";

export const PostCreate: React.FC = () => {
  const { current, gotoStep, stepsProps, formProps, saveButtonProps } =
    useStepsForm<IPost, HttpError, IPost>();

  const { selectProps: categorySelectProps } = useSelect<ICategory, HttpError>({
    resource: "categories",
  });

  // highlight-start
  const formList = [
    <>
      <Form.Item
        label="Title"
        name="title"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Input />
      </Form.Item>
    </>,
    <>
      <Form.Item
        label="Category"
        name={["category", "id"]}
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Select {...categorySelectProps} />
      </Form.Item>
    </>,
  ];
  // highlight-end

  return null;
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}
```

:::simple Relational Data

Since `category` is a relational data, we use `useSelect` to fetch its data.

Refer to [`useSelect` documentation for detailed usage. &#8594](/docs/ui-integrations/ant-design/hooks/use-select)

:::

<br />

You should use `stepsProps` on `<Steps>` component, `formProps` on the `<Form>` component. And as the last step, you should render the `<Steps>` component besides the form like this:

```tsx title="pages/posts/create.tsx"
import { Create, useSelect, useStepsForm } from "@refinedev/antd";
import { HttpError } from "@refinedev/core";
import {
  Form,
  Input,
  Select,
  // highlight-next-line
  Steps,
} from "antd";
import React from "react";

export const PostCreate: React.FC = () => {
  const { current, gotoStep, stepsProps, formProps, saveButtonProps, query } =
    useStepsForm<IPost, HttpError, IPost>();

  const { selectProps: categorySelectProps } = useSelect<ICategory, HttpError>({
    resource: "categories",
  });

  const formList = [
    <>
      <Form.Item
        label="Title"
        name="title"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Input />
      </Form.Item>
    </>,
    <>
      <Form.Item
        label="Category"
        name={["category", "id"]}
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Select {...categorySelectProps} />
      </Form.Item>
    </>,
  ];

  return (
    <Create saveButtonProps={saveButtonProps}>
      // highlight-start
      <Steps {...stepsProps}>
        <Step title="About Post" />
        <Step title="Content" />
      </Steps>
      <Form {...formProps} layout="vertical">
        {formList[current]}
      </Form>
      // highlight-end
    </Create>
  );
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}
```

:::simple Implementation Tips

Make sure to add as much `<Steps.Step>` components as the number of steps in the `formList` array.

:::

<br />

To help users navigate between steps in the form, you can use the action buttons. Your navigation buttons should use the `gotoStep` function that was previously returned from the `useStepsForm` hook.

```tsx title="pages/posts/create.tsx"
import {
  Create,
  // highlight-next-line
  SaveButton,
  useSelect,
  useStepsForm,
} from "@refinedev/antd";
import { HttpError } from "@refinedev/core";
import { Button, Form, Input, Select, Steps } from "antd";
import React from "react";

export const PostCreate: React.FC = () => {
  const {
    current,
    gotoStep,
    stepsProps,
    formProps,
    saveButtonProps,
    query,
    submit,
  } = useStepsForm<IPost, HttpError, IPost>();

  const { selectProps: categorySelectProps } = useSelect<ICategory, HttpError>({
    resource: "categories",
  });

  const formList = [
    <>
      <Form.Item
        label="Title"
        name="title"
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Input />
      </Form.Item>
    </>,
    <>
      <Form.Item
        label="Category"
        name={["category", "id"]}
        rules={[
          {
            required: true,
          },
        ]}
      >
        <Select {...categorySelectProps} />
      </Form.Item>
    </>,
  ];

  return (
    <Create
      // highlight-start
      footerButtons={
        <>
          {current > 0 && (
            <Button
              onClick={() => {
                gotoStep(current - 1);
              }}
            >
              Previous
            </Button>
          )}
          {current < formList.length - 1 && (
            <Button
              onClick={() => {
                gotoStep(current + 1);
              }}
            >
              Next
            </Button>
          )}
          {current === formList.length - 1 && (
            <SaveButton
              {...saveButtonProps}
              style={{ marginRight: 10 }}
              onClick={() => submit()}
            />
          )}
        </>
      }
      // highlight-end
    >
      <Steps {...stepsProps}>
        <Step title="About Post" />
        <Step title="Content" />
      </Steps>
      <Form {...formProps} layout="vertical">
        {formList[current]}
      </Form>
    </Create>
  );
};

interface ICategory {
  id: number;
  title: string;
}

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  category: { id: number };
}
```

<br/>

## Properties

All of the [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form) props are also available in `useStepsForm`. You can find descriptions on [`useForm` documentation](/docs/ui-integrations/ant-design/hooks/use-form#properties).

### defaultCurrent

`defaultCurrent` sets the default starting step number. Counting starts from `0`.

```tsx
const stepsForm = useStepsForm({
  defaultCurrent: 2,
});
```

### total

`total` is the maximum number of steps. `<Steps>` cannot go beyond this number.

```tsx
const stepsForm = useStepsForm({
  total: 3,
});
```

### isBackValidate

When `isBackValidate` is `true`, it validates a form fields when the user navigates to a previous step. It is `false` by default.

```tsx
const stepsForm = useStepsForm({
  isBackValidate: true,
});
```

<br/>

### overtimeOptions

If you want loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.
`interval` is the time interval in milliseconds. `onInterval` is the function that will be called on each interval.

Return the `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useStepsForm({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### autoSave

If you want to save the form automatically after some delay when user edits the form, you can pass true to `autoSave.enabled` prop.

By default the `autoSave` feature does not invalidate queries. However, you can use the `invalidateOnUnmount` prop to invalidate queries upon unmount.

It also supports `onMutationSuccess` and `onMutationError` callback functions. You can use `isAutoSave` parameter to determine whether the mutation is triggered by `autoSave` or not.

`autoSave` feature operates exclusively in `edit` mode. Users can take advantage of this feature while editing data, as changes are automatically saved in editing mode. However, when creating new data, manual saving is still required.

`onMutationSuccess` and `onMutationError` callbacks will be called after the mutation is successful or failed.

#### enabled

To enable the `autoSave` feature, set the `enabled` parameter to `true`. By default, it is `false`.

```tsx
useStepsForm({
  autoSave: {
    enabled: true,
  },
});
```

#### debounce

Set the debounce time for the `autoSave` prop. By default, it is `1000` milliseconds.

```tsx
useStepsForm({
  autoSave: {
    enabled: true,
    // highlight-next-line
    debounce: 2000,
  },
});
```

#### onFinish

If you want to modify the data before sending it to the server, you can use `onFinish` callback function.

```tsx
useStepsForm({
  autoSave: {
    enabled: true,
    // highlight-start
    onFinish: (values) => {
      return {
        foo: "bar",
        ...values,
      };
    },
    // highlight-end
  },
});
```

#### invalidateOnUnmount

This prop is useful when you want to invalidate the `list`, `many` and `detail` queries from the current resource when the hook is unmounted. By default, it invalidates the `list`, `many` and `detail` queries associated with the current resource. Also, You can use the `invalidates` prop to select which queries to invalidate. By default, it is `false`.

```tsx
useStepsForm({
  autoSave: {
    enabled: true,
    // highlight-next-line
    invalidateOnUnmount: true,
  },
});
```

### defaultFormValues

Default values for the form. Use this to pre-populate the form with data that needs to be displayed.

```tsx
useForm({
  defaultFormValues: {
    title: "Hello World",
  },
});
```

Also, it can be provided as an async function to fetch the default values. The loading state can be tracked using the [`defaultFormValuesLoading`](#defaultformvaluesloading) state returned from the hook.

> 🚨 When `action` is "edit" or "clone" a race condition with `async defaultFormValues` may occur. In this case, the form values will be the result of the last completed operation.

```tsx
const { defaultFormValuesLoading } = useForm({
  defaultFormValues: async () => {
    const response = await fetch("https://my-api.com/posts/1");
    const data = await response.json();
    return data;
  },
});
```

## Return Values

All [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form) return values also available in `useStepsForm`. You can find descriptions on [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form#return-values) docs.

### stepsProps

`stepsProps` is the props needed by the `<Steps>` component.

#### current

`current` is the current step, counting from `0`.

#### onChange

Callback function that is triggered when the current step of the form changes. The function takes in one argument, `currentStep`, which is a number representing the index of the current step.

### current

The Current step, counting from `0`.

### gotoStep

`gotoStep` is a function that allows you to programmatically change the current step of a form.
It takes in one argument, step, which is a number representing the index of the step you want to navigate to.

### submit

`submit` is a function that can submit the form. It's useful when you want to submit the form manually.

### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useStepsForm();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

### autoSaveProps

If `autoSave` is enabled, this hook returns `autoSaveProps` object with `data`, `error`, and `status` properties from mutation.

### defaultFormValuesLoading

If [`defaultFormValues`](#defaultformvalues) is an async function, `defaultFormValuesLoading` will be `true` until the function is resolved.

## FAQ

### How can I change the form data before submitting it to the API?

Here is an example where we modify the form data before submit:

We need to send the values we received from the user in two separate inputs, `name` and `surname`, to the API as `fullName`. We can do this by overriding the `submit` function.

```tsx title="pages/user/create.tsx"
import { useStepsForm } from "@refinedev/antd";
// ...
const { current, gotoStep, stepsProps, formProps, saveButtonProps, onFinish } =
  useStepsForm<IPost>({
    submit: (values) => {
      // highlight-start
      const data = {
        fullName: `${formValues.name} ${formValues.surname}`,
        age: formValues.age,
        city: formValues.city,
      };
      onFinish(data as any);
      // highlight-end
    },
  });
// ...
```

<br/>

## API Reference

### Properties

<PropsTable module="@refinedev/antd/useStepsForm"/>

### Type Parameters

| Property       | Description                                                                                                                                                         | Type                       | Default                    |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData   | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError         | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TVariables     | Values for params.                                                                                                                                                  | `{}`                       |                            |
| TData          | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |
| TResponse      | Result data returned by the mutation function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TData` will be used as the default value.        | [`BaseRecord`][baserecord] | `TData`                    |
| TResponseError | Custom error object that extends [`HttpError`][httperror]. If not specified, the value of `TError` will be used as the default value.                               | [`HttpError`][httperror]   | `TError`                   |

### Return Values

| Key                      | Description                                                  | Type                                                                                                                                    |
| ------------------------ | ------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------- |
| stepsProps               | Ant Design steps props                                       | [`StepsProps`](https://ant.design/components/steps/#API)                                                                                |
| current                  | Current step, counting from 0.                               | `number`                                                                                                                                |
| gotoStep                 | Go to the target step                                        | `(step: number) => void`                                                                                                                |
| formProps                | Ant Design form props                                        | [`FormProps`](/docs/ui-integrations/ant-design/hooks/use-form#formprops)                                                                |
| form                     | Ant Design form instance                                     | [`FormInstance<TVariables>`](https://ant.design/components/form/#FormInstance)                                                          |
| submit                   | Submit method, the parameter is the value of the form fields | `() => void`                                                                                                                            |
| overtime                 | Overtime loading props                                       | `{ elapsedTime?: number }`                                                                                                              |
| autoSaveProps            | Auto save props                                              | `{ data: UpdateResponse<TData>` \| `undefined, error: HttpError` \| `null, status: "loading"` \| `"error"` \| `"idle"` \| `"success" }` |
| defaultFormValuesLoading | DefaultFormValues loading status of form                     | `boolean`                                                                                                                               |

## Example

<CodeSandboxExample path="form-antd-use-steps-form" />

[baserecord]: /docs/core/interface-references#baserecord
[httperror]: /docs/core/interface-references#httperror
[antd-use-form]: /docs/ui-integrations/ant-design/hooks/use-form

================
File: ui-integrations/ant-design/hooks/use-table/_partial-use-table-basic-usage-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import { HttpError } from "@refinedev/core";

import { List, TagField, useTable } from "@refinedev/antd";
import { Table } from "antd";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
}

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost, HttpError>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column dataIndex="content" title="Content" />
        <Table.Column
          dataIndex="status"
          title="Status"
          render={(value: string) => <TagField value={value} />}
        />
      </Table>
    </List>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineAntdDemo />);
```

================
File: ui-integrations/ant-design/hooks/use-table/_partial-use-table-filtering-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import { HttpError } from "@refinedev/core";

import {
  List,
  TagField,
  useTable,
  // highlight-start
  FilterDropdown,
  // highlight-end
} from "@refinedev/antd";
import {
  Table,
  // highlight-start
  Radio,
  // highlight-end
} from "antd";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
}

const PostList: React.FC = () => {
  const { tableProps } = useTable<IPost, HttpError>();

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column dataIndex="content" title="Content" />
        <Table.Column
          dataIndex="status"
          title="Status"
          render={(value: string) => <TagField value={value} />}
          // highlight-start
          filterDropdown={(props) => (
            <FilterDropdown {...props}>
              <Radio.Group>
                <Radio value="published">Published</Radio>
                <Radio value="draft">Draft</Radio>
                <Radio value="rejected">Rejected</Radio>
              </Radio.Group>
            </FilterDropdown>
          )}
          // highlight-end
        />
      </Table>
    </List>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineAntdDemo />);
```

================
File: ui-integrations/ant-design/hooks/use-table/_partial-use-table-relational-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import { HttpError, useMany, getDefaultFilter } from "@refinedev/core";

import {
  List,
  TagField,
  useTable,
  // highlight-start
  useSelect,
  FilterDropdown,
  // highlight-end
} from "@refinedev/antd";
import {
  Table,
  // highlight-next-line
  Select,
} from "antd";

// highlight-start
interface ICategory {
  id: number;
  title: string;
}
// highlight-end

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
  // highlight-start
  category: {
    id: number;
  };
  // highlight-end
}

const PostList: React.FC = () => {
  const { tableProps, filters } = useTable<IPost, HttpError>();

  // highlight-start
  // Creates the array of ids. This will filter and fetch the category data for the relevant posts.
  const categoryIds =
    tableProps.dataSource?.map((p) => p.category.id.toString()) || [];
  // Fetches the category of each post. It uses the useMany hook to fetch the category data from the API.
  const { data, isFetching } = useMany<ICategory>({
    resource: "categories",
    ids: categoryIds,
    queryOptions: {
      // Set to true only if the posts array is not empty.
      enabled: categoryIds.length > 0,
    },
  });
  // highlight-end

  // highlight-start
  // Creates the props by needed the select component for filtering the posts by category.
  const { selectProps } = useSelect<ICategory>({
    resource: "categories",
    optionLabel: "title",
    optionValue: "id",
    defaultValue: getDefaultFilter("category.id", filters, "in"),
  });
  // highlight-end

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column dataIndex="content" title="Content" />
        {/* highlight-start */}
        <Table.Column
          dataIndex={["category", "id"]}
          title="Category"
          render={(value) => {
            if (isFetching) return "loading...";
            // Gets the title of the category from the data object, which is the result of the useMany hook.
            return data?.data.find((p) => p.id === value)?.title;
          }}
          filterDropdown={(props: FilterDropdownProps) => (
            <FilterDropdown
              {...props}
              mapValue={(selectedKeys) =>
                selectedKeys.map((i) => parseInt(i.toString()))
              }
            >
              <Select
                style={{ minWidth: 200 }}
                mode="multiple"
                {...selectProps}
              />
            </FilterDropdown>
          )}
        />
        {/* highlight-end */}
        <Table.Column
          dataIndex="status"
          title="Status"
          render={(value: string) => <TagField value={value} />}
        />
      </Table>
    </List>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineAntdDemo />);
```

================
File: ui-integrations/ant-design/hooks/use-table/_partial-use-table-search-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import { HttpError } from "@refinedev/core";

import {
  List,
  TagField,
  useTable,
  // highlight-start
  SaveButton,
  // highlight-end
} from "@refinedev/antd";
import {
  Table,
  // highlight-start
  Form,
  Input,
  // highlight-end
} from "antd";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
}

interface ISearch {
  title: string;
}

const PostList: React.FC = () => {
  const { tableProps, searchFormProps } = useTable<IPost, HttpError, ISearch>({
    // highlight-start
    onSearch: (values) => {
      return [
        {
          field: "title",
          operator: "contains",
          value: values.title,
        },
      ];
    },
    // highlight-end
  });

  return (
    <List>
      {/* highlight-start */}
      <Form {...searchFormProps} layout="inline">
        <Form.Item name="title">
          <Input placeholder="Search by title" />
        </Form.Item>
        <SaveButton onClick={searchFormProps.form?.submit} />
      </Form>
      {/* highlight-end */}
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column dataIndex="title" title="Title" />
        <Table.Column dataIndex="content" title="Content" />
        <Table.Column
          dataIndex="status"
          title="Status"
          render={(value: string) => <TagField value={value} />}
        />
      </Table>
    </List>
  );
};

// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineAntdDemo />);
```

================
File: ui-integrations/ant-design/hooks/use-table/_partial-use-table-sorter-live-preview.md
================
```css live shared
body {
  padding: 4px;
  background: white;
}
```

```tsx live url=http://localhost:3000/posts previewHeight=420px
setInitialRoutes(["/posts"]);

// visible-block-start
import { HttpError } from "@refinedev/core";

import {
  List,
  TagField,
  useTable,
  // highlight-next-line
  getDefaultSortOrder,
} from "@refinedev/antd";
import { Table } from "antd";

interface IPost {
  id: number;
  title: string;
  content: string;
  status: "published" | "draft" | "rejected";
}

const PostList: React.FC = () => {
  // highlight-start
  const { tableProps, sorter } = useTable<IPost>({
    sorters: {
      initial: [
        {
          field: "id",
          order: "desc",
        },
      ],
    },
  });
  // highlight-end

  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column
          dataIndex="id"
          title="ID"
          // highlight-start
          sorter={{ multiple: 2 }}
          defaultSortOrder={getDefaultSortOrder("id", sorter)}
          // highlight-end
        />
        <Table.Column
          dataIndex="title"
          title="Title"
          // highlight-start
          sorter={{ multiple: 1 }}
          defaultSortOrder={getDefaultSortOrder("title", sorter)}
          // highlight-end
        />
        <Table.Column dataIndex="content" title="Content" />
        <Table.Column
          dataIndex="status"
          title="Status"
          render={(value: string) => <TagField value={value} />}
        />
      </Table>
    </List>
  );
};
// visible-block-end

setRefineProps({
  resources: [
    {
      name: "posts",
      list: PostList,
    },
  ],
});

render(<RefineAntdDemo />);
```

================
File: ui-integrations/ant-design/hooks/use-table/index.md
================
---
title: useTable
source: packages/antd/src/hooks/table/useTable
---

import BasicUsageLivePreview from "./\_partial-use-table-basic-usage-live-preview.md";
import SorterLivePreview from "./\_partial-use-table-sorter-live-preview.md";
import FilteringPreview from "./\_partial-use-table-filtering-live-preview.md";
import SearchPreview from "./\_partial-use-table-search-live-preview.md";
import RelationalLivePreview from "./\_partial-use-table-relational-live-preview.md";
import PropResource from "@site/src/partials/prop-resource";

By using `useTable`, you can get properties that are compatible with Ant Design [`<Table>`][table] component. All features such as sorting, filtering, and pagination come out of the box. Under the hood it uses [`useList`](/docs/data/hooks/use-list) for the fetch.

For all the other features, you can refer to the Ant Design [`<Table>`][table] documentation.

`useTable` hook is extended from [`useTable`][use-table-core] hook from the [`@refinedev/core`](https://github.com/refinedev/refine/tree/main/packages/core) package. This means that you can use all the features of [`useTable`][use-table-core] hook.

## usage

In basic usage, `useTable` returns the data as it comes from the endpoint. By default, it reads [`resource`](#resource) from the URL.

<BasicUsageLivePreview />

## Pagination

This feature comes out of the box with the `tableProps.pagination`. It generates the pagination links for the `<Table>` component instead of react state and overrides `<Table>`'s `pagination.itemRender` value.

It also syncs the pagination state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

If you want to make a change in the pagination of the `<Table>`. You should pass the pagination object of the `tableProps` to the pagination property of the `<Table>` as below. You can override the values of the pagination object depending on your needs.

```tsx
const { tableProps } = useTable<IPost>();

<Table
  {...tableProps}
  rowKey="id"
  // highlight-start
  pagination={{
    ...tableProps.pagination,
    position: ["bottomCenter"],
    size: "small",
  }}
  // highlight-end
>
  // ---
</Table>;
```

:::simple Implementation Tips

By default, pagination happens on the server side. If you want to do pagination handling on the client side, you can pass the pagination.mode property and set it to "client". Also, you can disable the pagination by setting the "off".

:::

## Sorting

If we want to give a column the sorting property, the corresponding [`<Table.Column>`][table-column] component must be given the [sorter](https://ant.design/components/table/#components-table-demo-head) property.

It also syncs the sorting state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

<SorterLivePreview/>

During the sorting process, the `key` property of your `<Column />` component is used as the property name in the API request. If your Column component does not have a `key` value, the `dataIndex` property is used.
It can be used when your DataIndex and your sorting key are different.

When using multiple sorting, `multiple` value is required for `sorter` property. Which specifies the priority of the column in sorting.

## Filtering

We can use the `filterDropdown` property from [`<Table.Column>`][table-column] to make filtering based on the column values. In order to do this, we need to put the filtering form inside the [`<FilterDropdown>`][filter-dropdown] component and pass the properties coming to the function to these component's properties.

It also syncs the filtering state with the URL if you enable the [`syncWithLocation`](#syncwithlocation).

<FilteringPreview />

## Initial Filter and Sorter

If you're using the `initial`, don't forget to add `getDefaultSortOrder` or `defaultFilteredValue` to your `<Table.Column>` component. Otherwise, hook states may not sync with the table.

```tsx
// ---
const { tableProps, sorters, filters } = useTable({
    sorters: {
        initial: [
            {
                field: "title",
                order: "asc",
            },
        ],
    }
    filters: {
        initial: [
            {
                field: "status",
                operator: "eq",
                value: "published",
            },
        ],
    },
});

// ---
<Table.Column
    dataIndex="title"
    title="Title"
    // highlight-next-line
     defaultSortOrder={getDefaultSortOrder("title", sorters)}
/>
<Table.Column
    dataIndex="status"
    title="Status"
    render={(value) => <TagField value={value} />}
    // highlight-next-line
    defaultFilteredValue={getDefaultFilter("status", filters)}
    filterDropdown={(props) => (
        <FilterDropdown {...props}>
            <Radio.Group>
                <Radio value="published">Published</Radio>
                <Radio value="draft">Draft</Radio>
                <Radio value="rejected">Rejected</Radio>
            </Radio.Group>
        </FilterDropdown>
    )}
/>
// ---
```

:::simple Finding the filter value

Refine provides the [`getDefaultFilter`](https://github.com/refinedev/refine/blob/716656d9ad3deb169c32685cdebbfd46bac44beb/packages/core/src/definitions/table/index.ts#L166) function, You can use this function to find the filter value for the specific field.

```tsx
import { getDefaultFilter } from "@refinedev/core";
import { useTable } from "@refinedev/antd";

const MyComponent = () => {
  const { filters } = useTable({
    filters: {
      initial: [
        {
          field: "name",
          operator: "contains",
          value: "John Doe",
        },
      ],
    },
  });

  const nameFilterValue = getDefaultFilter("name", filters, "contains");
  console.log(nameFilterValue); // "John Doe"

  return {
    /** ... */
  };
};
```

:::

## Search

We can use the [`onSearch`](#onsearch) and [`searchFormProps`](#searchformprops) properties to make custom filter form. `onSearch` is a function that is called when the form is submitted. `searchFormProps` is a property that is passed to the [`<Form>`](https://ant.design/components/form) component.

<SearchPreview/>

## Realtime Updates

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

When the `useTable` hook is mounted, it will call the `subscribe` method from the `liveProvider` with some parameters such as `channel`, `resource` etc. It is useful when you want to subscribe to live updates.

> For more information, refer to the [`liveProvider` documentation &#8594](/docs/realtime/live-provider)

## Properties

### resource

<PropResource
hook={{
    name:"useList",
    URL:"/docs/data/hooks/use-list"
}}
method={{
    name:"getList",
    URL:"/docs/data/data-provider/#getlist"
}}
hasDefault={false}
/>

By default, it uses the inferred `resource` from the route.

```tsx
useTable({
  resource: "categories",
});
```

If you have multiple resources with the same name, you can pass the `identifier` instead of the `name` of the resource. It will only be used as the main matching key for the resource, data provider methods will still work with the `name` of the resource defined in the `<Refine/>` component.

> For more information, refer to the [`identifier` section of the `<Refine/>` component documentation &#8594](/docs/core/refine-component#identifier)

### onSearch

When [`searchFormProps.onFinish`](#searchformprops) is called, the `onSearch` function is called with the values of the form. The `onSearch` function should return [`CrudFilters | Promise<CrudFilters>`][crudfilters].
Also, `onSearch` will set the current page to 1.

It's useful when you want to filter the data with any query.

```tsx
const { searchFormProps, tableProps } = useTable({
  onSearch: (values) => {
    return [
      {
        field: "title",
        operator: "contains",
        value: values.title,
      },
    ];
  },
});

// --
<List>
  <Form {...searchFormProps}>
    <Space>
      <Form.Item name="title">
        <Input placeholder="Search by title" />
      </Form.Item>
      <SaveButton onClick={searchFormProps.form?.submit} />
    </Space>
  </Form>
  <Table {...tableProps} rowKey="id">
    <Table.Column title="Title" dataIndex="title" />
  </Table>
</List>;
// ---
```

### dataProviderName

If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use. It is useful when you want to use a different `dataProvider` for a specific resource.

```tsx
useTable({
  dataProviderName: "second-data-provider",
});
```

### pagination.current

Sets the initial value of the page index. It is set to `1` by default.

```tsx
useTable({
  pagination: {
    current: 2,
  },
});
```

### pagination.pageSize

Sets the initial value of the page size. It is set to `10` by default.

```tsx
useTable({
  pagination: {
    pageSize: 20,
  },
});
```

### pagination.mode

It can be `"off"`, `"server"` or `"client"`. It is set to `"server"` by default.

- **"off":** Pagination is disabled. All records will be fetched.
- **"client":** Pagination is done on the client side. All records will be fetched and then the records will be paginated on the client side.
- **"server":**: Pagination is done on the server side. Records will be fetched by using the `current` and `pageSize` values.

```tsx
useTable({
  pagination: {
    mode: "client",
  },
});
```

### sorters.initial

Sets the initial value of the sorter. The `initial` is not permanent. It will be cleared when the user changes the sorter. If you want to set a permanent value, use the `sorters.permanent` prop.

> For more information, refer to the [`CrudSorting` interface documentation &#8594](/docs/core/interface-references#crudsorting)

```tsx
useTable({
  sorters: {
    initial: [
      {
        field: "name",
        order: "asc",
      },
    ],
  },
});
```

### sorters.permanent

Sets the permanent value of the sorter. The `permanent` is permanent and unchangeable. It will not be cleared when the user changes the sorter. If you want to set a temporary value, use the `sorters.initial` prop.

> For more information, refer to the [`CrudSorting` interface documentation &#8594](/docs/core/interface-references#crudsorting)

```tsx
useTable({
  sorters: {
    permanent: [
      {
        field: "name",
        order: "asc",
      },
    ],
  },
});
```

### sorters.mode

It can be `"off"`, or `"server"`. It is `"server"` by default.

- **"off":** `sorters` are not sent to the server. You can use the `sorters` value to sort the records on the client side.
- **"server":**: Sorting is done on the server side. Records will be fetched by using the `sorters` value.

```tsx
useTable({
  sorters: {
    mode: "server",
  },
});
```

### filters.initial

Sets the initial value of the filter. The `initial` is not permanent. It will be cleared when the user changes the filter. If you want to set a permanent value, use the `filters.permanent` prop.

> For more information, refer to the [`CrudFilters` interface documentation &#8594](/docs/core/interface-references#crudfilters)

```tsx
useTable({
  filters: {
    initial: [
      {
        field: "name",
        operator: "contains",
        value: "Foo",
      },
    ],
  },
});
```

### filters.permanent

Sets the permanent value of the filter. The `permanent` is permanent and unchangeable. It will not be cleared when the user changes the filter. If you want to set a temporary value, use the `filters.initial` prop.

> For more information, refer to the [`CrudFilters` interface documentation &#8594](/docs/core/interface-references#crudfilters)

```tsx
useTable({
  filters: {
    permanent: [
      {
        field: "name",
        operator: "contains",
        value: "Foo",
      },
    ],
  },
});
```

### filters.defaultBehavior

The filtering behavior can be set to either `"merge"` or `"replace"`. By default, it is set to `"merge"`.

- When the filter behavior is set to `"merge"`, it will merge the new filter with the existing filters. This means that if the new filter has the same column as an existing filter, the new filter will replace the existing filter for that column. If the new filter has a different column than the existing filters, it will be added to the existing filters.

- When the filter behavior is set to `"replace"`, it will replace all existing filters with the new filter. This means that any existing filters will be removed and only the new filter will be applied to the table.

You can also override the default value by using the second parameter of the [`setFilters`](#setfilters) function.

```tsx
useTable({
  filters: {
    defaultBehavior: "replace",
  },
});
```

### filters.mode

It can be `"off"` or `"server"`. It is `"server"` by default.

- **"off":** `filters` are not sent to the server. You can use the `filters` value to filter the records on the client side.
- **"server":**: Filters are done on the server side. Records will be fetched by using the `filters` value.

```tsx
useTable({
  filters: {
    mode: "off",
  },
});
```

### syncWithLocation <GlobalConfigBadge id="core/refine-component/#syncwithlocation" />

When you use the `syncWithLocation` feature, the `useTable`'s state (e.g. sort order, filters, pagination) is automatically encoded in the query parameters of the URL, and when the URL changes, the `useTable` state is automatically updated to match. This makes it easy to share table state across different routes or pages, and to allow users to bookmark or share links to specific table views. It is set to `false` by default.

```tsx
useTable({
  syncWithLocation: true,
});
```

### queryOptions

`useTable` uses the [`useList`](/docs/data/hooks/use-list) hook to fetch data. You can pass the [`queryOptions`](https://tanstack.com/query/v4/docs/react/reference/useQuery) to it like this:

```tsx
useTable({
  queryOptions: {
    retry: 3,
  },
});
```

### meta

`meta` is a special property that can be used to pass additional information to data provider methods for the following purposes:

- Customizing the data provider methods for specific use cases.
- Generating GraphQL queries using plain JavaScript Objects (JSON).

> For more information, refer to the [`meta` section of the General Concepts documentation &#8594](/docs/guides-concepts/general-concepts/#meta-concept)

In the following example, we pass the `headers` property in the `meta` object to the `create` method. With similar logic, you can pass any properties to specifically handle the data provider methods.

```tsx
useTable({
  // highlight-start
  meta: {
    headers: { "x-meta-data": "true" },
  },
  // highlight-end
});

const myDataProvider = {
  //...
  getList: async ({
    resource,
    pagination,
    sorters,
    filters,
    // highlight-next-line
    meta,
  }) => {
    // highlight-next-line
    const headers = meta?.headers ?? {};
    const url = `${apiUrl}/${resource}`;

    //...
    //...

    // highlight-next-line
    const { data, headers } = await httpClient.get(`${url}`, { headers });

    return {
      data,
    };
  },
  //...
};
```

### successNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data is fetched successfully, `useTable` can call `open` function from [`NotificationProvider`][notification-provider] to show a success notification. With this prop, you can customize the success notification.

```tsx
useTable({
  successNotification: (data, values, resource) => {
    return {
      message: `${data.title} Successfully fetched.`,
      description: "Success with no errors",
      type: "success",
    };
  },
});
```

### errorNotification

> [`NotificationProvider`](/docs/notification/notification-provider) is required for this prop to work.

After data fetching is failed, `useTable` will call `open` function from [`NotificationProvider`][notification-provider] to show an error notification. With this prop, you can customize the error notification.

```tsx
useTable({
  errorNotification: (data, values, resource) => {
    return {
      message: `Something went wrong when getting ${data.id}`,
      description: "Error",
      type: "error",
    };
  },
});
```

### liveMode

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

`liveMode` determines whether to update data automatically ("auto") or not ("manual") if a related live event is received. It can be used to update and show data in Realtime throughout your app.

> For more information, refer to the [Live / Realtime documentation &#8594](/docs/realtime/live-provider#livemode)

```tsx
useTable({
  liveMode: "auto",
});
```

### onLiveEvent

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

The callback function is executed when new events from a subscription have arrived.

```tsx
useTable({
  onLiveEvent: (event) => {
    console.log(event);
  },
});
```

### liveParams

> [`LiveProvider`](/docs/realtime/live-provider) is required for this prop to work.

Params to pass to liveProvider's [subscribe](/docs/realtime/live-provider#subscribe) method.

### overtimeOptions

If you want the loading overtime for the request, you can pass the `overtimeOptions` prop to the this hook. It is useful when you want to show a loading indicator when the request takes too long.

`interval` is the time interval in milliseconds while `onInterval` is the function that will be called on each interval.

Return `overtime` object from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useTable({
  //...
  overtimeOptions: {
    interval: 1000,
    onInterval(elapsedInterval) {
      console.log(elapsedInterval);
    },
  },
});

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...

// You can use it like this:
{
  elapsedTime >= 4000 && <div>this takes a bit longer than expected</div>;
}
```

### ~~initialCurrent~~ <PropTag deprecated />

Use `pagination.current` instead.

### ~~initialPageSize~~ <PropTag deprecated />

Use `pagination.pageSize` instead.

### ~~hasPagination~~ <PropTag deprecated />

Use `pagination.mode` instead.

### ~~initialSorter~~ <PropTag deprecated />

Use `sorters.initial` instead.

### ~~permanentSorter~~ <PropTag deprecated />

Use `sorters.permanent` instead.

### ~~initialFilter~~ <PropTag deprecated />

Use `filters.initial` instead.

### ~~permanentFilter~~ <PropTag deprecated />

Use `filters.permanent` instead.

### ~~defaultSetFilterBehavior~~ <PropTag deprecated />

Use `filters.defaultBehavior` instead.

## Return Values

### tableProps

`tableProps` are the props needed by the [`<Table>`][table] component.

#### onChange

The `onChange` callback function is executed when a user interacts(filter, sort, etc.) with the table.

:::caution

`useTable` handles sorting, filtering, and pagination with this function. If you override this function, you need to handle these operations manually.

:::

```tsx
const { tableProps } = useTable()

<Table {...tableProps} onChange={tableProps.onChange} rowKey="id">
    <Table.Column title="Title" dataIndex="title" />
</Table>
```

#### dataSource

`dataSource` contains the data to be displayed in the table. Values fetched with [`useList`](/docs/data/hooks/use-list) hook.

#### loading

`loading` indicates whether the data is being fetched.

#### pagination

`pagination` returns the pagination configuration values(pageSize, current, position, etc.).

#### scroll

`scroll` is for making the table scrollable or not. It is set to `{ x: true }` by default.

### searchFormProps

`searchFormProps` returns [`<Form>`](https://ant.design/components/form/) instance of Ant Design. When `searchFormProps.onFinish` is called, it will trigger [`onSearch`](#onsearch) function.
You can also use `searchFormProps.form.submit` to submit the form manually.

It's useful when you want to create a filter form for your `<Table>`.

```tsx
import { HttpError } from "@refinedev/core";
import { List, useTable, SaveButton } from "@refinedev/antd";
import { Table, Form, Input } from "antd";

interface IPost {
  id: number;
  title: string;
}

interface ISearch {
  title: string;
}

const PostList: React.FC = () => {
  const { searchFormProps, tableProps } = useTable<IPost, HttpError, ISearch>({
    onSearch: (values) => {
      return [
        {
          field: "title",
          operator: "contains",
          value: values.title,
        },
      ];
    },
  });

  return (
    <List>
      <Form {...searchFormProps} layout="inline">
        <Form.Item name="title">
          <Input placeholder="Search by title" />
        </Form.Item>
        {/* highlight-next-line */}
        <SaveButton onClick={searchFormProps.form?.submit} />
      </Form>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="ID" />
        <Table.Column title="Title" dataIndex="title" />
      </Table>
    </List>
  );
};
```

### tableQuery

`tableQuery` are the returned values from [`useList`](/docs/data/hooks/use-list) hook.

### sorters

`sorters` is the current [sorters state][crudsorting].

### setSorters

`setSorters` is a function to set current [sorters state][crudsorting].

```tsx
 (sorters: CrudSorting) => void;
```

### filters

`filters` is the current [filters state][crudfilters].

### setFilters

```tsx
((filters: CrudFilters, behavior?: SetFilterBehavior) => void) & ((setter: (prevFilters: CrudFilters) => CrudFilters) => void)
```

`setFilters` is a function to set current [filters state][crudfilters].

### current

`current` is the current page index state. If pagination is disabled, it will be `undefined`.

### setCurrent

```tsx
React.Dispatch<React.SetStateAction<number>> | undefined;
```

`setCurrent` is a function to set the current page index state. If pagination is disabled, it will be `undefined`.

### pageSize

`pageSize` is the current page size state. If pagination is disabled, it will be `undefined`.

### setPageSize

```tsx
React.Dispatch<React.SetStateAction<number>> | undefined;
```

`setPageSize` is a function to set the current page size state. If pagination is disabled, it will be `undefined`.

### pageCount

`pageCount` is the total page count state. If pagination is disabled, it will be `undefined`.

### createLinkForSyncWithLocation

```tsx
(params: SyncWithLocationParams) => string;
```

`createLinkForSyncWithLocation` is a function creates accessible links for `syncWithLocation`. It takes an [SyncWithLocationParams][syncwithlocationparams] as parameters.

### overtime

`overtime` object is returned from this hook. `elapsedTime` is the elapsed time in milliseconds. It becomes `undefined` when the request is completed.

```tsx
const { overtime } = useTable();

console.log(overtime.elapsedTime); // undefined, 1000, 2000, 3000 4000, ...
```

### ~~sorter~~ <PropTag deprecated />

Use `sorters` instead.

### ~~setSorter~~ <PropTag deprecated />

Use `setSorters` instead.

### ~~tableQueryResult~~ <PropTag deprecated />

Use [`tableQuery`](#tablequery) instead.

## FAQ

### How can I handle relational data?

You can use the [`useMany`](/docs/data/hooks/use-many) hook to fetch relational data and filter `<Table>` by categories with the help of [`useSelect`](/docs/ui-integrations/ant-design/hooks/use-select/)

<RelationalLivePreview/>

### How can I handle client side filtering?

You can set the [`filters.mode: "off"`](#filtersmode) in order to disable server-side filtering. `useTable` is fully compatible with [`Ant Design <Table> component's`](https://ant.design/components/table#components-table-demo-head) filtering feature.

```tsx
import { useTable } from "@refinedev/antd";
import { Table } from "antd";

const ListPage = () => {
  const { tableProps } = useTable({
    filters: {
      mode: "off",
    },
  });

  return (
    <Table {...tableProps} rowKey="id">
      {/* ... */}
      <Table.Column
        dataIndex="status"
        title="Status"
        filters={[
          {
            text: "Published",
            value: "published",
          },
          {
            text: "Draft",
            value: "draft",
          },
          {
            text: "Rejected",
            value: "rejected",
          },
        ]}
        onFilter={(value, record) => record.status === value}
      />
    </Table>
  );
};
```

### How can I handle client side sorting?

You can set the [`sorters.mode: "off"`](#sortersmode) in order to disable server-side sorting. `useTable` is fully compatible with [`Ant Design <Table> component's`](https://ant.design/components/table#components-table-demo-head) sorting feature.

```tsx
import { useTable } from "@refinedev/antd";
import { Table } from "antd";

const ListPage = () => {
  const { tableProps } = useTable({
    sorters: {
      mode: "off",
    },
  });

  return (
    <Table {...tableProps} rowKey="id">
      <Table.Column dataIndex="id" title="ID" sorter={(a, b) => a.id - b.id} />
      {/* ... */}
    </Table>
  );
};
```

## API

### Properties

<PropsTable module="@refinedev/antd/useTable"/>

### Type Parameters

| Property         | Description                                                                                                                                                         | Type                       | Default                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- |
| TQueryFnData     | Result data returned by the query function. Extends [`BaseRecord`][baserecord]                                                                                      | [`BaseRecord`][baserecord] | [`BaseRecord`][baserecord] |
| TError           | Custom error object that extends [`HttpError`][httperror]                                                                                                           | [`HttpError`][httperror]   | [`HttpError`][httperror]   |
| TSearchVariables | Values for search params                                                                                                                                            |                            | `{}`                       |
| TData            | Result data returned by the `select` function. Extends [`BaseRecord`][baserecord]. If not specified, the value of `TQueryFnData` will be used as the default value. | [`BaseRecord`][baserecord] | `TQueryFnData`             |

### Return values

| Property        | Description                                                                           | Type                                                                                                                                              |
| --------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| searchFormProps | Ant Design [`<Form>`][form] props                                                     | [`FormProps<TSearchVariables>`][form]                                                                                                             |
| tableProps      | Ant Design [`<Table>`][table] props                                                   | [`TableProps<TData>`][table]                                                                                                                      |
| tableQuery      | Result of the `react-query`'s `useQuery`                                              | [` QueryObserverResult<{`` data: TData[];`` total: number; },`` TError> `][usequery]                                                              |
| totalPage       | Total page count (returns `undefined` if pagination is disabled)                      | `number` \| `undefined`                                                                                                                           |
| current         | Current page index state (returns `undefined` if pagination is disabled)              | `number` \| `undefined`                                                                                                                           |
| setCurrent      | A function that changes the current (returns `undefined` if pagination is disabled)   | `React.Dispatch<React.SetStateAction<number>>` \| `undefined`                                                                                     |
| pageSize        | Current pageSize state (returns `undefined` if pagination is disabled)                | `number` \| `undefined`                                                                                                                           |
| setPageSize     | A function that changes the pageSize. (returns `undefined` if pagination is disabled) | `React.Dispatch<React.SetStateAction<number>>` \| `undefined`                                                                                     |
| sorters         | Current sorting state                                                                 | [`CrudSorting`][crudsorting]                                                                                                                      |
| setSorters      | A function that accepts a new sorters state.                                          | `(sorters: CrudSorting) => void`                                                                                                                  |
| ~~sorter~~      | Current sorting state                                                                 | [`CrudSorting`][crudsorting]                                                                                                                      |
| ~~setSorter~~   | A function that accepts a new sorters state.                                          | `(sorters: CrudSorting) => void`                                                                                                                  |
| filters         | Current filters state                                                                 | [`CrudFilters`][crudfilters]                                                                                                                      |
| setFilters      | A function that accepts a new filter state                                            | - `(filters: CrudFilters, behavior?: "merge" \| "replace" = "merge") => void` - `(setter: (previousFilters: CrudFilters) => CrudFilters) => void` |
| overtime        | Overtime loading props                                                                | `{ elapsedTime?: number }`                                                                                                                        |

<br />

## Example

<CodeSandboxExample path="table-antd-use-table" />

[use-table-core]: /docs/data/hooks/use-table
[table]: https://ant.design/components/table/#API
[table-column]: https://ant.design/components/table#column
[form]: https://ant.design/components/form/#API
[usequery]: https://react-query.tanstack.com/reference/useQuery
[baserecord]: /docs/core/interface-references#baserecord
[crudsorting]: /docs/core/interface-references#crudsorting
[crudfilters]: /docs/core/interface-references#crudfilters
[httperror]: /docs/core/interface-references#httperror
[table search]: /advanced-tutorials/search/table-search.md
[Refine swl]: /docs/core/refine-component#syncwithlocation
[filter-dropdown]: /docs/ui-integrations/ant-design/components/filter-dropdown
[syncwithlocationparams]: /docs/core/interface-references#syncwithlocationparams
[notification-provider]: /docs/notification/notification-provider

================
File: ui-integrations/ant-design/introduction/index.md
================
---
title: Introduction
---

Refine provides an integration package for [Ant Design](https://ant.design/) framework. This package provides a set of ready to use components and hooks that connects Refine with Ant Design components. While Refine's integration offers a set of components and hooks, it is not a replacement for the Ant Design package, you will be able to use all the features of Ant Design in the same way you would use it in a regular React application. Refine's integration only provides components and hooks for an easier usage of Ant Design components in combination with Refine's features and functionalities.

import Example from "./previews/example.tsx";

<Example />

## Installation

Installing the package is as simple as just by running the following command without any additional configuration:

<InstallPackagesCommand args="@refinedev/antd antd"/>

## Usage

We'll wrap our app with the [`<ConfigProvider />`](https://ant.design/components/config-provider) to make sure we have the theme available for our app, then we'll use the layout components to wrap them around our routes. Check out the examples below to see how to use Refine's Ant Design integration.

<Tabs wrapContent={false}>
<TabItem value="react-router-dom" label="React Router">

import UsageReactRouterDom from "./previews/usage-react-router-dom.tsx";

<UsageReactRouterDom />

</TabItem>
<TabItem value="next-js" label="Next.js">

import UsageNextJs from "./previews/usage-next-js.tsx";

<UsageNextJs />

</TabItem>
<TabItem value="remix" label="Remix">

import UsageRemix from "./previews/usage-remix.tsx";

<UsageRemix />

</TabItem>
</Tabs>

## Tables

Refine provides a seamless integration with the [`<Table />`](https://ant.design/components/table) component of Ant Design from pagination to sorting and filtering via the [`useTable`](/docs/ui-integrations/ant-design/hooks/use-table) hook exported from the `@refinedev/antd` package. This hook is an extension of the `@refinedev/core`'s [`useTable`](/docs/data/hooks/use-table) and provides a set of additional features and transformations to make it work with Ant Design's `<Table />` component without any additional configuration.

```tsx title="pages/products/list.tsx"
import { useTable } from "@refinedev/antd";
import { Table } from "antd";

export const ProductList = () => {
  // highlight-next-line
  const { tableProps } = useTable<IProduct>();
  // `tableProps` contains the necessary props to be passed
  // to the `<Table />` component of Ant Design
  // by transforming the values to fit the Ant Design's API.

  return (
    // highlight-next-line
    <Table {...tableProps} rowKey="id">
      <Table.Column dataIndex="id" title="ID" />
      <Table.Column dataIndex="name" title="Name" />
      <Table.Column dataIndex="price" title="Price" />
    </Table>
  );
};

interface IProduct {
  id: string;
  name: string;
  price: number;
  description: string;
}
```

`@refinedev/antd` package also provides a [`<FilterDropdown />`](/docs/ui-integrations/ant-design/components/filter-dropdown) component to be used in the filter popover of the `<Table />` component. This component makes it easy to apply filters from the Ant Design UI without any additional configuration.

## Forms

Refine provides a seamless integration with the [`<Form />`](https://ant.design/components/form) component of Ant Design from validation to submission via the [`useForm`](/docs/ui-integrations/ant-design/hooks/use-form) hook exported from the `@refinedev/antd` package. This hook is an extension of the `@refinedev/core`'s [`useForm`](/docs/data/hooks/use-form/) and provides a set of additional features and transformations to make it work with Ant Design's `<Form />` component.

```tsx title="pages/products/create.tsx"
import { useForm, SaveButton } from "@refinedev/antd";
import { Form, Input, InputNumber } from "antd";

export const ProductCreate = () => {
    // highlight-next-line
    const { formProps, saveButtonProps } = useForm<IProduct>();
    // `formProps` contains the necessary props to be passed
    // to the `<Form />` component of Ant Design
    // by transforming the values to fit the Ant Design's API.

    return (
        <Form {...formProps} layout="vertical">
            <Form.Item
                label="Name"
                name="name"
                rules={[{ required: true }]}
            >
                <Input />
            </Form.Item>
            <Form.Item
                label="Price"
                name="price"
                rules={[{ required: true }]}
            >
                <InputNumber />
            </Form.Item>
            <Form.Item
                label="Description"
                name="description"
                rules={[{ required: true }]}
            >
                <Input.TextArea rows={4} />
            </Form.Item>
            <SaveButton {...saveButtonProps}>
        </Form>
    )
}

interface IProduct {
  id: string;
  name: string;
  price: number;
  description: string;
}
```

`@refinedev/antd` also offers hooks to implement different types of forms such as [`useDrawerForm`](/docs/ui-integrations/ant-design/hooks/use-drawer-form), [`useModalForm`](/docs/ui-integrations/ant-design/hooks/use-modal-form) and [`useStepsForm`](/docs/ui-integrations/ant-design/hooks/use-steps-form) hooks. Additionally [`useSelect`](/docs/ui-integrations/ant-design/hooks/use-select), [`useCheckboxGroup`](/docs/ui-integrations/ant-design/hooks/use-checkbox-group) and [`useRadioGroup`](/docs/ui-integrations/ant-design/hooks/use-radio-group) hooks are also provided to make it easier to implement form fields with relational data. These hooks leverage the [`useSelect`](/docs/data/hooks/use-select) hook from the `@refinedev/core` package.

## Notifications

Ant Design has its own [notification system](https://ant.design/components/notification) which works seamlessly with its UI elements. Refine also provides a seamless integration with Ant Design's notification system and show notifications for related actions and events. This integration is provided by the `useNotificationProvider` hook exported from the `@refinedev/antd` package which can be directly used in the [`notificationProvider`](/docs/core/refine-component#notificationprovider) prop of the `<Refine />` component.

```tsx title="app.tsx"
import { Refine } from "@refinedev/core";
import { useNotificationProvider, RefineThemes } from "@refinedev/antd";
import { App as AntdApp } from "antd";

const App = () => {
  return (
    <ConfigProvider theme={RefineThemes.Green}>
      <AntdApp>
        <Refine notificationProvider={useNotificationProvider}>
          {/* ... */}
        </Refine>
      </AntdApp>
    </ConfigProvider>
  );
};
```

:::tip
If you have any configurations in the Ant Design's theme, you should wrap your app with the [`<App />`](https://ant.design/components/app) component to make sure the notifications are also receiving the current theme configuration.
:::

## Predefined Components and Views

### Layouts, Menus and Breadcrumbs

Refine provides Layout components that can be used to implement a layout for the application. These components are crafted using Ant Design's components and includes Refine's features and functionalities such as navigation menus, headers, authentication, authorization and more.

<Tabs wrapContent={false}>
<TabItem value="react-router-dom" label="React Router">

import LayoutReactRouterDom from "./previews/layout-react-router-dom.tsx";

<LayoutReactRouterDom />

</TabItem>
<TabItem value="next-js" label="Next.js">

import LayoutNextJs from "./previews/layout-next-js.tsx";

<LayoutNextJs />

</TabItem>
<TabItem value="remix" label="Remix">

import LayoutRemix from "./previews/layout-remix.tsx";

<LayoutRemix />

</TabItem>
</Tabs>

[`<ThemedLayoutV2 />`](/docs/ui-integrations/ant-design/components/themed-layout) component consists of a header, sider and a content area. The sider have a navigation menu items for the defined resources of Refine, if an authentication provider is present, it will also have a functional logout button. The header contains the app logo and name and also information about the current user if an authentication provider is present.

Additionally, Refine also provides a [`<Breadcrumb />`](/docs/ui-integrations/ant-design/components/breadcrumb) component that uses the Ant Design's component as a base and provide appropriate breadcrumbs for the current route. This component is used in the basic views provided by Refine's Ant Design package automatically.

### Buttons

Refine's Ant Design integration offers variety of buttons that are built above the [`<Button />`](https://ant.design/components/button) component of Ant Design and includes many logical functionalities such as;

- Authorization checks
- Confirmation dialogs
- Loading states
- Invalidation
- Navigation
- Form actions
- Import/Export and more.

You can use buttons such as [`<EditButton />`](/docs/ui-integrations/ant-design/components/buttons/edit-button) or [`<ListButton />`](/docs/ui-integrations/ant-design/components/buttons/list-button) etc. in your views to provide navigation for the related routes or [`<DeleteButton />`](/docs/ui-integrations/ant-design/components/buttons/delete-button) and [`<SaveButton />`](/docs/ui-integrations/ant-design/components/buttons/save-button) etc. to perform related actions without having to worry about the authorization checks and other logical functionalities.

An example usage of the `<EditButton />` component is as follows:

```tsx title="pages/products/list.tsx"
import { useTable, EditButton } from "@refinedev/antd";
import { Table } from "antd";

export const ProductList = () => {
  const { tableProps } = useTable<IProduct>();

  return (
    // highlight-next-line
    <Table {...tableProps} rowKey="id">
      <Table.Column dataIndex="id" title="ID" />
      <Table.Column dataIndex="name" title="Name" />
      <Table.Column dataIndex="price" title="Price" />
      <Table.Column
        title="Actions"
        dataIndex="actions"
        render={(_, record) => (
          // highlight-start
          <EditButton hideText size="small" recordItemId={record.id} />
          // highlight-end
        )}
      />
    </Table>
  );
};

interface IProduct {
  id: string;
  name: string;
  price: number;
  description: string;
}
```

The list of provided buttons are:

- [`<CreateButton />`](/docs/ui-integrations/ant-design/components/buttons/create-button)
- [`<EditButton />`](/docs/ui-integrations/ant-design/components/buttons/edit-button)
- [`<ListButton />`](/docs/ui-integrations/ant-design/components/buttons/list-button)
- [`<ShowButton />`](/docs/ui-integrations/ant-design/components/buttons/show-button)
- [`<CloneButton />`](/docs/ui-integrations/ant-design/components/buttons/clone-button)
- [`<DeleteButton />`](/docs/ui-integrations/ant-design/components/buttons/delete-button)
- [`<SaveButton />`](/docs/ui-integrations/ant-design/components/buttons/save-button)
- [`<RefreshButton />`](/docs/ui-integrations/ant-design/components/buttons/refresh-button)
- [`<ImportButton />`](/docs/ui-integrations/ant-design/components/buttons/import-button)
- [`<ExportButton />`](/docs/ui-integrations/ant-design/components/buttons/export-button)

Many of these buttons are already used in the views provided by Refine's Ant Design integration. If you're using the basic view elements provided by Refine, you will have the appropriate buttons placed in your application out of the box.

### Views

Views are designed as wrappers around the content of the pages in the application. They are designed to be used within the layouts and provide basic functionalities such as titles based on the resource, breadcrumbs, related actions and authorization checks. Refine's Ant Design integration uses components such as [`<Card />`](https://ant.design/components/card) and [`<Space />`](https://ant.design/components/space) to provide these views and provides customization options by passing related props to these components.

The list of provided views are:

- [`<List />`](/docs/ui-integrations/ant-design/components/basic-views/list)
- [`<Show />`](/docs/ui-integrations/ant-design/components/basic-views/show)
- [`<Edit />`](/docs/ui-integrations/ant-design/components/basic-views/edit)
- [`<Create />`](/docs/ui-integrations/ant-design/components/basic-views/create)

import BasicViews from "./previews/basic-views.tsx";

<BasicViews />

### Fields

Refine's Ant Design also provides field components to render values with appropriate design and format of Ant Design. These components are built on top of respective Ant Design components and also provide logic for formatting of the values. While these components might not always be suitable for your use case, they can be combined or extended to provide the desired functionality.

The list of provided field components are:

- [`<BooleanField />`](/docs/ui-integrations/ant-design/components/fields/boolean-field)
- [`<DateField />`](/docs/ui-integrations/ant-design/components/fields/date-field)
- [`<EmailField />`](/docs/ui-integrations/ant-design/components/fields/email-field)
- [`<FileField />`](/docs/ui-integrations/ant-design/components/fields/file-field)
- [`<ImageField />`](/docs/ui-integrations/ant-design/components/fields/image-field)
- [`<MarkdownField />`](/docs/ui-integrations/ant-design/components/fields/markdown-field)
- [`<NumberField />`](/docs/ui-integrations/ant-design/components/fields/number-field)
- [`<TagField />`](/docs/ui-integrations/ant-design/components/fields/tag-field)
- [`<TextField />`](/docs/ui-integrations/ant-design/components/fields/text-field)
- [`<UrlField />`](/docs/ui-integrations/ant-design/components/fields/url-field)

```tsx title="pages/products/show.tsx"
import { useShow } from "@refinedev/core";
import { Show, TextField, NumberField } from "@refinedev/antd";
import { Typography } from "antd";

export const ProductShow = () => {
  const { queryResult } = useShow<IProduct>();
  const { data, isLoading } = queryResult;
  const record = data?.data;

  return (
    <Show isLoading={isLoading}>
      <Typography.Title level={5}>Id</Typography.Title>
      {/* highlight-next-line */}
      <TextField value={record?.id} />

      <Typography.Title level={5}>Title</Typography.Title>
      {/* highlight-next-line */}
      <TextField value={record?.title} />

      <Typography.Title level={5}>Price</Typography.Title>
      {/* highlight-next-line */}
      <NumberField
        value={record?.price}
        options={{ style: "currency", currency: "USD" }}
      />
    </Show>
  );
};

interface IProduct {
  id: string;
  name: string;
  price: number;
  description: string;
}
```

### Auth Pages

Auth pages are designed to be used as the pages of the authentication flow of the application. They offer an out of the box solution for the login, register, forgot password and reset password pages by leveraging the authentication hooks of Refine. Auth page components are built on top of basic Ant Design components such as [`<Form />`](https://ant.design/components/form) and [`<Card />`](https://ant.design/components/card) etc.

The list of types of auth pages that are available in the UI integrations are:

- `<AuthPage type="login" />`
- `<AuthPage type="register" />`
- `<AuthPage type="forgot-password" />`
- `<AuthPage type="reset-password" />`

An example usage of the [`<AuthPage />`](/docs/ui-integrations/ant-design/components/auth-page) component is as follows:

import AuthPage from "./previews/auth-page.tsx";

<AuthPage />

### Error Components

Refine's Ant Design integration also provides an `<ErrorComponent />` component that you can use to render a 404 page in your app. While these components does not offer much functionality, they are provided as an easy way to render an error page with a consistent design language.

An example usage of the `<ErrorComponent />` component is as follows:

```tsx title="pages/404.tsx"
import { ErrorComponent } from "@refinedev/antd";

const NotFoundPage = () => {
  return <ErrorComponent />;
};
```

## Theming

Since Refine offers application level components such as layout, sidebar and header and page level components for each action, it is important to have it working with the styling of Ant Design. All components and providers exported from the `@refinedev/antd` package will use the current theme of Ant Design without any additional configuration.

Additionally, Refine also provides a set of carefully crafted themes for Ant Design which outputs a nice UI with Refine's components with light and dark theme support. These themes are exported as `RefineThemes` object from the `@refinedev/antd` package and can be used in [`<ConfigProvider />`](https://ant.design/components/config-provider) component of Ant Design.

import Theming from "./previews/theming.tsx";

<Theming />

To learn more about the theme configuration of Ant Design, please refer to the [official documentation](https://ant.design/docs/react/customize-theme).

## Inferencer

You can automatically generate views for your resources using `@refinedev/inferencer`. Inferencer exports the `AntdListInferencer`, `AntdShowInferencer`, `AntdEditInferencer`, `AntdCreateInferencer` components and finally the `AntdInferencer` component, which combines all in one place.

To learn more about Inferencer, please refer to the [Ant Design Inferencer](/docs/ui-integrations/ant-design/components/inferencer) docs.

## Known Issues

Next.js Pages Router with version 14 and above gives the following error when using `@ant-design` package:

```bash title="Compile errors"
Server Error
SyntaxError: Unexpected token 'export'

This error happened while generating the page. Any console logs will be displayed in the terminal window.
Call Stack
<unknown>
/Users/user/Desktop/refine/node_modules/ (ant-design/icons-svg/es/asn/AccountBookFilled.js (3)
```

You can find issue details from the official Ant Design repository:

- https://github.com/ant-design/ant-design/issues/43510
- https://github.com/ant-design/ant-design/issues/46053

================
File: ui-integrations/ant-design/introduction/previews/auth-page.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export default function AuthPage() {
  return (
    <Sandpack
      showNavigator
      //   showFiles
      initialPercentage={40}
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/login"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/pages/products.tsx": {
          code: ListTsxCode,
          hidden: true,
        },
        "/pages/login.tsx": {
          code: LoginTsxCode,
          active: true,
        },
        "/pages/register.tsx": {
          code: RegisterTsxCode,
        },
        "/pages/forgot-password.tsx": {
          code: ForgotPasswordTsxCode,
        },
        "/pages/reset-password.tsx": {
          code: ResetPasswordTsxCode,
        },
        "/auth-provider.tsx": {
          code: AuthProviderTsxCode,
          hidden: true,
        },
      }}
    />
  );
}
const AuthProviderTsxCode = /* jsx */ `
const authProvider = {
    login: async ({ username, password }) => {
      (window as any).authenticated = true;
      return { success: true };
    },
    check: async () => {
      return { authenticated: Boolean((window as any).authenticated) };
    },
    logout: async () => {
      (window as any).authenticated = false;
      return { success: true };
    },
    register: async () => {
      return { success: true };
    },
    forgotPassword: async () => {
      return { success: true };
    },
    resetPassword: async () => {
      return { success: true };
    },
    getIdentity: async () => ({ id: 1, name: "John Doe", avatar: "https://i.pravatar.cc/300"})
};
export default authProvider;
`.trim();
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import { BrowserRouter, Route, Routes, Outlet, Navigate } from "react-router";
import { ErrorComponent, RefineThemes, ThemedLayoutV2, useNotificationProvider, AuthPage } from "@refinedev/antd";
import { App as AntdApp, ConfigProvider } from "antd";
import authProvider from "./auth-provider";
import "@refinedev/antd/dist/reset.css";
import { ProductList } from "./pages/products";
import { LoginPage } from "./pages/login";
import { RegisterPage } from "./pages/register";
import { ForgotPasswordPage } from "./pages/forgot-password";
import { ResetPasswordPage } from "./pages/reset-password";
export default function App() {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <AntdApp>
          <Refine
            routerProvider={routerProvider}
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            authProvider={authProvider}
            notificationProvider={useNotificationProvider}
            resources={[
              {
                name: "products",
                list: "/products",
              }
            ]}
            options={{ syncWithLocation: true }}
          >
            <Routes>
              <Route element={<Authenticated fallback={<Navigate to="/login" />}><Outlet /></Authenticated>}>
                <Route
                  element={
                    <ThemedLayoutV2>
                      <Outlet />
                    </ThemedLayoutV2>
                  }
                >
                  <Route path="/products" element={<ProductList />} />
                  <Route path="*" element={<ErrorComponent />} />
                </Route>
              </Route>
              <Route element={<Authenticated fallback={<Outlet />}><NavigateToResource resource="products" /></Authenticated>}>
                <Route path="/login" element={<LoginPage />} />
                <Route path="/register" element={<RegisterPage />} />
                <Route path="/forgot-password" element={<ForgotPasswordPage />} />
                <Route path="/reset-password" element={<ResetPasswordPage />} />
                <Route path="*" element={<ErrorComponent />} />
              </Route>
            </Routes>
          </Refine>
        </AntdApp>
      </ConfigProvider>
    </BrowserRouter>
  );
};
`.trim();
const ListTsxCode = /* jsx */ `
import React from "react";
import { List, useTable } from "@refinedev/antd";
import { Space, Table } from "antd";
export const ProductList = () => {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
      </Table>
    </List>
  );
};
`.trim();
const LoginTsxCode = /* jsx */ `
import { AuthPage } from "@refinedev/antd";
export const LoginPage = () => {
    return (
        <AuthPage
            type="login"
            formProps={{
                initialValues: {
                  email: "demo@refine.dev",
                  password: "demodemo",
                },
            }}
        />
    );
};
`.trim();
const RegisterTsxCode = /* jsx */ `
import { AuthPage } from "@refinedev/antd";
export const RegisterPage = () => {
    return <AuthPage type="register" />;
};
`.trim();
const ForgotPasswordTsxCode = /* jsx */ `
import { AuthPage } from "@refinedev/antd";
export const ForgotPasswordPage = () => {
    return <AuthPage type="forgotPassword" />;
};
`.trim();
const ResetPasswordTsxCode = /* jsx */ `
import { AuthPage } from "@refinedev/antd";
export const ResetPasswordPage = () => {
    return <AuthPage type="resetPassword" />;
};
`.trim();

================
File: ui-integrations/ant-design/introduction/previews/basic-views.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export default function BasicViews() {
  return (
    <Sandpack
      showNavigator
      initialPercentage={40}
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
          active: true,
        },
        "/pages/products/show.tsx": {
          code: ShowTsxCode,
        },
        "/pages/products/edit.tsx": {
          code: EditTsxCode,
        },
        "/pages/products/create.tsx": {
          code: CreateTsxCode,
        },
      }}
    />
  );
}
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import { BrowserRouter, Route, Routes, Outlet, Navigate } from "react-router";
import { ErrorComponent, RefineThemes, ThemedLayoutV2, useNotificationProvider } from "@refinedev/antd";
import { App as AntdApp, ConfigProvider } from "antd";
import "@refinedev/antd/dist/reset.css";
import { ProductList } from "./pages/products/list";
import { ProductShow } from "./pages/products/show";
import { ProductEdit } from "./pages/products/edit";
import { ProductCreate } from "./pages/products/create";
export default function App() {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <AntdApp>
          <Refine
            routerProvider={routerProvider}
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            notificationProvider={useNotificationProvider}
            resources={[
              {
                name: "products",
                list: "/products",
                show: "/products/:id",
                edit: "/products/:id/edit",
                create: "/products/create"
              }
            ]}
            options={{ syncWithLocation: true }}
          >
            <Routes>
                <Route
                    element={
                    <ThemedLayoutV2>
                        <Outlet />
                    </ThemedLayoutV2>
                    }
                >
                    <Route path="/products" element={<Outlet />}>
                        <Route index element={<ProductList />} />
                        <Route path="create" element={<ProductCreate />} />
                        <Route path=":id" element={<ProductShow />} />
                        <Route path=":id/edit" element={<ProductEdit />} />
                    </Route>
                    <Route path="*" element={<ErrorComponent />} />
                </Route>
            </Routes>
          </Refine>
        </AntdApp>
      </ConfigProvider>
    </BrowserRouter>
  );
};
`.trim();
const ListTsxCode = /* jsx */ `
import { List, ShowButton, EditButton, useTable } from "@refinedev/antd";
import { Space, Table } from "antd";
import React from "react";
export const ProductList = () => {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
        <Table.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record: BaseRecord) => (
            <Space>
              <ShowButton hideText size="small" recordItemId={record.id} />
              <EditButton hideText size="small" recordItemId={record.id} />
            </Space>
          )}
        />
      </Table>
    </List>
  );
};
`.trim();
const ShowTsxCode = /* jsx */ `
import { MarkdownField, NumberField, Show, TextField } from "@refinedev/antd";
import { useShow } from "@refinedev/core";
import { Typography } from "antd";
import React from "react";
const { Title } = Typography;
export const ProductShow = () => {
  const { queryResult } = useShow();
  const { data, isLoading } = queryResult;
  const record = data?.data;
  return (
    <Show isLoading={isLoading}>
      <Title level={5}>Id</Title>
      <NumberField value={record?.id ?? ""} />
      <Title level={5}>Name</Title>
      <TextField value={record?.name} />
      <Title level={5}>Material</Title>
      <TextField value={record?.material} />
      <Title level={5}>Description</Title>
      <MarkdownField value={record?.description} />
      <Title level={5}>Price</Title>
      <NumberField value={record?.price ?? ""} />
    </Show>
  );
};
`.trim();
const EditTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Edit, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export const ProductEdit: React.FC = () => {
  const { formProps, saveButtonProps, formLoading } = useForm();
  return (
    <Edit saveButtonProps={saveButtonProps} isLoading={formLoading}>
      <Form {...formProps} layout="vertical">
          <Form.Item
              label="Name"
              name="name"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <Input />
          </Form.Item>
          <Form.Item
              label="Material"
              name="material"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <Input />
          </Form.Item>
          <Form.Item
              label="Description"
              name="description"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <TextArea rows={4} />
          </Form.Item>
          <Form.Item
              label="Price"
              name="price"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <InputNumber />
          </Form.Item>
      </Form>
  </Edit>
  );
};
`.trim();
const CreateTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Create, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export const ProductCreate = () => {
  const { formProps, saveButtonProps, formLoading } = useForm();
  return (
    <Create saveButtonProps={saveButtonProps} isLoading={formLoading}>
      <Form {...formProps} layout="vertical">
        <Form.Item
            label="Name"
            name="name"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Material"
            name="material"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Description"
            name="description"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <TextArea rows={4} />
        </Form.Item>
        <Form.Item
            label="Price"
            name="price"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <InputNumber />
        </Form.Item>
      </Form>
    </Create>
  );
};
`.trim();

================
File: ui-integrations/ant-design/introduction/previews/example.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export default function Usage() {
  return (
    <Sandpack
      showNavigator
      previewOnly
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          active: true,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
        },
        "/pages/products/show.tsx": {
          code: ShowTsxCode,
        },
        "/pages/products/edit.tsx": {
          code: EditTsxCode,
        },
        "/pages/products/create.tsx": {
          code: CreateTsxCode,
        },
        "/auth-provider.tsx": {
          code: AuthProviderTsxCode,
          hidden: true,
        },
      }}
    />
  );
}
const AuthProviderTsxCode = /* jsx */ `
const authProvider = {
    login: async ({ username, password }) => {
      (window as any).authenticated = true;
      return { success: true };
    },
    check: async () => {
      // auto login at first time
      if (typeof (window as any).authenticated === "undefined") {
        (window as any).authenticated = true;
      }
      return { authenticated: Boolean((window as any).authenticated) };
    },
    logout: async () => {
      (window as any).authenticated = false;
      return { success: true };
    },
    register: async () => {
      return { success: true };
    },
    forgotPassword: async () => {
      return { success: true };
    },
    resetPassword: async () => {
      return { success: true };
    },
    getIdentity: async () => ({ id: 1, name: "John Doe", avatar: "https://i.pravatar.cc/300"})
};
export default authProvider;
`.trim();
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import { BrowserRouter, Route, Routes, Outlet, Navigate } from "react-router";
import { ErrorComponent, RefineThemes, ThemedLayoutV2, useNotificationProvider, AuthPage } from "@refinedev/antd";
import { App as AntdApp, ConfigProvider } from "antd";
import authProvider from "./auth-provider";
import "@refinedev/antd/dist/reset.css";
import { ProductList } from "./pages/products/list";
import { ProductShow } from "./pages/products/show";
import { ProductEdit } from "./pages/products/edit";
import { ProductCreate } from "./pages/products/create";
export default function App() {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <AntdApp>
          <Refine
            routerProvider={routerProvider}
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            authProvider={authProvider}
            notificationProvider={useNotificationProvider}
            resources={[
              {
                name: "products",
                list: "/products",
                show: "/products/:id",
                edit: "/products/:id/edit",
                create: "/products/create"
              }
            ]}
            options={{ syncWithLocation: true }}
          >
            <Routes>
              <Route element={<Authenticated fallback={<Navigate to="/login" />}><Outlet /></Authenticated>}>
                <Route
                  element={
                    <ThemedLayoutV2>
                      <Outlet />
                    </ThemedLayoutV2>
                  }
                >
                  <Route path="/products" element={<Outlet />}>
                      <Route index element={<ProductList />} />
                      <Route path="create" element={<ProductCreate />} />
                      <Route path=":id" element={<ProductShow />} />
                      <Route path=":id/edit" element={<ProductEdit />} />
                  </Route>
                  <Route path="*" element={<ErrorComponent />} />
                </Route>
              </Route>
              <Route element={<Authenticated fallback={<Outlet />}><NavigateToResource resource="products" /></Authenticated>}>
                <Route
                  path="/login"
                  element={(
                    <AuthPage
                      type="login"
                      formProps={{
                        initialValues: {
                          email: "demo@refine.dev",
                          password: "demodemo",
                        },
                      }}
                    />
                  )}
                />
                <Route path="/register" element={<AuthPage type="register" />} />
                <Route path="/forgot-password" element={<AuthPage type="forgotPassword" />} />
                <Route path="/reset-password" element={<AuthPage type="resetPassword" />} />
                <Route path="*" element={<ErrorComponent />} />
              </Route>
            </Routes>
          </Refine>
        </AntdApp>
      </ConfigProvider>
    </BrowserRouter>
  );
};
`.trim();
const ListTsxCode = /* jsx */ `
import { List, ShowButton, EditButton, useTable } from "@refinedev/antd";
import { BaseRecord } from "@refinedev/core";
import { Space, Table } from "antd";
import React from "react";
export const ProductList = () => {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
        <Table.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record: BaseRecord) => (
            <Space>
              <ShowButton hideText size="small" recordItemId={record.id} />
              <EditButton hideText size="small" recordItemId={record.id} />
            </Space>
          )}
        />
      </Table>
    </List>
  );
};
`.trim();
const ShowTsxCode = /* jsx */ `
import { MarkdownField, NumberField, Show, TextField } from "@refinedev/antd";
import { useShow } from "@refinedev/core";
import { Typography } from "antd";
import React from "react";
const { Title } = Typography;
export const ProductShow = () => {
  const { queryResult } = useShow();
  const { data, isLoading } = queryResult;
  const record = data?.data;
  return (
    <Show isLoading={isLoading}>
      <Title level={5}>Id</Title>
      <NumberField value={record?.id ?? ""} />
      <Title level={5}>Name</Title>
      <TextField value={record?.name} />
      <Title level={5}>Material</Title>
      <TextField value={record?.material} />
      <Title level={5}>Description</Title>
      <MarkdownField value={record?.description} />
      <Title level={5}>Price</Title>
      <NumberField value={record?.price ?? ""} />
    </Show>
  );
};
`.trim();
const EditTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Edit, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export const ProductEdit: React.FC = () => {
  const { formProps, saveButtonProps } = useForm();
  return (
    <Edit saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
          <Form.Item
              label="Name"
              name="name"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <Input />
          </Form.Item>
          <Form.Item
              label="Material"
              name="material"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <Input />
          </Form.Item>
          <Form.Item
              label="Description"
              name="description"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <TextArea rows={4} />
          </Form.Item>
          <Form.Item
              label="Price"
              name="price"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <InputNumber />
          </Form.Item>
      </Form>
  </Edit>
  );
};
`.trim();
const CreateTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Create, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export const ProductCreate = () => {
  const { formProps, saveButtonProps } = useForm();
  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
            label="Name"
            name="name"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Material"
            name="material"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Description"
            name="description"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <TextArea rows={4} />
        </Form.Item>
        <Form.Item
            label="Price"
            name="price"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <InputNumber />
        </Form.Item>
      </Form>
    </Create>
  );
};
`.trim();

================
File: ui-integrations/ant-design/introduction/previews/layout-react-router-dom.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export default function LayoutReactRouterDom() {
  return (
    <Sandpack
      showNavigator
      // hidePreview
      //   showFiles
      initialPercentage={35}
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          active: true,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
          hidden: true,
        },
        "/auth-provider.tsx": {
          code: AuthProviderTsxCode,
          hidden: true,
        },
      }}
    />
  );
}
const AuthProviderTsxCode = /* jsx */ `
const authProvider = {
    login: async ({ username, password }) => {
      (window as any).authenticated = true;
      return { success: true };
    },
    check: async () => {
      // auto login at first time
      if (typeof (window as any).authenticated === "undefined") {
        (window as any).authenticated = true;
      }
      return { authenticated: Boolean((window as any).authenticated) };
    },
    logout: async () => {
      (window as any).authenticated = false;
      return { success: true };
    },
    register: async () => {
      return { success: true };
    },
    forgotPassword: async () => {
      return { success: true };
    },
    resetPassword: async () => {
      return { success: true };
    },
    getIdentity: async () => ({ id: 1, name: "John Doe", avatar: "https://i.pravatar.cc/300"})
};
export default authProvider;
`.trim();
const AppTsxCode = /* jsx */ `
import React from "react";
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider from "@refinedev/react-router";
import { BrowserRouter, Route, Routes, Outlet } from "react-router";
import { ErrorComponent, RefineThemes, ThemedLayoutV2, useNotificationProvider } from "@refinedev/antd";
import { App as AntdApp, ConfigProvider } from "antd";
import "@refinedev/antd/dist/reset.css";
import authProvider from "./auth-provider";
import { ProductList } from "./pages/products/list";
export default function App() {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <AntdApp>
          <Refine
            routerProvider={routerProvider}
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            notificationProvider={useNotificationProvider}
            authProvider={authProvider}
            resources={[
              {
                name: "products",
                list: "/products",
              }
            ]}
          >
            <Routes>
                <Route
                  // The layout will wrap all the pages inside this route
                  element={
                    <ThemedLayoutV2>
                      <Outlet />
                    </ThemedLayoutV2>
                  }
                >
                    <Route path="/products" element={<ProductList />} />
                    <Route path="*" element={<ErrorComponent />} />
                </Route>
            </Routes>
          </Refine>
        </AntdApp>
      </ConfigProvider>
    </BrowserRouter>
  );
};
`.trim();
const ListTsxCode = /* jsx */ `
import React from "react";
import { List, useTable } from "@refinedev/antd";
import { Space, Table } from "antd";
export const ProductList = () => {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
      </Table>
    </List>
  );
};
`.trim();

================
File: ui-integrations/ant-design/introduction/previews/layout-remix.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export default function LayoutRemix() {
  return (
    <Sandpack
      showNavigator
      hidePreview
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/remix-router": "latest",
        antd: "^5.0.5",
      }}
      startRoute="/products"
      files={{
        "/app/root.tsx": {
          code: RootTsxCode,
        },
        "/app/routes/_layout.tsx": {
          code: ProtectedTsxCode,
          active: true,
        },
        "/app/routes/_layout.products._index.tsx": {
          code: ListTsxCode,
          hidden: true,
        },
      }}
    />
  );
}
const RootTsxCode = /* jsx */ `
import React from "react";
import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/remix-router";
import dataProvider from "@refinedev/simple-rest";
import { useNotificationProvider, RefineThemes } from "@refinedev/antd";
import { ConfigProvider, App as AntdApp } from "antd";
import resetStyle from "@refinedev/antd/dist/reset.css";
export default function App() {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <ConfigProvider theme={RefineThemes.Blue}>
          <AntdApp>
            <Refine
              routerProvider={routerProvider}
              dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
              notificationProvider={useNotificationProvider}
              resources={[
                {
                  name: "products",
                  list: "/products",
                },
              ]}
            >
              <Outlet />
            </Refine>
          </AntdApp>
        </ConfigProvider>
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}
`.trim();
const ProtectedTsxCode = /* jsx */ `
import { ThemedLayoutV2 } from "@refinedev/antd";
import { Outlet } from "@remix-run/react";
import { LoaderFunctionArgs, redirect } from "@remix-run/node";
/**
 * Routes starting with \`_layout\` will have their children rendered inside the layout.
 */
export default function Layout() {
    return (
        <ThemedLayoutV2>
            <Outlet />
        </ThemedLayoutV2>
    );
}
`.trim();
const ListTsxCode = /* jsx */ `
import React from "react";
import { List, useTable } from "@refinedev/antd";
import { Space, Table } from "antd";
export default function ProductList() {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
      </Table>
    </List>
  );
};
`.trim();

================
File: ui-integrations/ant-design/introduction/previews/theming.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export default function Usage() {
  return (
    <Sandpack
      showNavigator
      layout="col"
      height={320}
      showOpenInCodeSandbox={false}
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          hidden: true,
        },
        "/theme-provider.tsx": {
          code: ThemeProviderTsxCode,
          active: true,
        },
        "/pages/products/index.tsx": {
          code: ProductsTsxCode,
          hidden: true,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
          hidden: true,
        },
        "/pages/products/show.tsx": {
          code: ShowTsxCode,
          hidden: true,
        },
        "/pages/products/edit.tsx": {
          code: EditTsxCode,
          hidden: true,
        },
        "/pages/products/create.tsx": {
          code: CreateTsxCode,
          hidden: true,
        },
        "/auth-provider.tsx": {
          code: AuthProviderTsxCode,
          hidden: true,
        },
      }}
    />
  );
}
const AuthProviderTsxCode = /* jsx */ `
const authProvider = {
    login: async ({ username, password }) => {
      (window as any).authenticated = true;
      return { success: true };
    },
    check: async () => {
      // auto login at first time
      if (typeof (window as any).authenticated === "undefined") {
        (window as any).authenticated = true;
      }
      return { authenticated: Boolean((window as any).authenticated) };
    },
    logout: async () => {
      (window as any).authenticated = false;
      return { success: true };
    },
    register: async () => {
      return { success: true };
    },
    forgotPassword: async () => {
      return { success: true };
    },
    resetPassword: async () => {
      return { success: true };
    },
    getIdentity: async () => ({ id: 1, name: "John Doe", avatar: "https://i.pravatar.cc/300"})
};
export default authProvider;
`.trim();
const ProductsTsxCode = /* jsx */ `
export * from "./list";
export * from "./show";
export * from "./edit";
export * from "./create";
`.trim();
const ThemeProviderTsxCode = /* jsx */ `
import { ConfigProvider, App } from "antd";
import { RefineThemes } from "@refinedev/antd";
export const ThemeProvider = ({ children }) => (
    // Available themes: Blue, Purple, Magenta, Red, Orange, Yellow, Green
    // Change the line below to change the theme
    <ConfigProvider theme={RefineThemes.Magenta}>
        <App>
            {children}
        </App>
    </ConfigProvider>
);
`.trim();
const AppTsxCode = /* jsx */ `
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import { BrowserRouter, Route, Routes, Outlet, Navigate } from "react-router";
import { ErrorComponent, RefineThemes, ThemedLayoutV2, useNotificationProvider, AuthPage } from "@refinedev/antd";
import { App as AntdApp, ConfigProvider } from "antd";
import authProvider from "./auth-provider";
import { ThemeProvider } from "./theme-provider";
import "@refinedev/antd/dist/reset.css";
import { ProductList, ProductShow, ProductEdit, ProductCreate } from "./pages/products";
export default function App() {
  return (
    <BrowserRouter>
      <ThemeProvider>
        {/**
         * This is a small hack to make the sidebar visible in the example on small screens
        */}
        <ConfigProvider theme={{
            token: {
                screenLG: 600,
                screenLGMin: 600,
                screenMDMax: 599,
                screenMD: 580,
                screenMDMin: 580,
                screenSMMax: 579,
            }
        }}>
            <Refine
                routerProvider={routerProvider}
                dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
                authProvider={authProvider}
                notificationProvider={useNotificationProvider}
                resources={[
                {
                    name: "products",
                    list: "/products",
                    show: "/products/:id",
                    edit: "/products/:id/edit",
                    create: "/products/create"
                }
                ]}
            >
                <Routes>
                <Route element={<Authenticated fallback={<Navigate to="/login" />}><Outlet /></Authenticated>}>
                    <Route
                    element={
                        <ThemedLayoutV2>
                        <Outlet />
                        </ThemedLayoutV2>
                    }
                    >
                    <Route path="/products" element={<Outlet />}>
                        <Route index element={<ProductList />} />
                        <Route path="create" element={<ProductCreate />} />
                        <Route path=":id" element={<ProductShow />} />
                        <Route path=":id/edit" element={<ProductEdit />} />
                    </Route>
                    <Route path="*" element={<ErrorComponent />} />
                    </Route>
                </Route>
                <Route element={<Authenticated fallback={<Outlet />}><NavigateToResource resource="products" /></Authenticated>}>
                    <Route
                    path="/login"
                    element={(
                        <AuthPage
                        type="login"
                        formProps={{
                            initialValues: {
                            email: "demo@refine.dev",
                            password: "demodemo",
                            },
                        }}
                        />
                    )}
                    />
                    <Route path="/register" element={<AuthPage type="register" />} />
                    <Route path="/forgot-password" element={<AuthPage type="forgotPassword" />} />
                    <Route path="/reset-password" element={<AuthPage type="resetPassword" />} />
                    <Route path="*" element={<ErrorComponent />} />
                </Route>
                </Routes>
            </Refine>
          </ConfigProvider>
      </ThemeProvider>
    </BrowserRouter>
  );
};
`.trim();
const ListTsxCode = /* jsx */ `
import { List, ShowButton, EditButton, useTable } from "@refinedev/antd";
import { BaseRecord } from "@refinedev/core";
import { Space, Table } from "antd";
import React from "react";
export const ProductList = () => {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
        <Table.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record: BaseRecord) => (
            <Space>
              <ShowButton hideText size="small" recordItemId={record.id} />
              <EditButton hideText size="small" recordItemId={record.id} />
            </Space>
          )}
        />
      </Table>
    </List>
  );
};
`.trim();
const ShowTsxCode = /* jsx */ `
import { MarkdownField, NumberField, Show, TextField } from "@refinedev/antd";
import { useShow } from "@refinedev/core";
import { Typography } from "antd";
import React from "react";
const { Title } = Typography;
export const ProductShow = () => {
  const { queryResult } = useShow();
  const { data, isLoading } = queryResult;
  const record = data?.data;
  return (
    <Show isLoading={isLoading}>
      <Title level={5}>Id</Title>
      <NumberField value={record?.id ?? ""} />
      <Title level={5}>Name</Title>
      <TextField value={record?.name} />
      <Title level={5}>Material</Title>
      <TextField value={record?.material} />
      <Title level={5}>Description</Title>
      <MarkdownField value={record?.description} />
      <Title level={5}>Price</Title>
      <NumberField value={record?.price ?? ""} />
    </Show>
  );
};
`.trim();
const EditTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Edit, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export const ProductEdit: React.FC = () => {
  const { formProps, saveButtonProps } = useForm();
  return (
    <Edit saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
          <Form.Item
              label="Name"
              name="name"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <Input />
          </Form.Item>
          <Form.Item
              label="Material"
              name="material"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <Input />
          </Form.Item>
          <Form.Item
              label="Description"
              name="description"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <TextArea rows={4} />
          </Form.Item>
          <Form.Item
              label="Price"
              name="price"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <InputNumber />
          </Form.Item>
      </Form>
  </Edit>
  );
};
`.trim();
const CreateTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Create, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export const ProductCreate = () => {
  const { formProps, saveButtonProps } = useForm();
  return (
    <Create saveButtonProps={saveButtonProps}>
      <Form {...formProps} layout="vertical">
        <Form.Item
            label="Name"
            name="name"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Material"
            name="material"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Description"
            name="description"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <TextArea rows={4} />
        </Form.Item>
        <Form.Item
            label="Price"
            name="price"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <InputNumber />
        </Form.Item>
      </Form>
    </Create>
  );
};
`.trim();

================
File: ui-integrations/ant-design/introduction/previews/usage-react-router-dom.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export default function UsageReactRouterDom() {
  return (
    <Sandpack
      showNavigator
      hidePreview
      showFiles
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/react-router": "latest",
        "react-router": "^7.0.2",
        antd: "^5.0.5",
      }}
      startRoute="/products"
      files={{
        "/App.tsx": {
          code: AppTsxCode,
          active: true,
        },
        "/pages/products/index.tsx": {
          code: ProductsTsxCode,
        },
        "/pages/products/list.tsx": {
          code: ListTsxCode,
        },
        "/pages/products/show.tsx": {
          code: ShowTsxCode,
        },
        "/pages/products/edit.tsx": {
          code: EditTsxCode,
        },
        "/pages/products/create.tsx": {
          code: CreateTsxCode,
        },
        "/auth-provider.tsx": {
          code: AuthProviderTsxCode,
          hidden: true,
        },
      }}
    />
  );
}
const AuthProviderTsxCode = /* jsx */ `
const authProvider = {
    login: async ({ username, password }) => {
      (window as any).authenticated = true;
      return { success: true };
    },
    check: async () => {
      // auto login at first time
      if (typeof (window as any).authenticated === "undefined") {
        (window as any).authenticated = true;
      }
      return { authenticated: Boolean((window as any).authenticated) };
    },
    logout: async () => {
      (window as any).authenticated = false;
      return { success: true };
    },
    register: async () => {
      return { success: true };
    },
    forgotPassword: async () => {
      return { success: true };
    },
    resetPassword: async () => {
      return { success: true };
    },
    getIdentity: async () => ({ id: 1, name: "John Doe", avatar: "https://i.pravatar.cc/300"})
};
export default authProvider;
`.trim();
const AppTsxCode = /* jsx */ `
import { Refine, Authenticated } from "@refinedev/core";
import dataProvider from "@refinedev/simple-rest";
import routerProvider, { NavigateToResource } from "@refinedev/react-router";
import { BrowserRouter, Route, Routes, Outlet, Navigate } from "react-router";
import { ErrorComponent, RefineThemes, ThemedLayoutV2, useNotificationProvider, AuthPage } from "@refinedev/antd";
import { App as AntdApp, ConfigProvider } from "antd";
import authProvider from "./auth-provider";
import "@refinedev/antd/dist/reset.css";
import { ProductList, ProductShow, ProductEdit, ProductCreate } from "./pages/products";
export default function App() {
  return (
    <BrowserRouter>
      <ConfigProvider theme={RefineThemes.Blue}>
        <AntdApp>
          <Refine
            routerProvider={routerProvider}
            dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
            authProvider={authProvider}
            notificationProvider={useNotificationProvider}
            resources={[
              {
                name: "products",
                list: "/products",
                show: "/products/:id",
                edit: "/products/:id/edit",
                create: "/products/create"
              }
            ]}
            options={{ syncWithLocation: true }}
          >
            <Routes>
              <Route element={<Authenticated fallback={<Navigate to="/login" />}><Outlet /></Authenticated>}>
                <Route
                  element={
                    <ThemedLayoutV2>
                      <Outlet />
                    </ThemedLayoutV2>
                  }
                >
                  <Route path="/products" element={<Outlet />}>
                      <Route index element={<ProductList />} />
                      <Route path="create" element={<ProductCreate />} />
                      <Route path=":id" element={<ProductShow />} />
                      <Route path=":id/edit" element={<ProductEdit />} />
                  </Route>
                  <Route path="*" element={<ErrorComponent />} />
                </Route>
              </Route>
              <Route element={<Authenticated fallback={<Outlet />}><NavigateToResource resource="products" /></Authenticated>}>
                <Route path="/login" element={<AuthPage type="login" />} />
                <Route path="/register" element={<AuthPage type="register" />} />
                <Route path="/forgot-password" element={<AuthPage type="forgotPassword" />} />
                <Route path="/reset-password" element={<AuthPage type="resetPassword" />} />
                <Route path="*" element={<ErrorComponent />} />
              </Route>
            </Routes>
          </Refine>
        </AntdApp>
      </ConfigProvider>
    </BrowserRouter>
  );
};
`.trim();
const ProductsTsxCode = /* jsx */ `
export * from "./list";
export * from "./show";
export * from "./edit";
export * from "./create";
`.trim();
const ListTsxCode = /* jsx */ `
import React from "react";
import { List, ShowButton, EditButton, useTable } from "@refinedev/antd";
import { Space, Table } from "antd";
export const ProductList = () => {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
        <Table.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record: BaseRecord) => (
            <Space>
              <ShowButton hideText size="small" recordItemId={record.id} />
              <EditButton hideText size="small" recordItemId={record.id} />
            </Space>
          )}
        />
      </Table>
    </List>
  );
};
`.trim();
const ShowTsxCode = /* jsx */ `
import React from "react";
import { useShow } from "@refinedev/core";
import { MarkdownField, NumberField, Show, TextField } from "@refinedev/antd";
import { Typography } from "antd";
const { Title } = Typography;
export const ProductShow = () => {
  const { queryResult } = useShow();
  const { data, isLoading } = queryResult;
  const record = data?.data;
  return (
    <Show isLoading={isLoading}>
      <Title level={5}>Id</Title>
      <NumberField value={record?.id ?? ""} />
      <Title level={5}>Name</Title>
      <TextField value={record?.name} />
      <Title level={5}>Material</Title>
      <TextField value={record?.material} />
      <Title level={5}>Description</Title>
      <MarkdownField value={record?.description} />
      <Title level={5}>Price</Title>
      <NumberField value={record?.price ?? ""} />
    </Show>
  );
};
`.trim();
const EditTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Edit, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export const ProductEdit = () => {
  const { formProps, saveButtonProps, formLoading } = useForm();
  return (
    <Edit saveButtonProps={saveButtonProps} isLoading={formLoading}>
      <Form {...formProps} layout="vertical">
          <Form.Item
              label="Name"
              name="name"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <Input />
          </Form.Item>
          <Form.Item
              label="Material"
              name="material"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <Input />
          </Form.Item>
          <Form.Item
              label="Description"
              name="description"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <TextArea rows={4} />
          </Form.Item>
          <Form.Item
              label="Price"
              name="price"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <InputNumber />
          </Form.Item>
      </Form>
  </Edit>
  );
};
`.trim();
const CreateTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Create, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export const ProductCreate = () => {
  const { formProps, saveButtonProps, formLoading } = useForm();
  return (
    <Create saveButtonProps={saveButtonProps} isLoading={formLoading}>
      <Form {...formProps} layout="vertical">
        <Form.Item
            label="Name"
            name="name"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Material"
            name="material"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Description"
            name="description"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <TextArea rows={4} />
        </Form.Item>
        <Form.Item
            label="Price"
            name="price"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <InputNumber />
        </Form.Item>
      </Form>
    </Create>
  );
};
`.trim();

================
File: ui-integrations/ant-design/introduction/previews/usage-remix.tsx
================
import React from "react";
import { Sandpack } from "@site/src/components/sandpack";
export default function UsageRemix() {
  return (
    <Sandpack
      showNavigator
      hidePreview
      showFiles
      dependencies={{
        "@refinedev/antd": "latest",
        "@refinedev/core": "latest",
        "@refinedev/simple-rest": "latest",
        "@refinedev/remix-router": "latest",
        antd: "^5.0.5",
      }}
      startRoute="/products"
      files={{
        "/app/root.tsx": {
          code: RootTsxCode,
          active: true,
        },
        "/app/routes/_protected.tsx": {
          code: ProtectedTsxCode,
        },
        "/app/routes/_protected.products._index.tsx": {
          code: ListTsxCode,
        },
        "/app/routes/_protected.products.$id.tsx": {
          code: ShowTsxCode,
        },
        "/app/routes/_protected.products.$id.edit.tsx": {
          code: EditTsxCode,
        },
        "/app/routes/_protected.products.create.tsx": {
          code: CreateTsxCode,
        },
        "/app/routes/_auth.tsx": {
          code: AuthTsxCode,
        },
        "/app/routes/_auth.login.tsx": {
          code: LoginTsxCode,
        },
        "/app/auth-provider.tsx": {
          code: AuthProviderTsxCode,
          hidden: true,
        },
      }}
    />
  );
}
const AuthProviderTsxCode = /* jsx */ `
const authProvider = {
    login: async ({ username, password }) => {
      (window as any).authenticated = true;
      return { success: true };
    },
    check: async () => {
      // auto login at first time
      if (typeof (window as any).authenticated === "undefined") {
        (window as any).authenticated = true;
      }
      return { authenticated: Boolean((window as any).authenticated) };
    },
    logout: async () => {
      (window as any).authenticated = false;
      return { success: true };
    },
    register: async () => {
      return { success: true };
    },
    forgotPassword: async () => {
      return { success: true };
    },
    resetPassword: async () => {
      return { success: true };
    },
    getIdentity: async () => ({ id: 1, name: "John Doe", avatar: "https://i.pravatar.cc/300"})
};
export default authProvider;
`.trim();
const RootTsxCode = /* jsx */ `
import React from "react";
import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";
import { Refine } from "@refinedev/core";
import routerProvider from "@refinedev/remix-router";
import dataProvider from "@refinedev/simple-rest";
import { useNotificationProvider, RefineThemes } from "@refinedev/antd";
import { ConfigProvider, App as AntdApp } from "antd";
import resetStyle from "@refinedev/antd/dist/reset.css";
import authProvider from "./auth-provider";
export default function App() {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <ConfigProvider theme={RefineThemes.Blue}>
          <AntdApp>
            <Refine
              routerProvider={routerProvider}
              dataProvider={dataProvider("https://api.fake-rest.refine.dev")}
              authProvider={authProvider}
              notificationProvider={useNotificationProvider}
              resources={[
                {
                  name: "products",
                  list: "/products",
                  show: "/products/:id",
                  edit: "/products/:id/edit",
                  create: "/products/create",
                },
              ]}
              options={{ syncWithLocation: true }}
            >
              <Outlet />
            </Refine>
          </AntdApp>
        </ConfigProvider>
        <ScrollRestoration />
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}
`.trim();
const ProtectedTsxCode = /* jsx */ `
import { ThemedLayoutV2 } from "@refinedev/antd";
import { Outlet } from "@remix-run/react";
import { LoaderFunctionArgs, redirect } from "@remix-run/node";
import authProvider from "../auth-provider";
export default function AuthenticatedLayout() {
    // \`<ThemedLayoutV2>\` is only applied to the authenticated users
    return (
        <ThemedLayoutV2>
            <Outlet />
        </ThemedLayoutV2>
    );
}
/**
 * We're checking if the current session is authenticated.
 * If not, we're redirecting the user to the login page.
 * This is applied for all routes that are nested under this layout (_protected).
 */
export async function loader({ request }: LoaderFunctionArgs) {
    const { authenticated, redirectTo } = await authProvider.check(request);
    if (!authenticated) {
        throw redirect(redirectTo ?? "/login");
    }
    return {};
}
`.trim();
const AuthTsxCode = /* jsx */ `
import { Outlet } from "@remix-run/react";
import { LoaderFunctionArgs, redirect } from "@remix-run/node";
import { authProvider } from "~/authProvider";
export default function AuthLayout() {
    // no layout is applied for the auth routes
    return <Outlet />;
}
/**
 * If the current session is authenticated, we're redirecting the user to the home page.
 * Alternatively, we could also use the \`Authenticated\` component inside the \`AuthLayout\` to handle the redirect.
 * But, server-side redirects are more performant.
 */
export async function loader({ request }: LoaderFunctionArgs) {
    const { authenticated, redirectTo } = await authProvider.check(request);
    if (authenticated) {
        throw redirect(redirectTo ?? "/");
    }
    return {};
}
`.trim();
const LoginTsxCode = /* jsx */ `
import { AuthPage } from "@refinedev/antd";
export default function LoginPage() {
  return <AuthPage type="login" />;
}
`.trim();
const ListTsxCode = /* jsx */ `
import React from "react";
import { List, ShowButton, EditButton, useTable } from "@refinedev/antd";
import { Space, Table } from "antd";
export default function ProductList() {
  const { tableProps } = useTable();
  return (
    <List>
      <Table {...tableProps} rowKey="id">
        <Table.Column dataIndex="id" title="Id" />
        <Table.Column dataIndex="name" title="Name" />
        <Table.Column dataIndex="price" title="Price" />
        <Table.Column
          title="Actions"
          dataIndex="actions"
          render={(_, record: BaseRecord) => (
            <Space>
              <ShowButton hideText size="small" recordItemId={record.id} />
              <EditButton hideText size="small" recordItemId={record.id} />
            </Space>
          )}
        />
      </Table>
    </List>
  );
};
`.trim();
const ShowTsxCode = /* jsx */ `
import React from "react";
import { useShow } from "@refinedev/core";
import { MarkdownField, NumberField, Show, TextField } from "@refinedev/antd";
import { Typography } from "antd";
const { Title } = Typography;
export default function ProductShow() {
  const { queryResult } = useShow();
  const { data, isLoading } = queryResult;
  const record = data?.data;
  return (
    <Show isLoading={isLoading}>
      <Title level={5}>Id</Title>
      <NumberField value={record?.id ?? ""} />
      <Title level={5}>Name</Title>
      <TextField value={record?.name} />
      <Title level={5}>Material</Title>
      <TextField value={record?.material} />
      <Title level={5}>Description</Title>
      <MarkdownField value={record?.description} />
      <Title level={5}>Price</Title>
      <NumberField value={record?.price ?? ""} />
    </Show>
  );
};
`.trim();
const EditTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Edit, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export default function ProductEdit() {
  const { formProps, saveButtonProps, formLoading } = useForm();
  return (
    <Edit saveButtonProps={saveButtonProps} isLoading={formLoading}>
      <Form {...formProps} layout="vertical">
          <Form.Item
              label="Name"
              name="name"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <Input />
          </Form.Item>
          <Form.Item
              label="Material"
              name="material"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <Input />
          </Form.Item>
          <Form.Item
              label="Description"
              name="description"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <TextArea rows={4} />
          </Form.Item>
          <Form.Item
              label="Price"
              name="price"
              rules={[
                  {
                      required: true,
                  },
              ]}
          >
              <InputNumber />
          </Form.Item>
      </Form>
  </Edit>
  );
};
`.trim();
const CreateTsxCode = /* jsx */ `
import React from "react";
import { Typography, Form, Input, InputNumber } from "antd";
import { Create, useForm } from "@refinedev/antd";
const { Title } = Typography;
const { TextArea } = Input;
export default function ProductCreate() {
  const { formProps, saveButtonProps, formLoading } = useForm();
  return (
    <Create saveButtonProps={saveButtonProps} isLoading={formLoading}>
      <Form {...formProps} layout="vertical">
        <Form.Item
            label="Name"
            name="name"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Material"
            name="material"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <Input />
        </Form.Item>
        <Form.Item
            label="Description"
            name="description"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <TextArea rows={4} />
        </Form.Item>
        <Form.Item
            label="Price"
            name="price"
            rules={[
                {
                    required: true,
                },
            ]}
        >
            <InputNumber />
        </Form.Item>
      </Form>
    </Create>
  );
};
`.trim();

================
File: ui-integrations/ant-design/migration-guide/index.md
================
---
title: Migration Guide
---

Ant Design released a new major version, v5. This document will help you upgrade from antd 4.x version to antd 5.x version.

Ant Design removed `less` and adopted `CSS-in-JS` for better support of dynamic themes. So now, the bottom layer uses [`@ant-design/cssinjs`](https://github.com/ant-design/cssinjs) instead of `less` as a solution.

Some components were removed or renamed, and some APIs are changed.

Some of the changes are:

- `<PageHeader>` component moved into `@ant-design/pro-components`. Refine is using `<PageHeader>` in `<List>`, `<Create>`, `<Edit>`, `<Show>` components and added as a dependency. You don't need to install `@ant-design/pro-components` package manually.
- `<Comment>` component moved into `@ant-design/compatible`.
- `moment.js` is replaced with `day.js`.
- `less` is removed from `antd` package.

> For more information, please refer to [Ant Design's own migration guide](https://ant.design/docs/react/migration-v5).

:::info A little more clarification

| Refine package                                                   | Ant Design version |
| ---------------------------------------------------------------- | ------------------ |
| &#64;pankod/refine-antd&#64;3.x.x                                | antd&#64;4.x.x     |
| &#64;pankod/refine-antd&#64;4.x.x, &#64;refinedev/antd&#64;5.x.x | antd&#64;5.x.x     |

:::

## Updating the packages

[`@refinedev/antd`](https://github.com/refinedev/refine/tree/main/packages/antd) must be updated to `4.x.x`

<Tabs
defaultValue="refine-cli"
values={[
{label: 'Refine CLI', value: 'refine-cli'},
{label: 'Manual', value: 'manual'},
]}>

<TabItem value="refine-cli">

⚡️ You can easily update Refine packages with the Refine CLI [`update`](/docs/packages/cli/#update) command.

```bash
npm run refine update
```

> [How to add Refine CLI to an existing project?](/docs/packages/cli/#how-to-add-to-an-existing-project)

</TabItem>

<TabItem value="manual">

```bash
npm i @refinedev/antd@latest
```

</TabItem>

</Tabs>

## 🪄 Migrating your project automatically with Codemod ✨ (recommended)

`@refinedev/codemod` package handles the breaking changes for your project automatically, migrating your [`@refinedev/antd`](https://github.com/refinedev/refine/tree/main/packages/antd) version from 3.x.x to 4.x.x. without any manual steps

Just `cd` into root folder of your project (where `package.json` is contained) and run this command:

```sh
npx @refinedev/codemod antd4-to-antd5
```

And it's done. Now your project uses `@refinedev/antd@4.x.x`.

> 🚨 The Customized or swizzled [components](#customized-sider) and [.less](#less-users) files cannot be migrated automatically. You need to migrate them manually.

## Migrating your project manually

### Updating Imports

- CSS files are no longer included in package. Since CSS-in-JS supports importing on demand, the original `styles/antd.less` has also been abandoned. If you need to reset some basic styles, please import `@refinedev/antd/dist/reset.css`

```diff title="App.tsx"
- import "@refinedev/antd/dist/styles.min.css";
+ import "@refinedev/antd/dist/reset.css";
```

### Updating Props

`actionButtons` and `pageHeaderProps` props was deprecated on `@refinedev/antd@3.x.x` and has been removed on `@refinedev/antd@4.x.x` from `<List>`, `<Create>`, `<Edit>`, `<Show>` component due to inconsistency with all UI packages. Use the `headerButtons` and `headerProps` props instead.

```diff title="List.tsx"
- <List actionButtons={actionButtons} pageHeaderProps={pageHeaderProps}>
+ <List headerButtons={actionButtons} headerProps={pageHeaderProps}>
```

```diff title="Create.tsx"
- <Create actionButtons={actionButtons} pageHeaderProps={pageHeaderProps}>
+ <Create headerButtons={actionButtons} headerProps={pageHeaderProps}>
```

```diff title="Show.tsx"
- <Show actionButtons={actionButtons} pageHeaderProps={pageHeaderProps}>
+ <Show headerButtons={actionButtons} headerProps={pageHeaderProps}>
```

```diff title="Edit.tsx"
- <Edit actionButtons={actionButtons} pageHeaderProps={pageHeaderProps}>
+ <Edit headerButtons={actionButtons} headerProps={pageHeaderProps}>
```

### Customized `<Sider>`

If you have customized or `swizzled` the `<Sider>` component, there may be a color mismatch issue.
You can give theme dark to the `<Menu>` component in the `<Sider>` component.

```diff title="Sider.tsx"
    <AntdLayout.Sider
      collapsible
      collapsed={collapsed}
      onCollapse={(collapsed: boolean): void => setCollapsed(collapsed)}
      collapsedWidth={isMobile ? 0 : 80}
      breakpoint='lg'
      style={isMobile ? antLayoutSiderMobile : antLayoutSider}>
      <RenderToTitle collapsed={collapsed} />
      <Menu
+       theme='dark'
        selectedKeys={[selectedKey]}
        defaultOpenKeys={defaultOpenKeys}
        mode='inline'
        onClick={() => {
          if (!breakpoint.lg) {
            setCollapsed(true)
          }
        }}>
        {renderSider()}
      </Menu>
    </AntdLayout.Sider>
```

### Customized `<Header>`

:::caution

If you have customized or `swizzled` the `<Header>` component, there may be a color mismatch issue.

:::

You can remove constant background color in `<Header>` component:

```diff title="Header.tsx"
   <AntdLayout.Header
      style={{
        display: 'flex',
        justifyContent: 'flex-end',
        alignItems: 'center',
        padding: '0px 24px',
        height: '64px',
-       backgroundColor: '#FFF',
      }}>
```

### LESS Users

Ant Design removed `less`, uses and recommends `CSS-in-JS` instead. You need to manually migrate your `.less` files to `CSS-in-JS`. [Ant Design's documentation for `less` migration.](https://ant.design/docs/react/migration-v5#less-migration)

## Known Issues

### Compile errors

Some users reported ([issue#1](https://discord.com/channels/837692625737613362/1056236230641209396/1056236230641209396), [issue#2](https://discord.com/channels/837692625737613362/1056592183702061177/1056592183702061177)) compile errors after upgrading from `@refinedev/antd@3.x.x` to `@refinedev/antd@4.x.x`. They also provided solutions.

#### Solution 1

1. remove `node_modules` folder
2. remove `package-lock.json` file
3. `npm install`

#### Solution 2

```bash
npm install react@latest react-dom@latest
```

================
File: ui-integrations/ant-design/theming/index.md
================
---
title: Theming
---

Ant Design allows you to customize design tokens to satisfy UI diversity from business or brand requirements, including primary color, border radius, border color, etc.
Design Tokens are the smallest element that affects the theme. By modifying the Design Token, we can present various themes or components.

> For more information, refer to the [Ant Design documentation about theme customization &#8594](https://ant.design/docs/react/customize-theme)

## Predefined Themes

[`RefineThemes`](https://github.com/refinedev/refine/blob/main/packages/antd/src/definitions/themes/index.ts) has predefined themes that you can use by importing them from `@refinedev/antd` package.

```ts
const { Blue, Purple, Magenta, Red, Orange, Yellow } = RefineThemes;
```

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2, RefineThemes } from "@refinedev/antd";

import { ConfigProvider } from "antd";

const App: React.FC = () => {
  return (
    <ConfigProvider theme={RefineThemes.Blue}>
      <Refine
      /* ... */
      >
        <ThemedLayoutV2>{/* ... */}</ThemedLayoutV2>
      </Refine>
    </ConfigProvider>
  );
};
```

If you want to see how themes change the look of the application, check out this [example &#8594](/docs/examples/themes/refine-themes-antd/)

## Theme customization

You can use either the [`<ConfigProvider/>`](https://ant.design/components/config-provider/#components-config-provider-demo-theme) component or the `RefineThemes` provided by Refine to change the theme. This is not required if you decide to use the default theme.

### Overriding the themes

You can not only override or extend the default themes, but also create your own, just like this:

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2 } from "@refinedev/antd";

import { ConfigProvider } from "antd";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
  return (
    // highlight-start
    <ConfigProvider
      theme={{
        components: {
          Button: {
            borderRadius: 0,
          },
          Typography: {
            colorTextHeading: "#1890ff",
          },
        },
        token: {
          colorPrimary: "#f0f",
        },
      }}
    >
      {/* highlight-end */}
      <Refine
      /* ... */
      >
        <ThemedLayoutV2>{/* ... */}</ThemedLayoutV2>
      </Refine>
      // highlight-next-line
    </ConfigProvider>
  );
};
```

### Use Preset Algorithms

Themes with different styles can be quickly generated by modifying the algorithm. Ant Design 5.0 provides three sets of [preset algorithms by default](https://ant.design/docs/react/customize-theme#theme-presets): the default algorithm `theme.defaultAlgorithm`, the dark algorithm `theme.darkAlgorithm` and the compact algorithm `theme.compactAlgorithm`.

You can switch between algorithms by modifying the algorithm property of theme in [`<ConfigProvider/>`](https://ant.design/components/config-provider/#components-config-provider-demo-theme).

> For more information, refer to the [Ant Design documentation on customizing themes&#8594](https://ant.design/docs/react/customize-theme#use-preset-algorithms)

#### Switching to dark theme

Let's start with adding a switch to the `Header` component:

```tsx
import { Space, Button } from "antd";

interface HeaderProps {
  theme: "light" | "dark";
  setTheme: (theme: "light" | "dark") => void;
}

const Header: FC<HeaderProps> = (props) => {
  return (
    <Space
      direction="vertical"
      align="end"
      style={{
        padding: "1rem",
      }}
    >
      <Button
        onClick={() => {
          props.setTheme(props.theme === "light" ? "dark" : "light");
        }}
        icon={props.theme === "light" ? <IconMoonStars /> : <IconSun />}
      />
    </Space>
  );
};
```

Then, we can use the `theme` property of the `ConfigProvider` component to switch between light and dark themes:

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2 } from "@refinedev/antd";
import { ConfigProvider, theme } from "antd";

import { Header } from "./Header";

const App: React.FC = () => {
  // highlight-next-line
  const [currentTheme, setCurrentTheme] = useState<"light" | "dark">("dark");

  return (
    <ConfigProvider
      // highlight-start
      theme={{
        algorithm:
          currentTheme === "light"
            ? theme.defaultAlgorithm
            : theme.darkAlgorithm,
      }}
      // highlight-end
    >
      <Refine
      /* ... */
      >
        <ThemedLayoutV2 Header={Header}>{/* ... */}</ThemedLayoutV2>
      </Refine>
    </ConfigProvider>
  );
};
```

### `useNotificationProvider` compatible with Theme

The `notificationProvider` export has been deprecated because it cannot consume the current `theme` context by default. To enable the `Notification` component to consume the current `theme` context, import the `App` component from `antd` and the `useNotificationProvider` export from `@refinedev/antd` and pass it as highlighted below:

```tsx
import { Refine } from "@refinedev/core";
import { ThemedLayoutV2, useNotificationProvider } from "@refinedev/antd";

import { ConfigProvider, App as AntdApp } from "antd";

const API_URL = "https://api.fake-rest.refine.dev";

const App: React.FC = () => {
    return (
        <ConfigProvider theme={RefineThemes.Blue}>
            {/* highlight-next-line */}
            <AntdApp>
                <Refine
                    //...
                    {/* highlight-next-line */}
                    notificationProvider={useNotificationProvider}
                >
                    <ThemedLayoutV2>{/* ... */}</ThemedLayoutV2>
                </Refine>
                {/* highlight-next-line */}
            </AntdApp>
        </ConfigProvider>
    );
};
```

If you want to customize the default layout elements provided with `@refinedev/antd` package, check out the [Custom Layout](/docs/advanced-tutorials/custom-layout) tutorial.

## Example

<CodeSandboxExample path="customization-theme-antd" />



================================================================
End of Codebase
================================================================
