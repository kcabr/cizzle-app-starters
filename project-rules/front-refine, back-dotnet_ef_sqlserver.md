These are project rules to be used by apps built with the Refine/.NET stack.

# Project Instructions

Use these specifications and guidelines as you build the app.

Write the complete code for every step. Do not get lazy.

Your goal is to completely finish whatever I ask for.

You will see `<ai_context>` tags in the code. These are context tags that you should use to help you understand the codebase.

## Overview

This is a web app template for enterprise applications.

## Tech Stack

-   **Frontend**: Refine React Framework, Simple REST dataProvider, Ant Design component library (frontend types autogenerated off DB with external tool)
-   **Backend**: SQL Server, .NET Core Web API, EF Core (autogenerated from DB using external tool), CRUD REST operations for all relevant DB types, ViewModels/DTOs for passing data to frontend
-   **Auth**: Refine authProvider (frontend) / MS Identity .NET (backend)
-   **Analytics**: Application Insights
-   **Deployment**: Azure / Docker containers

## Project Structure

The frontend and backend are separate projects. This structure describes the **Refine frontend application**.

-   `public` - Static assets
    -   Favicons and site manifest
-   `src` - Source code
    -   `components` - Shared React components
        -   `layout` - Custom layout components (if any)
        -   Other application-specific components
    -   `interfaces` - Auto-generated TypeScript interfaces/types (DTOs) from the backend
    -   `pages` - Page components, organized by resource
        -   `products`
            -   `list.tsx`
            -   `create.tsx`
            -   `edit.tsx`
            -   `show.tsx`
    -   `providers` - Refine providers
        -   `dataProvider.ts` - Data provider configuration
        -   `authProvider.ts` - Auth provider configuration
    -   `App.tsx` - Main application component where `<Refine>` is configured and routes are defined
    -   `index.tsx` - Client entry point
-   `Dockerfile` - For containerizing the frontend application
-   Configuration files
    -   `tsconfig.json` - TypeScript configuration
    -   `vite.config.ts` - Vite configuration (or equivalent for your bundler)

## Rules

Follow these rules when building the app.

### General Rules

-   Use `@` to import anything from the app unless otherwise specified.
-   Use kebab case for all files and folders unless otherwise specified.
-   Use Ant Design components for the UI. Do not add other UI libraries unless specified.

#### Env Rules

-   If you update environment variables, update the `.env.example` file.
-   All local environment variables should go in `.env.local`.
-   Do not expose secret environment variables to the frontend.
-   Use `VITE_` prefix for environment variables that need to be accessed from the frontend.
-   You may import environment variables on the server-side (if using SSR with a framework like Next.js) by using `process.env.VARIABLE_NAME`. For client-side Vite apps, use `import.meta.env.VITE_VARIABLE_NAME`.

#### Type Rules

Follow these rules when working with types.

-   Frontend types (DTOs) are auto-generated from the backend API/database schema using an external tool. Place these generated types in the `src/interfaces` directory.
-   Name type files using kebab-case like `product-types.ts` or `order-types.ts`.
-   Prefer interfaces over type aliases for object types (DTOs).
-   For utility types or complex unions, use type aliases.
-   Use PascalCase for type and interface names.
-   For React event handlers, use the built-in React types (e.g., `React.FormEvent`).
-   Use TypeScript path aliases with `~/` for imports from the src directory.

An example of a DTO file:
`src/interfaces/product-dto.ts`

```ts
export interface ProductDto {
    id: number;
    name: string;
    description?: string;
    price: number;
    categoryId: number;
}

export interface CategoryDto {
    id: number;
    name: string;
}
```

Then using it in components:

```tsx
import type { ProductDto } from "~/interfaces/product-dto";
import { useTable } from "@refinedev/antd";

function ProductList() {
    const { tableProps } = useTable<ProductDto>();
    // Implementation
}
```

### Frontend Rules

Follow these rules when working on the frontend.

It uses the Refine framework with the Ant Design component library and the Simple REST data provider.

#### General Rules

-   Use `@ant-design/icons` for icons.
-   Leverage Refine's pre-built Ant Design components (`<List>`, `<Edit>`, `<Create>`, `<Show>`, etc.) for CRUD pages.

#### Components

-   Use appropriate semantic HTML tags (like `<header>`, `<main>`, `<section>`, etc.) when their meaning matches your content's purpose. Only fall back to `<div>` elements for non-semantic grouping or layout purposes.
-   Separate the main parts of a component's JSX with an extra blank line for visual spacing.

##### Organization

-   All components should be named using PascalCase like `ExampleComponent.tsx`.
-   Put page components under `src/pages`, organized by resource.
-   Put shared, reusable components under `src/components`.

##### Component Hook Encapsulation

**Always encapsulate related state, effects, and event handlers in custom hooks (`use...`) rather than directly in components.**

âœ… **Good Practice:**

```jsx
// hooks/useProductDetails.ts
// Custom hook encapsulates all related state and logic
function useProductDetails(productId) {
    const { data, isLoading, isError } = useOne({
        resource: "products",
        id: productId,
    });

    // You can add more related logic here, like fetching reviews, etc.

    return {
        product: data?.data,
        isLoading,
        isError,
    };
}

// pages/products/show.tsx
// Clean component with logic abstracted away
function ProductShowPage() {
    const { id } = useParams();
    const { product, isLoading, isError } = useProductDetails(id);

    if (isLoading) return <Spin />;
    if (isError) return <Alert type="error" message="Could not fetch product" />;

    return (
        <Show>
            <Title level={5}>Name</Title>
            <Text>{product.name}</Text>
        </Show>
    );
}
```

#### Data Fetching & Mutations

-   Use Refine's data hooks (`useTable`, `useForm`, `useOne`, `useList`, `useMany`, `useDelete`) for all CRUD operations.
-   Configure the `dataProvider` in `src/providers/dataProvider.ts` to communicate with the .NET Web API endpoints.
-   The `resource` property of hooks should correspond to the API controller name (e.g., `resource: "products"` maps to `/api/products`).
-   Use the `meta` property in hooks to pass extra information to the `dataProvider`, like custom headers or query parameters if needed.

Example of using a Refine data hook:

```tsx
import { useTable } from "@refinedev/antd";
import { List, Table } from "antd";
import type { ProductDto } from "~/interfaces/product-dto";

function ProductList() {
    const { tableProps } = useTable<ProductDto>();

    return (
        <List>
            <Table {...tableProps} rowKey="id">
                <Table.Column dataIndex="id" title="ID" />
                <Table.Column dataIndex="name" title="Name" />
                <Table.Column dataIndex="price" title="Price" />
            </Table>
        </List>
    );
}
```

Example of using a mutation hook from a form:

```tsx
import { useForm, Create } from "@refinedev/antd";
import { Form, Input } from "antd";
import type { ProductDto } from "~/interfaces/product-dto";

function ProductCreate() {
    const { formProps, saveButtonProps } = useForm<ProductDto>();

    return (
        <Create saveButtonProps={saveButtonProps}>
            <Form {...formProps} layout="vertical">
                <Form.Item label="Name" name="name" rules={[{ required: true }]}>
                    <Input />
                </Form.Item>
                {/* ... other form items */}
            </Form>
        </Create>
    );
}
```

#### Routes

-   Use `react-router-dom` for routing.
-   Define routes in `App.tsx` within the `<Routes>` component.
-   Define resource paths in the `resources` prop of the `<Refine>` component. This allows Refine to automatically handle navigation and infer the current resource.
-   Protect routes using the `<Authenticated />` component from `@refinedev/core`.

Example of route setup:

```tsx
// in App.tsx
import { Refine, Authenticated } from "@refinedev/core";
import { BrowserRouter, Route, Routes, Outlet } from "react-router-dom";
import { ThemedLayoutV2 } from "@refinedev/antd";
// ... page imports

<Refine
    // ... other providers
    resources={[
        {
            name: "products",
            list: "/products",
            create: "/products/create",
            edit: "/products/edit/:id",
            show: "/products/show/:id",
        },
    ]}
>
    <Routes>
        <Route
            element={
                <Authenticated
                    key="authenticated-routes"
                    fallback={<CatchAllNavigate to="/login" />}
                >
                    <ThemedLayoutV2>
                        <Outlet />
                    </ThemedLayoutV2>
                </Authenticated>
            }
        >
            <Route path="/products" element={<ProductList />} />
            <Route path="/products/create" element={<ProductCreate />} />
            <Route path="/products/edit/:id" element={<ProductEdit />} />
            <Route path="/products/show/:id" element={<ProductShow />} />
        </Route>

        <Route
            element={
                <Authenticated key="auth-pages" fallback={<Outlet />}>
                    <NavigateToResource resource="products" />
                </Authenticated>
            }
        >
            <Route path="/login" element={<AuthPage type="login" />} />
        </Route>
    </Routes>
</Refine>;
```

### Backend Rules for .NET Core Web API with EF Core

Follow these rules when working on the backend.

The project uses SQL Server, .NET Core Web API, and Entity Framework Core. The backend is a separate project from the frontend.

### General Rules

-   Use `dotnet ef migrations add <MigrationName>` to create database migrations after changing EF Core models.
-   Use `dotnet ef database update` to apply migrations to the database.

### Organization

#### API Project Structure

-   **Controllers**: Contain API endpoints. One controller per resource (e.g., `ProductsController.cs`).
-   **Data**: Contains `DbContext` and `Migrations`.
-   **DTOs**: Data Transfer Objects used for API request/response bodies to decouple the API shape from the database schema.
-   **Models**: EF Core entity classes that map to database tables.
-   **Services**: Business logic layer that controllers call into.

#### Models & DTOs

-   Define EF Core entity models in the `Models` folder. These should be plain C# objects (POCOs) that represent database tables.
-   Use Data Annotations or Fluent API in the `DbContext` to configure the database schema.
-   Create DTOs (Data Transfer Objects) for every model that is exposed via the API. This prevents over-posting and decouples your API from your database implementation.
-   Use a mapping library like AutoMapper to map between Entities and DTOs.

Example of an Entity and a DTO:

`Models/Product.cs`

```csharp
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public decimal Price { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}
```

`DTOs/ProductDto.cs`

```csharp
public class ProductDto
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}
```

### REST API Endpoints

-   Implement standard RESTful CRUD endpoints for each resource.
-   The API should conform to the expectations of Refine's `simple-rest` data provider.
-   **`GET /api/{resource}`**: Should return a list of items. It must support pagination (`_start`, `_end`), sorting (`_sort`, `_order`), and filtering (e.g., `name_like=value`). The total count of records (before pagination) must be returned in the `X-Total-Count` header.
-   **`GET /api/{resource}/{id}`**: Should return a single item.
-   **`POST /api/{resource}`**: Should create a new item and return it.
-   **`PATCH /api/{resource}/{id}`**: Should update an existing item and return it.
-   **`DELETE /api/{resource}/{id}`**: Should delete an item.

Example Controller action for `GET /api/products`:

```csharp
[HttpGet]
public async Task<ActionResult<IEnumerable<ProductDto>>> GetProducts([FromQuery] int _start = 0, [FromQuery] int _end = 10, [FromQuery] string _sort = "id", [FromQuery] string _order = "ASC")
{
    var query = _context.Products.AsQueryable();

    // Apply filtering and sorting here based on query params

    var totalCount = await query.CountAsync();
    Response.Headers.Add("X-Total-Count", totalCount.ToString());

    var products = await query
        .Skip(_start)
        .Take(_end - _start)
        .ToListAsync();

    // Map to DTOs before returning
    return _mapper.Map<List<ProductDto>>(products);
}
```

### Auth Rules

Follow these rules when working on auth.

It uses **MS Identity** for the backend and Refine's **AuthProvider** on the frontend.

#### General Rules

-   The backend should expose standard endpoints for authentication: `/login`, `/logout`, `/register`.
-   Use JWT Bearer tokens for securing API endpoints. The frontend will store this token and send it in the `Authorization` header.
-   The frontend's `authProvider` will make API calls to these endpoints.
-   Secure controller actions with the `[Authorize]` attribute. Use policies for role-based authorization (e.g., `[Authorize(Policy = "AdminOnly")]`).

Example of a frontend `authProvider.login` method:

```ts
// providers/authProvider.ts
import { AuthProvider } from "@refinedev/core";
import axios from "axios";

const authProvider: AuthProvider = {
    login: async ({ username, password }) => {
        try {
            const response = await axios.post("/api/auth/login", {
                username,
                password,
            });
            const { token } = response.data;
            if (token) {
                localStorage.setItem("auth_token", token);
                return { success: true, redirectTo: "/" };
            }
            return { success: false };
        } catch (error) {
            return {
                success: false,
                error: {
                    message: "Login failed",
                    name: "Invalid credentials",
                },
            };
        }
    },
    // ... other methods
};
```

### Analytics Rules

Follow these rules when working on analytics.

It uses **Azure Application Insights**.

-   Configure the Application Insights instrumentation key in the backend's `appsettings.json`.
-   Use the Application Insights SDK to track custom events, exceptions, and dependencies in the .NET backend.
-   On the frontend, you can use the `@microsoft/applicationinsights-react-js` package to send telemetry data from the client-side.

### Error Handling

-   Always wrap service logic and database operations in try/catch blocks.
-   Use a global exception handling middleware in the .NET API to catch unhandled exceptions and return a standardized error response (e.g., HTTP 500 with a generic message).
-   For validation errors (HTTP 400), return a structured error object that Refine's `useForm` can parse.

Example of a validation error response:

```json
{
    "errors": {
        "Name": ["The Name field is required."],
        "Price": ["The field Price must be between 0.01 and 10000."]
    },
    "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
    "title": "One or more validation errors occurred.",
    "status": 400
}
```